/* automatically generated by rust-bindgen 0.59.1 */

pub type va_list = *mut ::std::os::raw::c_char;
pub type size_t = ::std::os::raw::c_ulonglong;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_less {
    pub _address: u8,
}
pub type std_less_first_argument_type = u8;
pub type std_less_second_argument_type = u8;
pub type std_less_result_type = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_pair {
    pub _address: u8,
}
pub type std_pair_first_type = u8;
pub type std_pair_second_type = u8;
#[repr(C)]
#[repr(align(1))]
#[derive(Debug, Copy, Clone)]
pub struct std_forward_iterator_tag {
    pub _bindgen_opaque_blob: u8,
}
#[test]
fn bindgen_test_layout_std_forward_iterator_tag() {
    assert_eq!(
        ::std::mem::size_of::<std_forward_iterator_tag>(),
        1usize,
        concat!("Size of: ", stringify!(std_forward_iterator_tag))
    );
    assert_eq!(
        ::std::mem::align_of::<std_forward_iterator_tag>(),
        1usize,
        concat!("Alignment of ", stringify!(std_forward_iterator_tag))
    );
}
#[repr(C)]
#[repr(align(1))]
#[derive(Debug, Copy, Clone)]
pub struct std_bidirectional_iterator_tag {
    pub _bindgen_opaque_blob: u8,
}
#[test]
fn bindgen_test_layout_std_bidirectional_iterator_tag() {
    assert_eq!(
        ::std::mem::size_of::<std_bidirectional_iterator_tag>(),
        1usize,
        concat!("Size of: ", stringify!(std_bidirectional_iterator_tag))
    );
    assert_eq!(
        ::std::mem::align_of::<std_bidirectional_iterator_tag>(),
        1usize,
        concat!("Alignment of ", stringify!(std_bidirectional_iterator_tag))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_allocator {
    pub _address: u8,
}
pub type std_allocator__From_primary = u8;
pub type std_allocator_value_type = u8;
pub type std_allocator_pointer = u8;
pub type std_allocator_const_pointer = u8;
pub type std_allocator_reference = u8;
pub type std_allocator_const_reference = u8;
pub type std_allocator_size_type = u64;
pub type std_allocator_difference_type = u64;
pub type std_allocator_propagate_on_container_move_assignment = u8;
pub type std_allocator_is_always_equal = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_allocator_rebind {
    pub _address: u8,
}
pub type std_allocator_rebind_other = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_char_traits {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_basic_string {
    pub _address: u8,
}
pub type std_basic_string__Alty = u8;
pub type std_basic_string__Alty_traits = u8;
pub type std_basic_string__Scary_val = u8;
pub type std_basic_string_traits_type = u8;
pub type std_basic_string_allocator_type = u8;
pub type std_basic_string_value_type = u8;
pub type std_basic_string_size_type = u8;
pub type std_basic_string_difference_type = u8;
pub type std_basic_string_pointer = u8;
pub type std_basic_string_const_pointer = u8;
pub type std_basic_string_reference = u8;
pub type std_basic_string_const_reference = u8;
pub type std_basic_string_iterator = u8;
pub type std_basic_string_const_iterator = u8;
pub type std_basic_string_reverse_iterator = u8;
pub type std_basic_string_const_reverse_iterator = u8;
pub type std_basic_string__Is_elem_cptr = u8;
pub type std_string = [u64; 4usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_set {
    pub _address: u8,
}
pub type std_set__Mybase = u8;
pub type std_set_key_type = u8;
pub type std_set_key_compare = u8;
pub type std_set_value_compare = u8;
pub type std_set_value_type = u8;
pub type std_set_allocator_type = u8;
pub type std_set_size_type = u8;
pub type std_set_difference_type = u8;
pub type std_set_pointer = u8;
pub type std_set_const_pointer = u8;
pub type std_set_reference = u8;
pub type std_set_const_reference = u8;
pub type std_set_iterator = u8;
pub type std_set_const_iterator = u8;
pub type std_set_reverse_iterator = u8;
pub type std_set_const_reverse_iterator = u8;
pub type std_set__Alnode = u8;
pub type std_set__Alnode_traits = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_map {
    pub _address: u8,
}
pub type std_map__Mybase = u8;
pub type std_map__Nodeptr = u8;
pub type std_map_key_type = u8;
pub type std_map_mapped_type = u8;
pub type std_map_key_compare = u8;
pub type std_map_value_compare = u8;
pub type std_map_value_type = u8;
pub type std_map_allocator_type = u8;
pub type std_map_size_type = u8;
pub type std_map_difference_type = u8;
pub type std_map_pointer = u8;
pub type std_map_const_pointer = u8;
pub type std_map_reference = u8;
pub type std_map_const_reference = u8;
pub type std_map_iterator = u8;
pub type std_map_const_iterator = u8;
pub type std_map_reverse_iterator = u8;
pub type std_map_const_reverse_iterator = u8;
pub type std_map__Alnode = u8;
pub type std_map__Alnode_traits = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_vector {
    pub _address: u8,
}
pub type std_vector__Alty = u8;
pub type std_vector__Alty_traits = u8;
pub type std_vector_value_type = u8;
pub type std_vector_allocator_type = u8;
pub type std_vector_pointer = u8;
pub type std_vector_const_pointer = u8;
pub type std_vector_reference = u8;
pub type std_vector_const_reference = u8;
pub type std_vector_size_type = u8;
pub type std_vector_difference_type = u8;
pub type std_vector__Scary_val = u8;
pub type std_vector_iterator = u8;
pub type std_vector_const_iterator = u8;
pub type std_vector_reverse_iterator = u8;
pub type std_vector_const_reverse_iterator = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_basic_ostream {}
pub type std_basic_ostream__Myios = u8;
pub type std_basic_ostream__Mysb = u8;
pub type std_basic_ostream__Iter = u8;
pub type std_basic_ostream__Nput = u8;
pub type std_basic_ostream_int_type = u8;
pub type std_basic_ostream_pos_type = u8;
pub type std_basic_ostream_off_type = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_basic_ostream__Sentry_base {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_basic_ostream_sentry {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_basic_istream {}
pub type std_basic_istream__Myios = u8;
pub type std_basic_istream__Mysb = u8;
pub type std_basic_istream__Iter = u8;
pub type std_basic_istream__Ctype = u8;
pub type std_basic_istream__Nget = u8;
pub type std_basic_istream_int_type = u8;
pub type std_basic_istream_pos_type = u8;
pub type std_basic_istream_off_type = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_basic_istream__Sentry_base {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_basic_istream_sentry {
    pub _address: u8,
}
#[repr(C)]
pub struct cocos2d_CCDataVisitor__bindgen_vtable(::std::os::raw::c_void);
#[doc = " Visitor that helps to perform action that depends on polymorphic object type"]
#[doc = ""]
#[doc = " Use cases:"]
#[doc = "  - data serialization,"]
#[doc = "  - pretty printing of \\a CCObject *"]
#[doc = "  - safe value reading from \\a CCArray, \\a CCDictionary, \\a CCSet"]
#[doc = ""]
#[doc = " Usage:"]
#[doc = "  1. subclass CCDataVisitor"]
#[doc = "  2. overload visit() methods for object that you need to handle"]
#[doc = "  3. handle other objects in \\a visitObject()"]
#[doc = "  4. pass your visitor to \\a CCObject::acceptVisitor()"]
#[doc = "  @js NA"]
#[doc = "  @lua NA"]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCDataVisitor {
    pub vtable_: *const cocos2d_CCDataVisitor__bindgen_vtable,
}
#[test]
fn bindgen_test_layout_cocos2d_CCDataVisitor() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCDataVisitor>(),
        8usize,
        concat!("Size of: ", stringify!(cocos2d_CCDataVisitor))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCDataVisitor>(),
        8usize,
        concat!("Alignment of ", stringify!(cocos2d_CCDataVisitor))
    );
}
extern "C" {
    #[link_name = "\u{1}?visit@CCDataVisitor@cocos2d@@UEAAXPEBVCCBool@2@@Z"]
    pub fn cocos2d_CCDataVisitor_visit(this: *mut ::std::os::raw::c_void, p: *const cocos2d_CCBool);
}
extern "C" {
    #[link_name = "\u{1}?visit@CCDataVisitor@cocos2d@@UEAAXPEBVCCInteger@2@@Z"]
    pub fn cocos2d_CCDataVisitor_visit1(
        this: *mut ::std::os::raw::c_void,
        p: *const cocos2d_CCInteger,
    );
}
extern "C" {
    #[link_name = "\u{1}?visit@CCDataVisitor@cocos2d@@UEAAXPEBVCCFloat@2@@Z"]
    pub fn cocos2d_CCDataVisitor_visit2(
        this: *mut ::std::os::raw::c_void,
        p: *const cocos2d_CCFloat,
    );
}
extern "C" {
    #[link_name = "\u{1}?visit@CCDataVisitor@cocos2d@@UEAAXPEBVCCDouble@2@@Z"]
    pub fn cocos2d_CCDataVisitor_visit3(
        this: *mut ::std::os::raw::c_void,
        p: *const cocos2d_CCDouble,
    );
}
extern "C" {
    #[link_name = "\u{1}?visit@CCDataVisitor@cocos2d@@UEAAXPEBVCCString@2@@Z"]
    pub fn cocos2d_CCDataVisitor_visit4(
        this: *mut ::std::os::raw::c_void,
        p: *const cocos2d_CCString,
    );
}
extern "C" {
    #[link_name = "\u{1}?visit@CCDataVisitor@cocos2d@@UEAAXPEBVCCArray@2@@Z"]
    pub fn cocos2d_CCDataVisitor_visit5(
        this: *mut ::std::os::raw::c_void,
        p: *const cocos2d_CCArray,
    );
}
extern "C" {
    #[link_name = "\u{1}?visit@CCDataVisitor@cocos2d@@UEAAXPEBVCCDictionary@2@@Z"]
    pub fn cocos2d_CCDataVisitor_visit6(
        this: *mut ::std::os::raw::c_void,
        p: *const cocos2d_CCDictionary,
    );
}
extern "C" {
    #[link_name = "\u{1}?visit@CCDataVisitor@cocos2d@@UEAAXPEBVCCSet@2@@Z"]
    pub fn cocos2d_CCDataVisitor_visit7(this: *mut ::std::os::raw::c_void, p: *const cocos2d_CCSet);
}
#[doc = "  @js NA"]
#[doc = "  @lua NA"]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCPrettyPrinter {
    pub _base: cocos2d_CCDataVisitor,
    pub _indentLevel: ::std::os::raw::c_int,
    pub _indentStr: std_string,
    pub _result: std_string,
}
#[test]
fn bindgen_test_layout_cocos2d_CCPrettyPrinter() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCPrettyPrinter>(),
        80usize,
        concat!("Size of: ", stringify!(cocos2d_CCPrettyPrinter))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCPrettyPrinter>(),
        8usize,
        concat!("Alignment of ", stringify!(cocos2d_CCPrettyPrinter))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cocos2d_CCPrettyPrinter>()))._indentLevel as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCPrettyPrinter),
            "::",
            stringify!(_indentLevel)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cocos2d_CCPrettyPrinter>()))._indentStr as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCPrettyPrinter),
            "::",
            stringify!(_indentStr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cocos2d_CCPrettyPrinter>()))._result as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCPrettyPrinter),
            "::",
            stringify!(_result)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}??0CCPrettyPrinter@cocos2d@@QEAA@H@Z"]
    pub fn cocos2d_CCPrettyPrinter_CCPrettyPrinter(
        this: *mut cocos2d_CCPrettyPrinter,
        indentLevel: ::std::os::raw::c_int,
    );
}
impl cocos2d_CCPrettyPrinter {
    #[inline]
    pub unsafe fn new(indentLevel: ::std::os::raw::c_int) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cocos2d_CCPrettyPrinter_CCPrettyPrinter(__bindgen_tmp.as_mut_ptr(), indentLevel);
        __bindgen_tmp.assume_init()
    }
}
extern "C" {
    #[link_name = "\u{1}?clear@CCPrettyPrinter@cocos2d@@UEAAXXZ"]
    pub fn cocos2d_CCPrettyPrinter_clear(this: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[link_name = "\u{1}?getResult@CCPrettyPrinter@cocos2d@@UEAA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ"]
    pub fn cocos2d_CCPrettyPrinter_getResult(this: *mut ::std::os::raw::c_void) -> std_string;
}
extern "C" {
    #[link_name = "\u{1}?visitObject@CCPrettyPrinter@cocos2d@@UEAAXPEBVCCObject@2@@Z"]
    pub fn cocos2d_CCPrettyPrinter_visitObject(
        this: *mut ::std::os::raw::c_void,
        p: *const cocos2d_CCObject,
    );
}
extern "C" {
    #[link_name = "\u{1}?visit@CCPrettyPrinter@cocos2d@@UEAAXPEBVCCBool@2@@Z"]
    pub fn cocos2d_CCPrettyPrinter_visit(
        this: *mut ::std::os::raw::c_void,
        p: *const cocos2d_CCBool,
    );
}
extern "C" {
    #[link_name = "\u{1}?visit@CCPrettyPrinter@cocos2d@@UEAAXPEBVCCInteger@2@@Z"]
    pub fn cocos2d_CCPrettyPrinter_visit1(
        this: *mut ::std::os::raw::c_void,
        p: *const cocos2d_CCInteger,
    );
}
extern "C" {
    #[link_name = "\u{1}?visit@CCPrettyPrinter@cocos2d@@UEAAXPEBVCCFloat@2@@Z"]
    pub fn cocos2d_CCPrettyPrinter_visit2(
        this: *mut ::std::os::raw::c_void,
        p: *const cocos2d_CCFloat,
    );
}
extern "C" {
    #[link_name = "\u{1}?visit@CCPrettyPrinter@cocos2d@@UEAAXPEBVCCDouble@2@@Z"]
    pub fn cocos2d_CCPrettyPrinter_visit3(
        this: *mut ::std::os::raw::c_void,
        p: *const cocos2d_CCDouble,
    );
}
extern "C" {
    #[link_name = "\u{1}?visit@CCPrettyPrinter@cocos2d@@UEAAXPEBVCCString@2@@Z"]
    pub fn cocos2d_CCPrettyPrinter_visit4(
        this: *mut ::std::os::raw::c_void,
        p: *const cocos2d_CCString,
    );
}
extern "C" {
    #[link_name = "\u{1}?visit@CCPrettyPrinter@cocos2d@@UEAAXPEBVCCArray@2@@Z"]
    pub fn cocos2d_CCPrettyPrinter_visit5(
        this: *mut ::std::os::raw::c_void,
        p: *const cocos2d_CCArray,
    );
}
extern "C" {
    #[link_name = "\u{1}?visit@CCPrettyPrinter@cocos2d@@UEAAXPEBVCCDictionary@2@@Z"]
    pub fn cocos2d_CCPrettyPrinter_visit6(
        this: *mut ::std::os::raw::c_void,
        p: *const cocos2d_CCDictionary,
    );
}
extern "C" {
    #[link_name = "\u{1}?visit@CCPrettyPrinter@cocos2d@@UEAAXPEBVCCSet@2@@Z"]
    pub fn cocos2d_CCPrettyPrinter_visit7(
        this: *mut ::std::os::raw::c_void,
        p: *const cocos2d_CCSet,
    );
}
#[doc = " The max length of CCLog message."]
pub const cocos2d_kMaxLogLen: ::std::os::raw::c_int = 16384;
extern "C" {
    #[doc = "@brief Output Debug message."]
    #[link_name = "\u{1}?CCLog@cocos2d@@YAXPEBDZZ"]
    pub fn cocos2d_CCLog(pszFormat: *const ::std::os::raw::c_char, ...);
}
extern "C" {
    #[doc = " lua can not deal with ..."]
    #[link_name = "\u{1}?CCLuaLog@cocos2d@@YAXPEBD@Z"]
    pub fn cocos2d_CCLuaLog(pszFormat: *const ::std::os::raw::c_char);
}
extern "C" {
    #[doc = "@brief Pop out a message box"]
    #[link_name = "\u{1}?CCMessageBox@cocos2d@@YAXPEBD0@Z"]
    pub fn cocos2d_CCMessageBox(
        pszMsg: *const ::std::os::raw::c_char,
        pszTitle: *const ::std::os::raw::c_char,
    );
}
pub const cocos2d_LanguageType_kLanguageEnglish: cocos2d_LanguageType = 0;
pub const cocos2d_LanguageType_kLanguageChinese: cocos2d_LanguageType = 1;
pub const cocos2d_LanguageType_kLanguageFrench: cocos2d_LanguageType = 2;
pub const cocos2d_LanguageType_kLanguageItalian: cocos2d_LanguageType = 3;
pub const cocos2d_LanguageType_kLanguageGerman: cocos2d_LanguageType = 4;
pub const cocos2d_LanguageType_kLanguageSpanish: cocos2d_LanguageType = 5;
pub const cocos2d_LanguageType_kLanguageDutch: cocos2d_LanguageType = 6;
pub const cocos2d_LanguageType_kLanguageRussian: cocos2d_LanguageType = 7;
pub const cocos2d_LanguageType_kLanguageKorean: cocos2d_LanguageType = 8;
pub const cocos2d_LanguageType_kLanguageJapanese: cocos2d_LanguageType = 9;
pub const cocos2d_LanguageType_kLanguageHungarian: cocos2d_LanguageType = 10;
pub const cocos2d_LanguageType_kLanguagePortuguese: cocos2d_LanguageType = 11;
pub const cocos2d_LanguageType_kLanguageArabic: cocos2d_LanguageType = 12;
#[doc = "@brief Enum the language type supported now"]
pub type cocos2d_LanguageType = ::std::os::raw::c_int;
#[doc = "@brief Enum the language type supported now"]
pub use self::cocos2d_LanguageType as cocos2d_ccLanguageType;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cocos2d_timezone {
    pub tz_minuteswest: ::std::os::raw::c_int,
    pub tz_dsttime: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_cocos2d_timezone() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d_timezone>(),
        8usize,
        concat!("Size of: ", stringify!(cocos2d_timezone))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_timezone>(),
        4usize,
        concat!("Alignment of ", stringify!(cocos2d_timezone))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cocos2d_timezone>())).tz_minuteswest as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_timezone),
            "::",
            stringify!(tz_minuteswest)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cocos2d_timezone>())).tz_dsttime as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_timezone),
            "::",
            stringify!(tz_dsttime)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}?gettimeofday@cocos2d@@YAHPEAUtimeval@@PEAUtimezone@1@@Z"]
    pub fn cocos2d_gettimeofday(
        arg1: *mut timeval,
        arg2: *mut cocos2d_timezone,
    ) -> ::std::os::raw::c_int;
}
#[doc = " @addtogroup base_nodes"]
#[doc = " @{"]
pub type cocos2d_CCObjectType = ::std::os::raw::c_int;
#[repr(C)]
pub struct cocos2d_CCCopying__bindgen_vtable(::std::os::raw::c_void);
#[doc = " @js NA"]
#[doc = " @lua NA"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cocos2d_CCCopying {
    pub vtable_: *const cocos2d_CCCopying__bindgen_vtable,
}
#[test]
fn bindgen_test_layout_cocos2d_CCCopying() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCCopying>(),
        8usize,
        concat!("Size of: ", stringify!(cocos2d_CCCopying))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCCopying>(),
        8usize,
        concat!("Alignment of ", stringify!(cocos2d_CCCopying))
    );
}
extern "C" {
    #[link_name = "\u{1}?copyWithZone@CCCopying@cocos2d@@UEAAPEAVCCObject@2@PEAVCCZone@2@@Z"]
    pub fn cocos2d_CCCopying_copyWithZone(
        this: *mut ::std::os::raw::c_void,
        pZone: *mut cocos2d_CCZone,
    ) -> *mut cocos2d_CCObject;
}
#[doc = " @addtogroup data_structures"]
#[doc = " @{"]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCObject {
    pub _base: cocos2d_CCCopying,
    pub m_uID: ::std::os::raw::c_uint,
    pub m_nLuaID: ::std::os::raw::c_int,
    pub m_nTag: ::std::os::raw::c_int,
    pub m_uReference: ::std::os::raw::c_uint,
    pub m_uAutoReleaseCount: ::std::os::raw::c_uint,
    pub m_eObjType: ::std::os::raw::c_int,
    pub m_nUnknown: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_cocos2d_CCObject() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCObject>(),
        40usize,
        concat!("Size of: ", stringify!(cocos2d_CCObject))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCObject>(),
        8usize,
        concat!("Alignment of ", stringify!(cocos2d_CCObject))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cocos2d_CCObject>())).m_uID as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCObject),
            "::",
            stringify!(m_uID)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cocos2d_CCObject>())).m_nLuaID as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCObject),
            "::",
            stringify!(m_nLuaID)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cocos2d_CCObject>())).m_nTag as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCObject),
            "::",
            stringify!(m_nTag)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cocos2d_CCObject>())).m_uReference as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCObject),
            "::",
            stringify!(m_uReference)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cocos2d_CCObject>())).m_uAutoReleaseCount as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCObject),
            "::",
            stringify!(m_uAutoReleaseCount)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cocos2d_CCObject>())).m_eObjType as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCObject),
            "::",
            stringify!(m_eObjType)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cocos2d_CCObject>())).m_nUnknown as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCObject),
            "::",
            stringify!(m_nUnknown)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}?release@CCObject@cocos2d@@QEAAXXZ"]
    pub fn cocos2d_CCObject_release(this: *mut cocos2d_CCObject);
}
extern "C" {
    #[link_name = "\u{1}?retain@CCObject@cocos2d@@QEAAXXZ"]
    pub fn cocos2d_CCObject_retain(this: *mut cocos2d_CCObject);
}
extern "C" {
    #[link_name = "\u{1}?autorelease@CCObject@cocos2d@@QEAAPEAV12@XZ"]
    pub fn cocos2d_CCObject_autorelease(this: *mut cocos2d_CCObject) -> *mut cocos2d_CCObject;
}
extern "C" {
    #[link_name = "\u{1}?copy@CCObject@cocos2d@@QEAAPEAV12@XZ"]
    pub fn cocos2d_CCObject_copy(this: *mut cocos2d_CCObject) -> *mut cocos2d_CCObject;
}
extern "C" {
    #[link_name = "\u{1}?isSingleReference@CCObject@cocos2d@@QEBA_NXZ"]
    pub fn cocos2d_CCObject_isSingleReference(this: *const cocos2d_CCObject) -> bool;
}
extern "C" {
    #[link_name = "\u{1}?retainCount@CCObject@cocos2d@@QEBAIXZ"]
    pub fn cocos2d_CCObject_retainCount(this: *const cocos2d_CCObject) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[link_name = "\u{1}?createWithCoder@CCObject@cocos2d@@SAPEAV12@PEAVDS_Dictionary@@@Z"]
    pub fn cocos2d_CCObject_createWithCoder(arg1: *mut DS_Dictionary) -> *mut cocos2d_CCObject;
}
extern "C" {
    #[link_name = "\u{1}?getObjType@CCObject@cocos2d@@QEBA?AW4CCObjectType@2@XZ"]
    pub fn cocos2d_CCObject_getObjType(this: *const cocos2d_CCObject) -> cocos2d_CCObjectType;
}
extern "C" {
    #[link_name = "\u{1}?setObjType@CCObject@cocos2d@@QEAAXW4CCObjectType@2@@Z"]
    pub fn cocos2d_CCObject_setObjType(this: *mut cocos2d_CCObject, arg1: cocos2d_CCObjectType);
}
extern "C" {
    #[link_name = "\u{1}??0CCObject@cocos2d@@QEAA@XZ"]
    pub fn cocos2d_CCObject_CCObject(this: *mut cocos2d_CCObject);
}
extern "C" {
    #[link_name = "\u{1}??0CCObject@cocos2d@@QEAA@AEBV01@@Z"]
    pub fn cocos2d_CCObject_CCObject1(this: *mut cocos2d_CCObject, arg1: *const cocos2d_CCObject);
}
impl cocos2d_CCObject {
    #[inline]
    pub unsafe fn release(&mut self) {
        cocos2d_CCObject_release(self)
    }
    #[inline]
    pub unsafe fn retain(&mut self) {
        cocos2d_CCObject_retain(self)
    }
    #[inline]
    pub unsafe fn autorelease(&mut self) -> *mut cocos2d_CCObject {
        cocos2d_CCObject_autorelease(self)
    }
    #[inline]
    pub unsafe fn copy(&mut self) -> *mut cocos2d_CCObject {
        cocos2d_CCObject_copy(self)
    }
    #[inline]
    pub unsafe fn isSingleReference(&self) -> bool {
        cocos2d_CCObject_isSingleReference(self)
    }
    #[inline]
    pub unsafe fn retainCount(&self) -> ::std::os::raw::c_uint {
        cocos2d_CCObject_retainCount(self)
    }
    #[inline]
    pub unsafe fn createWithCoder(arg1: *mut DS_Dictionary) -> *mut cocos2d_CCObject {
        cocos2d_CCObject_createWithCoder(arg1)
    }
    #[inline]
    pub unsafe fn getObjType(&self) -> cocos2d_CCObjectType {
        cocos2d_CCObject_getObjType(self)
    }
    #[inline]
    pub unsafe fn setObjType(&mut self, arg1: cocos2d_CCObjectType) {
        cocos2d_CCObject_setObjType(self, arg1)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cocos2d_CCObject_CCObject(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new1(arg1: *const cocos2d_CCObject) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cocos2d_CCObject_CCObject1(__bindgen_tmp.as_mut_ptr(), arg1);
        __bindgen_tmp.assume_init()
    }
}
extern "C" {
    #[doc = "  @lua NA"]
    #[link_name = "\u{1}??_DCCObject@cocos2d@@QEAAXXZ"]
    pub fn cocos2d_CCObject_CCObject_destructor(this: *mut cocos2d_CCObject);
}
extern "C" {
    #[link_name = "\u{1}?isEqual@CCObject@cocos2d@@UEAA_NPEBV12@@Z"]
    pub fn cocos2d_CCObject_isEqual(
        this: *mut ::std::os::raw::c_void,
        pObject: *const cocos2d_CCObject,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}?acceptVisitor@CCObject@cocos2d@@UEAAXAEAVCCDataVisitor@2@@Z"]
    pub fn cocos2d_CCObject_acceptVisitor(
        this: *mut ::std::os::raw::c_void,
        visitor: *mut cocos2d_CCDataVisitor,
    );
}
extern "C" {
    #[link_name = "\u{1}?encodeWithCoder@CCObject@cocos2d@@UEAAXPEAVDS_Dictionary@@@Z"]
    pub fn cocos2d_CCObject_encodeWithCoder(
        this: *mut ::std::os::raw::c_void,
        arg1: *mut DS_Dictionary,
    );
}
extern "C" {
    #[link_name = "\u{1}?canEncode@CCObject@cocos2d@@UEAA_NXZ"]
    pub fn cocos2d_CCObject_canEncode(this: *mut ::std::os::raw::c_void) -> bool;
}
extern "C" {
    #[link_name = "\u{1}?getTag@CCObject@cocos2d@@UEBAHXZ"]
    pub fn cocos2d_CCObject_getTag(this: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}?setTag@CCObject@cocos2d@@UEAAXH@Z"]
    pub fn cocos2d_CCObject_setTag(this: *mut ::std::os::raw::c_void, nTag: ::std::os::raw::c_int);
}
pub type cocos2d_SEL_SCHEDULE = ::std::option::Option<unsafe extern "C" fn(arg1: f32)>;
pub type cocos2d_SEL_CallFunc = ::std::option::Option<unsafe extern "C" fn()>;
pub type cocos2d_SEL_CallFuncN =
    ::std::option::Option<unsafe extern "C" fn(arg1: *mut cocos2d_CCNode)>;
pub type cocos2d_SEL_CallFuncND = ::std::option::Option<
    unsafe extern "C" fn(arg1: *mut cocos2d_CCNode, arg2: *mut ::std::os::raw::c_void),
>;
pub type cocos2d_SEL_CallFuncO =
    ::std::option::Option<unsafe extern "C" fn(arg1: *mut cocos2d_CCObject)>;
pub type cocos2d_SEL_MenuHandler =
    ::std::option::Option<unsafe extern "C" fn(arg1: *mut cocos2d_CCObject)>;
pub type cocos2d_SEL_EventHandler =
    ::std::option::Option<unsafe extern "C" fn(arg1: *mut cocos2d_CCEvent)>;
pub type cocos2d_SEL_Compare = ::std::option::Option<
    unsafe extern "C" fn(arg1: *mut cocos2d_CCObject) -> ::std::os::raw::c_int,
>;
#[doc = " @js NA"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cocos2d_CCPoint {
    pub x: f32,
    pub y: f32,
}
#[test]
fn bindgen_test_layout_cocos2d_CCPoint() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCPoint>(),
        8usize,
        concat!("Size of: ", stringify!(cocos2d_CCPoint))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCPoint>(),
        4usize,
        concat!("Alignment of ", stringify!(cocos2d_CCPoint))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cocos2d_CCPoint>())).x as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCPoint),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cocos2d_CCPoint>())).y as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCPoint),
            "::",
            stringify!(y)
        )
    );
}
extern "C" {
    #[doc = " @lua NA"]
    #[link_name = "\u{1}?setPoint@CCPoint@cocos2d@@QEAAXMM@Z"]
    pub fn cocos2d_CCPoint_setPoint(this: *mut cocos2d_CCPoint, x: f32, y: f32);
}
extern "C" {
    #[link_name = "\u{1}?equals@CCPoint@cocos2d@@QEBA_NAEBV12@@Z"]
    pub fn cocos2d_CCPoint_equals(
        this: *const cocos2d_CCPoint,
        target: *const cocos2d_CCPoint,
    ) -> bool;
}
extern "C" {
    #[doc = " @returns if points have fuzzy equality which means equal with some degree of variance."]
    #[doc = " @since v2.1.4"]
    #[doc = " @lua NA"]
    #[link_name = "\u{1}?fuzzyEquals@CCPoint@cocos2d@@QEBA_NAEBV12@M@Z"]
    pub fn cocos2d_CCPoint_fuzzyEquals(
        this: *const cocos2d_CCPoint,
        target: *const cocos2d_CCPoint,
        variance: f32,
    ) -> bool;
}
extern "C" {
    #[doc = " @returns the angle in radians between two vector directions"]
    #[doc = "@since v2.1.4"]
    #[link_name = "\u{1}?getAngle@CCPoint@cocos2d@@QEBAMAEBV12@@Z"]
    pub fn cocos2d_CCPoint_getAngle(
        this: *const cocos2d_CCPoint,
        other: *const cocos2d_CCPoint,
    ) -> f32;
}
extern "C" {
    #[doc = " Rotates a point counter clockwise by the angle around a pivot"]
    #[doc = "@param pivot is the pivot, naturally"]
    #[doc = "@param angle is the angle of rotation ccw in radians"]
    #[doc = "@returns the rotated point"]
    #[doc = "@since v2.1.4"]
    #[link_name = "\u{1}?rotateByAngle@CCPoint@cocos2d@@QEBA?AV12@AEBV12@M@Z"]
    pub fn cocos2d_CCPoint_rotateByAngle(
        this: *const cocos2d_CCPoint,
        pivot: *const cocos2d_CCPoint,
        angle: f32,
    ) -> cocos2d_CCPoint;
}
extern "C" {
    #[link_name = "\u{1}??0CCPoint@cocos2d@@QEAA@XZ"]
    pub fn cocos2d_CCPoint_CCPoint(this: *mut cocos2d_CCPoint);
}
extern "C" {
    #[link_name = "\u{1}??0CCPoint@cocos2d@@QEAA@MM@Z"]
    pub fn cocos2d_CCPoint_CCPoint1(this: *mut cocos2d_CCPoint, x: f32, y: f32);
}
extern "C" {
    #[doc = " @lua NA"]
    #[link_name = "\u{1}??0CCPoint@cocos2d@@QEAA@AEBV01@@Z"]
    pub fn cocos2d_CCPoint_CCPoint2(this: *mut cocos2d_CCPoint, other: *const cocos2d_CCPoint);
}
extern "C" {
    #[doc = " @lua NA"]
    #[link_name = "\u{1}??0CCPoint@cocos2d@@QEAA@AEBVCCSize@1@@Z"]
    pub fn cocos2d_CCPoint_CCPoint3(this: *mut cocos2d_CCPoint, size: *const cocos2d_CCSize);
}
impl cocos2d_CCPoint {
    #[inline]
    pub unsafe fn setPoint(&mut self, x: f32, y: f32) {
        cocos2d_CCPoint_setPoint(self, x, y)
    }
    #[inline]
    pub unsafe fn equals(&self, target: *const cocos2d_CCPoint) -> bool {
        cocos2d_CCPoint_equals(self, target)
    }
    #[inline]
    pub unsafe fn fuzzyEquals(&self, target: *const cocos2d_CCPoint, variance: f32) -> bool {
        cocos2d_CCPoint_fuzzyEquals(self, target, variance)
    }
    #[inline]
    pub unsafe fn getAngle(&self, other: *const cocos2d_CCPoint) -> f32 {
        cocos2d_CCPoint_getAngle(self, other)
    }
    #[inline]
    pub unsafe fn rotateByAngle(
        &self,
        pivot: *const cocos2d_CCPoint,
        angle: f32,
    ) -> cocos2d_CCPoint {
        cocos2d_CCPoint_rotateByAngle(self, pivot, angle)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cocos2d_CCPoint_CCPoint(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new1(x: f32, y: f32) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cocos2d_CCPoint_CCPoint1(__bindgen_tmp.as_mut_ptr(), x, y);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new2(other: *const cocos2d_CCPoint) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cocos2d_CCPoint_CCPoint2(__bindgen_tmp.as_mut_ptr(), other);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new3(size: *const cocos2d_CCSize) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cocos2d_CCPoint_CCPoint3(__bindgen_tmp.as_mut_ptr(), size);
        __bindgen_tmp.assume_init()
    }
}
#[doc = " @addtogroup data_structures"]
#[doc = " @{"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cocos2d_CCSize {
    pub width: f32,
    pub height: f32,
}
#[test]
fn bindgen_test_layout_cocos2d_CCSize() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCSize>(),
        8usize,
        concat!("Size of: ", stringify!(cocos2d_CCSize))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCSize>(),
        4usize,
        concat!("Alignment of ", stringify!(cocos2d_CCSize))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cocos2d_CCSize>())).width as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCSize),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cocos2d_CCSize>())).height as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCSize),
            "::",
            stringify!(height)
        )
    );
}
extern "C" {
    #[doc = " @lua NA"]
    #[link_name = "\u{1}?setSize@CCSize@cocos2d@@QEAAXMM@Z"]
    pub fn cocos2d_CCSize_setSize(this: *mut cocos2d_CCSize, width: f32, height: f32);
}
extern "C" {
    #[doc = " @lua NA"]
    #[link_name = "\u{1}?equals@CCSize@cocos2d@@QEBA_NAEBV12@@Z"]
    pub fn cocos2d_CCSize_equals(
        this: *const cocos2d_CCSize,
        target: *const cocos2d_CCSize,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}??0CCSize@cocos2d@@QEAA@XZ"]
    pub fn cocos2d_CCSize_CCSize(this: *mut cocos2d_CCSize);
}
extern "C" {
    #[link_name = "\u{1}??0CCSize@cocos2d@@QEAA@MM@Z"]
    pub fn cocos2d_CCSize_CCSize1(this: *mut cocos2d_CCSize, width: f32, height: f32);
}
extern "C" {
    #[doc = " @lua NA"]
    #[link_name = "\u{1}??0CCSize@cocos2d@@QEAA@AEBV01@@Z"]
    pub fn cocos2d_CCSize_CCSize2(this: *mut cocos2d_CCSize, other: *const cocos2d_CCSize);
}
extern "C" {
    #[doc = " @lua NA"]
    #[link_name = "\u{1}??0CCSize@cocos2d@@QEAA@AEBVCCPoint@1@@Z"]
    pub fn cocos2d_CCSize_CCSize3(this: *mut cocos2d_CCSize, point: *const cocos2d_CCPoint);
}
impl cocos2d_CCSize {
    #[inline]
    pub unsafe fn setSize(&mut self, width: f32, height: f32) {
        cocos2d_CCSize_setSize(self, width, height)
    }
    #[inline]
    pub unsafe fn equals(&self, target: *const cocos2d_CCSize) -> bool {
        cocos2d_CCSize_equals(self, target)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cocos2d_CCSize_CCSize(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new1(width: f32, height: f32) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cocos2d_CCSize_CCSize1(__bindgen_tmp.as_mut_ptr(), width, height);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new2(other: *const cocos2d_CCSize) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cocos2d_CCSize_CCSize2(__bindgen_tmp.as_mut_ptr(), other);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new3(point: *const cocos2d_CCPoint) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cocos2d_CCSize_CCSize3(__bindgen_tmp.as_mut_ptr(), point);
        __bindgen_tmp.assume_init()
    }
}
#[doc = " @js NA"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cocos2d_CCRect {
    pub origin: cocos2d_CCPoint,
    pub size: cocos2d_CCSize,
}
#[test]
fn bindgen_test_layout_cocos2d_CCRect() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCRect>(),
        16usize,
        concat!("Size of: ", stringify!(cocos2d_CCRect))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCRect>(),
        4usize,
        concat!("Alignment of ", stringify!(cocos2d_CCRect))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cocos2d_CCRect>())).origin as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCRect),
            "::",
            stringify!(origin)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cocos2d_CCRect>())).size as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCRect),
            "::",
            stringify!(size)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}?setRect@CCRect@cocos2d@@QEAAXMMMM@Z"]
    pub fn cocos2d_CCRect_setRect(
        this: *mut cocos2d_CCRect,
        x: f32,
        y: f32,
        width: f32,
        height: f32,
    );
}
extern "C" {
    #[link_name = "\u{1}?getMinX@CCRect@cocos2d@@QEBAMXZ"]
    pub fn cocos2d_CCRect_getMinX(this: *const cocos2d_CCRect) -> f32;
}
extern "C" {
    #[doc = " return the leftmost x-value of current rect"]
    #[link_name = "\u{1}?getMidX@CCRect@cocos2d@@QEBAMXZ"]
    pub fn cocos2d_CCRect_getMidX(this: *const cocos2d_CCRect) -> f32;
}
extern "C" {
    #[doc = " return the midpoint x-value of current rect"]
    #[link_name = "\u{1}?getMaxX@CCRect@cocos2d@@QEBAMXZ"]
    pub fn cocos2d_CCRect_getMaxX(this: *const cocos2d_CCRect) -> f32;
}
extern "C" {
    #[doc = " return the rightmost x-value of current rect"]
    #[link_name = "\u{1}?getMinY@CCRect@cocos2d@@QEBAMXZ"]
    pub fn cocos2d_CCRect_getMinY(this: *const cocos2d_CCRect) -> f32;
}
extern "C" {
    #[doc = " return the bottommost y-value of current rect"]
    #[link_name = "\u{1}?getMidY@CCRect@cocos2d@@QEBAMXZ"]
    pub fn cocos2d_CCRect_getMidY(this: *const cocos2d_CCRect) -> f32;
}
extern "C" {
    #[doc = " return the midpoint y-value of current rect"]
    #[link_name = "\u{1}?getMaxY@CCRect@cocos2d@@QEBAMXZ"]
    pub fn cocos2d_CCRect_getMaxY(this: *const cocos2d_CCRect) -> f32;
}
extern "C" {
    #[doc = " return the topmost y-value of current rect"]
    #[link_name = "\u{1}?equals@CCRect@cocos2d@@QEBA_NAEBV12@@Z"]
    pub fn cocos2d_CCRect_equals(this: *const cocos2d_CCRect, rect: *const cocos2d_CCRect) -> bool;
}
extern "C" {
    #[link_name = "\u{1}?containsPoint@CCRect@cocos2d@@QEBA_NAEBVCCPoint@2@@Z"]
    pub fn cocos2d_CCRect_containsPoint(
        this: *const cocos2d_CCRect,
        point: *const cocos2d_CCPoint,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}?intersectsRect@CCRect@cocos2d@@QEBA_NAEBV12@@Z"]
    pub fn cocos2d_CCRect_intersectsRect(
        this: *const cocos2d_CCRect,
        rect: *const cocos2d_CCRect,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}??0CCRect@cocos2d@@QEAA@XZ"]
    pub fn cocos2d_CCRect_CCRect(this: *mut cocos2d_CCRect);
}
extern "C" {
    #[link_name = "\u{1}??0CCRect@cocos2d@@QEAA@MMMM@Z"]
    pub fn cocos2d_CCRect_CCRect1(
        this: *mut cocos2d_CCRect,
        x: f32,
        y: f32,
        width: f32,
        height: f32,
    );
}
extern "C" {
    #[doc = " @lua NA"]
    #[link_name = "\u{1}??0CCRect@cocos2d@@QEAA@AEBV01@@Z"]
    pub fn cocos2d_CCRect_CCRect2(this: *mut cocos2d_CCRect, other: *const cocos2d_CCRect);
}
impl cocos2d_CCRect {
    #[inline]
    pub unsafe fn setRect(&mut self, x: f32, y: f32, width: f32, height: f32) {
        cocos2d_CCRect_setRect(self, x, y, width, height)
    }
    #[inline]
    pub unsafe fn getMinX(&self) -> f32 {
        cocos2d_CCRect_getMinX(self)
    }
    #[inline]
    pub unsafe fn getMidX(&self) -> f32 {
        cocos2d_CCRect_getMidX(self)
    }
    #[inline]
    pub unsafe fn getMaxX(&self) -> f32 {
        cocos2d_CCRect_getMaxX(self)
    }
    #[inline]
    pub unsafe fn getMinY(&self) -> f32 {
        cocos2d_CCRect_getMinY(self)
    }
    #[inline]
    pub unsafe fn getMidY(&self) -> f32 {
        cocos2d_CCRect_getMidY(self)
    }
    #[inline]
    pub unsafe fn getMaxY(&self) -> f32 {
        cocos2d_CCRect_getMaxY(self)
    }
    #[inline]
    pub unsafe fn equals(&self, rect: *const cocos2d_CCRect) -> bool {
        cocos2d_CCRect_equals(self, rect)
    }
    #[inline]
    pub unsafe fn containsPoint(&self, point: *const cocos2d_CCPoint) -> bool {
        cocos2d_CCRect_containsPoint(self, point)
    }
    #[inline]
    pub unsafe fn intersectsRect(&self, rect: *const cocos2d_CCRect) -> bool {
        cocos2d_CCRect_intersectsRect(self, rect)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cocos2d_CCRect_CCRect(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new1(x: f32, y: f32, width: f32, height: f32) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cocos2d_CCRect_CCRect1(__bindgen_tmp.as_mut_ptr(), x, y, width, height);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new2(other: *const cocos2d_CCRect) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cocos2d_CCRect_CCRect2(__bindgen_tmp.as_mut_ptr(), other);
        __bindgen_tmp.assume_init()
    }
}
extern "C" {
    #[link_name = "\u{1}?CCPointZero@cocos2d@@3VCCPoint@1@B"]
    pub static cocos2d_CCPointZero: cocos2d_CCPoint;
}
extern "C" {
    #[link_name = "\u{1}?CCSizeZero@cocos2d@@3VCCSize@1@B"]
    pub static cocos2d_CCSizeZero: cocos2d_CCSize;
}
extern "C" {
    #[link_name = "\u{1}?CCRectZero@cocos2d@@3VCCRect@1@B"]
    pub static cocos2d_CCRectZero: cocos2d_CCRect;
}
#[doc = "! Default tag"]
pub const kCCActionTagInvalid: ::std::os::raw::c_int = -1;
pub type cocos2d__bindgen_ty_1 = ::std::os::raw::c_int;
#[doc = "@brief Base class for CCAction objects."]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCAction {
    pub _base: cocos2d_CCObject,
    pub m_pOriginalTarget: *mut cocos2d_CCNode,
    #[doc = " The \"target\"."]
    #[doc = "The target will be set with the 'startWithTarget' method."]
    #[doc = "When the 'stop' method is called, target will be set to nil."]
    #[doc = "The target is 'assigned', it is not 'retained'."]
    pub m_pTarget: *mut cocos2d_CCNode,
    #[doc = " The action tag. An identifier of the action"]
    pub m_nTag: ::std::os::raw::c_int,
    pub m_fSpeedMod: f32,
}
#[test]
fn bindgen_test_layout_cocos2d_CCAction() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCAction>(),
        64usize,
        concat!("Size of: ", stringify!(cocos2d_CCAction))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCAction>(),
        8usize,
        concat!("Alignment of ", stringify!(cocos2d_CCAction))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cocos2d_CCAction>())).m_pOriginalTarget as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCAction),
            "::",
            stringify!(m_pOriginalTarget)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cocos2d_CCAction>())).m_pTarget as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCAction),
            "::",
            stringify!(m_pTarget)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cocos2d_CCAction>())).m_nTag as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCAction),
            "::",
            stringify!(m_nTag)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cocos2d_CCAction>())).m_fSpeedMod as *const _ as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCAction),
            "::",
            stringify!(m_fSpeedMod)
        )
    );
}
extern "C" {
    #[doc = " @js NA"]
    #[doc = " @lua NA"]
    #[link_name = "\u{1}?description@CCAction@cocos2d@@QEAAPEBDXZ"]
    pub fn cocos2d_CCAction_description(
        this: *mut cocos2d_CCAction,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}?setSpeedMod@CCAction@cocos2d@@QEAAXM@Z"]
    pub fn cocos2d_CCAction_setSpeedMod(this: *mut cocos2d_CCAction, mod_: f32);
}
extern "C" {
    #[doc = " Create an action"]
    #[link_name = "\u{1}?create@CCAction@cocos2d@@SAPEAV12@XZ"]
    pub fn cocos2d_CCAction_create() -> *mut cocos2d_CCAction;
}
extern "C" {
    #[doc = " @js ctor"]
    #[link_name = "\u{1}??0CCAction@cocos2d@@QEAA@XZ"]
    pub fn cocos2d_CCAction_CCAction(this: *mut cocos2d_CCAction);
}
impl cocos2d_CCAction {
    #[inline]
    pub unsafe fn description(&mut self) -> *const ::std::os::raw::c_char {
        cocos2d_CCAction_description(self)
    }
    #[inline]
    pub unsafe fn setSpeedMod(&mut self, mod_: f32) {
        cocos2d_CCAction_setSpeedMod(self, mod_)
    }
    #[inline]
    pub unsafe fn create() -> *mut cocos2d_CCAction {
        cocos2d_CCAction_create()
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cocos2d_CCAction_CCAction(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
}
extern "C" {
    #[doc = " @js NA"]
    #[doc = " @lua NA"]
    #[link_name = "\u{1}??_DCCAction@cocos2d@@QEAAXXZ"]
    pub fn cocos2d_CCAction_CCAction_destructor(this: *mut cocos2d_CCAction);
}
extern "C" {
    #[doc = " @js NA"]
    #[doc = " @lua NA"]
    #[link_name = "\u{1}?copyWithZone@CCAction@cocos2d@@UEAAPEAVCCObject@2@PEAVCCZone@2@@Z"]
    pub fn cocos2d_CCAction_copyWithZone(
        this: *mut ::std::os::raw::c_void,
        pZone: *mut cocos2d_CCZone,
    ) -> *mut cocos2d_CCObject;
}
extern "C" {
    #[doc = "! return true if the action has finished"]
    #[link_name = "\u{1}?isDone@CCAction@cocos2d@@UEAA_NXZ"]
    pub fn cocos2d_CCAction_isDone(this: *mut ::std::os::raw::c_void) -> bool;
}
extern "C" {
    #[doc = "! called before the action start. It will also set the target."]
    #[link_name = "\u{1}?startWithTarget@CCAction@cocos2d@@UEAAXPEAVCCNode@2@@Z"]
    pub fn cocos2d_CCAction_startWithTarget(
        this: *mut ::std::os::raw::c_void,
        pTarget: *mut cocos2d_CCNode,
    );
}
extern "C" {
    #[doc = "called after the action has finished. It will set the 'target' to nil."]
    #[doc = "IMPORTANT: You should never call \"[action stop]\" manually. Instead, use: \"target->stopAction(action);\""]
    #[link_name = "\u{1}?stop@CCAction@cocos2d@@UEAAXXZ"]
    pub fn cocos2d_CCAction_stop(this: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[doc = "! called every frame with it's delta time. DON'T override unless you know what you are doing."]
    #[link_name = "\u{1}?step@CCAction@cocos2d@@UEAAXM@Z"]
    pub fn cocos2d_CCAction_step(this: *mut ::std::os::raw::c_void, dt: f32);
}
extern "C" {
    #[doc = "called once per frame. time a value between 0 and 1"]
    #[doc = ""]
    #[doc = "For example:"]
    #[doc = "- 0 means that the action just started"]
    #[doc = "- 0.5 means that the action is in the middle"]
    #[doc = "- 1 means that the action is over"]
    #[link_name = "\u{1}?update@CCAction@cocos2d@@UEAAXM@Z"]
    pub fn cocos2d_CCAction_update(this: *mut ::std::os::raw::c_void, time: f32);
}
#[doc = "@brief"]
#[doc = "Base class actions that do have a finite time duration."]
#[doc = "Possible actions:"]
#[doc = "- An action with a duration of 0 seconds"]
#[doc = "- An action with a duration of 35.5 seconds"]
#[doc = ""]
#[doc = "Infinite time actions are valid"]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCFiniteTimeAction {
    pub _base: cocos2d_CCAction,
    #[doc = "! duration in seconds"]
    pub m_fDuration: f32,
}
#[test]
fn bindgen_test_layout_cocos2d_CCFiniteTimeAction() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCFiniteTimeAction>(),
        72usize,
        concat!("Size of: ", stringify!(cocos2d_CCFiniteTimeAction))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCFiniteTimeAction>(),
        8usize,
        concat!("Alignment of ", stringify!(cocos2d_CCFiniteTimeAction))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cocos2d_CCFiniteTimeAction>())).m_fDuration as *const _ as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCFiniteTimeAction),
            "::",
            stringify!(m_fDuration)
        )
    );
}
extern "C" {
    #[doc = " returns a reversed action"]
    #[link_name = "\u{1}?reverse@CCFiniteTimeAction@cocos2d@@UEAAPEAV12@XZ"]
    pub fn cocos2d_CCFiniteTimeAction_reverse(
        this: *mut ::std::os::raw::c_void,
    ) -> *mut cocos2d_CCFiniteTimeAction;
}
#[doc = "@brief Changes the speed of an action, making it take longer (speed>1)"]
#[doc = "or less (speed<1) time."]
#[doc = "Useful to simulate 'slow motion' or 'fast forward' effect."]
#[doc = "@warning This action can't be Sequenceable because it is not an CCIntervalAction"]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCSpeed {
    pub _base: cocos2d_CCAction,
    pub m_fSpeed: f32,
    pub m_pInnerAction: *mut cocos2d_CCActionInterval,
}
#[test]
fn bindgen_test_layout_cocos2d_CCSpeed() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCSpeed>(),
        80usize,
        concat!("Size of: ", stringify!(cocos2d_CCSpeed))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCSpeed>(),
        8usize,
        concat!("Alignment of ", stringify!(cocos2d_CCSpeed))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cocos2d_CCSpeed>())).m_fSpeed as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCSpeed),
            "::",
            stringify!(m_fSpeed)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cocos2d_CCSpeed>())).m_pInnerAction as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCSpeed),
            "::",
            stringify!(m_pInnerAction)
        )
    );
}
extern "C" {
    #[doc = " initializes the action"]
    #[link_name = "\u{1}?initWithAction@CCSpeed@cocos2d@@QEAA_NPEAVCCActionInterval@2@M@Z"]
    pub fn cocos2d_CCSpeed_initWithAction(
        this: *mut cocos2d_CCSpeed,
        pAction: *mut cocos2d_CCActionInterval,
        fSpeed: f32,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}?setInnerAction@CCSpeed@cocos2d@@QEAAXPEAVCCActionInterval@2@@Z"]
    pub fn cocos2d_CCSpeed_setInnerAction(
        this: *mut cocos2d_CCSpeed,
        pAction: *mut cocos2d_CCActionInterval,
    );
}
extern "C" {
    #[doc = " create the action"]
    #[link_name = "\u{1}?create@CCSpeed@cocos2d@@SAPEAV12@PEAVCCActionInterval@2@M@Z"]
    pub fn cocos2d_CCSpeed_create(
        pAction: *mut cocos2d_CCActionInterval,
        fSpeed: f32,
    ) -> *mut cocos2d_CCSpeed;
}
impl cocos2d_CCSpeed {
    #[inline]
    pub unsafe fn initWithAction(
        &mut self,
        pAction: *mut cocos2d_CCActionInterval,
        fSpeed: f32,
    ) -> bool {
        cocos2d_CCSpeed_initWithAction(self, pAction, fSpeed)
    }
    #[inline]
    pub unsafe fn setInnerAction(&mut self, pAction: *mut cocos2d_CCActionInterval) {
        cocos2d_CCSpeed_setInnerAction(self, pAction)
    }
    #[inline]
    pub unsafe fn create(
        pAction: *mut cocos2d_CCActionInterval,
        fSpeed: f32,
    ) -> *mut cocos2d_CCSpeed {
        cocos2d_CCSpeed_create(pAction, fSpeed)
    }
}
extern "C" {
    #[doc = "  @js NA"]
    #[doc = "  @lua NA"]
    #[link_name = "\u{1}??_DCCSpeed@cocos2d@@QEAAXXZ"]
    pub fn cocos2d_CCSpeed_CCSpeed_destructor(this: *mut cocos2d_CCSpeed);
}
extern "C" {
    #[doc = "  @js NA"]
    #[doc = "  @lua NA"]
    #[link_name = "\u{1}?copyWithZone@CCSpeed@cocos2d@@UEAAPEAVCCObject@2@PEAVCCZone@2@@Z"]
    pub fn cocos2d_CCSpeed_copyWithZone(
        this: *mut ::std::os::raw::c_void,
        pZone: *mut cocos2d_CCZone,
    ) -> *mut cocos2d_CCObject;
}
extern "C" {
    #[link_name = "\u{1}?startWithTarget@CCSpeed@cocos2d@@UEAAXPEAVCCNode@2@@Z"]
    pub fn cocos2d_CCSpeed_startWithTarget(
        this: *mut ::std::os::raw::c_void,
        pTarget: *mut cocos2d_CCNode,
    );
}
extern "C" {
    #[link_name = "\u{1}?stop@CCSpeed@cocos2d@@UEAAXXZ"]
    pub fn cocos2d_CCSpeed_stop(this: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[link_name = "\u{1}?step@CCSpeed@cocos2d@@UEAAXM@Z"]
    pub fn cocos2d_CCSpeed_step(this: *mut ::std::os::raw::c_void, dt: f32);
}
extern "C" {
    #[link_name = "\u{1}?isDone@CCSpeed@cocos2d@@UEAA_NXZ"]
    pub fn cocos2d_CCSpeed_isDone(this: *mut ::std::os::raw::c_void) -> bool;
}
extern "C" {
    #[link_name = "\u{1}?reverse@CCSpeed@cocos2d@@UEAAPEAVCCActionInterval@2@XZ"]
    pub fn cocos2d_CCSpeed_reverse(
        this: *mut ::std::os::raw::c_void,
    ) -> *mut cocos2d_CCActionInterval;
}
#[doc = "@brief CCFollow is an action that \"follows\" a node."]
#[doc = ""]
#[doc = "Eg:"]
#[doc = "layer->runAction(CCFollow::actionWithTarget(hero));"]
#[doc = ""]
#[doc = "Instead of using CCCamera as a \"follower\", use this action instead."]
#[doc = "@since v0.99.2"]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCFollow {
    pub _base: cocos2d_CCAction,
    pub m_pobFollowedNode: *mut cocos2d_CCNode,
    pub m_bBoundarySet: bool,
    pub m_bBoundaryFullyCovered: bool,
    pub m_obHalfScreenSize: cocos2d_CCPoint,
    pub m_obFullScreenSize: cocos2d_CCPoint,
    pub m_fLeftBoundary: f32,
    pub m_fRightBoundary: f32,
    pub m_fTopBoundary: f32,
    pub m_fBottomBoundary: f32,
}
#[test]
fn bindgen_test_layout_cocos2d_CCFollow() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCFollow>(),
        112usize,
        concat!("Size of: ", stringify!(cocos2d_CCFollow))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCFollow>(),
        8usize,
        concat!("Alignment of ", stringify!(cocos2d_CCFollow))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cocos2d_CCFollow>())).m_pobFollowedNode as *const _ as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCFollow),
            "::",
            stringify!(m_pobFollowedNode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cocos2d_CCFollow>())).m_bBoundarySet as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCFollow),
            "::",
            stringify!(m_bBoundarySet)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cocos2d_CCFollow>())).m_bBoundaryFullyCovered as *const _
                as usize
        },
        73usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCFollow),
            "::",
            stringify!(m_bBoundaryFullyCovered)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cocos2d_CCFollow>())).m_obHalfScreenSize as *const _ as usize
        },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCFollow),
            "::",
            stringify!(m_obHalfScreenSize)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cocos2d_CCFollow>())).m_obFullScreenSize as *const _ as usize
        },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCFollow),
            "::",
            stringify!(m_obFullScreenSize)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cocos2d_CCFollow>())).m_fLeftBoundary as *const _ as usize
        },
        92usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCFollow),
            "::",
            stringify!(m_fLeftBoundary)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cocos2d_CCFollow>())).m_fRightBoundary as *const _ as usize
        },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCFollow),
            "::",
            stringify!(m_fRightBoundary)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cocos2d_CCFollow>())).m_fTopBoundary as *const _ as usize },
        100usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCFollow),
            "::",
            stringify!(m_fTopBoundary)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cocos2d_CCFollow>())).m_fBottomBoundary as *const _ as usize
        },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCFollow),
            "::",
            stringify!(m_fBottomBoundary)
        )
    );
}
extern "C" {
    #[doc = " initializes the action with a set boundary"]
    #[link_name = "\u{1}?initWithTarget@CCFollow@cocos2d@@QEAA_NPEAVCCNode@2@AEBVCCRect@2@@Z"]
    pub fn cocos2d_CCFollow_initWithTarget(
        this: *mut cocos2d_CCFollow,
        pFollowedNode: *mut cocos2d_CCNode,
        rect: *const cocos2d_CCRect,
    ) -> bool;
}
extern "C" {
    #[doc = " creates the action with a set boundary,"]
    #[doc = "It will work with no boundary if @param rect is equal to CCRectZero."]
    #[link_name = "\u{1}?create@CCFollow@cocos2d@@SAPEAV12@PEAVCCNode@2@AEBVCCRect@2@@Z"]
    pub fn cocos2d_CCFollow_create(
        pFollowedNode: *mut cocos2d_CCNode,
        rect: *const cocos2d_CCRect,
    ) -> *mut cocos2d_CCFollow;
}
impl cocos2d_CCFollow {
    #[inline]
    pub unsafe fn initWithTarget(
        &mut self,
        pFollowedNode: *mut cocos2d_CCNode,
        rect: *const cocos2d_CCRect,
    ) -> bool {
        cocos2d_CCFollow_initWithTarget(self, pFollowedNode, rect)
    }
    #[inline]
    pub unsafe fn create(
        pFollowedNode: *mut cocos2d_CCNode,
        rect: *const cocos2d_CCRect,
    ) -> *mut cocos2d_CCFollow {
        cocos2d_CCFollow_create(pFollowedNode, rect)
    }
}
extern "C" {
    #[doc = "  @js NA"]
    #[doc = "  @lua NA"]
    #[link_name = "\u{1}??_DCCFollow@cocos2d@@QEAAXXZ"]
    pub fn cocos2d_CCFollow_CCFollow_destructor(this: *mut cocos2d_CCFollow);
}
extern "C" {
    #[doc = "  @js NA"]
    #[doc = "  @lua NA"]
    #[link_name = "\u{1}?copyWithZone@CCFollow@cocos2d@@UEAAPEAVCCObject@2@PEAVCCZone@2@@Z"]
    pub fn cocos2d_CCFollow_copyWithZone(
        this: *mut ::std::os::raw::c_void,
        pZone: *mut cocos2d_CCZone,
    ) -> *mut cocos2d_CCObject;
}
extern "C" {
    #[link_name = "\u{1}?step@CCFollow@cocos2d@@UEAAXM@Z"]
    pub fn cocos2d_CCFollow_step(this: *mut ::std::os::raw::c_void, dt: f32);
}
extern "C" {
    #[link_name = "\u{1}?isDone@CCFollow@cocos2d@@UEAA_NXZ"]
    pub fn cocos2d_CCFollow_isDone(this: *mut ::std::os::raw::c_void) -> bool;
}
extern "C" {
    #[link_name = "\u{1}?stop@CCFollow@cocos2d@@UEAAXXZ"]
    pub fn cocos2d_CCFollow_stop(this: *mut ::std::os::raw::c_void);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cocos2d_CCAffineTransform {
    pub a: f32,
    pub b: f32,
    pub c: f32,
    pub d: f32,
    pub tx: f32,
    pub ty: f32,
}
#[test]
fn bindgen_test_layout_cocos2d_CCAffineTransform() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCAffineTransform>(),
        24usize,
        concat!("Size of: ", stringify!(cocos2d_CCAffineTransform))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCAffineTransform>(),
        4usize,
        concat!("Alignment of ", stringify!(cocos2d_CCAffineTransform))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cocos2d_CCAffineTransform>())).a as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCAffineTransform),
            "::",
            stringify!(a)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cocos2d_CCAffineTransform>())).b as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCAffineTransform),
            "::",
            stringify!(b)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cocos2d_CCAffineTransform>())).c as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCAffineTransform),
            "::",
            stringify!(c)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cocos2d_CCAffineTransform>())).d as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCAffineTransform),
            "::",
            stringify!(d)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cocos2d_CCAffineTransform>())).tx as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCAffineTransform),
            "::",
            stringify!(tx)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cocos2d_CCAffineTransform>())).ty as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCAffineTransform),
            "::",
            stringify!(ty)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}?__CCAffineTransformMake@cocos2d@@YA?AUCCAffineTransform@1@MMMMMM@Z"]
    pub fn cocos2d___CCAffineTransformMake(
        a: f32,
        b: f32,
        c: f32,
        d: f32,
        tx: f32,
        ty: f32,
    ) -> cocos2d_CCAffineTransform;
}
extern "C" {
    #[link_name = "\u{1}?__CCPointApplyAffineTransform@cocos2d@@YA?AVCCPoint@1@AEBV21@AEBUCCAffineTransform@1@@Z"]
    pub fn cocos2d___CCPointApplyAffineTransform(
        point: *const cocos2d_CCPoint,
        t: *const cocos2d_CCAffineTransform,
    ) -> cocos2d_CCPoint;
}
extern "C" {
    #[link_name = "\u{1}?__CCSizeApplyAffineTransform@cocos2d@@YA?AVCCSize@1@AEBV21@AEBUCCAffineTransform@1@@Z"]
    pub fn cocos2d___CCSizeApplyAffineTransform(
        size: *const cocos2d_CCSize,
        t: *const cocos2d_CCAffineTransform,
    ) -> cocos2d_CCSize;
}
extern "C" {
    #[link_name = "\u{1}?CCAffineTransformMakeIdentity@cocos2d@@YA?AUCCAffineTransform@1@XZ"]
    pub fn cocos2d_CCAffineTransformMakeIdentity() -> cocos2d_CCAffineTransform;
}
extern "C" {
    #[link_name = "\u{1}?CCRectApplyAffineTransform@cocos2d@@YA?AVCCRect@1@AEBV21@AEBUCCAffineTransform@1@@Z"]
    pub fn cocos2d_CCRectApplyAffineTransform(
        rect: *const cocos2d_CCRect,
        anAffineTransform: *const cocos2d_CCAffineTransform,
    ) -> cocos2d_CCRect;
}
extern "C" {
    #[link_name = "\u{1}?CCAffineTransformTranslate@cocos2d@@YA?AUCCAffineTransform@1@AEBU21@MM@Z"]
    pub fn cocos2d_CCAffineTransformTranslate(
        t: *const cocos2d_CCAffineTransform,
        tx: f32,
        ty: f32,
    ) -> cocos2d_CCAffineTransform;
}
extern "C" {
    #[link_name = "\u{1}?CCAffineTransformRotate@cocos2d@@YA?AUCCAffineTransform@1@AEBU21@M@Z"]
    pub fn cocos2d_CCAffineTransformRotate(
        aTransform: *const cocos2d_CCAffineTransform,
        anAngle: f32,
    ) -> cocos2d_CCAffineTransform;
}
extern "C" {
    #[link_name = "\u{1}?CCAffineTransformScale@cocos2d@@YA?AUCCAffineTransform@1@AEBU21@MM@Z"]
    pub fn cocos2d_CCAffineTransformScale(
        t: *const cocos2d_CCAffineTransform,
        sx: f32,
        sy: f32,
    ) -> cocos2d_CCAffineTransform;
}
extern "C" {
    #[link_name = "\u{1}?CCAffineTransformConcat@cocos2d@@YA?AUCCAffineTransform@1@AEBU21@0@Z"]
    pub fn cocos2d_CCAffineTransformConcat(
        t1: *const cocos2d_CCAffineTransform,
        t2: *const cocos2d_CCAffineTransform,
    ) -> cocos2d_CCAffineTransform;
}
extern "C" {
    #[link_name = "\u{1}?CCAffineTransformEqualToTransform@cocos2d@@YA_NAEBUCCAffineTransform@1@0@Z"]
    pub fn cocos2d_CCAffineTransformEqualToTransform(
        t1: *const cocos2d_CCAffineTransform,
        t2: *const cocos2d_CCAffineTransform,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}?CCAffineTransformInvert@cocos2d@@YA?AUCCAffineTransform@1@AEBU21@@Z"]
    pub fn cocos2d_CCAffineTransformInvert(
        t: *const cocos2d_CCAffineTransform,
    ) -> cocos2d_CCAffineTransform;
}
extern "C" {
    #[link_name = "\u{1}?CCAffineTransformIdentity@cocos2d@@3UCCAffineTransform@1@B"]
    pub static cocos2d_CCAffineTransformIdentity: cocos2d_CCAffineTransform;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cocos2d__ccArray {
    pub num: ::std::os::raw::c_uint,
    pub max: ::std::os::raw::c_uint,
    pub arr: *mut *mut cocos2d_CCObject,
}
#[test]
fn bindgen_test_layout_cocos2d__ccArray() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d__ccArray>(),
        16usize,
        concat!("Size of: ", stringify!(cocos2d__ccArray))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d__ccArray>(),
        8usize,
        concat!("Alignment of ", stringify!(cocos2d__ccArray))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cocos2d__ccArray>())).num as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d__ccArray),
            "::",
            stringify!(num)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cocos2d__ccArray>())).max as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d__ccArray),
            "::",
            stringify!(max)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cocos2d__ccArray>())).arr as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d__ccArray),
            "::",
            stringify!(arr)
        )
    );
}
pub type cocos2d_ccArray = cocos2d__ccArray;
extern "C" {
    #[doc = " Allocates and initializes a new array with specified capacity"]
    #[link_name = "\u{1}?ccArrayNew@cocos2d@@YAPEAU_ccArray@1@I@Z"]
    pub fn cocos2d_ccArrayNew(capacity: ::std::os::raw::c_uint) -> *mut cocos2d_ccArray;
}
extern "C" {
    #[doc = " Frees array after removing all remaining objects. Silently ignores nil arr."]
    #[link_name = "\u{1}?ccArrayFree@cocos2d@@YAXAEAPEAU_ccArray@1@@Z"]
    pub fn cocos2d_ccArrayFree(arr: *mut *mut cocos2d_ccArray);
}
extern "C" {
    #[doc = " Doubles array capacity"]
    #[link_name = "\u{1}?ccArrayDoubleCapacity@cocos2d@@YAXPEAU_ccArray@1@@Z"]
    pub fn cocos2d_ccArrayDoubleCapacity(arr: *mut cocos2d_ccArray);
}
extern "C" {
    #[doc = " Increases array capacity such that max >= num + extra."]
    #[link_name = "\u{1}?ccArrayEnsureExtraCapacity@cocos2d@@YAXPEAU_ccArray@1@I@Z"]
    pub fn cocos2d_ccArrayEnsureExtraCapacity(
        arr: *mut cocos2d_ccArray,
        extra: ::std::os::raw::c_uint,
    );
}
extern "C" {
    #[doc = " shrinks the array so the memory footprint corresponds with the number of items"]
    #[link_name = "\u{1}?ccArrayShrink@cocos2d@@YAXPEAU_ccArray@1@@Z"]
    pub fn cocos2d_ccArrayShrink(arr: *mut cocos2d_ccArray);
}
extern "C" {
    #[doc = " Returns index of first occurrence of object, NSNotFound if object not found."]
    #[link_name = "\u{1}?ccArrayGetIndexOfObject@cocos2d@@YAIPEAU_ccArray@1@PEAVCCObject@1@@Z"]
    pub fn cocos2d_ccArrayGetIndexOfObject(
        arr: *mut cocos2d_ccArray,
        object: *mut cocos2d_CCObject,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " Returns a Boolean value that indicates whether object is present in array."]
    #[link_name = "\u{1}?ccArrayContainsObject@cocos2d@@YA_NPEAU_ccArray@1@PEAVCCObject@1@@Z"]
    pub fn cocos2d_ccArrayContainsObject(
        arr: *mut cocos2d_ccArray,
        object: *mut cocos2d_CCObject,
    ) -> bool;
}
extern "C" {
    #[doc = " Appends an object. Behavior undefined if array doesn't have enough capacity."]
    #[link_name = "\u{1}?ccArrayAppendObject@cocos2d@@YAXPEAU_ccArray@1@PEAVCCObject@1@@Z"]
    pub fn cocos2d_ccArrayAppendObject(arr: *mut cocos2d_ccArray, object: *mut cocos2d_CCObject);
}
extern "C" {
    #[doc = " Appends an object. Capacity of arr is increased if needed."]
    #[link_name = "\u{1}?ccArrayAppendObjectWithResize@cocos2d@@YAXPEAU_ccArray@1@PEAVCCObject@1@@Z"]
    pub fn cocos2d_ccArrayAppendObjectWithResize(
        arr: *mut cocos2d_ccArray,
        object: *mut cocos2d_CCObject,
    );
}
extern "C" {
    #[doc = " Appends objects from plusArr to arr."]
    #[doc = "Behavior undefined if arr doesn't have enough capacity."]
    #[link_name = "\u{1}?ccArrayAppendArray@cocos2d@@YAXPEAU_ccArray@1@0@Z"]
    pub fn cocos2d_ccArrayAppendArray(arr: *mut cocos2d_ccArray, plusArr: *mut cocos2d_ccArray);
}
extern "C" {
    #[doc = " Appends objects from plusArr to arr. Capacity of arr is increased if needed."]
    #[link_name = "\u{1}?ccArrayAppendArrayWithResize@cocos2d@@YAXPEAU_ccArray@1@0@Z"]
    pub fn cocos2d_ccArrayAppendArrayWithResize(
        arr: *mut cocos2d_ccArray,
        plusArr: *mut cocos2d_ccArray,
    );
}
extern "C" {
    #[doc = " Inserts an object at index"]
    #[link_name = "\u{1}?ccArrayInsertObjectAtIndex@cocos2d@@YAXPEAU_ccArray@1@PEAVCCObject@1@I@Z"]
    pub fn cocos2d_ccArrayInsertObjectAtIndex(
        arr: *mut cocos2d_ccArray,
        object: *mut cocos2d_CCObject,
        index: ::std::os::raw::c_uint,
    );
}
extern "C" {
    #[doc = " Swaps two objects"]
    #[link_name = "\u{1}?ccArraySwapObjectsAtIndexes@cocos2d@@YAXPEAU_ccArray@1@II@Z"]
    pub fn cocos2d_ccArraySwapObjectsAtIndexes(
        arr: *mut cocos2d_ccArray,
        index1: ::std::os::raw::c_uint,
        index2: ::std::os::raw::c_uint,
    );
}
extern "C" {
    #[doc = " Removes all objects from arr"]
    #[link_name = "\u{1}?ccArrayRemoveAllObjects@cocos2d@@YAXPEAU_ccArray@1@@Z"]
    pub fn cocos2d_ccArrayRemoveAllObjects(arr: *mut cocos2d_ccArray);
}
extern "C" {
    #[doc = " Removes object at specified index and pushes back all subsequent objects."]
    #[doc = "Behavior undefined if index outside [0, num-1]."]
    #[link_name = "\u{1}?ccArrayRemoveObjectAtIndex@cocos2d@@YAXPEAU_ccArray@1@I_N@Z"]
    pub fn cocos2d_ccArrayRemoveObjectAtIndex(
        arr: *mut cocos2d_ccArray,
        index: ::std::os::raw::c_uint,
        bReleaseObj: bool,
    );
}
extern "C" {
    #[doc = " Removes object at specified index and fills the gap with the last object,"]
    #[doc = "thereby avoiding the need to push back subsequent objects."]
    #[doc = "Behavior undefined if index outside [0, num-1]."]
    #[link_name = "\u{1}?ccArrayFastRemoveObjectAtIndex@cocos2d@@YAXPEAU_ccArray@1@I@Z"]
    pub fn cocos2d_ccArrayFastRemoveObjectAtIndex(
        arr: *mut cocos2d_ccArray,
        index: ::std::os::raw::c_uint,
    );
}
extern "C" {
    #[link_name = "\u{1}?ccArrayFastRemoveObject@cocos2d@@YAXPEAU_ccArray@1@PEAVCCObject@1@@Z"]
    pub fn cocos2d_ccArrayFastRemoveObject(
        arr: *mut cocos2d_ccArray,
        object: *mut cocos2d_CCObject,
    );
}
extern "C" {
    #[doc = " Searches for the first occurrence of object and removes it. If object is not"]
    #[doc = "found the function has no effect."]
    #[link_name = "\u{1}?ccArrayRemoveObject@cocos2d@@YAXPEAU_ccArray@1@PEAVCCObject@1@_N@Z"]
    pub fn cocos2d_ccArrayRemoveObject(
        arr: *mut cocos2d_ccArray,
        object: *mut cocos2d_CCObject,
        bReleaseObj: bool,
    );
}
extern "C" {
    #[doc = " Removes from arr all objects in minusArr. For each object in minusArr, the"]
    #[doc = "first matching instance in arr will be removed."]
    #[link_name = "\u{1}?ccArrayRemoveArray@cocos2d@@YAXPEAU_ccArray@1@0@Z"]
    pub fn cocos2d_ccArrayRemoveArray(arr: *mut cocos2d_ccArray, minusArr: *mut cocos2d_ccArray);
}
extern "C" {
    #[doc = " Removes from arr all objects in minusArr. For each object in minusArr, all"]
    #[doc = "matching instances in arr will be removed."]
    #[link_name = "\u{1}?ccArrayFullRemoveArray@cocos2d@@YAXPEAU_ccArray@1@0@Z"]
    pub fn cocos2d_ccArrayFullRemoveArray(
        arr: *mut cocos2d_ccArray,
        minusArr: *mut cocos2d_ccArray,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cocos2d__ccCArray {
    pub num: ::std::os::raw::c_uint,
    pub max: ::std::os::raw::c_uint,
    pub arr: *mut *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_cocos2d__ccCArray() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d__ccCArray>(),
        16usize,
        concat!("Size of: ", stringify!(cocos2d__ccCArray))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d__ccCArray>(),
        8usize,
        concat!("Alignment of ", stringify!(cocos2d__ccCArray))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cocos2d__ccCArray>())).num as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d__ccCArray),
            "::",
            stringify!(num)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cocos2d__ccCArray>())).max as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d__ccCArray),
            "::",
            stringify!(max)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cocos2d__ccCArray>())).arr as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d__ccCArray),
            "::",
            stringify!(arr)
        )
    );
}
pub type cocos2d_ccCArray = cocos2d__ccCArray;
extern "C" {
    #[doc = " Allocates and initializes a new C array with specified capacity"]
    #[link_name = "\u{1}?ccCArrayNew@cocos2d@@YAPEAU_ccCArray@1@I@Z"]
    pub fn cocos2d_ccCArrayNew(capacity: ::std::os::raw::c_uint) -> *mut cocos2d_ccCArray;
}
extern "C" {
    #[doc = " Frees C array after removing all remaining values. Silently ignores nil arr."]
    #[link_name = "\u{1}?ccCArrayFree@cocos2d@@YAXPEAU_ccCArray@1@@Z"]
    pub fn cocos2d_ccCArrayFree(arr: *mut cocos2d_ccCArray);
}
extern "C" {
    #[doc = " Doubles C array capacity"]
    #[link_name = "\u{1}?ccCArrayDoubleCapacity@cocos2d@@YAXPEAU_ccCArray@1@@Z"]
    pub fn cocos2d_ccCArrayDoubleCapacity(arr: *mut cocos2d_ccCArray);
}
extern "C" {
    #[doc = " Increases array capacity such that max >= num + extra."]
    #[link_name = "\u{1}?ccCArrayEnsureExtraCapacity@cocos2d@@YAXPEAU_ccCArray@1@I@Z"]
    pub fn cocos2d_ccCArrayEnsureExtraCapacity(
        arr: *mut cocos2d_ccCArray,
        extra: ::std::os::raw::c_uint,
    );
}
extern "C" {
    #[doc = " Returns index of first occurrence of value, NSNotFound if value not found."]
    #[link_name = "\u{1}?ccCArrayGetIndexOfValue@cocos2d@@YAIPEAU_ccCArray@1@PEAX@Z"]
    pub fn cocos2d_ccCArrayGetIndexOfValue(
        arr: *mut cocos2d_ccCArray,
        value: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " Returns a Boolean value that indicates whether value is present in the C array."]
    #[link_name = "\u{1}?ccCArrayContainsValue@cocos2d@@YA_NPEAU_ccCArray@1@PEAX@Z"]
    pub fn cocos2d_ccCArrayContainsValue(
        arr: *mut cocos2d_ccCArray,
        value: *mut ::std::os::raw::c_void,
    ) -> bool;
}
extern "C" {
    #[doc = " Inserts a value at a certain position. Behavior undefined if array doesn't have enough capacity"]
    #[link_name = "\u{1}?ccCArrayInsertValueAtIndex@cocos2d@@YAXPEAU_ccCArray@1@PEAXI@Z"]
    pub fn cocos2d_ccCArrayInsertValueAtIndex(
        arr: *mut cocos2d_ccCArray,
        value: *mut ::std::os::raw::c_void,
        index: ::std::os::raw::c_uint,
    );
}
extern "C" {
    #[doc = " Appends an value. Behavior undefined if array doesn't have enough capacity."]
    #[link_name = "\u{1}?ccCArrayAppendValue@cocos2d@@YAXPEAU_ccCArray@1@PEAX@Z"]
    pub fn cocos2d_ccCArrayAppendValue(
        arr: *mut cocos2d_ccCArray,
        value: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    #[doc = " Appends an value. Capacity of arr is increased if needed."]
    #[link_name = "\u{1}?ccCArrayAppendValueWithResize@cocos2d@@YAXPEAU_ccCArray@1@PEAX@Z"]
    pub fn cocos2d_ccCArrayAppendValueWithResize(
        arr: *mut cocos2d_ccCArray,
        value: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    #[doc = " Appends values from plusArr to arr. Behavior undefined if arr doesn't have"]
    #[doc = "enough capacity."]
    #[link_name = "\u{1}?ccCArrayAppendArray@cocos2d@@YAXPEAU_ccCArray@1@0@Z"]
    pub fn cocos2d_ccCArrayAppendArray(arr: *mut cocos2d_ccCArray, plusArr: *mut cocos2d_ccCArray);
}
extern "C" {
    #[doc = " Appends values from plusArr to arr. Capacity of arr is increased if needed."]
    #[link_name = "\u{1}?ccCArrayAppendArrayWithResize@cocos2d@@YAXPEAU_ccCArray@1@0@Z"]
    pub fn cocos2d_ccCArrayAppendArrayWithResize(
        arr: *mut cocos2d_ccCArray,
        plusArr: *mut cocos2d_ccCArray,
    );
}
extern "C" {
    #[doc = " Removes all values from arr"]
    #[link_name = "\u{1}?ccCArrayRemoveAllValues@cocos2d@@YAXPEAU_ccCArray@1@@Z"]
    pub fn cocos2d_ccCArrayRemoveAllValues(arr: *mut cocos2d_ccCArray);
}
extern "C" {
    #[doc = " Removes value at specified index and pushes back all subsequent values."]
    #[doc = "Behavior undefined if index outside [0, num-1]."]
    #[doc = "@since v0.99.4"]
    #[link_name = "\u{1}?ccCArrayRemoveValueAtIndex@cocos2d@@YAXPEAU_ccCArray@1@I@Z"]
    pub fn cocos2d_ccCArrayRemoveValueAtIndex(
        arr: *mut cocos2d_ccCArray,
        index: ::std::os::raw::c_uint,
    );
}
extern "C" {
    #[doc = " Removes value at specified index and fills the gap with the last value,"]
    #[doc = "thereby avoiding the need to push back subsequent values."]
    #[doc = "Behavior undefined if index outside [0, num-1]."]
    #[doc = "@since v0.99.4"]
    #[link_name = "\u{1}?ccCArrayFastRemoveValueAtIndex@cocos2d@@YAXPEAU_ccCArray@1@I@Z"]
    pub fn cocos2d_ccCArrayFastRemoveValueAtIndex(
        arr: *mut cocos2d_ccCArray,
        index: ::std::os::raw::c_uint,
    );
}
extern "C" {
    #[doc = " Searches for the first occurrence of value and removes it. If value is not found the function has no effect."]
    #[doc = "@since v0.99.4"]
    #[link_name = "\u{1}?ccCArrayRemoveValue@cocos2d@@YAXPEAU_ccCArray@1@PEAX@Z"]
    pub fn cocos2d_ccCArrayRemoveValue(
        arr: *mut cocos2d_ccCArray,
        value: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    #[doc = " Removes from arr all values in minusArr. For each Value in minusArr, the first matching instance in arr will be removed."]
    #[doc = "@since v0.99.4"]
    #[link_name = "\u{1}?ccCArrayRemoveArray@cocos2d@@YAXPEAU_ccCArray@1@0@Z"]
    pub fn cocos2d_ccCArrayRemoveArray(arr: *mut cocos2d_ccCArray, minusArr: *mut cocos2d_ccCArray);
}
extern "C" {
    #[doc = " Removes from arr all values in minusArr. For each value in minusArr, all matching instances in arr will be removed."]
    #[doc = "@since v0.99.4"]
    #[link_name = "\u{1}?ccCArrayFullRemoveArray@cocos2d@@YAXPEAU_ccCArray@1@0@Z"]
    pub fn cocos2d_ccCArrayFullRemoveArray(
        arr: *mut cocos2d_ccCArray,
        minusArr: *mut cocos2d_ccCArray,
    );
}
#[doc = " @js NA"]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCArray {
    pub _base: cocos2d_CCObject,
    pub data: *mut cocos2d_ccArray,
}
#[test]
fn bindgen_test_layout_cocos2d_CCArray() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCArray>(),
        48usize,
        concat!("Size of: ", stringify!(cocos2d_CCArray))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCArray>(),
        8usize,
        concat!("Alignment of ", stringify!(cocos2d_CCArray))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cocos2d_CCArray>())).data as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCArray),
            "::",
            stringify!(data)
        )
    );
}
extern "C" {
    #[doc = " Create an array"]
    #[link_name = "\u{1}?create@CCArray@cocos2d@@SAPEAV12@XZ"]
    pub fn cocos2d_CCArray_create() -> *mut cocos2d_CCArray;
}
extern "C" {
    #[doc = " Create an array with some objects"]
    #[doc = "  @lua NA"]
    #[link_name = "\u{1}?create@CCArray@cocos2d@@SAPEAV12@PEAVCCObject@2@ZZ"]
    pub fn cocos2d_CCArray_create1(pObject: *mut cocos2d_CCObject, ...) -> *mut cocos2d_CCArray;
}
extern "C" {
    #[doc = " Create an array with one object"]
    #[link_name = "\u{1}?createWithObject@CCArray@cocos2d@@SAPEAV12@PEAVCCObject@2@@Z"]
    pub fn cocos2d_CCArray_createWithObject(pObject: *mut cocos2d_CCObject)
        -> *mut cocos2d_CCArray;
}
extern "C" {
    #[doc = " Create an array with capacity"]
    #[link_name = "\u{1}?createWithCapacity@CCArray@cocos2d@@SAPEAV12@I@Z"]
    pub fn cocos2d_CCArray_createWithCapacity(
        capacity: ::std::os::raw::c_uint,
    ) -> *mut cocos2d_CCArray;
}
extern "C" {
    #[doc = " Create an array with an existing array"]
    #[link_name = "\u{1}?createWithArray@CCArray@cocos2d@@SAPEAV12@PEAV12@@Z"]
    pub fn cocos2d_CCArray_createWithArray(
        otherArray: *mut cocos2d_CCArray,
    ) -> *mut cocos2d_CCArray;
}
extern "C" {
    #[doc = "@brief   Generate a CCArray pointer by file"]
    #[doc = "@param   pFileName  The file name of *.plist file"]
    #[doc = "@return  The CCArray pointer generated from the file"]
    #[link_name = "\u{1}?createWithContentsOfFile@CCArray@cocos2d@@SAPEAV12@PEBD@Z"]
    pub fn cocos2d_CCArray_createWithContentsOfFile(
        pFileName: *const ::std::os::raw::c_char,
    ) -> *mut cocos2d_CCArray;
}
extern "C" {
    #[link_name = "\u{1}?createWithContentsOfFileThreadSafe@CCArray@cocos2d@@SAPEAV12@PEBD@Z"]
    pub fn cocos2d_CCArray_createWithContentsOfFileThreadSafe(
        pFileName: *const ::std::os::raw::c_char,
    ) -> *mut cocos2d_CCArray;
}
extern "C" {
    #[doc = " Initializes an array"]
    #[doc = "  @lua NA"]
    #[link_name = "\u{1}?init@CCArray@cocos2d@@QEAA_NXZ"]
    pub fn cocos2d_CCArray_init(this: *mut cocos2d_CCArray) -> bool;
}
extern "C" {
    #[doc = " Initializes an array with one object"]
    #[doc = "  @lua NA"]
    #[link_name = "\u{1}?initWithObject@CCArray@cocos2d@@QEAA_NPEAVCCObject@2@@Z"]
    pub fn cocos2d_CCArray_initWithObject(
        this: *mut cocos2d_CCArray,
        pObject: *mut cocos2d_CCObject,
    ) -> bool;
}
extern "C" {
    #[doc = " Initializes an array with some objects"]
    #[doc = "  @lua NA"]
    #[link_name = "\u{1}?initWithObjects@CCArray@cocos2d@@QEAA_NPEAVCCObject@2@ZZ"]
    pub fn cocos2d_CCArray_initWithObjects(
        this: *mut cocos2d_CCArray,
        pObject: *mut cocos2d_CCObject,
        ...
    ) -> bool;
}
extern "C" {
    #[doc = " Initializes an array with capacity"]
    #[doc = "  @lua NA"]
    #[link_name = "\u{1}?initWithCapacity@CCArray@cocos2d@@QEAA_NI@Z"]
    pub fn cocos2d_CCArray_initWithCapacity(
        this: *mut cocos2d_CCArray,
        capacity: ::std::os::raw::c_uint,
    ) -> bool;
}
extern "C" {
    #[doc = " Initializes an array with an existing array"]
    #[doc = "  @lua NA"]
    #[link_name = "\u{1}?initWithArray@CCArray@cocos2d@@QEAA_NPEAV12@@Z"]
    pub fn cocos2d_CCArray_initWithArray(
        this: *mut cocos2d_CCArray,
        otherArray: *mut cocos2d_CCArray,
    ) -> bool;
}
extern "C" {
    #[doc = " Returns element count of the array"]
    #[link_name = "\u{1}?count@CCArray@cocos2d@@QEBAIXZ"]
    pub fn cocos2d_CCArray_count(this: *const cocos2d_CCArray) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " Returns capacity of the array"]
    #[link_name = "\u{1}?capacity@CCArray@cocos2d@@QEBAIXZ"]
    pub fn cocos2d_CCArray_capacity(this: *const cocos2d_CCArray) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " Returns index of a certain object, return UINT_MAX if doesn't contain the object"]
    #[link_name = "\u{1}?indexOfObject@CCArray@cocos2d@@QEBAIPEAVCCObject@2@@Z"]
    pub fn cocos2d_CCArray_indexOfObject(
        this: *const cocos2d_CCArray,
        object: *mut cocos2d_CCObject,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " Returns an element with a certain index"]
    #[link_name = "\u{1}?objectAtIndex@CCArray@cocos2d@@QEAAPEAVCCObject@2@I@Z"]
    pub fn cocos2d_CCArray_objectAtIndex(
        this: *mut cocos2d_CCArray,
        index: ::std::os::raw::c_uint,
    ) -> *mut cocos2d_CCObject;
}
extern "C" {
    #[doc = " Returns last element"]
    #[link_name = "\u{1}?lastObject@CCArray@cocos2d@@QEAAPEAVCCObject@2@XZ"]
    pub fn cocos2d_CCArray_lastObject(this: *mut cocos2d_CCArray) -> *mut cocos2d_CCObject;
}
extern "C" {
    #[doc = " Returns a random element"]
    #[link_name = "\u{1}?randomObject@CCArray@cocos2d@@QEAAPEAVCCObject@2@XZ"]
    pub fn cocos2d_CCArray_randomObject(this: *mut cocos2d_CCArray) -> *mut cocos2d_CCObject;
}
extern "C" {
    #[doc = " Returns a Boolean value that indicates whether object is present in array."]
    #[link_name = "\u{1}?containsObject@CCArray@cocos2d@@QEBA_NPEAVCCObject@2@@Z"]
    pub fn cocos2d_CCArray_containsObject(
        this: *const cocos2d_CCArray,
        object: *mut cocos2d_CCObject,
    ) -> bool;
}
extern "C" {
    #[doc = " @since 1.1"]
    #[link_name = "\u{1}?isEqualToArray@CCArray@cocos2d@@QEAA_NPEAV12@@Z"]
    pub fn cocos2d_CCArray_isEqualToArray(
        this: *mut cocos2d_CCArray,
        pOtherArray: *mut cocos2d_CCArray,
    ) -> bool;
}
extern "C" {
    #[doc = " Add a certain object"]
    #[link_name = "\u{1}?addObject@CCArray@cocos2d@@QEAAXPEAVCCObject@2@@Z"]
    pub fn cocos2d_CCArray_addObject(this: *mut cocos2d_CCArray, object: *mut cocos2d_CCObject);
}
extern "C" {
    #[doc = " Add all elements of an existing array"]
    #[link_name = "\u{1}?addObjectsFromArray@CCArray@cocos2d@@QEAAXPEAV12@@Z"]
    pub fn cocos2d_CCArray_addObjectsFromArray(
        this: *mut cocos2d_CCArray,
        otherArray: *mut cocos2d_CCArray,
    );
}
extern "C" {
    #[doc = " Insert a certain object at a certain index"]
    #[link_name = "\u{1}?insertObject@CCArray@cocos2d@@QEAAXPEAVCCObject@2@I@Z"]
    pub fn cocos2d_CCArray_insertObject(
        this: *mut cocos2d_CCArray,
        object: *mut cocos2d_CCObject,
        index: ::std::os::raw::c_uint,
    );
}
extern "C" {
    #[doc = " Remove last object"]
    #[link_name = "\u{1}?removeLastObject@CCArray@cocos2d@@QEAAX_N@Z"]
    pub fn cocos2d_CCArray_removeLastObject(this: *mut cocos2d_CCArray, bReleaseObj: bool);
}
extern "C" {
    #[doc = " Remove a certain object"]
    #[link_name = "\u{1}?removeObject@CCArray@cocos2d@@QEAAXPEAVCCObject@2@_N@Z"]
    pub fn cocos2d_CCArray_removeObject(
        this: *mut cocos2d_CCArray,
        object: *mut cocos2d_CCObject,
        bReleaseObj: bool,
    );
}
extern "C" {
    #[doc = " Remove an element with a certain index"]
    #[link_name = "\u{1}?removeObjectAtIndex@CCArray@cocos2d@@QEAAXI_N@Z"]
    pub fn cocos2d_CCArray_removeObjectAtIndex(
        this: *mut cocos2d_CCArray,
        index: ::std::os::raw::c_uint,
        bReleaseObj: bool,
    );
}
extern "C" {
    #[doc = " Remove all elements"]
    #[link_name = "\u{1}?removeObjectsInArray@CCArray@cocos2d@@QEAAXPEAV12@@Z"]
    pub fn cocos2d_CCArray_removeObjectsInArray(
        this: *mut cocos2d_CCArray,
        otherArray: *mut cocos2d_CCArray,
    );
}
extern "C" {
    #[doc = " Remove all objects"]
    #[link_name = "\u{1}?removeAllObjects@CCArray@cocos2d@@QEAAXXZ"]
    pub fn cocos2d_CCArray_removeAllObjects(this: *mut cocos2d_CCArray);
}
extern "C" {
    #[doc = " Fast way to remove a certain object"]
    #[link_name = "\u{1}?fastRemoveObject@CCArray@cocos2d@@QEAAXPEAVCCObject@2@@Z"]
    pub fn cocos2d_CCArray_fastRemoveObject(
        this: *mut cocos2d_CCArray,
        object: *mut cocos2d_CCObject,
    );
}
extern "C" {
    #[doc = " Fast way to remove an element with a certain index"]
    #[link_name = "\u{1}?fastRemoveObjectAtIndex@CCArray@cocos2d@@QEAAXI@Z"]
    pub fn cocos2d_CCArray_fastRemoveObjectAtIndex(
        this: *mut cocos2d_CCArray,
        index: ::std::os::raw::c_uint,
    );
}
extern "C" {
    #[doc = " Swap two elements"]
    #[link_name = "\u{1}?exchangeObject@CCArray@cocos2d@@QEAAXPEAVCCObject@2@0@Z"]
    pub fn cocos2d_CCArray_exchangeObject(
        this: *mut cocos2d_CCArray,
        object1: *mut cocos2d_CCObject,
        object2: *mut cocos2d_CCObject,
    );
}
extern "C" {
    #[doc = " Swap two elements with certain indexes"]
    #[link_name = "\u{1}?exchangeObjectAtIndex@CCArray@cocos2d@@QEAAXII@Z"]
    pub fn cocos2d_CCArray_exchangeObjectAtIndex(
        this: *mut cocos2d_CCArray,
        index1: ::std::os::raw::c_uint,
        index2: ::std::os::raw::c_uint,
    );
}
extern "C" {
    #[doc = " Replace object at index with another object."]
    #[link_name = "\u{1}?replaceObjectAtIndex@CCArray@cocos2d@@QEAAXIPEAVCCObject@2@_N@Z"]
    pub fn cocos2d_CCArray_replaceObjectAtIndex(
        this: *mut cocos2d_CCArray,
        uIndex: ::std::os::raw::c_uint,
        pObject: *mut cocos2d_CCObject,
        bReleaseObject: bool,
    );
}
extern "C" {
    #[doc = " Revers the array"]
    #[link_name = "\u{1}?reverseObjects@CCArray@cocos2d@@QEAAXXZ"]
    pub fn cocos2d_CCArray_reverseObjects(this: *mut cocos2d_CCArray);
}
extern "C" {
    #[link_name = "\u{1}?reduceMemoryFootprint@CCArray@cocos2d@@QEAAXXZ"]
    pub fn cocos2d_CCArray_reduceMemoryFootprint(this: *mut cocos2d_CCArray);
}
extern "C" {
    #[doc = "  @lua NA"]
    #[link_name = "\u{1}??0CCArray@cocos2d@@QEAA@XZ"]
    pub fn cocos2d_CCArray_CCArray(this: *mut cocos2d_CCArray);
}
extern "C" {
    #[doc = "  @lua NA"]
    #[link_name = "\u{1}??0CCArray@cocos2d@@QEAA@I@Z"]
    pub fn cocos2d_CCArray_CCArray1(this: *mut cocos2d_CCArray, capacity: ::std::os::raw::c_uint);
}
impl cocos2d_CCArray {
    #[inline]
    pub unsafe fn create() -> *mut cocos2d_CCArray {
        cocos2d_CCArray_create()
    }
    #[inline]
    pub unsafe fn createWithObject(pObject: *mut cocos2d_CCObject) -> *mut cocos2d_CCArray {
        cocos2d_CCArray_createWithObject(pObject)
    }
    #[inline]
    pub unsafe fn createWithCapacity(capacity: ::std::os::raw::c_uint) -> *mut cocos2d_CCArray {
        cocos2d_CCArray_createWithCapacity(capacity)
    }
    #[inline]
    pub unsafe fn createWithArray(otherArray: *mut cocos2d_CCArray) -> *mut cocos2d_CCArray {
        cocos2d_CCArray_createWithArray(otherArray)
    }
    #[inline]
    pub unsafe fn createWithContentsOfFile(
        pFileName: *const ::std::os::raw::c_char,
    ) -> *mut cocos2d_CCArray {
        cocos2d_CCArray_createWithContentsOfFile(pFileName)
    }
    #[inline]
    pub unsafe fn createWithContentsOfFileThreadSafe(
        pFileName: *const ::std::os::raw::c_char,
    ) -> *mut cocos2d_CCArray {
        cocos2d_CCArray_createWithContentsOfFileThreadSafe(pFileName)
    }
    #[inline]
    pub unsafe fn init(&mut self) -> bool {
        cocos2d_CCArray_init(self)
    }
    #[inline]
    pub unsafe fn initWithObject(&mut self, pObject: *mut cocos2d_CCObject) -> bool {
        cocos2d_CCArray_initWithObject(self, pObject)
    }
    #[inline]
    pub unsafe fn initWithCapacity(&mut self, capacity: ::std::os::raw::c_uint) -> bool {
        cocos2d_CCArray_initWithCapacity(self, capacity)
    }
    #[inline]
    pub unsafe fn initWithArray(&mut self, otherArray: *mut cocos2d_CCArray) -> bool {
        cocos2d_CCArray_initWithArray(self, otherArray)
    }
    #[inline]
    pub unsafe fn count(&self) -> ::std::os::raw::c_uint {
        cocos2d_CCArray_count(self)
    }
    #[inline]
    pub unsafe fn capacity(&self) -> ::std::os::raw::c_uint {
        cocos2d_CCArray_capacity(self)
    }
    #[inline]
    pub unsafe fn indexOfObject(&self, object: *mut cocos2d_CCObject) -> ::std::os::raw::c_uint {
        cocos2d_CCArray_indexOfObject(self, object)
    }
    #[inline]
    pub unsafe fn objectAtIndex(&mut self, index: ::std::os::raw::c_uint) -> *mut cocos2d_CCObject {
        cocos2d_CCArray_objectAtIndex(self, index)
    }
    #[inline]
    pub unsafe fn lastObject(&mut self) -> *mut cocos2d_CCObject {
        cocos2d_CCArray_lastObject(self)
    }
    #[inline]
    pub unsafe fn randomObject(&mut self) -> *mut cocos2d_CCObject {
        cocos2d_CCArray_randomObject(self)
    }
    #[inline]
    pub unsafe fn containsObject(&self, object: *mut cocos2d_CCObject) -> bool {
        cocos2d_CCArray_containsObject(self, object)
    }
    #[inline]
    pub unsafe fn isEqualToArray(&mut self, pOtherArray: *mut cocos2d_CCArray) -> bool {
        cocos2d_CCArray_isEqualToArray(self, pOtherArray)
    }
    #[inline]
    pub unsafe fn addObject(&mut self, object: *mut cocos2d_CCObject) {
        cocos2d_CCArray_addObject(self, object)
    }
    #[inline]
    pub unsafe fn addObjectsFromArray(&mut self, otherArray: *mut cocos2d_CCArray) {
        cocos2d_CCArray_addObjectsFromArray(self, otherArray)
    }
    #[inline]
    pub unsafe fn insertObject(
        &mut self,
        object: *mut cocos2d_CCObject,
        index: ::std::os::raw::c_uint,
    ) {
        cocos2d_CCArray_insertObject(self, object, index)
    }
    #[inline]
    pub unsafe fn removeLastObject(&mut self, bReleaseObj: bool) {
        cocos2d_CCArray_removeLastObject(self, bReleaseObj)
    }
    #[inline]
    pub unsafe fn removeObject(&mut self, object: *mut cocos2d_CCObject, bReleaseObj: bool) {
        cocos2d_CCArray_removeObject(self, object, bReleaseObj)
    }
    #[inline]
    pub unsafe fn removeObjectAtIndex(&mut self, index: ::std::os::raw::c_uint, bReleaseObj: bool) {
        cocos2d_CCArray_removeObjectAtIndex(self, index, bReleaseObj)
    }
    #[inline]
    pub unsafe fn removeObjectsInArray(&mut self, otherArray: *mut cocos2d_CCArray) {
        cocos2d_CCArray_removeObjectsInArray(self, otherArray)
    }
    #[inline]
    pub unsafe fn removeAllObjects(&mut self) {
        cocos2d_CCArray_removeAllObjects(self)
    }
    #[inline]
    pub unsafe fn fastRemoveObject(&mut self, object: *mut cocos2d_CCObject) {
        cocos2d_CCArray_fastRemoveObject(self, object)
    }
    #[inline]
    pub unsafe fn fastRemoveObjectAtIndex(&mut self, index: ::std::os::raw::c_uint) {
        cocos2d_CCArray_fastRemoveObjectAtIndex(self, index)
    }
    #[inline]
    pub unsafe fn exchangeObject(
        &mut self,
        object1: *mut cocos2d_CCObject,
        object2: *mut cocos2d_CCObject,
    ) {
        cocos2d_CCArray_exchangeObject(self, object1, object2)
    }
    #[inline]
    pub unsafe fn exchangeObjectAtIndex(
        &mut self,
        index1: ::std::os::raw::c_uint,
        index2: ::std::os::raw::c_uint,
    ) {
        cocos2d_CCArray_exchangeObjectAtIndex(self, index1, index2)
    }
    #[inline]
    pub unsafe fn replaceObjectAtIndex(
        &mut self,
        uIndex: ::std::os::raw::c_uint,
        pObject: *mut cocos2d_CCObject,
        bReleaseObject: bool,
    ) {
        cocos2d_CCArray_replaceObjectAtIndex(self, uIndex, pObject, bReleaseObject)
    }
    #[inline]
    pub unsafe fn reverseObjects(&mut self) {
        cocos2d_CCArray_reverseObjects(self)
    }
    #[inline]
    pub unsafe fn reduceMemoryFootprint(&mut self) {
        cocos2d_CCArray_reduceMemoryFootprint(self)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cocos2d_CCArray_CCArray(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new1(capacity: ::std::os::raw::c_uint) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cocos2d_CCArray_CCArray1(__bindgen_tmp.as_mut_ptr(), capacity);
        __bindgen_tmp.assume_init()
    }
}
extern "C" {
    #[doc = " @lua NA"]
    #[link_name = "\u{1}??_DCCArray@cocos2d@@QEAAXXZ"]
    pub fn cocos2d_CCArray_CCArray_destructor(this: *mut cocos2d_CCArray);
}
extern "C" {
    #[doc = " override functions"]
    #[doc = "  @js NA"]
    #[doc = "  @lua NA"]
    #[link_name = "\u{1}?copyWithZone@CCArray@cocos2d@@UEAAPEAVCCObject@2@PEAVCCZone@2@@Z"]
    pub fn cocos2d_CCArray_copyWithZone(
        this: *mut ::std::os::raw::c_void,
        pZone: *mut cocos2d_CCZone,
    ) -> *mut cocos2d_CCObject;
}
extern "C" {
    #[link_name = "\u{1}?acceptVisitor@CCArray@cocos2d@@UEAAXAEAVCCDataVisitor@2@@Z"]
    pub fn cocos2d_CCArray_acceptVisitor(
        this: *mut ::std::os::raw::c_void,
        visitor: *mut cocos2d_CCDataVisitor,
    );
}
pub const kCCVertexAttribFlag_None: ::std::os::raw::c_int = 0;
pub const kCCVertexAttribFlag_Position: ::std::os::raw::c_int = 1;
pub const kCCVertexAttribFlag_Color: ::std::os::raw::c_int = 2;
pub const kCCVertexAttribFlag_TexCoords: ::std::os::raw::c_int = 4;
pub const kCCVertexAttribFlag_PosColorTex: ::std::os::raw::c_int = 7;
#[doc = " vertex attrib flags"]
pub type cocos2d__bindgen_ty_2 = ::std::os::raw::c_int;
pub const cocos2d_ccGLServerState_CC_GL_ALL: cocos2d_ccGLServerState = 0;
#[doc = " GL server side states"]
pub type cocos2d_ccGLServerState = ::std::os::raw::c_int;
extern "C" {
    #[doc = " Invalidates the GL state cache."]
    #[doc = "If CC_ENABLE_GL_STATE_CACHE it will reset the GL state cache."]
    #[doc = "@since v2.0.0"]
    #[link_name = "\u{1}?ccGLInvalidateStateCache@cocos2d@@YAXXZ"]
    pub fn cocos2d_ccGLInvalidateStateCache();
}
extern "C" {
    #[doc = " Uses the GL program in case program is different than the current one."]
    #[doc = "If CC_ENABLE_GL_STATE_CACHE is disabled, it will the glUseProgram() directly."]
    #[doc = "@since v2.0.0"]
    #[link_name = "\u{1}?ccGLUseProgram@cocos2d@@YAXI@Z"]
    pub fn cocos2d_ccGLUseProgram(program: GLuint);
}
extern "C" {
    #[doc = " Deletes the GL program. If it is the one that is being used, it invalidates it."]
    #[doc = "If CC_ENABLE_GL_STATE_CACHE is disabled, it will the glDeleteProgram() directly."]
    #[doc = "@since v2.0.0"]
    #[link_name = "\u{1}?ccGLDeleteProgram@cocos2d@@YAXI@Z"]
    pub fn cocos2d_ccGLDeleteProgram(program: GLuint);
}
extern "C" {
    #[doc = " Uses a blending function in case it not already used."]
    #[doc = "If CC_ENABLE_GL_STATE_CACHE is disabled, it will the glBlendFunc() directly."]
    #[doc = "@since v2.0.0"]
    #[link_name = "\u{1}?ccGLBlendFunc@cocos2d@@YAXII@Z"]
    pub fn cocos2d_ccGLBlendFunc(sfactor: GLenum, dfactor: GLenum);
}
extern "C" {
    #[doc = " Resets the blending mode back to the cached state in case you used glBlendFuncSeparate() or glBlendEquation()."]
    #[doc = "If CC_ENABLE_GL_STATE_CACHE is disabled, it will just set the default blending mode using GL_FUNC_ADD."]
    #[doc = "@since v2.0.0"]
    #[link_name = "\u{1}?ccGLBlendResetToCache@cocos2d@@YAXXZ"]
    pub fn cocos2d_ccGLBlendResetToCache();
}
extern "C" {
    #[doc = " sets the projection matrix as dirty"]
    #[doc = "@since v2.0.0"]
    #[link_name = "\u{1}?ccSetProjectionMatrixDirty@cocos2d@@YAXXZ"]
    pub fn cocos2d_ccSetProjectionMatrixDirty();
}
extern "C" {
    #[doc = " Will enable the vertex attribs that are passed as flags."]
    #[doc = "Possible flags:"]
    #[doc = ""]
    #[doc = " kCCVertexAttribFlag_Position"]
    #[doc = " kCCVertexAttribFlag_Color"]
    #[doc = " kCCVertexAttribFlag_TexCoords"]
    #[doc = ""]
    #[doc = "These flags can be ORed. The flags that are not present, will be disabled."]
    #[doc = ""]
    #[doc = "@since v2.0.0"]
    #[link_name = "\u{1}?ccGLEnableVertexAttribs@cocos2d@@YAXI@Z"]
    pub fn cocos2d_ccGLEnableVertexAttribs(flags: ::std::os::raw::c_uint);
}
extern "C" {
    #[doc = " If the texture is not already bound to texture unit 0, it binds it."]
    #[doc = "If CC_ENABLE_GL_STATE_CACHE is disabled, it will call glBindTexture() directly."]
    #[doc = "@since v2.0.0"]
    #[link_name = "\u{1}?ccGLBindTexture2D@cocos2d@@YAXI@Z"]
    pub fn cocos2d_ccGLBindTexture2D(textureId: GLuint);
}
extern "C" {
    #[doc = " If the texture is not already bound to a given unit, it binds it."]
    #[doc = "If CC_ENABLE_GL_STATE_CACHE is disabled, it will call glBindTexture() directly."]
    #[doc = "@since v2.1.0"]
    #[link_name = "\u{1}?ccGLBindTexture2DN@cocos2d@@YAXII@Z"]
    pub fn cocos2d_ccGLBindTexture2DN(textureUnit: GLuint, textureId: GLuint);
}
extern "C" {
    #[doc = " It will delete a given texture. If the texture was bound, it will invalidate the cached."]
    #[doc = "If CC_ENABLE_GL_STATE_CACHE is disabled, it will call glDeleteTextures() directly."]
    #[doc = "@since v2.0.0"]
    #[link_name = "\u{1}?ccGLDeleteTexture@cocos2d@@YAXI@Z"]
    pub fn cocos2d_ccGLDeleteTexture(textureId: GLuint);
}
extern "C" {
    #[doc = " It will delete a given texture. If the texture was bound, it will invalidate the cached for the given texture unit."]
    #[doc = "If CC_ENABLE_GL_STATE_CACHE is disabled, it will call glDeleteTextures() directly."]
    #[doc = "@since v2.1.0"]
    #[link_name = "\u{1}?ccGLDeleteTextureN@cocos2d@@YAXII@Z"]
    pub fn cocos2d_ccGLDeleteTextureN(textureUnit: GLuint, textureId: GLuint);
}
extern "C" {
    #[doc = " If the vertex array is not already bound, it binds it."]
    #[doc = "If CC_ENABLE_GL_STATE_CACHE is disabled, it will call glBindVertexArray() directly."]
    #[doc = "@since v2.0.0"]
    #[link_name = "\u{1}?ccGLBindVAO@cocos2d@@YAXI@Z"]
    pub fn cocos2d_ccGLBindVAO(vaoId: GLuint);
}
extern "C" {
    #[doc = " It will enable / disable the server side GL states."]
    #[doc = "If CC_ENABLE_GL_STATE_CACHE is disabled, it will call glEnable() directly."]
    #[doc = "@since v2.0.0"]
    #[link_name = "\u{1}?ccGLEnable@cocos2d@@YAXW4ccGLServerState@1@@Z"]
    pub fn cocos2d_ccGLEnable(flags: cocos2d_ccGLServerState);
}
pub const kCCVertexAttrib_Position: ::std::os::raw::c_int = 0;
pub const kCCVertexAttrib_Color: ::std::os::raw::c_int = 1;
pub const kCCVertexAttrib_TexCoords: ::std::os::raw::c_int = 2;
pub const kCCVertexAttrib_MAX: ::std::os::raw::c_int = 3;
#[doc = " @addtogroup shaders"]
#[doc = " @{"]
pub type cocos2d__bindgen_ty_3 = ::std::os::raw::c_int;
pub const kCCUniformPMatrix: ::std::os::raw::c_int = 0;
pub const kCCUniformMVMatrix: ::std::os::raw::c_int = 1;
pub const kCCUniformMVPMatrix: ::std::os::raw::c_int = 2;
pub const kCCUniformTime: ::std::os::raw::c_int = 3;
pub const kCCUniformSinTime: ::std::os::raw::c_int = 4;
pub const kCCUniformCosTime: ::std::os::raw::c_int = 5;
pub const kCCUniformRandom01: ::std::os::raw::c_int = 6;
pub const kCCUniformSampler: ::std::os::raw::c_int = 7;
pub const kCCUniform_MAX: ::std::os::raw::c_int = 8;
pub type cocos2d__bindgen_ty_4 = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cocos2d__hashUniformEntry {
    _unused: [u8; 0],
}
pub type cocos2d_GLInfoFunction =
    ::std::option::Option<unsafe extern "C" fn(program: GLuint, pname: GLenum, params: *mut GLint)>;
pub type cocos2d_GLLogFunction = ::std::option::Option<
    unsafe extern "C" fn(
        program: GLuint,
        bufsize: GLsizei,
        length: *mut GLsizei,
        infolog: *mut GLchar,
    ),
>;
#[doc = " @addtogroup shaders"]
#[doc = " @{"]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCGLProgram {
    pub _base: cocos2d_CCObject,
    pub m_uProgram: GLuint,
    pub m_uVertShader: GLuint,
    pub m_uFragShader: GLuint,
    pub m_uUniforms: [GLint; 8usize],
    pub m_pHashForUniforms: *mut cocos2d__hashUniformEntry,
    pub m_bUsesTime: bool,
    pub m_hasShaderCompiler: bool,
}
#[test]
fn bindgen_test_layout_cocos2d_CCGLProgram() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCGLProgram>(),
        104usize,
        concat!("Size of: ", stringify!(cocos2d_CCGLProgram))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCGLProgram>(),
        8usize,
        concat!("Alignment of ", stringify!(cocos2d_CCGLProgram))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cocos2d_CCGLProgram>())).m_uProgram as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCGLProgram),
            "::",
            stringify!(m_uProgram)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cocos2d_CCGLProgram>())).m_uVertShader as *const _ as usize
        },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCGLProgram),
            "::",
            stringify!(m_uVertShader)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cocos2d_CCGLProgram>())).m_uFragShader as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCGLProgram),
            "::",
            stringify!(m_uFragShader)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cocos2d_CCGLProgram>())).m_uUniforms as *const _ as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCGLProgram),
            "::",
            stringify!(m_uUniforms)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cocos2d_CCGLProgram>())).m_pHashForUniforms as *const _ as usize
        },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCGLProgram),
            "::",
            stringify!(m_pHashForUniforms)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cocos2d_CCGLProgram>())).m_bUsesTime as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCGLProgram),
            "::",
            stringify!(m_bUsesTime)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cocos2d_CCGLProgram>())).m_hasShaderCompiler as *const _ as usize
        },
        97usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCGLProgram),
            "::",
            stringify!(m_hasShaderCompiler)
        )
    );
}
extern "C" {
    #[doc = " Initializes the CCGLProgram with a vertex and fragment with bytes array"]
    #[doc = " @js  initWithString"]
    #[doc = " @lua NA"]
    #[link_name = "\u{1}?initWithVertexShaderByteArray@CCGLProgram@cocos2d@@QEAA_NPEBD0@Z"]
    pub fn cocos2d_CCGLProgram_initWithVertexShaderByteArray(
        this: *mut cocos2d_CCGLProgram,
        vShaderByteArray: *const GLchar,
        fShaderByteArray: *const GLchar,
    ) -> bool;
}
extern "C" {
    #[doc = " Initializes the CCGLProgram with a vertex and fragment with contents of filenames"]
    #[doc = " @js  init"]
    #[doc = " @lua NA"]
    #[link_name = "\u{1}?initWithVertexShaderFilename@CCGLProgram@cocos2d@@QEAA_NPEBD0@Z"]
    pub fn cocos2d_CCGLProgram_initWithVertexShaderFilename(
        this: *mut cocos2d_CCGLProgram,
        vShaderFilename: *const ::std::os::raw::c_char,
        fShaderFilename: *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    #[doc = "  It will add a new attribute to the shader"]
    #[doc = " @lua NA"]
    #[link_name = "\u{1}?addAttribute@CCGLProgram@cocos2d@@QEAAXPEBDI@Z"]
    pub fn cocos2d_CCGLProgram_addAttribute(
        this: *mut cocos2d_CCGLProgram,
        attributeName: *const ::std::os::raw::c_char,
        index: GLuint,
    );
}
extern "C" {
    #[doc = " links the glProgram"]
    #[doc = " @lua NA"]
    #[link_name = "\u{1}?link@CCGLProgram@cocos2d@@QEAA_NXZ"]
    pub fn cocos2d_CCGLProgram_link(this: *mut cocos2d_CCGLProgram) -> bool;
}
extern "C" {
    #[doc = " it will call glUseProgram()"]
    #[doc = " @lua NA"]
    #[link_name = "\u{1}?use@CCGLProgram@cocos2d@@QEAAXXZ"]
    pub fn cocos2d_CCGLProgram_use(this: *mut cocos2d_CCGLProgram);
}
extern "C" {
    #[doc = " It will create 4 uniforms:"]
    #[doc = "- kCCUniformPMatrix"]
    #[doc = "- kCCUniformMVMatrix"]
    #[doc = "- kCCUniformMVPMatrix"]
    #[doc = "- kCCUniformSampler"]
    #[doc = ""]
    #[doc = "And it will bind \"kCCUniformSampler\" to 0"]
    #[doc = " @lua NA"]
    #[link_name = "\u{1}?updateUniforms@CCGLProgram@cocos2d@@QEAAXXZ"]
    pub fn cocos2d_CCGLProgram_updateUniforms(this: *mut cocos2d_CCGLProgram);
}
extern "C" {
    #[doc = " calls retrieves the named uniform location for this shader program."]
    #[doc = " @lua NA"]
    #[link_name = "\u{1}?getUniformLocationForName@CCGLProgram@cocos2d@@QEAAHPEBD@Z"]
    pub fn cocos2d_CCGLProgram_getUniformLocationForName(
        this: *mut cocos2d_CCGLProgram,
        name: *const ::std::os::raw::c_char,
    ) -> GLint;
}
extern "C" {
    #[doc = " calls glUniform1i only if the values are different than the previous call for this same shader program."]
    #[doc = "  @js  setUniformLocationI32"]
    #[doc = "  @lua NA"]
    #[link_name = "\u{1}?setUniformLocationWith1i@CCGLProgram@cocos2d@@QEAAXHH@Z"]
    pub fn cocos2d_CCGLProgram_setUniformLocationWith1i(
        this: *mut cocos2d_CCGLProgram,
        location: GLint,
        i1: GLint,
    );
}
extern "C" {
    #[doc = " calls glUniform2i only if the values are different than the previous call for this same shader program."]
    #[doc = " @lua NA"]
    #[link_name = "\u{1}?setUniformLocationWith2i@CCGLProgram@cocos2d@@QEAAXHHH@Z"]
    pub fn cocos2d_CCGLProgram_setUniformLocationWith2i(
        this: *mut cocos2d_CCGLProgram,
        location: GLint,
        i1: GLint,
        i2: GLint,
    );
}
extern "C" {
    #[doc = " calls glUniform3i only if the values are different than the previous call for this same shader program."]
    #[doc = " @lua NA"]
    #[link_name = "\u{1}?setUniformLocationWith3i@CCGLProgram@cocos2d@@QEAAXHHHH@Z"]
    pub fn cocos2d_CCGLProgram_setUniformLocationWith3i(
        this: *mut cocos2d_CCGLProgram,
        location: GLint,
        i1: GLint,
        i2: GLint,
        i3: GLint,
    );
}
extern "C" {
    #[doc = " calls glUniform4i only if the values are different than the previous call for this same shader program."]
    #[doc = " @lua NA"]
    #[link_name = "\u{1}?setUniformLocationWith4i@CCGLProgram@cocos2d@@QEAAXHHHHH@Z"]
    pub fn cocos2d_CCGLProgram_setUniformLocationWith4i(
        this: *mut cocos2d_CCGLProgram,
        location: GLint,
        i1: GLint,
        i2: GLint,
        i3: GLint,
        i4: GLint,
    );
}
extern "C" {
    #[doc = " calls glUniform2iv only if the values are different than the previous call for this same shader program."]
    #[doc = " @lua NA"]
    #[link_name = "\u{1}?setUniformLocationWith2iv@CCGLProgram@cocos2d@@QEAAXHPEAHI@Z"]
    pub fn cocos2d_CCGLProgram_setUniformLocationWith2iv(
        this: *mut cocos2d_CCGLProgram,
        location: GLint,
        ints: *mut GLint,
        numberOfArrays: ::std::os::raw::c_uint,
    );
}
extern "C" {
    #[doc = " calls glUniform3iv only if the values are different than the previous call for this same shader program."]
    #[doc = " @lua NA"]
    #[link_name = "\u{1}?setUniformLocationWith3iv@CCGLProgram@cocos2d@@QEAAXHPEAHI@Z"]
    pub fn cocos2d_CCGLProgram_setUniformLocationWith3iv(
        this: *mut cocos2d_CCGLProgram,
        location: GLint,
        ints: *mut GLint,
        numberOfArrays: ::std::os::raw::c_uint,
    );
}
extern "C" {
    #[doc = " calls glUniform4iv only if the values are different than the previous call for this same shader program."]
    #[doc = " @lua NA"]
    #[link_name = "\u{1}?setUniformLocationWith4iv@CCGLProgram@cocos2d@@QEAAXHPEAHI@Z"]
    pub fn cocos2d_CCGLProgram_setUniformLocationWith4iv(
        this: *mut cocos2d_CCGLProgram,
        location: GLint,
        ints: *mut GLint,
        numberOfArrays: ::std::os::raw::c_uint,
    );
}
extern "C" {
    #[doc = " calls glUniform1f only if the values are different than the previous call for this same shader program."]
    #[doc = "  @js  setUniformLocationF32"]
    #[doc = "  @lua NA"]
    #[link_name = "\u{1}?setUniformLocationWith1f@CCGLProgram@cocos2d@@QEAAXHM@Z"]
    pub fn cocos2d_CCGLProgram_setUniformLocationWith1f(
        this: *mut cocos2d_CCGLProgram,
        location: GLint,
        f1: GLfloat,
    );
}
extern "C" {
    #[doc = " calls glUniform2f only if the values are different than the previous call for this same shader program."]
    #[doc = "  @js  setUniformLocationF32"]
    #[doc = "  @lua NA"]
    #[link_name = "\u{1}?setUniformLocationWith2f@CCGLProgram@cocos2d@@QEAAXHMM@Z"]
    pub fn cocos2d_CCGLProgram_setUniformLocationWith2f(
        this: *mut cocos2d_CCGLProgram,
        location: GLint,
        f1: GLfloat,
        f2: GLfloat,
    );
}
extern "C" {
    #[doc = " calls glUniform3f only if the values are different than the previous call for this same shader program."]
    #[doc = "  @js  setUniformLocationF32"]
    #[doc = "  @lua NA"]
    #[link_name = "\u{1}?setUniformLocationWith3f@CCGLProgram@cocos2d@@QEAAXHMMM@Z"]
    pub fn cocos2d_CCGLProgram_setUniformLocationWith3f(
        this: *mut cocos2d_CCGLProgram,
        location: GLint,
        f1: GLfloat,
        f2: GLfloat,
        f3: GLfloat,
    );
}
extern "C" {
    #[doc = " calls glUniform4f only if the values are different than the previous call for this same shader program."]
    #[doc = "  @js  setUniformLocationF32"]
    #[doc = "  @lua NA"]
    #[link_name = "\u{1}?setUniformLocationWith4f@CCGLProgram@cocos2d@@QEAAXHMMMM@Z"]
    pub fn cocos2d_CCGLProgram_setUniformLocationWith4f(
        this: *mut cocos2d_CCGLProgram,
        location: GLint,
        f1: GLfloat,
        f2: GLfloat,
        f3: GLfloat,
        f4: GLfloat,
    );
}
extern "C" {
    #[doc = " calls glUniform2fv only if the values are different than the previous call for this same shader program."]
    #[doc = "  @js  NA"]
    #[doc = "  @lua NA"]
    #[link_name = "\u{1}?setUniformLocationWith2fv@CCGLProgram@cocos2d@@QEAAXHPEAMI@Z"]
    pub fn cocos2d_CCGLProgram_setUniformLocationWith2fv(
        this: *mut cocos2d_CCGLProgram,
        location: GLint,
        floats: *mut GLfloat,
        numberOfArrays: ::std::os::raw::c_uint,
    );
}
extern "C" {
    #[doc = " calls glUniform3fv only if the values are different than the previous call for this same shader program."]
    #[doc = "  @js  NA"]
    #[doc = "  @lua NA"]
    #[link_name = "\u{1}?setUniformLocationWith3fv@CCGLProgram@cocos2d@@QEAAXHPEAMI@Z"]
    pub fn cocos2d_CCGLProgram_setUniformLocationWith3fv(
        this: *mut cocos2d_CCGLProgram,
        location: GLint,
        floats: *mut GLfloat,
        numberOfArrays: ::std::os::raw::c_uint,
    );
}
extern "C" {
    #[doc = " calls glUniform4fv only if the values are different than the previous call for this same shader program."]
    #[doc = "  @js  NA"]
    #[doc = "  @lua NA"]
    #[link_name = "\u{1}?setUniformLocationWith4fv@CCGLProgram@cocos2d@@QEAAXHPEAMI@Z"]
    pub fn cocos2d_CCGLProgram_setUniformLocationWith4fv(
        this: *mut cocos2d_CCGLProgram,
        location: GLint,
        floats: *mut GLfloat,
        numberOfArrays: ::std::os::raw::c_uint,
    );
}
extern "C" {
    #[doc = " calls glUniformMatrix4fv only if the values are different than the previous call for this same shader program."]
    #[doc = "  @js  NA"]
    #[doc = "  @lua NA"]
    #[link_name = "\u{1}?setUniformLocationWithMatrix4fv@CCGLProgram@cocos2d@@QEAAXHPEAMI@Z"]
    pub fn cocos2d_CCGLProgram_setUniformLocationWithMatrix4fv(
        this: *mut cocos2d_CCGLProgram,
        location: GLint,
        matrixArray: *mut GLfloat,
        numberOfMatrices: ::std::os::raw::c_uint,
    );
}
extern "C" {
    #[doc = " will update the builtin uniforms if they are different than the previous call for this same shader program."]
    #[doc = "  @lua NA"]
    #[link_name = "\u{1}?setUniformsForBuiltins@CCGLProgram@cocos2d@@QEAAXXZ"]
    pub fn cocos2d_CCGLProgram_setUniformsForBuiltins(this: *mut cocos2d_CCGLProgram);
}
extern "C" {
    #[doc = " returns the vertexShader error log"]
    #[doc = "  @js  getVertexShaderLog"]
    #[doc = "  @lua NA"]
    #[link_name = "\u{1}?vertexShaderLog@CCGLProgram@cocos2d@@QEAAPEBDXZ"]
    pub fn cocos2d_CCGLProgram_vertexShaderLog(
        this: *mut cocos2d_CCGLProgram,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " returns the fragmentShader error log"]
    #[doc = "  @js  getFragmentShaderLog"]
    #[doc = "  @lua NA"]
    #[link_name = "\u{1}?fragmentShaderLog@CCGLProgram@cocos2d@@QEAAPEBDXZ"]
    pub fn cocos2d_CCGLProgram_fragmentShaderLog(
        this: *mut cocos2d_CCGLProgram,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " returns the program error log"]
    #[doc = "  @js  getProgramLog"]
    #[doc = "  @lua NA"]
    #[link_name = "\u{1}?programLog@CCGLProgram@cocos2d@@QEAAPEBDXZ"]
    pub fn cocos2d_CCGLProgram_programLog(
        this: *mut cocos2d_CCGLProgram,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " reload all shaders, this function is designed for android"]
    #[doc = "  when opengl context lost, so don't call it."]
    #[doc = "  @lua NA"]
    #[link_name = "\u{1}?reset@CCGLProgram@cocos2d@@QEAAXXZ"]
    pub fn cocos2d_CCGLProgram_reset(this: *mut cocos2d_CCGLProgram);
}
extern "C" {
    #[doc = " @js  ctor"]
    #[doc = " @lua NA"]
    #[link_name = "\u{1}??0CCGLProgram@cocos2d@@QEAA@XZ"]
    pub fn cocos2d_CCGLProgram_CCGLProgram(this: *mut cocos2d_CCGLProgram);
}
impl cocos2d_CCGLProgram {
    #[inline]
    pub unsafe fn initWithVertexShaderByteArray(
        &mut self,
        vShaderByteArray: *const GLchar,
        fShaderByteArray: *const GLchar,
    ) -> bool {
        cocos2d_CCGLProgram_initWithVertexShaderByteArray(self, vShaderByteArray, fShaderByteArray)
    }
    #[inline]
    pub unsafe fn initWithVertexShaderFilename(
        &mut self,
        vShaderFilename: *const ::std::os::raw::c_char,
        fShaderFilename: *const ::std::os::raw::c_char,
    ) -> bool {
        cocos2d_CCGLProgram_initWithVertexShaderFilename(self, vShaderFilename, fShaderFilename)
    }
    #[inline]
    pub unsafe fn addAttribute(
        &mut self,
        attributeName: *const ::std::os::raw::c_char,
        index: GLuint,
    ) {
        cocos2d_CCGLProgram_addAttribute(self, attributeName, index)
    }
    #[inline]
    pub unsafe fn link(&mut self) -> bool {
        cocos2d_CCGLProgram_link(self)
    }
    #[inline]
    pub unsafe fn use_(&mut self) {
        cocos2d_CCGLProgram_use(self)
    }
    #[inline]
    pub unsafe fn updateUniforms(&mut self) {
        cocos2d_CCGLProgram_updateUniforms(self)
    }
    #[inline]
    pub unsafe fn getUniformLocationForName(
        &mut self,
        name: *const ::std::os::raw::c_char,
    ) -> GLint {
        cocos2d_CCGLProgram_getUniformLocationForName(self, name)
    }
    #[inline]
    pub unsafe fn setUniformLocationWith1i(&mut self, location: GLint, i1: GLint) {
        cocos2d_CCGLProgram_setUniformLocationWith1i(self, location, i1)
    }
    #[inline]
    pub unsafe fn setUniformLocationWith2i(&mut self, location: GLint, i1: GLint, i2: GLint) {
        cocos2d_CCGLProgram_setUniformLocationWith2i(self, location, i1, i2)
    }
    #[inline]
    pub unsafe fn setUniformLocationWith3i(
        &mut self,
        location: GLint,
        i1: GLint,
        i2: GLint,
        i3: GLint,
    ) {
        cocos2d_CCGLProgram_setUniformLocationWith3i(self, location, i1, i2, i3)
    }
    #[inline]
    pub unsafe fn setUniformLocationWith4i(
        &mut self,
        location: GLint,
        i1: GLint,
        i2: GLint,
        i3: GLint,
        i4: GLint,
    ) {
        cocos2d_CCGLProgram_setUniformLocationWith4i(self, location, i1, i2, i3, i4)
    }
    #[inline]
    pub unsafe fn setUniformLocationWith2iv(
        &mut self,
        location: GLint,
        ints: *mut GLint,
        numberOfArrays: ::std::os::raw::c_uint,
    ) {
        cocos2d_CCGLProgram_setUniformLocationWith2iv(self, location, ints, numberOfArrays)
    }
    #[inline]
    pub unsafe fn setUniformLocationWith3iv(
        &mut self,
        location: GLint,
        ints: *mut GLint,
        numberOfArrays: ::std::os::raw::c_uint,
    ) {
        cocos2d_CCGLProgram_setUniformLocationWith3iv(self, location, ints, numberOfArrays)
    }
    #[inline]
    pub unsafe fn setUniformLocationWith4iv(
        &mut self,
        location: GLint,
        ints: *mut GLint,
        numberOfArrays: ::std::os::raw::c_uint,
    ) {
        cocos2d_CCGLProgram_setUniformLocationWith4iv(self, location, ints, numberOfArrays)
    }
    #[inline]
    pub unsafe fn setUniformLocationWith1f(&mut self, location: GLint, f1: GLfloat) {
        cocos2d_CCGLProgram_setUniformLocationWith1f(self, location, f1)
    }
    #[inline]
    pub unsafe fn setUniformLocationWith2f(&mut self, location: GLint, f1: GLfloat, f2: GLfloat) {
        cocos2d_CCGLProgram_setUniformLocationWith2f(self, location, f1, f2)
    }
    #[inline]
    pub unsafe fn setUniformLocationWith3f(
        &mut self,
        location: GLint,
        f1: GLfloat,
        f2: GLfloat,
        f3: GLfloat,
    ) {
        cocos2d_CCGLProgram_setUniformLocationWith3f(self, location, f1, f2, f3)
    }
    #[inline]
    pub unsafe fn setUniformLocationWith4f(
        &mut self,
        location: GLint,
        f1: GLfloat,
        f2: GLfloat,
        f3: GLfloat,
        f4: GLfloat,
    ) {
        cocos2d_CCGLProgram_setUniformLocationWith4f(self, location, f1, f2, f3, f4)
    }
    #[inline]
    pub unsafe fn setUniformLocationWith2fv(
        &mut self,
        location: GLint,
        floats: *mut GLfloat,
        numberOfArrays: ::std::os::raw::c_uint,
    ) {
        cocos2d_CCGLProgram_setUniformLocationWith2fv(self, location, floats, numberOfArrays)
    }
    #[inline]
    pub unsafe fn setUniformLocationWith3fv(
        &mut self,
        location: GLint,
        floats: *mut GLfloat,
        numberOfArrays: ::std::os::raw::c_uint,
    ) {
        cocos2d_CCGLProgram_setUniformLocationWith3fv(self, location, floats, numberOfArrays)
    }
    #[inline]
    pub unsafe fn setUniformLocationWith4fv(
        &mut self,
        location: GLint,
        floats: *mut GLfloat,
        numberOfArrays: ::std::os::raw::c_uint,
    ) {
        cocos2d_CCGLProgram_setUniformLocationWith4fv(self, location, floats, numberOfArrays)
    }
    #[inline]
    pub unsafe fn setUniformLocationWithMatrix4fv(
        &mut self,
        location: GLint,
        matrixArray: *mut GLfloat,
        numberOfMatrices: ::std::os::raw::c_uint,
    ) {
        cocos2d_CCGLProgram_setUniformLocationWithMatrix4fv(
            self,
            location,
            matrixArray,
            numberOfMatrices,
        )
    }
    #[inline]
    pub unsafe fn setUniformsForBuiltins(&mut self) {
        cocos2d_CCGLProgram_setUniformsForBuiltins(self)
    }
    #[inline]
    pub unsafe fn vertexShaderLog(&mut self) -> *const ::std::os::raw::c_char {
        cocos2d_CCGLProgram_vertexShaderLog(self)
    }
    #[inline]
    pub unsafe fn fragmentShaderLog(&mut self) -> *const ::std::os::raw::c_char {
        cocos2d_CCGLProgram_fragmentShaderLog(self)
    }
    #[inline]
    pub unsafe fn programLog(&mut self) -> *const ::std::os::raw::c_char {
        cocos2d_CCGLProgram_programLog(self)
    }
    #[inline]
    pub unsafe fn reset(&mut self) {
        cocos2d_CCGLProgram_reset(self)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cocos2d_CCGLProgram_CCGLProgram(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
}
extern "C" {
    #[doc = " @js NA"]
    #[doc = " @lua NA"]
    #[link_name = "\u{1}??_DCCGLProgram@cocos2d@@QEAAXXZ"]
    pub fn cocos2d_CCGLProgram_CCGLProgram_destructor(this: *mut cocos2d_CCGLProgram);
}
#[doc = "@brief The device accelerometer reports values for each axis in units of g-force"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cocos2d_CCAcceleration {
    pub x: f64,
    pub y: f64,
    pub z: f64,
    pub timestamp: f64,
}
#[test]
fn bindgen_test_layout_cocos2d_CCAcceleration() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCAcceleration>(),
        32usize,
        concat!("Size of: ", stringify!(cocos2d_CCAcceleration))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCAcceleration>(),
        8usize,
        concat!("Alignment of ", stringify!(cocos2d_CCAcceleration))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cocos2d_CCAcceleration>())).x as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCAcceleration),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cocos2d_CCAcceleration>())).y as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCAcceleration),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cocos2d_CCAcceleration>())).z as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCAcceleration),
            "::",
            stringify!(z)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cocos2d_CCAcceleration>())).timestamp as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCAcceleration),
            "::",
            stringify!(timestamp)
        )
    );
}
#[repr(C)]
pub struct cocos2d_CCAccelerometerDelegate__bindgen_vtable(::std::os::raw::c_void);
#[doc = "@brief"]
#[doc = "The CCAccelerometerDelegate defines a single method for"]
#[doc = "receiving acceleration-related data from the system."]
#[doc = "@js NA"]
#[doc = "@lua NA"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cocos2d_CCAccelerometerDelegate {
    pub vtable_: *const cocos2d_CCAccelerometerDelegate__bindgen_vtable,
}
#[test]
fn bindgen_test_layout_cocos2d_CCAccelerometerDelegate() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCAccelerometerDelegate>(),
        8usize,
        concat!("Size of: ", stringify!(cocos2d_CCAccelerometerDelegate))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCAccelerometerDelegate>(),
        8usize,
        concat!("Alignment of ", stringify!(cocos2d_CCAccelerometerDelegate))
    );
}
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCAccelerometer {
    pub m_obAccelerationValue: cocos2d_CCAcceleration,
    pub m_pAccelDelegate: *mut cocos2d_CCAccelerometerDelegate,
}
#[test]
fn bindgen_test_layout_cocos2d_CCAccelerometer() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCAccelerometer>(),
        40usize,
        concat!("Size of: ", stringify!(cocos2d_CCAccelerometer))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCAccelerometer>(),
        8usize,
        concat!("Alignment of ", stringify!(cocos2d_CCAccelerometer))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cocos2d_CCAccelerometer>())).m_obAccelerationValue as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCAccelerometer),
            "::",
            stringify!(m_obAccelerationValue)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cocos2d_CCAccelerometer>())).m_pAccelDelegate as *const _
                as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCAccelerometer),
            "::",
            stringify!(m_pAccelDelegate)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}?setDelegate@CCAccelerometer@cocos2d@@QEAAXPEAVCCAccelerometerDelegate@2@@Z"]
    pub fn cocos2d_CCAccelerometer_setDelegate(
        this: *mut cocos2d_CCAccelerometer,
        pDelegate: *mut cocos2d_CCAccelerometerDelegate,
    );
}
extern "C" {
    #[link_name = "\u{1}?setAccelerometerInterval@CCAccelerometer@cocos2d@@QEAAXM@Z"]
    pub fn cocos2d_CCAccelerometer_setAccelerometerInterval(
        this: *mut cocos2d_CCAccelerometer,
        interval: f32,
    );
}
extern "C" {
    #[link_name = "\u{1}?update@CCAccelerometer@cocos2d@@QEAAXNNNN@Z"]
    pub fn cocos2d_CCAccelerometer_update(
        this: *mut cocos2d_CCAccelerometer,
        x: f64,
        y: f64,
        z: f64,
        timestamp: f64,
    );
}
extern "C" {
    #[link_name = "\u{1}??0CCAccelerometer@cocos2d@@QEAA@XZ"]
    pub fn cocos2d_CCAccelerometer_CCAccelerometer(this: *mut cocos2d_CCAccelerometer);
}
extern "C" {
    #[link_name = "\u{1}??_DCCAccelerometer@cocos2d@@QEAAXXZ"]
    pub fn cocos2d_CCAccelerometer_CCAccelerometer_destructor(this: *mut cocos2d_CCAccelerometer);
}
impl cocos2d_CCAccelerometer {
    #[inline]
    pub unsafe fn setDelegate(&mut self, pDelegate: *mut cocos2d_CCAccelerometerDelegate) {
        cocos2d_CCAccelerometer_setDelegate(self, pDelegate)
    }
    #[inline]
    pub unsafe fn setAccelerometerInterval(&mut self, interval: f32) {
        cocos2d_CCAccelerometer_setAccelerometerInterval(self, interval)
    }
    #[inline]
    pub unsafe fn update(&mut self, x: f64, y: f64, z: f64, timestamp: f64) {
        cocos2d_CCAccelerometer_update(self, x, y, z, timestamp)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cocos2d_CCAccelerometer_CCAccelerometer(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn destruct(&mut self) {
        cocos2d_CCAccelerometer_CCAccelerometer_destructor(self)
    }
}
#[doc = " @addtogroup input"]
#[doc = " @{"]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCTouch {
    pub _base: cocos2d_CCObject,
    pub m_nId: ::std::os::raw::c_int,
    pub m_startPointCaptured: bool,
    pub m_startPoint: cocos2d_CCPoint,
    pub m_point: cocos2d_CCPoint,
    pub m_prevPoint: cocos2d_CCPoint,
}
#[test]
fn bindgen_test_layout_cocos2d_CCTouch() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCTouch>(),
        72usize,
        concat!("Size of: ", stringify!(cocos2d_CCTouch))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCTouch>(),
        8usize,
        concat!("Alignment of ", stringify!(cocos2d_CCTouch))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cocos2d_CCTouch>())).m_nId as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCTouch),
            "::",
            stringify!(m_nId)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cocos2d_CCTouch>())).m_startPointCaptured as *const _ as usize
        },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCTouch),
            "::",
            stringify!(m_startPointCaptured)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cocos2d_CCTouch>())).m_startPoint as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCTouch),
            "::",
            stringify!(m_startPoint)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cocos2d_CCTouch>())).m_point as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCTouch),
            "::",
            stringify!(m_point)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cocos2d_CCTouch>())).m_prevPoint as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCTouch),
            "::",
            stringify!(m_prevPoint)
        )
    );
}
extern "C" {
    #[doc = " returns the current touch location in OpenGL coordinates"]
    #[link_name = "\u{1}?getLocation@CCTouch@cocos2d@@QEBA?AVCCPoint@2@XZ"]
    pub fn cocos2d_CCTouch_getLocation(this: *const cocos2d_CCTouch) -> cocos2d_CCPoint;
}
extern "C" {
    #[doc = " returns the previous touch location in OpenGL coordinates"]
    #[link_name = "\u{1}?getPreviousLocation@CCTouch@cocos2d@@QEBA?AVCCPoint@2@XZ"]
    pub fn cocos2d_CCTouch_getPreviousLocation(this: *const cocos2d_CCTouch) -> cocos2d_CCPoint;
}
extern "C" {
    #[doc = " returns the start touch location in OpenGL coordinates"]
    #[link_name = "\u{1}?getStartLocation@CCTouch@cocos2d@@QEBA?AVCCPoint@2@XZ"]
    pub fn cocos2d_CCTouch_getStartLocation(this: *const cocos2d_CCTouch) -> cocos2d_CCPoint;
}
extern "C" {
    #[doc = " returns the delta of 2 current touches locations in screen coordinates"]
    #[link_name = "\u{1}?getDelta@CCTouch@cocos2d@@QEBA?AVCCPoint@2@XZ"]
    pub fn cocos2d_CCTouch_getDelta(this: *const cocos2d_CCTouch) -> cocos2d_CCPoint;
}
extern "C" {
    #[doc = " returns the current touch location in screen coordinates"]
    #[link_name = "\u{1}?getLocationInView@CCTouch@cocos2d@@QEBA?AVCCPoint@2@XZ"]
    pub fn cocos2d_CCTouch_getLocationInView(this: *const cocos2d_CCTouch) -> cocos2d_CCPoint;
}
extern "C" {
    #[doc = " returns the previous touch location in screen coordinates"]
    #[link_name = "\u{1}?getPreviousLocationInView@CCTouch@cocos2d@@QEBA?AVCCPoint@2@XZ"]
    pub fn cocos2d_CCTouch_getPreviousLocationInView(
        this: *const cocos2d_CCTouch,
    ) -> cocos2d_CCPoint;
}
extern "C" {
    #[doc = " returns the start touch location in screen coordinates"]
    #[link_name = "\u{1}?getStartLocationInView@CCTouch@cocos2d@@QEBA?AVCCPoint@2@XZ"]
    pub fn cocos2d_CCTouch_getStartLocationInView(this: *const cocos2d_CCTouch) -> cocos2d_CCPoint;
}
impl cocos2d_CCTouch {
    #[inline]
    pub unsafe fn getLocation(&self) -> cocos2d_CCPoint {
        cocos2d_CCTouch_getLocation(self)
    }
    #[inline]
    pub unsafe fn getPreviousLocation(&self) -> cocos2d_CCPoint {
        cocos2d_CCTouch_getPreviousLocation(self)
    }
    #[inline]
    pub unsafe fn getStartLocation(&self) -> cocos2d_CCPoint {
        cocos2d_CCTouch_getStartLocation(self)
    }
    #[inline]
    pub unsafe fn getDelta(&self) -> cocos2d_CCPoint {
        cocos2d_CCTouch_getDelta(self)
    }
    #[inline]
    pub unsafe fn getLocationInView(&self) -> cocos2d_CCPoint {
        cocos2d_CCTouch_getLocationInView(self)
    }
    #[inline]
    pub unsafe fn getPreviousLocationInView(&self) -> cocos2d_CCPoint {
        cocos2d_CCTouch_getPreviousLocationInView(self)
    }
    #[inline]
    pub unsafe fn getStartLocationInView(&self) -> cocos2d_CCPoint {
        cocos2d_CCTouch_getStartLocationInView(self)
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCEvent {
    pub _base: cocos2d_CCObject,
}
#[test]
fn bindgen_test_layout_cocos2d_CCEvent() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCEvent>(),
        40usize,
        concat!("Size of: ", stringify!(cocos2d_CCEvent))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCEvent>(),
        8usize,
        concat!("Alignment of ", stringify!(cocos2d_CCEvent))
    );
}
#[doc = " @addtogroup data_structures"]
#[doc = " @{"]
pub type cocos2d_CCSetIterator = u8;
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCSet {
    pub _base: cocos2d_CCObject,
    pub m_pSet: *mut [u64; 2usize],
}
#[test]
fn bindgen_test_layout_cocos2d_CCSet() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCSet>(),
        48usize,
        concat!("Size of: ", stringify!(cocos2d_CCSet))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCSet>(),
        8usize,
        concat!("Alignment of ", stringify!(cocos2d_CCSet))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cocos2d_CCSet>())).m_pSet as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCSet),
            "::",
            stringify!(m_pSet)
        )
    );
}
extern "C" {
    #[doc = " @brief Create and return a new empty set."]
    #[doc = " @lua NA"]
    #[link_name = "\u{1}?create@CCSet@cocos2d@@SAPEAV12@XZ"]
    pub fn cocos2d_CCSet_create() -> *mut cocos2d_CCSet;
}
extern "C" {
    #[doc = "@brief Return a copy of the CCSet, it will copy all the elements."]
    #[link_name = "\u{1}?copy@CCSet@cocos2d@@QEAAPEAV12@XZ"]
    pub fn cocos2d_CCSet_copy(this: *mut cocos2d_CCSet) -> *mut cocos2d_CCSet;
}
extern "C" {
    #[doc = "@brief It is the same as copy()."]
    #[doc = "@lua NA"]
    #[link_name = "\u{1}?mutableCopy@CCSet@cocos2d@@QEAAPEAV12@XZ"]
    pub fn cocos2d_CCSet_mutableCopy(this: *mut cocos2d_CCSet) -> *mut cocos2d_CCSet;
}
extern "C" {
    #[doc = "@brief Return the number of elements the CCSet contains."]
    #[link_name = "\u{1}?count@CCSet@cocos2d@@QEAAHXZ"]
    pub fn cocos2d_CCSet_count(this: *mut cocos2d_CCSet) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "@brief Add a element into CCSet, it will retain the element."]
    #[link_name = "\u{1}?addObject@CCSet@cocos2d@@QEAAXPEAVCCObject@2@@Z"]
    pub fn cocos2d_CCSet_addObject(this: *mut cocos2d_CCSet, pObject: *mut cocos2d_CCObject);
}
extern "C" {
    #[doc = "@brief Remove the given element, nothing todo if no element equals pObject."]
    #[link_name = "\u{1}?removeObject@CCSet@cocos2d@@QEAAXPEAVCCObject@2@@Z"]
    pub fn cocos2d_CCSet_removeObject(this: *mut cocos2d_CCSet, pObject: *mut cocos2d_CCObject);
}
extern "C" {
    #[doc = "@brief Remove all elements of the set"]
    #[link_name = "\u{1}?removeAllObjects@CCSet@cocos2d@@QEAAXXZ"]
    pub fn cocos2d_CCSet_removeAllObjects(this: *mut cocos2d_CCSet);
}
extern "C" {
    #[doc = "@brief Check if CCSet contains a element equals pObject."]
    #[link_name = "\u{1}?containsObject@CCSet@cocos2d@@QEAA_NPEAVCCObject@2@@Z"]
    pub fn cocos2d_CCSet_containsObject(
        this: *mut cocos2d_CCSet,
        pObject: *mut cocos2d_CCObject,
    ) -> bool;
}
extern "C" {
    #[doc = "@brief Return the iterator that points to the first element."]
    #[doc = "@js NA"]
    #[doc = "@lua NA"]
    #[link_name = "\u{1}?begin@CCSet@cocos2d@@QEAA?AV?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@PEAVCCObject@cocos2d@@@std@@@std@@@std@@XZ"]
    pub fn cocos2d_CCSet_begin(this: *mut cocos2d_CCSet) -> cocos2d_CCSetIterator;
}
extern "C" {
    #[doc = "@brief Return the iterator that points to the position after the last element."]
    #[doc = "@js NA"]
    #[doc = "@lua NA"]
    #[link_name = "\u{1}?end@CCSet@cocos2d@@QEAA?AV?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@PEAVCCObject@cocos2d@@@std@@@std@@@std@@XZ"]
    pub fn cocos2d_CCSet_end(this: *mut cocos2d_CCSet) -> cocos2d_CCSetIterator;
}
extern "C" {
    #[doc = "@brief Return the first element if it contains elements, or null if it doesn't contain any element."]
    #[link_name = "\u{1}?anyObject@CCSet@cocos2d@@QEAAPEAVCCObject@2@XZ"]
    pub fn cocos2d_CCSet_anyObject(this: *mut cocos2d_CCSet) -> *mut cocos2d_CCObject;
}
extern "C" {
    #[doc = " @js  ctor"]
    #[doc = " @lua NA"]
    #[link_name = "\u{1}??0CCSet@cocos2d@@QEAA@XZ"]
    pub fn cocos2d_CCSet_CCSet(this: *mut cocos2d_CCSet);
}
extern "C" {
    #[doc = " @lua NA"]
    #[link_name = "\u{1}??0CCSet@cocos2d@@QEAA@AEBV01@@Z"]
    pub fn cocos2d_CCSet_CCSet1(this: *mut cocos2d_CCSet, rSetObject: *const cocos2d_CCSet);
}
impl cocos2d_CCSet {
    #[inline]
    pub unsafe fn create() -> *mut cocos2d_CCSet {
        cocos2d_CCSet_create()
    }
    #[inline]
    pub unsafe fn copy(&mut self) -> *mut cocos2d_CCSet {
        cocos2d_CCSet_copy(self)
    }
    #[inline]
    pub unsafe fn mutableCopy(&mut self) -> *mut cocos2d_CCSet {
        cocos2d_CCSet_mutableCopy(self)
    }
    #[inline]
    pub unsafe fn count(&mut self) -> ::std::os::raw::c_int {
        cocos2d_CCSet_count(self)
    }
    #[inline]
    pub unsafe fn addObject(&mut self, pObject: *mut cocos2d_CCObject) {
        cocos2d_CCSet_addObject(self, pObject)
    }
    #[inline]
    pub unsafe fn removeObject(&mut self, pObject: *mut cocos2d_CCObject) {
        cocos2d_CCSet_removeObject(self, pObject)
    }
    #[inline]
    pub unsafe fn removeAllObjects(&mut self) {
        cocos2d_CCSet_removeAllObjects(self)
    }
    #[inline]
    pub unsafe fn containsObject(&mut self, pObject: *mut cocos2d_CCObject) -> bool {
        cocos2d_CCSet_containsObject(self, pObject)
    }
    #[inline]
    pub unsafe fn begin(&mut self) -> cocos2d_CCSetIterator {
        cocos2d_CCSet_begin(self)
    }
    #[inline]
    pub unsafe fn end(&mut self) -> cocos2d_CCSetIterator {
        cocos2d_CCSet_end(self)
    }
    #[inline]
    pub unsafe fn anyObject(&mut self) -> *mut cocos2d_CCObject {
        cocos2d_CCSet_anyObject(self)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cocos2d_CCSet_CCSet(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new1(rSetObject: *const cocos2d_CCSet) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cocos2d_CCSet_CCSet1(__bindgen_tmp.as_mut_ptr(), rSetObject);
        __bindgen_tmp.assume_init()
    }
}
extern "C" {
    #[doc = " @js NA"]
    #[doc = " @lua NA"]
    #[link_name = "\u{1}??_DCCSet@cocos2d@@QEAAXXZ"]
    pub fn cocos2d_CCSet_CCSet_destructor(this: *mut cocos2d_CCSet);
}
extern "C" {
    #[doc = " @js NA"]
    #[doc = " @lua NA"]
    #[link_name = "\u{1}?acceptVisitor@CCSet@cocos2d@@UEAAXAEAVCCDataVisitor@2@@Z"]
    pub fn cocos2d_CCSet_acceptVisitor(
        this: *mut ::std::os::raw::c_void,
        visitor: *mut cocos2d_CCDataVisitor,
    );
}
pub const cocos2d_ccScriptType_kScriptTypeNone: cocos2d_ccScriptType = 0;
pub const cocos2d_ccScriptType_kScriptTypeLua: cocos2d_ccScriptType = 1;
pub const cocos2d_ccScriptType_kScriptTypeJavascript: cocos2d_ccScriptType = 2;
pub type cocos2d_ccScriptType = ::std::os::raw::c_int;
#[doc = " @js NA"]
#[doc = " @lua NA"]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCScriptHandlerEntry {
    pub _base: cocos2d_CCObject,
    pub m_nHandler: ::std::os::raw::c_int,
    pub m_nEntryId: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_cocos2d_CCScriptHandlerEntry() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCScriptHandlerEntry>(),
        48usize,
        concat!("Size of: ", stringify!(cocos2d_CCScriptHandlerEntry))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCScriptHandlerEntry>(),
        8usize,
        concat!("Alignment of ", stringify!(cocos2d_CCScriptHandlerEntry))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cocos2d_CCScriptHandlerEntry>())).m_nHandler as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCScriptHandlerEntry),
            "::",
            stringify!(m_nHandler)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cocos2d_CCScriptHandlerEntry>())).m_nEntryId as *const _ as usize
        },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCScriptHandlerEntry),
            "::",
            stringify!(m_nEntryId)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}?create@CCScriptHandlerEntry@cocos2d@@SAPEAV12@H@Z"]
    pub fn cocos2d_CCScriptHandlerEntry_create(
        nHandler: ::std::os::raw::c_int,
    ) -> *mut cocos2d_CCScriptHandlerEntry;
}
impl cocos2d_CCScriptHandlerEntry {
    #[inline]
    pub unsafe fn create(nHandler: ::std::os::raw::c_int) -> *mut cocos2d_CCScriptHandlerEntry {
        cocos2d_CCScriptHandlerEntry_create(nHandler)
    }
}
extern "C" {
    #[link_name = "\u{1}??_DCCScriptHandlerEntry@cocos2d@@QEAAXXZ"]
    pub fn cocos2d_CCScriptHandlerEntry_CCScriptHandlerEntry_destructor(
        this: *mut cocos2d_CCScriptHandlerEntry,
    );
}
#[doc = " @addtogroup script_support"]
#[doc = " @{"]
#[doc = " @js NA"]
#[doc = " @lua NA"]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCSchedulerScriptHandlerEntry {
    pub _base: cocos2d_CCScriptHandlerEntry,
    pub m_pTimer: *mut cocos2d_CCTimer,
    pub m_bPaused: bool,
    pub m_bMarkedForDeletion: bool,
}
#[test]
fn bindgen_test_layout_cocos2d_CCSchedulerScriptHandlerEntry() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCSchedulerScriptHandlerEntry>(),
        64usize,
        concat!(
            "Size of: ",
            stringify!(cocos2d_CCSchedulerScriptHandlerEntry)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCSchedulerScriptHandlerEntry>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(cocos2d_CCSchedulerScriptHandlerEntry)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cocos2d_CCSchedulerScriptHandlerEntry>())).m_pTimer as *const _
                as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCSchedulerScriptHandlerEntry),
            "::",
            stringify!(m_pTimer)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cocos2d_CCSchedulerScriptHandlerEntry>())).m_bPaused as *const _
                as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCSchedulerScriptHandlerEntry),
            "::",
            stringify!(m_bPaused)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cocos2d_CCSchedulerScriptHandlerEntry>())).m_bMarkedForDeletion
                as *const _ as usize
        },
        57usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCSchedulerScriptHandlerEntry),
            "::",
            stringify!(m_bMarkedForDeletion)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}?create@CCSchedulerScriptHandlerEntry@cocos2d@@SAPEAV12@HM_N@Z"]
    pub fn cocos2d_CCSchedulerScriptHandlerEntry_create(
        nHandler: ::std::os::raw::c_int,
        fInterval: f32,
        bPaused: bool,
    ) -> *mut cocos2d_CCSchedulerScriptHandlerEntry;
}
impl cocos2d_CCSchedulerScriptHandlerEntry {
    #[inline]
    pub unsafe fn create(
        nHandler: ::std::os::raw::c_int,
        fInterval: f32,
        bPaused: bool,
    ) -> *mut cocos2d_CCSchedulerScriptHandlerEntry {
        cocos2d_CCSchedulerScriptHandlerEntry_create(nHandler, fInterval, bPaused)
    }
}
extern "C" {
    #[link_name = "\u{1}??_DCCSchedulerScriptHandlerEntry@cocos2d@@QEAAXXZ"]
    pub fn cocos2d_CCSchedulerScriptHandlerEntry_CCSchedulerScriptHandlerEntry_destructor(
        this: *mut cocos2d_CCSchedulerScriptHandlerEntry,
    );
}
#[doc = " @js NA"]
#[doc = " @lua NA"]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCTouchScriptHandlerEntry {
    pub _base: cocos2d_CCScriptHandlerEntry,
    pub m_bIsMultiTouches: bool,
    pub m_nPriority: ::std::os::raw::c_int,
    pub m_bSwallowsTouches: bool,
}
#[test]
fn bindgen_test_layout_cocos2d_CCTouchScriptHandlerEntry() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCTouchScriptHandlerEntry>(),
        64usize,
        concat!("Size of: ", stringify!(cocos2d_CCTouchScriptHandlerEntry))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCTouchScriptHandlerEntry>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(cocos2d_CCTouchScriptHandlerEntry)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cocos2d_CCTouchScriptHandlerEntry>())).m_bIsMultiTouches
                as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCTouchScriptHandlerEntry),
            "::",
            stringify!(m_bIsMultiTouches)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cocos2d_CCTouchScriptHandlerEntry>())).m_nPriority as *const _
                as usize
        },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCTouchScriptHandlerEntry),
            "::",
            stringify!(m_nPriority)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cocos2d_CCTouchScriptHandlerEntry>())).m_bSwallowsTouches
                as *const _ as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCTouchScriptHandlerEntry),
            "::",
            stringify!(m_bSwallowsTouches)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}?create@CCTouchScriptHandlerEntry@cocos2d@@SAPEAV12@H_NH0@Z"]
    pub fn cocos2d_CCTouchScriptHandlerEntry_create(
        nHandler: ::std::os::raw::c_int,
        bIsMultiTouches: bool,
        nPriority: ::std::os::raw::c_int,
        bSwallowsTouches: bool,
    ) -> *mut cocos2d_CCTouchScriptHandlerEntry;
}
impl cocos2d_CCTouchScriptHandlerEntry {
    #[inline]
    pub unsafe fn create(
        nHandler: ::std::os::raw::c_int,
        bIsMultiTouches: bool,
        nPriority: ::std::os::raw::c_int,
        bSwallowsTouches: bool,
    ) -> *mut cocos2d_CCTouchScriptHandlerEntry {
        cocos2d_CCTouchScriptHandlerEntry_create(
            nHandler,
            bIsMultiTouches,
            nPriority,
            bSwallowsTouches,
        )
    }
}
extern "C" {
    #[link_name = "\u{1}??_DCCTouchScriptHandlerEntry@cocos2d@@QEAAXXZ"]
    pub fn cocos2d_CCTouchScriptHandlerEntry_CCTouchScriptHandlerEntry_destructor(
        this: *mut cocos2d_CCTouchScriptHandlerEntry,
    );
}
#[repr(C)]
pub struct cocos2d_CCScriptEngineProtocol__bindgen_vtable(::std::os::raw::c_void);
#[doc = " @js NA"]
#[doc = " @lua NA"]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCScriptEngineProtocol {
    pub vtable_: *const cocos2d_CCScriptEngineProtocol__bindgen_vtable,
}
pub const cocos2d_CCScriptEngineProtocol_ConfigType_NONE:
    cocos2d_CCScriptEngineProtocol_ConfigType = 0;
pub const cocos2d_CCScriptEngineProtocol_ConfigType_COCOSTUDIO:
    cocos2d_CCScriptEngineProtocol_ConfigType = 1;
pub type cocos2d_CCScriptEngineProtocol_ConfigType = ::std::os::raw::c_int;
#[test]
fn bindgen_test_layout_cocos2d_CCScriptEngineProtocol() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCScriptEngineProtocol>(),
        8usize,
        concat!("Size of: ", stringify!(cocos2d_CCScriptEngineProtocol))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCScriptEngineProtocol>(),
        8usize,
        concat!("Alignment of ", stringify!(cocos2d_CCScriptEngineProtocol))
    );
}
#[doc = "CCScriptEngineManager is a singleton which holds an object instance of CCScriptEngineProtocl"]
#[doc = "It helps cocos2d-x and the user code to find back LuaEngine object"]
#[doc = "@since v0.99.5-x-0.8.5"]
#[doc = "@js NA"]
#[doc = "@lua NA"]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCScriptEngineManager {
    pub m_pScriptEngine: *mut cocos2d_CCScriptEngineProtocol,
}
#[test]
fn bindgen_test_layout_cocos2d_CCScriptEngineManager() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCScriptEngineManager>(),
        8usize,
        concat!("Size of: ", stringify!(cocos2d_CCScriptEngineManager))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCScriptEngineManager>(),
        8usize,
        concat!("Alignment of ", stringify!(cocos2d_CCScriptEngineManager))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cocos2d_CCScriptEngineManager>())).m_pScriptEngine as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCScriptEngineManager),
            "::",
            stringify!(m_pScriptEngine)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}?setScriptEngine@CCScriptEngineManager@cocos2d@@QEAAXPEAVCCScriptEngineProtocol@2@@Z"]
    pub fn cocos2d_CCScriptEngineManager_setScriptEngine(
        this: *mut cocos2d_CCScriptEngineManager,
        pScriptEngine: *mut cocos2d_CCScriptEngineProtocol,
    );
}
extern "C" {
    #[link_name = "\u{1}?removeScriptEngine@CCScriptEngineManager@cocos2d@@QEAAXXZ"]
    pub fn cocos2d_CCScriptEngineManager_removeScriptEngine(
        this: *mut cocos2d_CCScriptEngineManager,
    );
}
extern "C" {
    #[link_name = "\u{1}?sharedManager@CCScriptEngineManager@cocos2d@@SAPEAV12@XZ"]
    pub fn cocos2d_CCScriptEngineManager_sharedManager() -> *mut cocos2d_CCScriptEngineManager;
}
extern "C" {
    #[link_name = "\u{1}?purgeSharedManager@CCScriptEngineManager@cocos2d@@SAXXZ"]
    pub fn cocos2d_CCScriptEngineManager_purgeSharedManager();
}
extern "C" {
    #[link_name = "\u{1}??_DCCScriptEngineManager@cocos2d@@QEAAXXZ"]
    pub fn cocos2d_CCScriptEngineManager_CCScriptEngineManager_destructor(
        this: *mut cocos2d_CCScriptEngineManager,
    );
}
impl cocos2d_CCScriptEngineManager {
    #[inline]
    pub unsafe fn setScriptEngine(&mut self, pScriptEngine: *mut cocos2d_CCScriptEngineProtocol) {
        cocos2d_CCScriptEngineManager_setScriptEngine(self, pScriptEngine)
    }
    #[inline]
    pub unsafe fn removeScriptEngine(&mut self) {
        cocos2d_CCScriptEngineManager_removeScriptEngine(self)
    }
    #[inline]
    pub unsafe fn sharedManager() -> *mut cocos2d_CCScriptEngineManager {
        cocos2d_CCScriptEngineManager_sharedManager()
    }
    #[inline]
    pub unsafe fn purgeSharedManager() {
        cocos2d_CCScriptEngineManager_purgeSharedManager()
    }
    #[inline]
    pub unsafe fn destruct(&mut self) {
        cocos2d_CCScriptEngineManager_CCScriptEngineManager_destructor(self)
    }
}
#[doc = " RGB color composed of bytes 3 bytes"]
#[doc = "@since v0.8"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cocos2d__ccColor3B {
    pub r: GLubyte,
    pub g: GLubyte,
    pub b: GLubyte,
}
#[test]
fn bindgen_test_layout_cocos2d__ccColor3B() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d__ccColor3B>(),
        3usize,
        concat!("Size of: ", stringify!(cocos2d__ccColor3B))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d__ccColor3B>(),
        1usize,
        concat!("Alignment of ", stringify!(cocos2d__ccColor3B))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cocos2d__ccColor3B>())).r as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d__ccColor3B),
            "::",
            stringify!(r)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cocos2d__ccColor3B>())).g as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d__ccColor3B),
            "::",
            stringify!(g)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cocos2d__ccColor3B>())).b as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d__ccColor3B),
            "::",
            stringify!(b)
        )
    );
}
#[doc = " RGB color composed of bytes 3 bytes"]
#[doc = "@since v0.8"]
pub type cocos2d_ccColor3B = cocos2d__ccColor3B;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cocos2d__ccHSVValue {
    pub h: f32,
    pub s: f32,
    pub v: f32,
    pub absoluteSaturation: GLubyte,
    pub absoluteBrightness: GLubyte,
    pub __pad: [::std::os::raw::c_char; 2usize],
}
#[test]
fn bindgen_test_layout_cocos2d__ccHSVValue() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d__ccHSVValue>(),
        16usize,
        concat!("Size of: ", stringify!(cocos2d__ccHSVValue))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d__ccHSVValue>(),
        4usize,
        concat!("Alignment of ", stringify!(cocos2d__ccHSVValue))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cocos2d__ccHSVValue>())).h as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d__ccHSVValue),
            "::",
            stringify!(h)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cocos2d__ccHSVValue>())).s as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d__ccHSVValue),
            "::",
            stringify!(s)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cocos2d__ccHSVValue>())).v as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d__ccHSVValue),
            "::",
            stringify!(v)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cocos2d__ccHSVValue>())).absoluteSaturation as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d__ccHSVValue),
            "::",
            stringify!(absoluteSaturation)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cocos2d__ccHSVValue>())).absoluteBrightness as *const _ as usize
        },
        13usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d__ccHSVValue),
            "::",
            stringify!(absoluteBrightness)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cocos2d__ccHSVValue>())).__pad as *const _ as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d__ccHSVValue),
            "::",
            stringify!(__pad)
        )
    );
}
pub type cocos2d_ccHSVValue = cocos2d__ccHSVValue;
extern "C" {
    #[doc = "! White color (255,255,255)"]
    #[link_name = "\u{1}?ccWHITE@cocos2d@@3U_ccColor3B@1@B"]
    pub static cocos2d_ccWHITE: cocos2d_ccColor3B;
}
extern "C" {
    #[doc = "! Yellow color (255,255,0)"]
    #[link_name = "\u{1}?ccYELLOW@cocos2d@@3U_ccColor3B@1@B"]
    pub static cocos2d_ccYELLOW: cocos2d_ccColor3B;
}
extern "C" {
    #[doc = "! Blue color (0,0,255)"]
    #[link_name = "\u{1}?ccBLUE@cocos2d@@3U_ccColor3B@1@B"]
    pub static cocos2d_ccBLUE: cocos2d_ccColor3B;
}
extern "C" {
    #[doc = "! Green Color (0,255,0)"]
    #[link_name = "\u{1}?ccGREEN@cocos2d@@3U_ccColor3B@1@B"]
    pub static cocos2d_ccGREEN: cocos2d_ccColor3B;
}
extern "C" {
    #[doc = "! Red Color (255,0,0,)"]
    #[link_name = "\u{1}?ccRED@cocos2d@@3U_ccColor3B@1@B"]
    pub static cocos2d_ccRED: cocos2d_ccColor3B;
}
extern "C" {
    #[doc = "! Magenta Color (255,0,255)"]
    #[link_name = "\u{1}?ccMAGENTA@cocos2d@@3U_ccColor3B@1@B"]
    pub static cocos2d_ccMAGENTA: cocos2d_ccColor3B;
}
extern "C" {
    #[doc = "! Black Color (0,0,0)"]
    #[link_name = "\u{1}?ccBLACK@cocos2d@@3U_ccColor3B@1@B"]
    pub static cocos2d_ccBLACK: cocos2d_ccColor3B;
}
extern "C" {
    #[doc = "! Orange Color (255,127,0)"]
    #[link_name = "\u{1}?ccORANGE@cocos2d@@3U_ccColor3B@1@B"]
    pub static cocos2d_ccORANGE: cocos2d_ccColor3B;
}
extern "C" {
    #[doc = "! Gray Color (166,166,166)"]
    #[link_name = "\u{1}?ccGRAY@cocos2d@@3U_ccColor3B@1@B"]
    pub static cocos2d_ccGRAY: cocos2d_ccColor3B;
}
#[doc = " RGBA color composed of 4 bytes"]
#[doc = "@since v0.8"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cocos2d__ccColor4B {
    pub r: GLubyte,
    pub g: GLubyte,
    pub b: GLubyte,
    pub a: GLubyte,
}
#[test]
fn bindgen_test_layout_cocos2d__ccColor4B() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d__ccColor4B>(),
        4usize,
        concat!("Size of: ", stringify!(cocos2d__ccColor4B))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d__ccColor4B>(),
        1usize,
        concat!("Alignment of ", stringify!(cocos2d__ccColor4B))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cocos2d__ccColor4B>())).r as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d__ccColor4B),
            "::",
            stringify!(r)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cocos2d__ccColor4B>())).g as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d__ccColor4B),
            "::",
            stringify!(g)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cocos2d__ccColor4B>())).b as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d__ccColor4B),
            "::",
            stringify!(b)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cocos2d__ccColor4B>())).a as *const _ as usize },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d__ccColor4B),
            "::",
            stringify!(a)
        )
    );
}
#[doc = " RGBA color composed of 4 bytes"]
#[doc = "@since v0.8"]
pub type cocos2d_ccColor4B = cocos2d__ccColor4B;
#[doc = " RGBA color composed of 4 floats"]
#[doc = "@since v0.8"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cocos2d__ccColor4F {
    pub r: GLfloat,
    pub g: GLfloat,
    pub b: GLfloat,
    pub a: GLfloat,
}
#[test]
fn bindgen_test_layout_cocos2d__ccColor4F() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d__ccColor4F>(),
        16usize,
        concat!("Size of: ", stringify!(cocos2d__ccColor4F))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d__ccColor4F>(),
        4usize,
        concat!("Alignment of ", stringify!(cocos2d__ccColor4F))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cocos2d__ccColor4F>())).r as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d__ccColor4F),
            "::",
            stringify!(r)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cocos2d__ccColor4F>())).g as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d__ccColor4F),
            "::",
            stringify!(g)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cocos2d__ccColor4F>())).b as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d__ccColor4F),
            "::",
            stringify!(b)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cocos2d__ccColor4F>())).a as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d__ccColor4F),
            "::",
            stringify!(a)
        )
    );
}
#[doc = " RGBA color composed of 4 floats"]
#[doc = "@since v0.8"]
pub type cocos2d_ccColor4F = cocos2d__ccColor4F;
#[doc = " A vertex composed of 2 floats: x, y"]
#[doc = "@since v0.8"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cocos2d__ccVertex2F {
    pub x: GLfloat,
    pub y: GLfloat,
}
#[test]
fn bindgen_test_layout_cocos2d__ccVertex2F() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d__ccVertex2F>(),
        8usize,
        concat!("Size of: ", stringify!(cocos2d__ccVertex2F))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d__ccVertex2F>(),
        4usize,
        concat!("Alignment of ", stringify!(cocos2d__ccVertex2F))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cocos2d__ccVertex2F>())).x as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d__ccVertex2F),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cocos2d__ccVertex2F>())).y as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d__ccVertex2F),
            "::",
            stringify!(y)
        )
    );
}
#[doc = " A vertex composed of 2 floats: x, y"]
#[doc = "@since v0.8"]
pub type cocos2d_ccVertex2F = cocos2d__ccVertex2F;
#[doc = " A vertex composed of 2 floats: x, y"]
#[doc = "@since v0.8"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cocos2d__ccVertex3F {
    pub x: GLfloat,
    pub y: GLfloat,
    pub z: GLfloat,
}
#[test]
fn bindgen_test_layout_cocos2d__ccVertex3F() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d__ccVertex3F>(),
        12usize,
        concat!("Size of: ", stringify!(cocos2d__ccVertex3F))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d__ccVertex3F>(),
        4usize,
        concat!("Alignment of ", stringify!(cocos2d__ccVertex3F))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cocos2d__ccVertex3F>())).x as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d__ccVertex3F),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cocos2d__ccVertex3F>())).y as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d__ccVertex3F),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cocos2d__ccVertex3F>())).z as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d__ccVertex3F),
            "::",
            stringify!(z)
        )
    );
}
#[doc = " A vertex composed of 2 floats: x, y"]
#[doc = "@since v0.8"]
pub type cocos2d_ccVertex3F = cocos2d__ccVertex3F;
#[doc = " A texcoord composed of 2 floats: u, y"]
#[doc = "@since v0.8"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cocos2d__ccTex2F {
    pub u: GLfloat,
    pub v: GLfloat,
}
#[test]
fn bindgen_test_layout_cocos2d__ccTex2F() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d__ccTex2F>(),
        8usize,
        concat!("Size of: ", stringify!(cocos2d__ccTex2F))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d__ccTex2F>(),
        4usize,
        concat!("Alignment of ", stringify!(cocos2d__ccTex2F))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cocos2d__ccTex2F>())).u as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d__ccTex2F),
            "::",
            stringify!(u)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cocos2d__ccTex2F>())).v as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d__ccTex2F),
            "::",
            stringify!(v)
        )
    );
}
#[doc = " A texcoord composed of 2 floats: u, y"]
#[doc = "@since v0.8"]
pub type cocos2d_ccTex2F = cocos2d__ccTex2F;
#[doc = "! Point Sprite component"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cocos2d__ccPointSprite {
    pub pos: cocos2d_ccVertex2F,
    pub color: cocos2d_ccColor4B,
    pub size: GLfloat,
}
#[test]
fn bindgen_test_layout_cocos2d__ccPointSprite() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d__ccPointSprite>(),
        16usize,
        concat!("Size of: ", stringify!(cocos2d__ccPointSprite))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d__ccPointSprite>(),
        4usize,
        concat!("Alignment of ", stringify!(cocos2d__ccPointSprite))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cocos2d__ccPointSprite>())).pos as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d__ccPointSprite),
            "::",
            stringify!(pos)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cocos2d__ccPointSprite>())).color as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d__ccPointSprite),
            "::",
            stringify!(color)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cocos2d__ccPointSprite>())).size as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d__ccPointSprite),
            "::",
            stringify!(size)
        )
    );
}
#[doc = "! Point Sprite component"]
pub type cocos2d_ccPointSprite = cocos2d__ccPointSprite;
#[doc = "!    A 2D Quad. 4 * 2 floats"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cocos2d__ccQuad2 {
    pub tl: cocos2d_ccVertex2F,
    pub tr: cocos2d_ccVertex2F,
    pub bl: cocos2d_ccVertex2F,
    pub br: cocos2d_ccVertex2F,
}
#[test]
fn bindgen_test_layout_cocos2d__ccQuad2() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d__ccQuad2>(),
        32usize,
        concat!("Size of: ", stringify!(cocos2d__ccQuad2))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d__ccQuad2>(),
        4usize,
        concat!("Alignment of ", stringify!(cocos2d__ccQuad2))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cocos2d__ccQuad2>())).tl as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d__ccQuad2),
            "::",
            stringify!(tl)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cocos2d__ccQuad2>())).tr as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d__ccQuad2),
            "::",
            stringify!(tr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cocos2d__ccQuad2>())).bl as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d__ccQuad2),
            "::",
            stringify!(bl)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cocos2d__ccQuad2>())).br as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d__ccQuad2),
            "::",
            stringify!(br)
        )
    );
}
#[doc = "!    A 2D Quad. 4 * 2 floats"]
pub type cocos2d_ccQuad2 = cocos2d__ccQuad2;
#[doc = "!    A 3D Quad. 4 * 3 floats"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cocos2d__ccQuad3 {
    pub bl: cocos2d_ccVertex3F,
    pub br: cocos2d_ccVertex3F,
    pub tl: cocos2d_ccVertex3F,
    pub tr: cocos2d_ccVertex3F,
}
#[test]
fn bindgen_test_layout_cocos2d__ccQuad3() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d__ccQuad3>(),
        48usize,
        concat!("Size of: ", stringify!(cocos2d__ccQuad3))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d__ccQuad3>(),
        4usize,
        concat!("Alignment of ", stringify!(cocos2d__ccQuad3))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cocos2d__ccQuad3>())).bl as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d__ccQuad3),
            "::",
            stringify!(bl)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cocos2d__ccQuad3>())).br as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d__ccQuad3),
            "::",
            stringify!(br)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cocos2d__ccQuad3>())).tl as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d__ccQuad3),
            "::",
            stringify!(tl)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cocos2d__ccQuad3>())).tr as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d__ccQuad3),
            "::",
            stringify!(tr)
        )
    );
}
#[doc = "!    A 3D Quad. 4 * 3 floats"]
pub type cocos2d_ccQuad3 = cocos2d__ccQuad3;
#[doc = "! a Point with a vertex point, a tex coord point and a color 4B"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cocos2d__ccV2F_C4B_T2F {
    #[doc = "! vertices (2F)"]
    pub vertices: cocos2d_ccVertex2F,
    #[doc = "! colors (4B)"]
    pub colors: cocos2d_ccColor4B,
    #[doc = "! tex coords (2F)"]
    pub texCoords: cocos2d_ccTex2F,
}
#[test]
fn bindgen_test_layout_cocos2d__ccV2F_C4B_T2F() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d__ccV2F_C4B_T2F>(),
        20usize,
        concat!("Size of: ", stringify!(cocos2d__ccV2F_C4B_T2F))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d__ccV2F_C4B_T2F>(),
        4usize,
        concat!("Alignment of ", stringify!(cocos2d__ccV2F_C4B_T2F))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cocos2d__ccV2F_C4B_T2F>())).vertices as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d__ccV2F_C4B_T2F),
            "::",
            stringify!(vertices)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cocos2d__ccV2F_C4B_T2F>())).colors as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d__ccV2F_C4B_T2F),
            "::",
            stringify!(colors)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cocos2d__ccV2F_C4B_T2F>())).texCoords as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d__ccV2F_C4B_T2F),
            "::",
            stringify!(texCoords)
        )
    );
}
#[doc = "! a Point with a vertex point, a tex coord point and a color 4B"]
pub type cocos2d_ccV2F_C4B_T2F = cocos2d__ccV2F_C4B_T2F;
#[doc = "! a Point with a vertex point, a tex coord point and a color 4F"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cocos2d__ccV2F_C4F_T2F {
    #[doc = "! vertices (2F)"]
    pub vertices: cocos2d_ccVertex2F,
    #[doc = "! colors (4F)"]
    pub colors: cocos2d_ccColor4F,
    #[doc = "! tex coords (2F)"]
    pub texCoords: cocos2d_ccTex2F,
}
#[test]
fn bindgen_test_layout_cocos2d__ccV2F_C4F_T2F() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d__ccV2F_C4F_T2F>(),
        32usize,
        concat!("Size of: ", stringify!(cocos2d__ccV2F_C4F_T2F))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d__ccV2F_C4F_T2F>(),
        4usize,
        concat!("Alignment of ", stringify!(cocos2d__ccV2F_C4F_T2F))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cocos2d__ccV2F_C4F_T2F>())).vertices as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d__ccV2F_C4F_T2F),
            "::",
            stringify!(vertices)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cocos2d__ccV2F_C4F_T2F>())).colors as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d__ccV2F_C4F_T2F),
            "::",
            stringify!(colors)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cocos2d__ccV2F_C4F_T2F>())).texCoords as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d__ccV2F_C4F_T2F),
            "::",
            stringify!(texCoords)
        )
    );
}
#[doc = "! a Point with a vertex point, a tex coord point and a color 4F"]
pub type cocos2d_ccV2F_C4F_T2F = cocos2d__ccV2F_C4F_T2F;
#[doc = "! a Point with a vertex point, a tex coord point and a color 4B"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cocos2d__ccV3F_C4B_T2F {
    #[doc = "! vertices (3F)"]
    pub vertices: cocos2d_ccVertex3F,
    #[doc = "! colors (4B)"]
    pub colors: cocos2d_ccColor4B,
    pub texCoords: cocos2d_ccTex2F,
}
#[test]
fn bindgen_test_layout_cocos2d__ccV3F_C4B_T2F() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d__ccV3F_C4B_T2F>(),
        24usize,
        concat!("Size of: ", stringify!(cocos2d__ccV3F_C4B_T2F))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d__ccV3F_C4B_T2F>(),
        4usize,
        concat!("Alignment of ", stringify!(cocos2d__ccV3F_C4B_T2F))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cocos2d__ccV3F_C4B_T2F>())).vertices as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d__ccV3F_C4B_T2F),
            "::",
            stringify!(vertices)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cocos2d__ccV3F_C4B_T2F>())).colors as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d__ccV3F_C4B_T2F),
            "::",
            stringify!(colors)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cocos2d__ccV3F_C4B_T2F>())).texCoords as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d__ccV3F_C4B_T2F),
            "::",
            stringify!(texCoords)
        )
    );
}
#[doc = "! a Point with a vertex point, a tex coord point and a color 4B"]
pub type cocos2d_ccV3F_C4B_T2F = cocos2d__ccV3F_C4B_T2F;
#[doc = "! A Triangle of ccV2F_C4B_T2F"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cocos2d__ccV2F_C4B_T2F_Triangle {
    #[doc = "! Point A"]
    pub a: cocos2d_ccV2F_C4B_T2F,
    #[doc = "! Point B"]
    pub b: cocos2d_ccV2F_C4B_T2F,
    #[doc = "! Point B"]
    pub c: cocos2d_ccV2F_C4B_T2F,
}
#[test]
fn bindgen_test_layout_cocos2d__ccV2F_C4B_T2F_Triangle() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d__ccV2F_C4B_T2F_Triangle>(),
        60usize,
        concat!("Size of: ", stringify!(cocos2d__ccV2F_C4B_T2F_Triangle))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d__ccV2F_C4B_T2F_Triangle>(),
        4usize,
        concat!("Alignment of ", stringify!(cocos2d__ccV2F_C4B_T2F_Triangle))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cocos2d__ccV2F_C4B_T2F_Triangle>())).a as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d__ccV2F_C4B_T2F_Triangle),
            "::",
            stringify!(a)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cocos2d__ccV2F_C4B_T2F_Triangle>())).b as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d__ccV2F_C4B_T2F_Triangle),
            "::",
            stringify!(b)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cocos2d__ccV2F_C4B_T2F_Triangle>())).c as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d__ccV2F_C4B_T2F_Triangle),
            "::",
            stringify!(c)
        )
    );
}
#[doc = "! A Triangle of ccV2F_C4B_T2F"]
pub type cocos2d_ccV2F_C4B_T2F_Triangle = cocos2d__ccV2F_C4B_T2F_Triangle;
#[doc = "! A Quad of ccV2F_C4B_T2F"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cocos2d__ccV2F_C4B_T2F_Quad {
    #[doc = "! bottom left"]
    pub bl: cocos2d_ccV2F_C4B_T2F,
    #[doc = "! bottom right"]
    pub br: cocos2d_ccV2F_C4B_T2F,
    #[doc = "! top left"]
    pub tl: cocos2d_ccV2F_C4B_T2F,
    #[doc = "! top right"]
    pub tr: cocos2d_ccV2F_C4B_T2F,
}
#[test]
fn bindgen_test_layout_cocos2d__ccV2F_C4B_T2F_Quad() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d__ccV2F_C4B_T2F_Quad>(),
        80usize,
        concat!("Size of: ", stringify!(cocos2d__ccV2F_C4B_T2F_Quad))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d__ccV2F_C4B_T2F_Quad>(),
        4usize,
        concat!("Alignment of ", stringify!(cocos2d__ccV2F_C4B_T2F_Quad))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cocos2d__ccV2F_C4B_T2F_Quad>())).bl as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d__ccV2F_C4B_T2F_Quad),
            "::",
            stringify!(bl)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cocos2d__ccV2F_C4B_T2F_Quad>())).br as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d__ccV2F_C4B_T2F_Quad),
            "::",
            stringify!(br)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cocos2d__ccV2F_C4B_T2F_Quad>())).tl as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d__ccV2F_C4B_T2F_Quad),
            "::",
            stringify!(tl)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cocos2d__ccV2F_C4B_T2F_Quad>())).tr as *const _ as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d__ccV2F_C4B_T2F_Quad),
            "::",
            stringify!(tr)
        )
    );
}
#[doc = "! A Quad of ccV2F_C4B_T2F"]
pub type cocos2d_ccV2F_C4B_T2F_Quad = cocos2d__ccV2F_C4B_T2F_Quad;
#[doc = "! 4 ccVertex3FTex2FColor4B"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cocos2d__ccV3F_C4B_T2F_Quad {
    #[doc = "! top left"]
    pub tl: cocos2d_ccV3F_C4B_T2F,
    #[doc = "! bottom left"]
    pub bl: cocos2d_ccV3F_C4B_T2F,
    #[doc = "! top right"]
    pub tr: cocos2d_ccV3F_C4B_T2F,
    #[doc = "! bottom right"]
    pub br: cocos2d_ccV3F_C4B_T2F,
}
#[test]
fn bindgen_test_layout_cocos2d__ccV3F_C4B_T2F_Quad() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d__ccV3F_C4B_T2F_Quad>(),
        96usize,
        concat!("Size of: ", stringify!(cocos2d__ccV3F_C4B_T2F_Quad))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d__ccV3F_C4B_T2F_Quad>(),
        4usize,
        concat!("Alignment of ", stringify!(cocos2d__ccV3F_C4B_T2F_Quad))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cocos2d__ccV3F_C4B_T2F_Quad>())).tl as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d__ccV3F_C4B_T2F_Quad),
            "::",
            stringify!(tl)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cocos2d__ccV3F_C4B_T2F_Quad>())).bl as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d__ccV3F_C4B_T2F_Quad),
            "::",
            stringify!(bl)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cocos2d__ccV3F_C4B_T2F_Quad>())).tr as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d__ccV3F_C4B_T2F_Quad),
            "::",
            stringify!(tr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cocos2d__ccV3F_C4B_T2F_Quad>())).br as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d__ccV3F_C4B_T2F_Quad),
            "::",
            stringify!(br)
        )
    );
}
#[doc = "! 4 ccVertex3FTex2FColor4B"]
pub type cocos2d_ccV3F_C4B_T2F_Quad = cocos2d__ccV3F_C4B_T2F_Quad;
#[doc = "! 4 ccVertex2FTex2FColor4F Quad"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cocos2d__ccV2F_C4F_T2F_Quad {
    #[doc = "! bottom left"]
    pub bl: cocos2d_ccV2F_C4F_T2F,
    #[doc = "! bottom right"]
    pub br: cocos2d_ccV2F_C4F_T2F,
    #[doc = "! top left"]
    pub tl: cocos2d_ccV2F_C4F_T2F,
    #[doc = "! top right"]
    pub tr: cocos2d_ccV2F_C4F_T2F,
}
#[test]
fn bindgen_test_layout_cocos2d__ccV2F_C4F_T2F_Quad() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d__ccV2F_C4F_T2F_Quad>(),
        128usize,
        concat!("Size of: ", stringify!(cocos2d__ccV2F_C4F_T2F_Quad))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d__ccV2F_C4F_T2F_Quad>(),
        4usize,
        concat!("Alignment of ", stringify!(cocos2d__ccV2F_C4F_T2F_Quad))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cocos2d__ccV2F_C4F_T2F_Quad>())).bl as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d__ccV2F_C4F_T2F_Quad),
            "::",
            stringify!(bl)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cocos2d__ccV2F_C4F_T2F_Quad>())).br as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d__ccV2F_C4F_T2F_Quad),
            "::",
            stringify!(br)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cocos2d__ccV2F_C4F_T2F_Quad>())).tl as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d__ccV2F_C4F_T2F_Quad),
            "::",
            stringify!(tl)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cocos2d__ccV2F_C4F_T2F_Quad>())).tr as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d__ccV2F_C4F_T2F_Quad),
            "::",
            stringify!(tr)
        )
    );
}
#[doc = "! 4 ccVertex2FTex2FColor4F Quad"]
pub type cocos2d_ccV2F_C4F_T2F_Quad = cocos2d__ccV2F_C4F_T2F_Quad;
#[doc = "! Blend Function used for textures"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cocos2d__ccBlendFunc {
    #[doc = "! source blend function"]
    pub src: GLenum,
    #[doc = "! destination blend function"]
    pub dst: GLenum,
}
#[test]
fn bindgen_test_layout_cocos2d__ccBlendFunc() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d__ccBlendFunc>(),
        8usize,
        concat!("Size of: ", stringify!(cocos2d__ccBlendFunc))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d__ccBlendFunc>(),
        4usize,
        concat!("Alignment of ", stringify!(cocos2d__ccBlendFunc))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cocos2d__ccBlendFunc>())).src as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d__ccBlendFunc),
            "::",
            stringify!(src)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cocos2d__ccBlendFunc>())).dst as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d__ccBlendFunc),
            "::",
            stringify!(dst)
        )
    );
}
#[doc = "! Blend Function used for textures"]
pub type cocos2d_ccBlendFunc = cocos2d__ccBlendFunc;
extern "C" {
    #[link_name = "\u{1}?kCCBlendFuncDisable@cocos2d@@3U_ccBlendFunc@1@B"]
    pub static cocos2d_kCCBlendFuncDisable: cocos2d_ccBlendFunc;
}
pub const cocos2d_CCVerticalTextAlignment_kCCVerticalTextAlignmentTop:
    cocos2d_CCVerticalTextAlignment = 0;
pub const cocos2d_CCVerticalTextAlignment_kCCVerticalTextAlignmentCenter:
    cocos2d_CCVerticalTextAlignment = 1;
pub const cocos2d_CCVerticalTextAlignment_kCCVerticalTextAlignmentBottom:
    cocos2d_CCVerticalTextAlignment = 2;
#[doc = "! Vertical text alignment type"]
pub type cocos2d_CCVerticalTextAlignment = ::std::os::raw::c_int;
pub const cocos2d_CCTextAlignment_kCCTextAlignmentLeft: cocos2d_CCTextAlignment = 0;
pub const cocos2d_CCTextAlignment_kCCTextAlignmentCenter: cocos2d_CCTextAlignment = 1;
pub const cocos2d_CCTextAlignment_kCCTextAlignmentRight: cocos2d_CCTextAlignment = 2;
#[doc = "! Horizontal text alignment type"]
pub type cocos2d_CCTextAlignment = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cocos2d__ccT2F_Quad {
    #[doc = "! bottom left"]
    pub bl: cocos2d_ccTex2F,
    #[doc = "! bottom right"]
    pub br: cocos2d_ccTex2F,
    #[doc = "! top left"]
    pub tl: cocos2d_ccTex2F,
    #[doc = "! top right"]
    pub tr: cocos2d_ccTex2F,
}
#[test]
fn bindgen_test_layout_cocos2d__ccT2F_Quad() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d__ccT2F_Quad>(),
        32usize,
        concat!("Size of: ", stringify!(cocos2d__ccT2F_Quad))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d__ccT2F_Quad>(),
        4usize,
        concat!("Alignment of ", stringify!(cocos2d__ccT2F_Quad))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cocos2d__ccT2F_Quad>())).bl as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d__ccT2F_Quad),
            "::",
            stringify!(bl)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cocos2d__ccT2F_Quad>())).br as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d__ccT2F_Quad),
            "::",
            stringify!(br)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cocos2d__ccT2F_Quad>())).tl as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d__ccT2F_Quad),
            "::",
            stringify!(tl)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cocos2d__ccT2F_Quad>())).tr as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d__ccT2F_Quad),
            "::",
            stringify!(tr)
        )
    );
}
pub type cocos2d_ccT2F_Quad = cocos2d__ccT2F_Quad;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cocos2d_ccAnimationFrameData {
    pub texCoords: cocos2d_ccT2F_Quad,
    pub delay: f32,
    pub size: cocos2d_CCSize,
}
#[test]
fn bindgen_test_layout_cocos2d_ccAnimationFrameData() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d_ccAnimationFrameData>(),
        44usize,
        concat!("Size of: ", stringify!(cocos2d_ccAnimationFrameData))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_ccAnimationFrameData>(),
        4usize,
        concat!("Alignment of ", stringify!(cocos2d_ccAnimationFrameData))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cocos2d_ccAnimationFrameData>())).texCoords as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_ccAnimationFrameData),
            "::",
            stringify!(texCoords)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cocos2d_ccAnimationFrameData>())).delay as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_ccAnimationFrameData),
            "::",
            stringify!(delay)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cocos2d_ccAnimationFrameData>())).size as *const _ as usize
        },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_ccAnimationFrameData),
            "::",
            stringify!(size)
        )
    );
}
#[doc = "types used for defining fonts properties (i.e. font name, size, stroke or shadow)"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cocos2d__ccFontShadow {
    pub m_shadowEnabled: bool,
    pub m_shadowOffset: cocos2d_CCSize,
    pub m_shadowBlur: f32,
    pub m_shadowOpacity: f32,
}
#[test]
fn bindgen_test_layout_cocos2d__ccFontShadow() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d__ccFontShadow>(),
        20usize,
        concat!("Size of: ", stringify!(cocos2d__ccFontShadow))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d__ccFontShadow>(),
        4usize,
        concat!("Alignment of ", stringify!(cocos2d__ccFontShadow))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cocos2d__ccFontShadow>())).m_shadowEnabled as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d__ccFontShadow),
            "::",
            stringify!(m_shadowEnabled)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cocos2d__ccFontShadow>())).m_shadowOffset as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d__ccFontShadow),
            "::",
            stringify!(m_shadowOffset)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cocos2d__ccFontShadow>())).m_shadowBlur as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d__ccFontShadow),
            "::",
            stringify!(m_shadowBlur)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cocos2d__ccFontShadow>())).m_shadowOpacity as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d__ccFontShadow),
            "::",
            stringify!(m_shadowOpacity)
        )
    );
}
#[doc = "types used for defining fonts properties (i.e. font name, size, stroke or shadow)"]
pub type cocos2d_ccFontShadow = cocos2d__ccFontShadow;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cocos2d__ccFontStroke {
    pub m_strokeEnabled: bool,
    pub m_strokeColor: cocos2d_ccColor3B,
    pub m_strokeSize: f32,
}
#[test]
fn bindgen_test_layout_cocos2d__ccFontStroke() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d__ccFontStroke>(),
        8usize,
        concat!("Size of: ", stringify!(cocos2d__ccFontStroke))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d__ccFontStroke>(),
        4usize,
        concat!("Alignment of ", stringify!(cocos2d__ccFontStroke))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cocos2d__ccFontStroke>())).m_strokeEnabled as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d__ccFontStroke),
            "::",
            stringify!(m_strokeEnabled)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cocos2d__ccFontStroke>())).m_strokeColor as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d__ccFontStroke),
            "::",
            stringify!(m_strokeColor)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cocos2d__ccFontStroke>())).m_strokeSize as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d__ccFontStroke),
            "::",
            stringify!(m_strokeSize)
        )
    );
}
pub type cocos2d_ccFontStroke = cocos2d__ccFontStroke;
#[doc = "  @js NA"]
#[doc = "  @lua NA"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cocos2d__ccFontDefinition {
    pub m_fontName: std_string,
    pub m_fontSize: ::std::os::raw::c_int,
    pub m_alignment: cocos2d_CCTextAlignment,
    pub m_vertAlignment: cocos2d_CCVerticalTextAlignment,
    pub m_dimensions: cocos2d_CCSize,
    pub m_fontFillColor: cocos2d_ccColor3B,
    pub m_shadow: cocos2d_ccFontShadow,
    pub m_stroke: cocos2d_ccFontStroke,
}
#[test]
fn bindgen_test_layout_cocos2d__ccFontDefinition() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d__ccFontDefinition>(),
        88usize,
        concat!("Size of: ", stringify!(cocos2d__ccFontDefinition))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d__ccFontDefinition>(),
        8usize,
        concat!("Alignment of ", stringify!(cocos2d__ccFontDefinition))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cocos2d__ccFontDefinition>())).m_fontName as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d__ccFontDefinition),
            "::",
            stringify!(m_fontName)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cocos2d__ccFontDefinition>())).m_fontSize as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d__ccFontDefinition),
            "::",
            stringify!(m_fontSize)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cocos2d__ccFontDefinition>())).m_alignment as *const _ as usize
        },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d__ccFontDefinition),
            "::",
            stringify!(m_alignment)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cocos2d__ccFontDefinition>())).m_vertAlignment as *const _
                as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d__ccFontDefinition),
            "::",
            stringify!(m_vertAlignment)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cocos2d__ccFontDefinition>())).m_dimensions as *const _ as usize
        },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d__ccFontDefinition),
            "::",
            stringify!(m_dimensions)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cocos2d__ccFontDefinition>())).m_fontFillColor as *const _
                as usize
        },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d__ccFontDefinition),
            "::",
            stringify!(m_fontFillColor)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cocos2d__ccFontDefinition>())).m_shadow as *const _ as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d__ccFontDefinition),
            "::",
            stringify!(m_shadow)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cocos2d__ccFontDefinition>())).m_stroke as *const _ as usize
        },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d__ccFontDefinition),
            "::",
            stringify!(m_stroke)
        )
    );
}
#[doc = "  @js NA"]
#[doc = "  @lua NA"]
pub type cocos2d_ccFontDefinition = cocos2d__ccFontDefinition;
#[doc = "! 32-bit texture: RGBA8888"]
pub const cocos2d_CCTexture2DPixelFormat_kCCTexture2DPixelFormat_RGBA8888:
    cocos2d_CCTexture2DPixelFormat = 0;
#[doc = "! 24-bit texture: RGBA888"]
pub const cocos2d_CCTexture2DPixelFormat_kCCTexture2DPixelFormat_RGB888:
    cocos2d_CCTexture2DPixelFormat = 1;
#[doc = "! 16-bit texture without Alpha channel"]
pub const cocos2d_CCTexture2DPixelFormat_kCCTexture2DPixelFormat_RGB565:
    cocos2d_CCTexture2DPixelFormat = 2;
#[doc = "! 8-bit textures used as masks"]
pub const cocos2d_CCTexture2DPixelFormat_kCCTexture2DPixelFormat_A8:
    cocos2d_CCTexture2DPixelFormat = 3;
#[doc = "! 8-bit intensity texture"]
pub const cocos2d_CCTexture2DPixelFormat_kCCTexture2DPixelFormat_I8:
    cocos2d_CCTexture2DPixelFormat = 4;
#[doc = "! 16-bit textures used as masks"]
pub const cocos2d_CCTexture2DPixelFormat_kCCTexture2DPixelFormat_AI88:
    cocos2d_CCTexture2DPixelFormat = 5;
#[doc = "! 16-bit textures: RGBA4444"]
pub const cocos2d_CCTexture2DPixelFormat_kCCTexture2DPixelFormat_RGBA4444:
    cocos2d_CCTexture2DPixelFormat = 6;
#[doc = "! 16-bit textures: RGB5A1"]
pub const cocos2d_CCTexture2DPixelFormat_kCCTexture2DPixelFormat_RGB5A1:
    cocos2d_CCTexture2DPixelFormat = 7;
#[doc = "! 4-bit PVRTC-compressed texture: PVRTC4"]
pub const cocos2d_CCTexture2DPixelFormat_kCCTexture2DPixelFormat_PVRTC4:
    cocos2d_CCTexture2DPixelFormat = 8;
#[doc = "! 2-bit PVRTC-compressed texture: PVRTC2"]
pub const cocos2d_CCTexture2DPixelFormat_kCCTexture2DPixelFormat_PVRTC2:
    cocos2d_CCTexture2DPixelFormat = 9;
#[doc = "! Default texture format: RGBA8888"]
pub const cocos2d_CCTexture2DPixelFormat_kCCTexture2DPixelFormat_Default:
    cocos2d_CCTexture2DPixelFormat = 0;
#[doc = "! Default texture format: RGBA8888"]
pub const cocos2d_CCTexture2DPixelFormat_kTexture2DPixelFormat_RGBA8888:
    cocos2d_CCTexture2DPixelFormat = 0;
#[doc = "! Default texture format: RGBA8888"]
pub const cocos2d_CCTexture2DPixelFormat_kTexture2DPixelFormat_RGB888:
    cocos2d_CCTexture2DPixelFormat = 1;
#[doc = "! Default texture format: RGBA8888"]
pub const cocos2d_CCTexture2DPixelFormat_kTexture2DPixelFormat_RGB565:
    cocos2d_CCTexture2DPixelFormat = 2;
#[doc = "! Default texture format: RGBA8888"]
pub const cocos2d_CCTexture2DPixelFormat_kTexture2DPixelFormat_A8: cocos2d_CCTexture2DPixelFormat =
    3;
#[doc = "! Default texture format: RGBA8888"]
pub const cocos2d_CCTexture2DPixelFormat_kTexture2DPixelFormat_RGBA4444:
    cocos2d_CCTexture2DPixelFormat = 6;
#[doc = "! Default texture format: RGBA8888"]
pub const cocos2d_CCTexture2DPixelFormat_kTexture2DPixelFormat_RGB5A1:
    cocos2d_CCTexture2DPixelFormat = 7;
#[doc = "! Default texture format: RGBA8888"]
pub const cocos2d_CCTexture2DPixelFormat_kTexture2DPixelFormat_Default:
    cocos2d_CCTexture2DPixelFormat = 0;
#[doc = " @typedef CCTexture2DPixelFormat"]
#[doc = "Possible texture pixel formats"]
pub type cocos2d_CCTexture2DPixelFormat = ::std::os::raw::c_int;
#[doc = "Extension to set the Min / Mag filter"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cocos2d__ccTexParams {
    pub minFilter: GLuint,
    pub magFilter: GLuint,
    pub wrapS: GLuint,
    pub wrapT: GLuint,
}
#[test]
fn bindgen_test_layout_cocos2d__ccTexParams() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d__ccTexParams>(),
        16usize,
        concat!("Size of: ", stringify!(cocos2d__ccTexParams))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d__ccTexParams>(),
        4usize,
        concat!("Alignment of ", stringify!(cocos2d__ccTexParams))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cocos2d__ccTexParams>())).minFilter as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d__ccTexParams),
            "::",
            stringify!(minFilter)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cocos2d__ccTexParams>())).magFilter as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d__ccTexParams),
            "::",
            stringify!(magFilter)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cocos2d__ccTexParams>())).wrapS as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d__ccTexParams),
            "::",
            stringify!(wrapS)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cocos2d__ccTexParams>())).wrapT as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d__ccTexParams),
            "::",
            stringify!(wrapT)
        )
    );
}
#[doc = "Extension to set the Min / Mag filter"]
pub type cocos2d_ccTexParams = cocos2d__ccTexParams;
#[doc = " @brief CCTexture2D class."]
#[doc = " This class allows to easily create OpenGL 2D textures from images, text or raw data."]
#[doc = " The created CCTexture2D object will always have power-of-two dimensions."]
#[doc = " Depending on how you create the CCTexture2D object, the actual image area of the texture might be smaller than the texture dimensions i.e. \"contentSize\" != (pixelsWide, pixelsHigh) and (maxS, maxT) != (1.0, 1.0)."]
#[doc = " Be aware that the content of the generated textures will be upside-down!"]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCTexture2D {
    pub _base: cocos2d_CCObject,
    pub m_bPVRHaveAlphaPremultiplied: bool,
    pub m_ePixelFormat: cocos2d_CCTexture2DPixelFormat,
    pub m_uPixelsWide: ::std::os::raw::c_uint,
    pub m_uPixelsHigh: ::std::os::raw::c_uint,
    pub m_uName: GLuint,
    pub m_fMaxS: GLfloat,
    pub m_fMaxT: GLfloat,
    pub m_tContentSize: cocos2d_CCSize,
    #[doc = " whether or not the texture has their Alpha premultiplied"]
    pub m_bHasPremultipliedAlpha: bool,
    pub m_bHasMipmaps: bool,
    pub m_pShaderProgram: *mut cocos2d_CCGLProgram,
}
#[test]
fn bindgen_test_layout_cocos2d_CCTexture2D() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCTexture2D>(),
        88usize,
        concat!("Size of: ", stringify!(cocos2d_CCTexture2D))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCTexture2D>(),
        8usize,
        concat!("Alignment of ", stringify!(cocos2d_CCTexture2D))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cocos2d_CCTexture2D>())).m_bPVRHaveAlphaPremultiplied as *const _
                as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCTexture2D),
            "::",
            stringify!(m_bPVRHaveAlphaPremultiplied)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cocos2d_CCTexture2D>())).m_ePixelFormat as *const _ as usize
        },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCTexture2D),
            "::",
            stringify!(m_ePixelFormat)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cocos2d_CCTexture2D>())).m_uPixelsWide as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCTexture2D),
            "::",
            stringify!(m_uPixelsWide)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cocos2d_CCTexture2D>())).m_uPixelsHigh as *const _ as usize
        },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCTexture2D),
            "::",
            stringify!(m_uPixelsHigh)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cocos2d_CCTexture2D>())).m_uName as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCTexture2D),
            "::",
            stringify!(m_uName)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cocos2d_CCTexture2D>())).m_fMaxS as *const _ as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCTexture2D),
            "::",
            stringify!(m_fMaxS)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cocos2d_CCTexture2D>())).m_fMaxT as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCTexture2D),
            "::",
            stringify!(m_fMaxT)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cocos2d_CCTexture2D>())).m_tContentSize as *const _ as usize
        },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCTexture2D),
            "::",
            stringify!(m_tContentSize)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cocos2d_CCTexture2D>())).m_bHasPremultipliedAlpha as *const _
                as usize
        },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCTexture2D),
            "::",
            stringify!(m_bHasPremultipliedAlpha)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cocos2d_CCTexture2D>())).m_bHasMipmaps as *const _ as usize
        },
        77usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCTexture2D),
            "::",
            stringify!(m_bHasMipmaps)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cocos2d_CCTexture2D>())).m_pShaderProgram as *const _ as usize
        },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCTexture2D),
            "::",
            stringify!(m_pShaderProgram)
        )
    );
}
extern "C" {
    #[doc = "  @js NA"]
    #[doc = "  @lua NA"]
    #[link_name = "\u{1}?description@CCTexture2D@cocos2d@@QEAAPEBDXZ"]
    pub fn cocos2d_CCTexture2D_description(
        this: *mut cocos2d_CCTexture2D,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " These functions are needed to create mutable textures"]
    #[doc = " @js NA"]
    #[link_name = "\u{1}?releaseData@CCTexture2D@cocos2d@@QEAAXPEAX@Z"]
    pub fn cocos2d_CCTexture2D_releaseData(
        this: *mut cocos2d_CCTexture2D,
        data: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    #[doc = " @js NA"]
    #[link_name = "\u{1}?keepData@CCTexture2D@cocos2d@@QEAAPEAXPEAXI@Z"]
    pub fn cocos2d_CCTexture2D_keepData(
        this: *mut cocos2d_CCTexture2D,
        data: *mut ::std::os::raw::c_void,
        length: ::std::os::raw::c_uint,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " Initializes with a texture2d with data"]
    #[doc = " @js NA"]
    #[doc = " @lua NA"]
    #[link_name = "\u{1}?initWithData@CCTexture2D@cocos2d@@QEAA_NPEBXW4CCTexture2DPixelFormat@2@IIAEBVCCSize@2@@Z"]
    pub fn cocos2d_CCTexture2D_initWithData(
        this: *mut cocos2d_CCTexture2D,
        data: *const ::std::os::raw::c_void,
        pixelFormat: cocos2d_CCTexture2DPixelFormat,
        pixelsWide: ::std::os::raw::c_uint,
        pixelsHigh: ::std::os::raw::c_uint,
        contentSize: *const cocos2d_CCSize,
    ) -> bool;
}
extern "C" {
    #[doc = "Drawing extensions to make it easy to draw basic quads using a CCTexture2D object."]
    #[doc = "These functions require GL_TEXTURE_2D and both GL_VERTEX_ARRAY and GL_TEXTURE_COORD_ARRAY client states to be enabled."]
    #[link_name = "\u{1}?drawAtPoint@CCTexture2D@cocos2d@@QEAAXAEBVCCPoint@2@@Z"]
    pub fn cocos2d_CCTexture2D_drawAtPoint(
        this: *mut cocos2d_CCTexture2D,
        point: *const cocos2d_CCPoint,
    );
}
extern "C" {
    #[doc = " draws a texture inside a rect"]
    #[link_name = "\u{1}?drawInRect@CCTexture2D@cocos2d@@QEAAXAEBVCCRect@2@@Z"]
    pub fn cocos2d_CCTexture2D_drawInRect(
        this: *mut cocos2d_CCTexture2D,
        rect: *const cocos2d_CCRect,
    );
}
extern "C" {
    #[doc = "Extensions to make it easy to create a CCTexture2D object from an image file."]
    #[doc = "Note that RGBA type textures will have their alpha premultiplied - use the blending mode (GL_ONE, GL_ONE_MINUS_SRC_ALPHA)."]
    #[link_name = "\u{1}?initWithImage@CCTexture2D@cocos2d@@QEAA_NPEAVCCImage@2@@Z"]
    pub fn cocos2d_CCTexture2D_initWithImage(
        this: *mut cocos2d_CCTexture2D,
        uiImage: *mut cocos2d_CCImage,
    ) -> bool;
}
extern "C" {
    #[doc = " Initializes a texture from a string with dimensions, alignment, font name and font size"]
    #[link_name = "\u{1}?initWithString@CCTexture2D@cocos2d@@QEAA_NPEBD0MAEBVCCSize@2@W4CCTextAlignment@2@W4CCVerticalTextAlignment@2@@Z"]
    pub fn cocos2d_CCTexture2D_initWithString(
        this: *mut cocos2d_CCTexture2D,
        text: *const ::std::os::raw::c_char,
        fontName: *const ::std::os::raw::c_char,
        fontSize: f32,
        dimensions: *const cocos2d_CCSize,
        hAlignment: cocos2d_CCTextAlignment,
        vAlignment: cocos2d_CCVerticalTextAlignment,
    ) -> bool;
}
extern "C" {
    #[doc = " Initializes a texture from a string with font name and font size"]
    #[link_name = "\u{1}?initWithString@CCTexture2D@cocos2d@@QEAA_NPEBD0M@Z"]
    pub fn cocos2d_CCTexture2D_initWithString1(
        this: *mut cocos2d_CCTexture2D,
        text: *const ::std::os::raw::c_char,
        fontName: *const ::std::os::raw::c_char,
        fontSize: f32,
    ) -> bool;
}
extern "C" {
    #[doc = " Initializes a texture from a string using a text definition"]
    #[link_name = "\u{1}?initWithString@CCTexture2D@cocos2d@@QEAA_NPEBDPEAU_ccFontDefinition@2@@Z"]
    pub fn cocos2d_CCTexture2D_initWithString2(
        this: *mut cocos2d_CCTexture2D,
        text: *const ::std::os::raw::c_char,
        textDefinition: *mut cocos2d_ccFontDefinition,
    ) -> bool;
}
extern "C" {
    #[doc = " Initializes a texture from a PVR file"]
    #[link_name = "\u{1}?initWithPVRFile@CCTexture2D@cocos2d@@QEAA_NPEBD@Z"]
    pub fn cocos2d_CCTexture2D_initWithPVRFile(
        this: *mut cocos2d_CCTexture2D,
        file: *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    #[doc = " Initializes a texture from a ETC file"]
    #[link_name = "\u{1}?initWithETCFile@CCTexture2D@cocos2d@@QEAA_NPEBD@Z"]
    pub fn cocos2d_CCTexture2D_initWithETCFile(
        this: *mut cocos2d_CCTexture2D,
        file: *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    #[doc = " sets the min filter, mag filter, wrap s and wrap t texture parameters."]
    #[doc = "If the texture size is NPOT (non power of 2), then in can only use GL_CLAMP_TO_EDGE in GL_TEXTURE_WRAP_{S,T}."]
    #[doc = ""]
    #[doc = "@warning Calling this method could allocate additional texture memory."]
    #[doc = ""]
    #[doc = "@since v0.8"]
    #[doc = "@code"]
    #[doc = "when this functon bound to js,the input param are changed"]
    #[doc = "js: var setTexParameters(var minFilter, var magFilter, var wrapS, var wrapT)"]
    #[doc = "@endcode"]
    #[link_name = "\u{1}?setTexParameters@CCTexture2D@cocos2d@@QEAAXPEAU_ccTexParams@2@@Z"]
    pub fn cocos2d_CCTexture2D_setTexParameters(
        this: *mut cocos2d_CCTexture2D,
        texParams: *mut cocos2d_ccTexParams,
    );
}
extern "C" {
    #[doc = " sets antialias texture parameters:"]
    #[doc = "- GL_TEXTURE_MIN_FILTER = GL_LINEAR"]
    #[doc = "- GL_TEXTURE_MAG_FILTER = GL_LINEAR"]
    #[doc = ""]
    #[doc = "@warning Calling this method could allocate additional texture memory."]
    #[doc = ""]
    #[doc = "@since v0.8"]
    #[link_name = "\u{1}?setAntiAliasTexParameters@CCTexture2D@cocos2d@@QEAAXXZ"]
    pub fn cocos2d_CCTexture2D_setAntiAliasTexParameters(this: *mut cocos2d_CCTexture2D);
}
extern "C" {
    #[doc = " sets alias texture parameters:"]
    #[doc = "- GL_TEXTURE_MIN_FILTER = GL_NEAREST"]
    #[doc = "- GL_TEXTURE_MAG_FILTER = GL_NEAREST"]
    #[doc = ""]
    #[doc = "@warning Calling this method could allocate additional texture memory."]
    #[doc = ""]
    #[doc = "@since v0.8"]
    #[link_name = "\u{1}?setAliasTexParameters@CCTexture2D@cocos2d@@QEAAXXZ"]
    pub fn cocos2d_CCTexture2D_setAliasTexParameters(this: *mut cocos2d_CCTexture2D);
}
extern "C" {
    #[doc = " Generates mipmap images for the texture."]
    #[doc = "It only works if the texture size is POT (power of 2)."]
    #[doc = "@since v0.99.0"]
    #[link_name = "\u{1}?generateMipmap@CCTexture2D@cocos2d@@QEAAXXZ"]
    pub fn cocos2d_CCTexture2D_generateMipmap(this: *mut cocos2d_CCTexture2D);
}
extern "C" {
    #[doc = " returns the pixel format."]
    #[doc = "@since v2.0"]
    #[link_name = "\u{1}?stringForFormat@CCTexture2D@cocos2d@@QEAAPEBDXZ"]
    pub fn cocos2d_CCTexture2D_stringForFormat(
        this: *mut cocos2d_CCTexture2D,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " returns the bits-per-pixel of the in-memory OpenGL texture"]
    #[doc = "@since v1.0"]
    #[link_name = "\u{1}?bitsPerPixelForFormat@CCTexture2D@cocos2d@@QEAAIXZ"]
    pub fn cocos2d_CCTexture2D_bitsPerPixelForFormat(
        this: *mut cocos2d_CCTexture2D,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " Helper functions that returns bits per pixels for a given format."]
    #[doc = "@since v2.0"]
    #[link_name = "\u{1}?bitsPerPixelForFormat@CCTexture2D@cocos2d@@QEAAIW4CCTexture2DPixelFormat@2@@Z"]
    pub fn cocos2d_CCTexture2D_bitsPerPixelForFormat1(
        this: *mut cocos2d_CCTexture2D,
        format: cocos2d_CCTexture2DPixelFormat,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " sets the default pixel format for UIImagescontains alpha channel."]
    #[doc = "If the UIImage contains alpha channel, then the options are:"]
    #[doc = "- generate 32-bit textures: kCCTexture2DPixelFormat_RGBA8888 (default one)"]
    #[doc = "- generate 24-bit textures: kCCTexture2DPixelFormat_RGB888"]
    #[doc = "- generate 16-bit textures: kCCTexture2DPixelFormat_RGBA4444"]
    #[doc = "- generate 16-bit textures: kCCTexture2DPixelFormat_RGB5A1"]
    #[doc = "- generate 16-bit textures: kCCTexture2DPixelFormat_RGB565"]
    #[doc = "- generate 8-bit textures: kCCTexture2DPixelFormat_A8 (only use it if you use just 1 color)"]
    #[doc = ""]
    #[doc = "How does it work ?"]
    #[doc = "- If the image is an RGBA (with Alpha) then the default pixel format will be used (it can be a 8-bit, 16-bit or 32-bit texture)"]
    #[doc = "- If the image is an RGB (without Alpha) then: If the default pixel format is RGBA8888 then a RGBA8888 (32-bit) will be used. Otherwise a RGB565 (16-bit texture) will be used."]
    #[doc = ""]
    #[doc = "This parameter is not valid for PVR / PVR.CCZ images."]
    #[doc = ""]
    #[doc = "@since v0.8"]
    #[link_name = "\u{1}?setDefaultAlphaPixelFormat@CCTexture2D@cocos2d@@SAXW4CCTexture2DPixelFormat@2@@Z"]
    pub fn cocos2d_CCTexture2D_setDefaultAlphaPixelFormat(format: cocos2d_CCTexture2DPixelFormat);
}
extern "C" {
    #[doc = " returns the alpha pixel format"]
    #[doc = "@since v0.8"]
    #[doc = "@js getDefaultAlphaPixelFormat"]
    #[link_name = "\u{1}?defaultAlphaPixelFormat@CCTexture2D@cocos2d@@SA?AW4CCTexture2DPixelFormat@2@XZ"]
    pub fn cocos2d_CCTexture2D_defaultAlphaPixelFormat() -> cocos2d_CCTexture2DPixelFormat;
}
extern "C" {
    #[doc = " treats (or not) PVR files as if they have alpha premultiplied."]
    #[doc = "Since it is impossible to know at runtime if the PVR images have the alpha channel premultiplied, it is"]
    #[doc = "possible load them as if they have (or not) the alpha channel premultiplied."]
    #[doc = ""]
    #[doc = "By default it is disabled."]
    #[doc = ""]
    #[doc = "@since v0.99.5"]
    #[link_name = "\u{1}?PVRImagesHavePremultipliedAlpha@CCTexture2D@cocos2d@@SAX_N@Z"]
    pub fn cocos2d_CCTexture2D_PVRImagesHavePremultipliedAlpha(haveAlphaPremultiplied: bool);
}
extern "C" {
    #[doc = " content size"]
    #[link_name = "\u{1}?getContentSizeInPixels@CCTexture2D@cocos2d@@QEAAAEBVCCSize@2@XZ"]
    pub fn cocos2d_CCTexture2D_getContentSizeInPixels(
        this: *mut cocos2d_CCTexture2D,
    ) -> *const cocos2d_CCSize;
}
extern "C" {
    #[link_name = "\u{1}?hasPremultipliedAlpha@CCTexture2D@cocos2d@@QEAA_NXZ"]
    pub fn cocos2d_CCTexture2D_hasPremultipliedAlpha(this: *mut cocos2d_CCTexture2D) -> bool;
}
extern "C" {
    #[link_name = "\u{1}?hasMipmaps@CCTexture2D@cocos2d@@QEAA_NXZ"]
    pub fn cocos2d_CCTexture2D_hasMipmaps(this: *mut cocos2d_CCTexture2D) -> bool;
}
extern "C" {
    #[doc = " @js ctor"]
    #[link_name = "\u{1}??0CCTexture2D@cocos2d@@QEAA@XZ"]
    pub fn cocos2d_CCTexture2D_CCTexture2D(this: *mut cocos2d_CCTexture2D);
}
impl cocos2d_CCTexture2D {
    #[inline]
    pub unsafe fn description(&mut self) -> *const ::std::os::raw::c_char {
        cocos2d_CCTexture2D_description(self)
    }
    #[inline]
    pub unsafe fn releaseData(&mut self, data: *mut ::std::os::raw::c_void) {
        cocos2d_CCTexture2D_releaseData(self, data)
    }
    #[inline]
    pub unsafe fn keepData(
        &mut self,
        data: *mut ::std::os::raw::c_void,
        length: ::std::os::raw::c_uint,
    ) -> *mut ::std::os::raw::c_void {
        cocos2d_CCTexture2D_keepData(self, data, length)
    }
    #[inline]
    pub unsafe fn initWithData(
        &mut self,
        data: *const ::std::os::raw::c_void,
        pixelFormat: cocos2d_CCTexture2DPixelFormat,
        pixelsWide: ::std::os::raw::c_uint,
        pixelsHigh: ::std::os::raw::c_uint,
        contentSize: *const cocos2d_CCSize,
    ) -> bool {
        cocos2d_CCTexture2D_initWithData(
            self,
            data,
            pixelFormat,
            pixelsWide,
            pixelsHigh,
            contentSize,
        )
    }
    #[inline]
    pub unsafe fn drawAtPoint(&mut self, point: *const cocos2d_CCPoint) {
        cocos2d_CCTexture2D_drawAtPoint(self, point)
    }
    #[inline]
    pub unsafe fn drawInRect(&mut self, rect: *const cocos2d_CCRect) {
        cocos2d_CCTexture2D_drawInRect(self, rect)
    }
    #[inline]
    pub unsafe fn initWithImage(&mut self, uiImage: *mut cocos2d_CCImage) -> bool {
        cocos2d_CCTexture2D_initWithImage(self, uiImage)
    }
    #[inline]
    pub unsafe fn initWithString(
        &mut self,
        text: *const ::std::os::raw::c_char,
        fontName: *const ::std::os::raw::c_char,
        fontSize: f32,
        dimensions: *const cocos2d_CCSize,
        hAlignment: cocos2d_CCTextAlignment,
        vAlignment: cocos2d_CCVerticalTextAlignment,
    ) -> bool {
        cocos2d_CCTexture2D_initWithString(
            self, text, fontName, fontSize, dimensions, hAlignment, vAlignment,
        )
    }
    #[inline]
    pub unsafe fn initWithString1(
        &mut self,
        text: *const ::std::os::raw::c_char,
        fontName: *const ::std::os::raw::c_char,
        fontSize: f32,
    ) -> bool {
        cocos2d_CCTexture2D_initWithString1(self, text, fontName, fontSize)
    }
    #[inline]
    pub unsafe fn initWithString2(
        &mut self,
        text: *const ::std::os::raw::c_char,
        textDefinition: *mut cocos2d_ccFontDefinition,
    ) -> bool {
        cocos2d_CCTexture2D_initWithString2(self, text, textDefinition)
    }
    #[inline]
    pub unsafe fn initWithPVRFile(&mut self, file: *const ::std::os::raw::c_char) -> bool {
        cocos2d_CCTexture2D_initWithPVRFile(self, file)
    }
    #[inline]
    pub unsafe fn initWithETCFile(&mut self, file: *const ::std::os::raw::c_char) -> bool {
        cocos2d_CCTexture2D_initWithETCFile(self, file)
    }
    #[inline]
    pub unsafe fn setTexParameters(&mut self, texParams: *mut cocos2d_ccTexParams) {
        cocos2d_CCTexture2D_setTexParameters(self, texParams)
    }
    #[inline]
    pub unsafe fn setAntiAliasTexParameters(&mut self) {
        cocos2d_CCTexture2D_setAntiAliasTexParameters(self)
    }
    #[inline]
    pub unsafe fn setAliasTexParameters(&mut self) {
        cocos2d_CCTexture2D_setAliasTexParameters(self)
    }
    #[inline]
    pub unsafe fn generateMipmap(&mut self) {
        cocos2d_CCTexture2D_generateMipmap(self)
    }
    #[inline]
    pub unsafe fn stringForFormat(&mut self) -> *const ::std::os::raw::c_char {
        cocos2d_CCTexture2D_stringForFormat(self)
    }
    #[inline]
    pub unsafe fn bitsPerPixelForFormat(&mut self) -> ::std::os::raw::c_uint {
        cocos2d_CCTexture2D_bitsPerPixelForFormat(self)
    }
    #[inline]
    pub unsafe fn bitsPerPixelForFormat1(
        &mut self,
        format: cocos2d_CCTexture2DPixelFormat,
    ) -> ::std::os::raw::c_uint {
        cocos2d_CCTexture2D_bitsPerPixelForFormat1(self, format)
    }
    #[inline]
    pub unsafe fn setDefaultAlphaPixelFormat(format: cocos2d_CCTexture2DPixelFormat) {
        cocos2d_CCTexture2D_setDefaultAlphaPixelFormat(format)
    }
    #[inline]
    pub unsafe fn defaultAlphaPixelFormat() -> cocos2d_CCTexture2DPixelFormat {
        cocos2d_CCTexture2D_defaultAlphaPixelFormat()
    }
    #[inline]
    pub unsafe fn PVRImagesHavePremultipliedAlpha(haveAlphaPremultiplied: bool) {
        cocos2d_CCTexture2D_PVRImagesHavePremultipliedAlpha(haveAlphaPremultiplied)
    }
    #[inline]
    pub unsafe fn getContentSizeInPixels(&mut self) -> *const cocos2d_CCSize {
        cocos2d_CCTexture2D_getContentSizeInPixels(self)
    }
    #[inline]
    pub unsafe fn hasPremultipliedAlpha(&mut self) -> bool {
        cocos2d_CCTexture2D_hasPremultipliedAlpha(self)
    }
    #[inline]
    pub unsafe fn hasMipmaps(&mut self) -> bool {
        cocos2d_CCTexture2D_hasMipmaps(self)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cocos2d_CCTexture2D_CCTexture2D(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
}
extern "C" {
    #[doc = " @js NA"]
    #[doc = " @lua NA"]
    #[link_name = "\u{1}??_DCCTexture2D@cocos2d@@QEAAXXZ"]
    pub fn cocos2d_CCTexture2D_CCTexture2D_destructor(this: *mut cocos2d_CCTexture2D);
}
extern "C" {
    #[link_name = "\u{1}?getPixelFormat@CCTexture2D@cocos2d@@UEAA?AW4CCTexture2DPixelFormat@2@XZ"]
    pub fn cocos2d_CCTexture2D_getPixelFormat(
        this: *mut ::std::os::raw::c_void,
    ) -> cocos2d_CCTexture2DPixelFormat;
}
extern "C" {
    #[link_name = "\u{1}?getPixelsWide@CCTexture2D@cocos2d@@UEAAIXZ"]
    pub fn cocos2d_CCTexture2D_getPixelsWide(
        this: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[link_name = "\u{1}?getPixelsHigh@CCTexture2D@cocos2d@@UEAAIXZ"]
    pub fn cocos2d_CCTexture2D_getPixelsHigh(
        this: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[link_name = "\u{1}?getName@CCTexture2D@cocos2d@@UEAAIXZ"]
    pub fn cocos2d_CCTexture2D_getName(this: *mut ::std::os::raw::c_void) -> GLuint;
}
extern "C" {
    #[link_name = "\u{1}?getMaxS@CCTexture2D@cocos2d@@UEAAMXZ"]
    pub fn cocos2d_CCTexture2D_getMaxS(this: *mut ::std::os::raw::c_void) -> GLfloat;
}
extern "C" {
    #[link_name = "\u{1}?setMaxS@CCTexture2D@cocos2d@@UEAAXM@Z"]
    pub fn cocos2d_CCTexture2D_setMaxS(this: *mut ::std::os::raw::c_void, var: GLfloat);
}
extern "C" {
    #[link_name = "\u{1}?getMaxT@CCTexture2D@cocos2d@@UEAAMXZ"]
    pub fn cocos2d_CCTexture2D_getMaxT(this: *mut ::std::os::raw::c_void) -> GLfloat;
}
extern "C" {
    #[link_name = "\u{1}?setMaxT@CCTexture2D@cocos2d@@UEAAXM@Z"]
    pub fn cocos2d_CCTexture2D_setMaxT(this: *mut ::std::os::raw::c_void, var: GLfloat);
}
extern "C" {
    #[link_name = "\u{1}?getContentSize@CCTexture2D@cocos2d@@UEAA?AVCCSize@2@XZ"]
    pub fn cocos2d_CCTexture2D_getContentSize(this: *mut ::std::os::raw::c_void) -> cocos2d_CCSize;
}
extern "C" {
    #[link_name = "\u{1}?getShaderProgram@CCTexture2D@cocos2d@@UEAAPEAVCCGLProgram@2@XZ"]
    pub fn cocos2d_CCTexture2D_getShaderProgram(
        this: *mut ::std::os::raw::c_void,
    ) -> *mut cocos2d_CCGLProgram;
}
extern "C" {
    #[link_name = "\u{1}?setShaderProgram@CCTexture2D@cocos2d@@UEAAXPEAVCCGLProgram@2@@Z"]
    pub fn cocos2d_CCTexture2D_setShaderProgram(
        this: *mut ::std::os::raw::c_void,
        var: *mut cocos2d_CCGLProgram,
    );
}
#[repr(C)]
pub struct cocos2d_CCRGBAProtocol__bindgen_vtable(::std::os::raw::c_void);
#[doc = " RGBA protocol that affects CCNode's color and opacity"]
#[doc = " @js NA"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cocos2d_CCRGBAProtocol {
    pub vtable_: *const cocos2d_CCRGBAProtocol__bindgen_vtable,
}
#[test]
fn bindgen_test_layout_cocos2d_CCRGBAProtocol() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCRGBAProtocol>(),
        8usize,
        concat!("Size of: ", stringify!(cocos2d_CCRGBAProtocol))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCRGBAProtocol>(),
        8usize,
        concat!("Alignment of ", stringify!(cocos2d_CCRGBAProtocol))
    );
}
#[repr(C)]
pub struct cocos2d_CCBlendProtocol__bindgen_vtable(::std::os::raw::c_void);
#[doc = " Specify the blending function according glBlendFunc"]
#[doc = " Please refer to glBlendFunc in OpenGL ES Manual"]
#[doc = " http://www.khronos.org/opengles/sdk/docs/man/xhtml/glBlendFunc.xml for more details."]
#[doc = " @js NA"]
#[doc = " @lua NA"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cocos2d_CCBlendProtocol {
    pub vtable_: *const cocos2d_CCBlendProtocol__bindgen_vtable,
}
#[test]
fn bindgen_test_layout_cocos2d_CCBlendProtocol() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCBlendProtocol>(),
        8usize,
        concat!("Size of: ", stringify!(cocos2d_CCBlendProtocol))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCBlendProtocol>(),
        8usize,
        concat!("Alignment of ", stringify!(cocos2d_CCBlendProtocol))
    );
}
#[doc = " CCNode objects that uses a CCTexture2D to render the images."]
#[doc = " The texture can have a blending function."]
#[doc = " If the texture has alpha premultiplied the default blending function is:"]
#[doc = "   src=GL_ONE dst= GL_ONE_MINUS_SRC_ALPHA"]
#[doc = " else"]
#[doc = "   src=GL_SRC_ALPHA dst= GL_ONE_MINUS_SRC_ALPHA"]
#[doc = " But you can change the blending function at any time."]
#[doc = " @js NA"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cocos2d_CCTextureProtocol {
    pub _base: cocos2d_CCBlendProtocol,
}
#[test]
fn bindgen_test_layout_cocos2d_CCTextureProtocol() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCTextureProtocol>(),
        8usize,
        concat!("Size of: ", stringify!(cocos2d_CCTextureProtocol))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCTextureProtocol>(),
        8usize,
        concat!("Alignment of ", stringify!(cocos2d_CCTextureProtocol))
    );
}
#[repr(C)]
pub struct cocos2d_CCLabelProtocol__bindgen_vtable(::std::os::raw::c_void);
#[doc = " Common interface for Labels"]
#[doc = " @js NA"]
#[doc = " @lua NA"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cocos2d_CCLabelProtocol {
    pub vtable_: *const cocos2d_CCLabelProtocol__bindgen_vtable,
}
#[test]
fn bindgen_test_layout_cocos2d_CCLabelProtocol() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCLabelProtocol>(),
        8usize,
        concat!("Size of: ", stringify!(cocos2d_CCLabelProtocol))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCLabelProtocol>(),
        8usize,
        concat!("Alignment of ", stringify!(cocos2d_CCLabelProtocol))
    );
}
#[repr(C)]
pub struct cocos2d_CCDirectorDelegate__bindgen_vtable(::std::os::raw::c_void);
#[doc = " OpenGL projection protocol"]
#[doc = " @js NA"]
#[doc = " @lua NA"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cocos2d_CCDirectorDelegate {
    pub vtable_: *const cocos2d_CCDirectorDelegate__bindgen_vtable,
}
#[test]
fn bindgen_test_layout_cocos2d_CCDirectorDelegate() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCDirectorDelegate>(),
        8usize,
        concat!("Size of: ", stringify!(cocos2d_CCDirectorDelegate))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCDirectorDelegate>(),
        8usize,
        concat!("Alignment of ", stringify!(cocos2d_CCDirectorDelegate))
    );
}
pub const kCCNodeTagInvalid: ::std::os::raw::c_int = -1;
#[doc = " @addtogroup base_nodes"]
#[doc = " @{"]
pub type cocos2d__bindgen_ty_5 = ::std::os::raw::c_int;
pub const kCCNodeOnEnter: ::std::os::raw::c_int = 0;
pub const kCCNodeOnExit: ::std::os::raw::c_int = 1;
pub const kCCNodeOnEnterTransitionDidFinish: ::std::os::raw::c_int = 2;
pub const kCCNodeOnExitTransitionDidStart: ::std::os::raw::c_int = 3;
pub const kCCNodeOnCleanup: ::std::os::raw::c_int = 4;
pub type cocos2d__bindgen_ty_6 = ::std::os::raw::c_int;
#[doc = " @brief CCNode is the main element. Anything that gets drawn or contains things that get drawn is a CCNode."]
#[doc = "The most popular CCNodes are: CCScene, CCLayer, CCSprite, CCMenu."]
#[doc = ""]
#[doc = "The main features of a CCNode are:"]
#[doc = "- They can contain other CCNode nodes (addChild, getChildByTag, removeChild, etc)"]
#[doc = "- They can schedule periodic callback (schedule, unschedule, etc)"]
#[doc = "- They can execute actions (runAction, stopAction, etc)"]
#[doc = ""]
#[doc = "Some CCNode nodes provide extra functionality for them or their children."]
#[doc = ""]
#[doc = "Subclassing a CCNode usually means (one/all) of:"]
#[doc = "- overriding init to initialize resources and schedule callbacks"]
#[doc = "- create callbacks to handle the advancement of time"]
#[doc = "- overriding draw to render the node"]
#[doc = ""]
#[doc = "Features of CCNode:"]
#[doc = "- position"]
#[doc = "- scale (x, y)"]
#[doc = "- rotation (in degrees, clockwise)"]
#[doc = "- CCCamera (an interface to gluLookAt )"]
#[doc = "- CCGridBase (to do mesh transformations)"]
#[doc = "- anchor point"]
#[doc = "- size"]
#[doc = "- visible"]
#[doc = "- z-order"]
#[doc = "- openGL z position"]
#[doc = ""]
#[doc = "Default values:"]
#[doc = "- rotation: 0"]
#[doc = "- position: (x=0,y=0)"]
#[doc = "- scale: (x=1,y=1)"]
#[doc = "- contentSize: (x=0,y=0)"]
#[doc = "- anchorPoint: (x=0,y=0)"]
#[doc = ""]
#[doc = "Limitations:"]
#[doc = "- A CCNode is a \"void\" object. It doesn't have a texture"]
#[doc = ""]
#[doc = "Order in transformations with grid disabled"]
#[doc = "-# The node will be translated (position)"]
#[doc = "-# The node will be rotated (rotation)"]
#[doc = "-# The node will be scaled (scale)"]
#[doc = "-# The node will be moved according to the camera values (camera)"]
#[doc = ""]
#[doc = "Order in transformations with grid enabled"]
#[doc = "-# The node will be translated (position)"]
#[doc = "-# The node will be rotated (rotation)"]
#[doc = "-# The node will be scaled (scale)"]
#[doc = "-# The grid will capture the screen"]
#[doc = "-# The node will be moved according to the camera values (camera)"]
#[doc = "-# The grid will render the captured screen"]
#[doc = ""]
#[doc = "Camera:"]
#[doc = "- Each node has a camera. By default it points to the center of the CCNode."]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCNode {
    pub _base: cocos2d_CCObject,
    #[doc = "< rotation angle on x-axis"]
    pub m_fRotationX: f32,
    #[doc = "< rotation angle on y-axis"]
    pub m_fRotationY: f32,
    #[doc = "< scaling factor on x-axis"]
    pub m_fScaleX: f32,
    #[doc = "< scaling factor on y-axis"]
    pub m_fScaleY: f32,
    #[doc = "< OpenGL real Z vertex"]
    pub m_fVertexZ: f32,
    #[doc = "< position of the node"]
    pub m_obPosition: cocos2d_CCPoint,
    #[doc = "< skew angle on x-axis"]
    pub m_fSkewX: f32,
    #[doc = "< skew angle on y-axis"]
    pub m_fSkewY: f32,
    #[doc = "< anchor point in points"]
    pub m_obAnchorPointInPoints: cocos2d_CCPoint,
    #[doc = "< anchor point normalized (NOT in points)"]
    pub m_obAnchorPoint: cocos2d_CCPoint,
    #[doc = "< untransformed size of the node"]
    pub m_obContentSize: cocos2d_CCSize,
    #[doc = "< transform"]
    pub m_sAdditionalTransform: cocos2d_CCAffineTransform,
    #[doc = "< transform"]
    pub m_sTransform: cocos2d_CCAffineTransform,
    #[doc = "< transform"]
    pub m_sInverse: cocos2d_CCAffineTransform,
    #[doc = "< a camera"]
    pub m_pCamera: *mut cocos2d_CCCamera,
    #[doc = "< a grid"]
    pub m_pGrid: *mut cocos2d_CCGridBase,
    #[doc = "< z-order value that affects the draw order"]
    pub m_nZOrder: ::std::os::raw::c_int,
    #[doc = "< array of children nodes"]
    pub m_pChildren: *mut cocos2d_CCArray,
    #[doc = "< weak reference to parent node"]
    pub m_pParent: *mut cocos2d_CCNode,
    #[doc = "< A user assingned void pointer, Can be point to any cpp object"]
    pub m_pUserData: *mut ::std::os::raw::c_void,
    #[doc = "< A user assigned CCObject"]
    pub m_pUserObject: *mut cocos2d_CCObject,
    #[doc = "< OpenGL shader"]
    pub m_pShaderProgram: *mut cocos2d_CCGLProgram,
    #[doc = "< OpenGL servier side state"]
    pub m_eGLServerState: cocos2d_ccGLServerState,
    #[doc = "< used to preserve sequence while sorting children with the same zOrder"]
    pub m_uOrderOfArrival: ::std::os::raw::c_uint,
    #[doc = "< scheduler used to schedule timers and updates"]
    pub m_pScheduler: *mut cocos2d_CCScheduler,
    #[doc = "< a pointer to ActionManager singleton, which is used to handle all the actions"]
    pub m_pActionManager: *mut cocos2d_CCActionManager,
    #[doc = "< is running"]
    pub m_bRunning: bool,
    #[doc = "< transform dirty flag"]
    pub m_bTransformDirty: bool,
    #[doc = "< transform dirty flag"]
    pub m_bInverseDirty: bool,
    #[doc = "< The flag to check whether the additional transform is dirty"]
    pub m_bAdditionalTransformDirty: bool,
    #[doc = "< is this node visible"]
    pub m_bVisible: bool,
    #[doc = "< true if the Anchor Point will be (0,0) when you position the CCNode, false otherwise."]
    #[doc = "< Used by CCLayer and CCScene."]
    pub m_bIgnoreAnchorPointForPosition: bool,
    #[doc = "< children order dirty flag"]
    pub m_bReorderChildDirty: bool,
    #[doc = "< script handler for onEnter() & onExit(), used in Javascript binding and Lua binding."]
    pub m_nScriptHandler: ::std::os::raw::c_int,
    #[doc = "< script handler for update() callback per frame, which is invoked from lua & javascript."]
    pub m_nUpdateScriptHandler: ::std::os::raw::c_int,
    #[doc = "< type of script binding, lua or javascript"]
    pub m_eScriptType: cocos2d_ccScriptType,
    #[doc = "< Dictionary of components"]
    pub m_pComponentContainer: *mut cocos2d_CCComponentContainer,
}
#[test]
fn bindgen_test_layout_cocos2d_CCNode() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCNode>(),
        296usize,
        concat!("Size of: ", stringify!(cocos2d_CCNode))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCNode>(),
        8usize,
        concat!("Alignment of ", stringify!(cocos2d_CCNode))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cocos2d_CCNode>())).m_fRotationX as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCNode),
            "::",
            stringify!(m_fRotationX)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cocos2d_CCNode>())).m_fRotationY as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCNode),
            "::",
            stringify!(m_fRotationY)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cocos2d_CCNode>())).m_fScaleX as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCNode),
            "::",
            stringify!(m_fScaleX)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cocos2d_CCNode>())).m_fScaleY as *const _ as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCNode),
            "::",
            stringify!(m_fScaleY)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cocos2d_CCNode>())).m_fVertexZ as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCNode),
            "::",
            stringify!(m_fVertexZ)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cocos2d_CCNode>())).m_obPosition as *const _ as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCNode),
            "::",
            stringify!(m_obPosition)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cocos2d_CCNode>())).m_fSkewX as *const _ as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCNode),
            "::",
            stringify!(m_fSkewX)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cocos2d_CCNode>())).m_fSkewY as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCNode),
            "::",
            stringify!(m_fSkewY)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cocos2d_CCNode>())).m_obAnchorPointInPoints as *const _ as usize
        },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCNode),
            "::",
            stringify!(m_obAnchorPointInPoints)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cocos2d_CCNode>())).m_obAnchorPoint as *const _ as usize },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCNode),
            "::",
            stringify!(m_obAnchorPoint)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cocos2d_CCNode>())).m_obContentSize as *const _ as usize },
        92usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCNode),
            "::",
            stringify!(m_obContentSize)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cocos2d_CCNode>())).m_sAdditionalTransform as *const _ as usize
        },
        100usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCNode),
            "::",
            stringify!(m_sAdditionalTransform)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cocos2d_CCNode>())).m_sTransform as *const _ as usize },
        124usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCNode),
            "::",
            stringify!(m_sTransform)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cocos2d_CCNode>())).m_sInverse as *const _ as usize },
        148usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCNode),
            "::",
            stringify!(m_sInverse)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cocos2d_CCNode>())).m_pCamera as *const _ as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCNode),
            "::",
            stringify!(m_pCamera)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cocos2d_CCNode>())).m_pGrid as *const _ as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCNode),
            "::",
            stringify!(m_pGrid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cocos2d_CCNode>())).m_nZOrder as *const _ as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCNode),
            "::",
            stringify!(m_nZOrder)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cocos2d_CCNode>())).m_pChildren as *const _ as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCNode),
            "::",
            stringify!(m_pChildren)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cocos2d_CCNode>())).m_pParent as *const _ as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCNode),
            "::",
            stringify!(m_pParent)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cocos2d_CCNode>())).m_pUserData as *const _ as usize },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCNode),
            "::",
            stringify!(m_pUserData)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cocos2d_CCNode>())).m_pUserObject as *const _ as usize },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCNode),
            "::",
            stringify!(m_pUserObject)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cocos2d_CCNode>())).m_pShaderProgram as *const _ as usize },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCNode),
            "::",
            stringify!(m_pShaderProgram)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cocos2d_CCNode>())).m_eGLServerState as *const _ as usize },
        240usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCNode),
            "::",
            stringify!(m_eGLServerState)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cocos2d_CCNode>())).m_uOrderOfArrival as *const _ as usize
        },
        244usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCNode),
            "::",
            stringify!(m_uOrderOfArrival)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cocos2d_CCNode>())).m_pScheduler as *const _ as usize },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCNode),
            "::",
            stringify!(m_pScheduler)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cocos2d_CCNode>())).m_pActionManager as *const _ as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCNode),
            "::",
            stringify!(m_pActionManager)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cocos2d_CCNode>())).m_bRunning as *const _ as usize },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCNode),
            "::",
            stringify!(m_bRunning)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cocos2d_CCNode>())).m_bTransformDirty as *const _ as usize
        },
        265usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCNode),
            "::",
            stringify!(m_bTransformDirty)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cocos2d_CCNode>())).m_bInverseDirty as *const _ as usize },
        266usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCNode),
            "::",
            stringify!(m_bInverseDirty)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cocos2d_CCNode>())).m_bAdditionalTransformDirty as *const _
                as usize
        },
        267usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCNode),
            "::",
            stringify!(m_bAdditionalTransformDirty)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cocos2d_CCNode>())).m_bVisible as *const _ as usize },
        268usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCNode),
            "::",
            stringify!(m_bVisible)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cocos2d_CCNode>())).m_bIgnoreAnchorPointForPosition as *const _
                as usize
        },
        269usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCNode),
            "::",
            stringify!(m_bIgnoreAnchorPointForPosition)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cocos2d_CCNode>())).m_bReorderChildDirty as *const _ as usize
        },
        270usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCNode),
            "::",
            stringify!(m_bReorderChildDirty)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cocos2d_CCNode>())).m_nScriptHandler as *const _ as usize },
        272usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCNode),
            "::",
            stringify!(m_nScriptHandler)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cocos2d_CCNode>())).m_nUpdateScriptHandler as *const _ as usize
        },
        276usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCNode),
            "::",
            stringify!(m_nUpdateScriptHandler)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cocos2d_CCNode>())).m_eScriptType as *const _ as usize },
        280usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCNode),
            "::",
            stringify!(m_eScriptType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cocos2d_CCNode>())).m_pComponentContainer as *const _ as usize
        },
        288usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCNode),
            "::",
            stringify!(m_pComponentContainer)
        )
    );
}
extern "C" {
    #[doc = " Allocates and initializes a node."]
    #[doc = " @return A initialized node which is marked as \"autorelease\"."]
    #[link_name = "\u{1}?create@CCNode@cocos2d@@SAPEAV12@XZ"]
    pub fn cocos2d_CCNode_create() -> *mut cocos2d_CCNode;
}
extern "C" {
    #[doc = " Gets the description string. It makes debugging easier."]
    #[doc = " @return A string terminated with '\\0'"]
    #[doc = " @js NA"]
    #[link_name = "\u{1}?description@CCNode@cocos2d@@QEAAPEBDXZ"]
    pub fn cocos2d_CCNode_description(this: *mut cocos2d_CCNode) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Schedules for lua script."]
    #[doc = " @js NA"]
    #[link_name = "\u{1}?scheduleUpdateWithPriorityLua@CCNode@cocos2d@@QEAAXHH@Z"]
    pub fn cocos2d_CCNode_scheduleUpdateWithPriorityLua(
        this: *mut cocos2d_CCNode,
        nHandler: ::std::os::raw::c_int,
        priority: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " Returns a \"local\" axis aligned bounding box of the node."]
    #[doc = " The returned box is relative only to its parent."]
    #[doc = ""]
    #[doc = " @note This method returns a temporaty variable, so it can't returns const CCRect&"]
    #[doc = " @todo Rename to getBoundingBox() in the future versions."]
    #[doc = ""]
    #[doc = " @return A \"local\" axis aligned boudning box of the node."]
    #[doc = " @js getBoundingBox"]
    #[link_name = "\u{1}?boundingBox@CCNode@cocos2d@@QEAA?AVCCRect@2@XZ"]
    pub fn cocos2d_CCNode_boundingBox(this: *mut cocos2d_CCNode) -> cocos2d_CCRect;
}
extern "C" {
    #[doc = " Executes an action, and returns the action that is executed."]
    #[doc = ""]
    #[doc = " This node becomes the action's target. Refer to CCAction::getTarget()"]
    #[doc = " @warning Actions don't retain their target."]
    #[doc = ""]
    #[doc = " @return An Action pointer"]
    #[link_name = "\u{1}?runAction@CCNode@cocos2d@@QEAAPEAVCCAction@2@PEAV32@@Z"]
    pub fn cocos2d_CCNode_runAction(
        this: *mut cocos2d_CCNode,
        action: *mut cocos2d_CCAction,
    ) -> *mut cocos2d_CCAction;
}
extern "C" {
    #[doc = " Stops and removes all actions from the running action list ."]
    #[link_name = "\u{1}?stopAllActions@CCNode@cocos2d@@QEAAXXZ"]
    pub fn cocos2d_CCNode_stopAllActions(this: *mut cocos2d_CCNode);
}
extern "C" {
    #[doc = " Stops and removes an action from the running action list."]
    #[doc = ""]
    #[doc = " @param An action object to be removed."]
    #[link_name = "\u{1}?stopAction@CCNode@cocos2d@@QEAAXPEAVCCAction@2@@Z"]
    pub fn cocos2d_CCNode_stopAction(this: *mut cocos2d_CCNode, action: *mut cocos2d_CCAction);
}
extern "C" {
    #[doc = " Removes an action from the running action list by its tag."]
    #[doc = ""]
    #[doc = " @param A tag that indicates the action to be removed."]
    #[link_name = "\u{1}?stopActionByTag@CCNode@cocos2d@@QEAAXH@Z"]
    pub fn cocos2d_CCNode_stopActionByTag(this: *mut cocos2d_CCNode, tag: ::std::os::raw::c_int);
}
extern "C" {
    #[doc = " Gets an action from the running action list by its tag."]
    #[doc = ""]
    #[doc = " @see setTag(int), getTag()."]
    #[doc = ""]
    #[doc = " @return The action object with the given tag."]
    #[link_name = "\u{1}?getActionByTag@CCNode@cocos2d@@QEAAPEAVCCAction@2@H@Z"]
    pub fn cocos2d_CCNode_getActionByTag(
        this: *mut cocos2d_CCNode,
        tag: ::std::os::raw::c_int,
    ) -> *mut cocos2d_CCAction;
}
extern "C" {
    #[doc = " Returns the numbers of actions that are running plus the ones that are schedule to run (actions in actionsToAdd and actions arrays)."]
    #[doc = ""]
    #[doc = " Composable actions are counted as 1 action. Example:"]
    #[doc = "    If you are running 1 Sequence of 7 actions, it will return 1."]
    #[doc = "    If you are running 7 Sequences of 2 actions, it will return 7."]
    #[doc = " @todo Rename to getNumberOfRunningActions()"]
    #[doc = ""]
    #[doc = " @return The number of actions that are running plus the ones that are schedule to run"]
    #[link_name = "\u{1}?numberOfRunningActions@CCNode@cocos2d@@QEAAIXZ"]
    pub fn cocos2d_CCNode_numberOfRunningActions(
        this: *mut cocos2d_CCNode,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " Checks whether a selector is scheduled."]
    #[doc = ""]
    #[doc = " @param selector      A function selector"]
    #[doc = " @return Whether the funcion selector is scheduled."]
    #[doc = " @js NA"]
    #[doc = " @lua NA"]
    #[link_name = "\u{1}?isScheduled@CCNode@cocos2d@@QEAA_NP8CCObject@2@EAAXM@Z@Z"]
    pub fn cocos2d_CCNode_isScheduled(
        this: *mut cocos2d_CCNode,
        selector: cocos2d_SEL_SCHEDULE,
    ) -> bool;
}
extern "C" {
    #[doc = " Schedules the \"update\" method."]
    #[doc = ""]
    #[doc = " It will use the order number 0. This method will be called every frame."]
    #[doc = " Scheduled methods with a lower order value will be called before the ones that have a higher order value."]
    #[doc = " Only one \"update\" method could be scheduled per node."]
    #[doc = " @lua NA"]
    #[link_name = "\u{1}?scheduleUpdate@CCNode@cocos2d@@QEAAXXZ"]
    pub fn cocos2d_CCNode_scheduleUpdate(this: *mut cocos2d_CCNode);
}
extern "C" {
    #[doc = " Schedules the \"update\" method with a custom priority."]
    #[doc = ""]
    #[doc = " This selector will be called every frame."]
    #[doc = " Scheduled methods with a lower priority will be called before the ones that have a higher value."]
    #[doc = " Only one \"update\" selector could be scheduled per node (You can't have 2 'update' selectors)."]
    #[doc = " @lua NA"]
    #[link_name = "\u{1}?scheduleUpdateWithPriority@CCNode@cocos2d@@QEAAXH@Z"]
    pub fn cocos2d_CCNode_scheduleUpdateWithPriority(
        this: *mut cocos2d_CCNode,
        priority: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}?unscheduleUpdate@CCNode@cocos2d@@QEAAXXZ"]
    pub fn cocos2d_CCNode_unscheduleUpdate(this: *mut cocos2d_CCNode);
}
extern "C" {
    #[doc = " Schedules a custom selector."]
    #[doc = ""]
    #[doc = " If the selector is already scheduled, then the interval parameter will be updated without scheduling it again."]
    #[doc = " @code"]
    #[doc = " // firstly, implement a schedule function"]
    #[doc = " void MyNode::TickMe(float dt);"]
    #[doc = " // wrap this function into a selector via schedule_selector marco."]
    #[doc = " this->schedule(schedule_selector(MyNode::TickMe), 0, 0, 0);"]
    #[doc = " @endcode"]
    #[doc = ""]
    #[doc = " @param interval  Tick interval in seconds. 0 means tick every frame. If interval = 0, it's recommended to use scheduleUpdate() instead."]
    #[doc = " @param repeat    The selector will be excuted (repeat + 1) times, you can use kCCRepeatForever for tick infinitely."]
    #[doc = " @param delay     The amount of time that the first tick will wait before execution."]
    #[doc = " @lua NA"]
    #[link_name = "\u{1}?schedule@CCNode@cocos2d@@QEAAXP8CCObject@2@EAAXM@ZMIM@Z"]
    pub fn cocos2d_CCNode_schedule(
        this: *mut cocos2d_CCNode,
        selector: cocos2d_SEL_SCHEDULE,
        interval: f32,
        repeat: ::std::os::raw::c_uint,
        delay: f32,
    );
}
extern "C" {
    #[doc = " Schedules a custom selector with an interval time in seconds."]
    #[doc = " @see schedule(SEL_SCHEDULE, float, unsigned int, float)"]
    #[doc = ""]
    #[doc = " @param selector      A function wrapped as a selector"]
    #[doc = " @param interval      Callback interval time in seconds. 0 means tick every frame,"]
    #[doc = " @lua NA"]
    #[link_name = "\u{1}?schedule@CCNode@cocos2d@@QEAAXP8CCObject@2@EAAXM@ZM@Z"]
    pub fn cocos2d_CCNode_schedule1(
        this: *mut cocos2d_CCNode,
        selector: cocos2d_SEL_SCHEDULE,
        interval: f32,
    );
}
extern "C" {
    #[doc = " Schedules a selector that runs only once, with a delay of 0 or larger"]
    #[doc = " @see schedule(SEL_SCHEDULE, float, unsigned int, float)"]
    #[doc = ""]
    #[doc = " @param selector      A function wrapped as a selector"]
    #[doc = " @param delay         The amount of time that the first tick will wait before execution."]
    #[doc = " @lua NA"]
    #[link_name = "\u{1}?scheduleOnce@CCNode@cocos2d@@QEAAXP8CCObject@2@EAAXM@ZM@Z"]
    pub fn cocos2d_CCNode_scheduleOnce(
        this: *mut cocos2d_CCNode,
        selector: cocos2d_SEL_SCHEDULE,
        delay: f32,
    );
}
extern "C" {
    #[doc = " Schedules a custom selector, the scheduled selector will be ticked every frame"]
    #[doc = " @see schedule(SEL_SCHEDULE, float, unsigned int, float)"]
    #[doc = ""]
    #[doc = " @param selector      A function wrapped as a selector"]
    #[doc = " @lua NA"]
    #[link_name = "\u{1}?schedule@CCNode@cocos2d@@QEAAXP8CCObject@2@EAAXM@Z@Z"]
    pub fn cocos2d_CCNode_schedule2(this: *mut cocos2d_CCNode, selector: cocos2d_SEL_SCHEDULE);
}
extern "C" {
    #[doc = " Unschedules a custom selector."]
    #[doc = " @see schedule(SEL_SCHEDULE, float, unsigned int, float)"]
    #[doc = ""]
    #[doc = " @param selector      A function wrapped as a selector"]
    #[doc = " @lua NA"]
    #[link_name = "\u{1}?unschedule@CCNode@cocos2d@@QEAAXP8CCObject@2@EAAXM@Z@Z"]
    pub fn cocos2d_CCNode_unschedule(this: *mut cocos2d_CCNode, selector: cocos2d_SEL_SCHEDULE);
}
extern "C" {
    #[doc = " Unschedule all scheduled selectors: custom selectors, and the 'update' selector."]
    #[doc = " Actions are not affected by this method."]
    #[link_name = "\u{1}?unscheduleAllSelectors@CCNode@cocos2d@@QEAAXXZ"]
    pub fn cocos2d_CCNode_unscheduleAllSelectors(this: *mut cocos2d_CCNode);
}
extern "C" {
    #[doc = " Resumes all scheduled selectors and actions."]
    #[doc = " This method is called internally by onEnter"]
    #[doc = " @js NA"]
    #[doc = " @lua NA"]
    #[link_name = "\u{1}?resumeSchedulerAndActions@CCNode@cocos2d@@QEAAXXZ"]
    pub fn cocos2d_CCNode_resumeSchedulerAndActions(this: *mut cocos2d_CCNode);
}
extern "C" {
    #[doc = " Pauses all scheduled selectors and actions."]
    #[doc = " This method is called internally by onExit"]
    #[doc = " @js NA"]
    #[doc = " @lua NA"]
    #[link_name = "\u{1}?pauseSchedulerAndActions@CCNode@cocos2d@@QEAAXXZ"]
    pub fn cocos2d_CCNode_pauseSchedulerAndActions(this: *mut cocos2d_CCNode);
}
extern "C" {
    #[doc = " Performs OpenGL view-matrix transformation based on position, scale, rotation and other attributes."]
    #[link_name = "\u{1}?transform@CCNode@cocos2d@@QEAAXXZ"]
    pub fn cocos2d_CCNode_transform(this: *mut cocos2d_CCNode);
}
extern "C" {
    #[doc = " Performs OpenGL view-matrix transformation of it's ancestors."]
    #[doc = " Generally the ancestors are already transformed, but in certain cases (eg: attaching a FBO)"]
    #[doc = " It's necessary to transform the ancestors again."]
    #[link_name = "\u{1}?transformAncestors@CCNode@cocos2d@@QEAAXXZ"]
    pub fn cocos2d_CCNode_transformAncestors(this: *mut cocos2d_CCNode);
}
extern "C" {
    #[doc = " Converts a Point to node (local) space coordinates. The result is in Points."]
    #[link_name = "\u{1}?convertToNodeSpace@CCNode@cocos2d@@QEAA?AVCCPoint@2@AEBV32@@Z"]
    pub fn cocos2d_CCNode_convertToNodeSpace(
        this: *mut cocos2d_CCNode,
        worldPoint: *const cocos2d_CCPoint,
    ) -> cocos2d_CCPoint;
}
extern "C" {
    #[doc = " Converts a Point to world space coordinates. The result is in Points."]
    #[link_name = "\u{1}?convertToWorldSpace@CCNode@cocos2d@@QEAA?AVCCPoint@2@AEBV32@@Z"]
    pub fn cocos2d_CCNode_convertToWorldSpace(
        this: *mut cocos2d_CCNode,
        nodePoint: *const cocos2d_CCPoint,
    ) -> cocos2d_CCPoint;
}
extern "C" {
    #[doc = " Converts a Point to node (local) space coordinates. The result is in Points."]
    #[doc = " treating the returned/received node point as anchor relative."]
    #[link_name = "\u{1}?convertToNodeSpaceAR@CCNode@cocos2d@@QEAA?AVCCPoint@2@AEBV32@@Z"]
    pub fn cocos2d_CCNode_convertToNodeSpaceAR(
        this: *mut cocos2d_CCNode,
        worldPoint: *const cocos2d_CCPoint,
    ) -> cocos2d_CCPoint;
}
extern "C" {
    #[doc = " Converts a local Point to world space coordinates.The result is in Points."]
    #[doc = " treating the returned/received node point as anchor relative."]
    #[link_name = "\u{1}?convertToWorldSpaceAR@CCNode@cocos2d@@QEAA?AVCCPoint@2@AEBV32@@Z"]
    pub fn cocos2d_CCNode_convertToWorldSpaceAR(
        this: *mut cocos2d_CCNode,
        nodePoint: *const cocos2d_CCPoint,
    ) -> cocos2d_CCPoint;
}
extern "C" {
    #[doc = " convenience methods which take a CCTouch instead of CCPoint"]
    #[link_name = "\u{1}?convertTouchToNodeSpace@CCNode@cocos2d@@QEAA?AVCCPoint@2@PEAVCCTouch@2@@Z"]
    pub fn cocos2d_CCNode_convertTouchToNodeSpace(
        this: *mut cocos2d_CCNode,
        touch: *mut cocos2d_CCTouch,
    ) -> cocos2d_CCPoint;
}
extern "C" {
    #[doc = " converts a CCTouch (world coordinates) into a local coordinate. This method is AR (Anchor Relative)."]
    #[link_name = "\u{1}?convertTouchToNodeSpaceAR@CCNode@cocos2d@@QEAA?AVCCPoint@2@PEAVCCTouch@2@@Z"]
    pub fn cocos2d_CCNode_convertTouchToNodeSpaceAR(
        this: *mut cocos2d_CCNode,
        touch: *mut cocos2d_CCTouch,
    ) -> cocos2d_CCPoint;
}
extern "C" {
    #[doc = "  Sets the additional transform."]
    #[doc = ""]
    #[doc = "  @note The additional transform will be concatenated at the end of nodeToParentTransform."]
    #[doc = "        It could be used to simulate `parent-child` relationship between two nodes (e.g. one is in BatchNode, another isn't)."]
    #[doc = "  @code"]
    #[doc = "CCSpriteBatchNode* batch= CCSpriteBatchNode::create(\"Icon-114.png\");"]
    #[doc = "this->addChild(batch);"]
    #[doc = ""]
    #[doc = "CCSprite* spriteA = CCSprite::createWithTexture(batch->getTexture());"]
    #[doc = "CCSprite* spriteB = CCSprite::create(\"Icon-72.png\");"]
    #[doc = ""]
    #[doc = "batch->addChild(spriteA);"]
    #[doc = ""]
    #[doc = "this->addChild(spriteB);"]
    #[doc = ""]
    #[doc = "spriteA->setPosition(ccp(200, 200));"]
    #[doc = ""]
    #[doc = "CCAffineTransform t = spriteA->nodeToParentTransform();"]
    #[doc = ""]
    #[doc = "spriteB->setAdditionalTransform(t);"]
    #[doc = ""]
    #[doc = "spriteA->setScale(2);"]
    #[doc = ""]
    #[doc = "t = spriteA->nodeToParentTransform();"]
    #[doc = ""]
    #[doc = "spriteB->setAdditionalTransform(t);"]
    #[doc = ""]
    #[doc = "spriteA->setRotation(20);"]
    #[doc = ""]
    #[doc = "t = spriteA->nodeToParentTransform();"]
    #[doc = ""]
    #[doc = "spriteB->setAdditionalTransform(t);"]
    #[doc = "  @endcode"]
    #[link_name = "\u{1}?setAdditionalTransform@CCNode@cocos2d@@QEAAXAEBUCCAffineTransform@2@@Z"]
    pub fn cocos2d_CCNode_setAdditionalTransform(
        this: *mut cocos2d_CCNode,
        additionalTransform: *const cocos2d_CCAffineTransform,
    );
}
extern "C" {
    #[doc = " @{"]
    #[doc = " @name component functions"]
    #[doc = "**"]
    #[doc = "*   gets a component by its name"]
    #[doc = "*/"]
    #[link_name = "\u{1}?getComponent@CCNode@cocos2d@@QEBAPEAVCCComponent@2@PEBD@Z"]
    pub fn cocos2d_CCNode_getComponent(
        this: *const cocos2d_CCNode,
        pName: *const ::std::os::raw::c_char,
    ) -> *mut cocos2d_CCComponent;
}
extern "C" {
    #[doc = " Default constructor"]
    #[doc = " @js ctor"]
    #[link_name = "\u{1}??0CCNode@cocos2d@@QEAA@XZ"]
    pub fn cocos2d_CCNode_CCNode(this: *mut cocos2d_CCNode);
}
extern "C" {
    #[link_name = "\u{1}??0CCNode@cocos2d@@QEAA@AEBV01@@Z"]
    pub fn cocos2d_CCNode_CCNode1(this: *mut cocos2d_CCNode, arg1: *const cocos2d_CCNode);
}
impl cocos2d_CCNode {
    #[inline]
    pub unsafe fn create() -> *mut cocos2d_CCNode {
        cocos2d_CCNode_create()
    }
    #[inline]
    pub unsafe fn description(&mut self) -> *const ::std::os::raw::c_char {
        cocos2d_CCNode_description(self)
    }
    #[inline]
    pub unsafe fn scheduleUpdateWithPriorityLua(
        &mut self,
        nHandler: ::std::os::raw::c_int,
        priority: ::std::os::raw::c_int,
    ) {
        cocos2d_CCNode_scheduleUpdateWithPriorityLua(self, nHandler, priority)
    }
    #[inline]
    pub unsafe fn boundingBox(&mut self) -> cocos2d_CCRect {
        cocos2d_CCNode_boundingBox(self)
    }
    #[inline]
    pub unsafe fn runAction(&mut self, action: *mut cocos2d_CCAction) -> *mut cocos2d_CCAction {
        cocos2d_CCNode_runAction(self, action)
    }
    #[inline]
    pub unsafe fn stopAllActions(&mut self) {
        cocos2d_CCNode_stopAllActions(self)
    }
    #[inline]
    pub unsafe fn stopAction(&mut self, action: *mut cocos2d_CCAction) {
        cocos2d_CCNode_stopAction(self, action)
    }
    #[inline]
    pub unsafe fn stopActionByTag(&mut self, tag: ::std::os::raw::c_int) {
        cocos2d_CCNode_stopActionByTag(self, tag)
    }
    #[inline]
    pub unsafe fn getActionByTag(&mut self, tag: ::std::os::raw::c_int) -> *mut cocos2d_CCAction {
        cocos2d_CCNode_getActionByTag(self, tag)
    }
    #[inline]
    pub unsafe fn numberOfRunningActions(&mut self) -> ::std::os::raw::c_uint {
        cocos2d_CCNode_numberOfRunningActions(self)
    }
    #[inline]
    pub unsafe fn isScheduled(&mut self, selector: cocos2d_SEL_SCHEDULE) -> bool {
        cocos2d_CCNode_isScheduled(self, selector)
    }
    #[inline]
    pub unsafe fn scheduleUpdate(&mut self) {
        cocos2d_CCNode_scheduleUpdate(self)
    }
    #[inline]
    pub unsafe fn scheduleUpdateWithPriority(&mut self, priority: ::std::os::raw::c_int) {
        cocos2d_CCNode_scheduleUpdateWithPriority(self, priority)
    }
    #[inline]
    pub unsafe fn unscheduleUpdate(&mut self) {
        cocos2d_CCNode_unscheduleUpdate(self)
    }
    #[inline]
    pub unsafe fn schedule(
        &mut self,
        selector: cocos2d_SEL_SCHEDULE,
        interval: f32,
        repeat: ::std::os::raw::c_uint,
        delay: f32,
    ) {
        cocos2d_CCNode_schedule(self, selector, interval, repeat, delay)
    }
    #[inline]
    pub unsafe fn schedule1(&mut self, selector: cocos2d_SEL_SCHEDULE, interval: f32) {
        cocos2d_CCNode_schedule1(self, selector, interval)
    }
    #[inline]
    pub unsafe fn scheduleOnce(&mut self, selector: cocos2d_SEL_SCHEDULE, delay: f32) {
        cocos2d_CCNode_scheduleOnce(self, selector, delay)
    }
    #[inline]
    pub unsafe fn schedule2(&mut self, selector: cocos2d_SEL_SCHEDULE) {
        cocos2d_CCNode_schedule2(self, selector)
    }
    #[inline]
    pub unsafe fn unschedule(&mut self, selector: cocos2d_SEL_SCHEDULE) {
        cocos2d_CCNode_unschedule(self, selector)
    }
    #[inline]
    pub unsafe fn unscheduleAllSelectors(&mut self) {
        cocos2d_CCNode_unscheduleAllSelectors(self)
    }
    #[inline]
    pub unsafe fn resumeSchedulerAndActions(&mut self) {
        cocos2d_CCNode_resumeSchedulerAndActions(self)
    }
    #[inline]
    pub unsafe fn pauseSchedulerAndActions(&mut self) {
        cocos2d_CCNode_pauseSchedulerAndActions(self)
    }
    #[inline]
    pub unsafe fn transform(&mut self) {
        cocos2d_CCNode_transform(self)
    }
    #[inline]
    pub unsafe fn transformAncestors(&mut self) {
        cocos2d_CCNode_transformAncestors(self)
    }
    #[inline]
    pub unsafe fn convertToNodeSpace(
        &mut self,
        worldPoint: *const cocos2d_CCPoint,
    ) -> cocos2d_CCPoint {
        cocos2d_CCNode_convertToNodeSpace(self, worldPoint)
    }
    #[inline]
    pub unsafe fn convertToWorldSpace(
        &mut self,
        nodePoint: *const cocos2d_CCPoint,
    ) -> cocos2d_CCPoint {
        cocos2d_CCNode_convertToWorldSpace(self, nodePoint)
    }
    #[inline]
    pub unsafe fn convertToNodeSpaceAR(
        &mut self,
        worldPoint: *const cocos2d_CCPoint,
    ) -> cocos2d_CCPoint {
        cocos2d_CCNode_convertToNodeSpaceAR(self, worldPoint)
    }
    #[inline]
    pub unsafe fn convertToWorldSpaceAR(
        &mut self,
        nodePoint: *const cocos2d_CCPoint,
    ) -> cocos2d_CCPoint {
        cocos2d_CCNode_convertToWorldSpaceAR(self, nodePoint)
    }
    #[inline]
    pub unsafe fn convertTouchToNodeSpace(
        &mut self,
        touch: *mut cocos2d_CCTouch,
    ) -> cocos2d_CCPoint {
        cocos2d_CCNode_convertTouchToNodeSpace(self, touch)
    }
    #[inline]
    pub unsafe fn convertTouchToNodeSpaceAR(
        &mut self,
        touch: *mut cocos2d_CCTouch,
    ) -> cocos2d_CCPoint {
        cocos2d_CCNode_convertTouchToNodeSpaceAR(self, touch)
    }
    #[inline]
    pub unsafe fn setAdditionalTransform(
        &mut self,
        additionalTransform: *const cocos2d_CCAffineTransform,
    ) {
        cocos2d_CCNode_setAdditionalTransform(self, additionalTransform)
    }
    #[inline]
    pub unsafe fn getComponent(
        &self,
        pName: *const ::std::os::raw::c_char,
    ) -> *mut cocos2d_CCComponent {
        cocos2d_CCNode_getComponent(self, pName)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cocos2d_CCNode_CCNode(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new1(arg1: *const cocos2d_CCNode) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cocos2d_CCNode_CCNode1(__bindgen_tmp.as_mut_ptr(), arg1);
        __bindgen_tmp.assume_init()
    }
}
extern "C" {
    #[doc = " Default destructor"]
    #[doc = " @js NA"]
    #[doc = " @lua NA"]
    #[link_name = "\u{1}??_DCCNode@cocos2d@@QEAAXXZ"]
    pub fn cocos2d_CCNode_CCNode_destructor(this: *mut cocos2d_CCNode);
}
extern "C" {
    #[doc = "  Initializes the instance of CCNode"]
    #[doc = "  @return Whether the initialization was successful."]
    #[link_name = "\u{1}?init@CCNode@cocos2d@@UEAA_NXZ"]
    pub fn cocos2d_CCNode_init(this: *mut ::std::os::raw::c_void) -> bool;
}
extern "C" {
    #[doc = " Sets the Z order which stands for the drawing order, and reorder this node in its parent's children array."]
    #[doc = ""]
    #[doc = " The Z order of node is relative to its \"brothers\": children of the same parent."]
    #[doc = " It's nothing to do with OpenGL's z vertex. This one only affects the draw order of nodes in cocos2d."]
    #[doc = " The larger number it is, the later this node will be drawn in each message loop."]
    #[doc = " Please refer to setVertexZ(float) for the difference."]
    #[doc = ""]
    #[doc = " @param nZOrder   Z order of this node."]
    #[link_name = "\u{1}?setZOrder@CCNode@cocos2d@@UEAAXH@Z"]
    pub fn cocos2d_CCNode_setZOrder(
        this: *mut ::std::os::raw::c_void,
        zOrder: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " Sets the z order which stands for the drawing order"]
    #[doc = ""]
    #[doc = " This is an internal method. Don't call it outside the framework."]
    #[doc = " The difference between setZOrder(int) and _setOrder(int) is:"]
    #[doc = " - _setZOrder(int) is a pure setter for m_nZOrder memeber variable"]
    #[doc = " - setZOrder(int) firstly changes m_nZOrder, then recorder this node in its parent's chilren array."]
    #[link_name = "\u{1}?_setZOrder@CCNode@cocos2d@@UEAAXH@Z"]
    pub fn cocos2d_CCNode__setZOrder(this: *mut ::std::os::raw::c_void, z: ::std::os::raw::c_int);
}
extern "C" {
    #[doc = " Gets the Z order of this node."]
    #[doc = ""]
    #[doc = " @see setZOrder(int)"]
    #[doc = ""]
    #[doc = " @return The Z order."]
    #[link_name = "\u{1}?getZOrder@CCNode@cocos2d@@UEAAHXZ"]
    pub fn cocos2d_CCNode_getZOrder(this: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Sets the real OpenGL Z vertex."]
    #[doc = ""]
    #[doc = " Differences between openGL Z vertex and cocos2d Z order:"]
    #[doc = " - OpenGL Z modifies the Z vertex, and not the Z order in the relation between parent-children"]
    #[doc = " - OpenGL Z might require to set 2D projection"]
    #[doc = " - cocos2d Z order works OK if all the nodes uses the same openGL Z vertex. eg: vertexZ = 0"]
    #[doc = ""]
    #[doc = " @warning Use it at your own risk since it might break the cocos2d parent-children z order"]
    #[doc = ""]
    #[doc = " @param fVertexZ  OpenGL Z vertex of this node."]
    #[link_name = "\u{1}?setVertexZ@CCNode@cocos2d@@UEAAXM@Z"]
    pub fn cocos2d_CCNode_setVertexZ(this: *mut ::std::os::raw::c_void, vertexZ: f32);
}
extern "C" {
    #[doc = " Gets OpenGL Z vertex of this node."]
    #[doc = ""]
    #[doc = " @see setVertexZ(float)"]
    #[doc = ""]
    #[doc = " @return OpenGL Z vertex of this node"]
    #[link_name = "\u{1}?getVertexZ@CCNode@cocos2d@@UEAAMXZ"]
    pub fn cocos2d_CCNode_getVertexZ(this: *mut ::std::os::raw::c_void) -> f32;
}
extern "C" {
    #[doc = " Changes the scale factor on X axis of this node"]
    #[doc = ""]
    #[doc = " The deafult value is 1.0 if you haven't changed it before"]
    #[doc = ""]
    #[doc = " @param fScaleX   The scale factor on X axis."]
    #[link_name = "\u{1}?setScaleX@CCNode@cocos2d@@UEAAXM@Z"]
    pub fn cocos2d_CCNode_setScaleX(this: *mut ::std::os::raw::c_void, fScaleX: f32);
}
extern "C" {
    #[doc = " Returns the scale factor on X axis of this node"]
    #[doc = ""]
    #[doc = " @see setScaleX(float)"]
    #[doc = ""]
    #[doc = " @return The scale factor on X axis."]
    #[link_name = "\u{1}?getScaleX@CCNode@cocos2d@@UEAAMXZ"]
    pub fn cocos2d_CCNode_getScaleX(this: *mut ::std::os::raw::c_void) -> f32;
}
extern "C" {
    #[doc = " Changes the scale factor on Y axis of this node"]
    #[doc = ""]
    #[doc = " The Default value is 1.0 if you haven't changed it before."]
    #[doc = ""]
    #[doc = " @param fScaleY   The scale factor on Y axis."]
    #[link_name = "\u{1}?setScaleY@CCNode@cocos2d@@UEAAXM@Z"]
    pub fn cocos2d_CCNode_setScaleY(this: *mut ::std::os::raw::c_void, fScaleY: f32);
}
extern "C" {
    #[doc = " Returns the scale factor on Y axis of this node"]
    #[doc = ""]
    #[doc = " @see setScaleY(float)"]
    #[doc = ""]
    #[doc = " @return The scale factor on Y axis."]
    #[link_name = "\u{1}?getScaleY@CCNode@cocos2d@@UEAAMXZ"]
    pub fn cocos2d_CCNode_getScaleY(this: *mut ::std::os::raw::c_void) -> f32;
}
extern "C" {
    #[doc = " Changes both X and Y scale factor of the node."]
    #[doc = ""]
    #[doc = " 1.0 is the default scale factor. It modifies the X and Y scale at the same time."]
    #[doc = ""]
    #[doc = " @param scale     The scale factor for both X and Y axis."]
    #[link_name = "\u{1}?setScale@CCNode@cocos2d@@UEAAXM@Z"]
    pub fn cocos2d_CCNode_setScale(this: *mut ::std::os::raw::c_void, scale: f32);
}
extern "C" {
    #[doc = " Gets the scale factor of the node,  when X and Y have the same scale factor."]
    #[doc = ""]
    #[doc = " @warning Assert when m_fScaleX != m_fScaleY."]
    #[doc = " @see setScale(float)"]
    #[doc = ""]
    #[doc = " @return The scale factor of the node."]
    #[link_name = "\u{1}?getScale@CCNode@cocos2d@@UEAAMXZ"]
    pub fn cocos2d_CCNode_getScale(this: *mut ::std::os::raw::c_void) -> f32;
}
extern "C" {
    #[doc = " Changes both X and Y scale factor of the node."]
    #[doc = ""]
    #[doc = " 1.0 is the default scale factor. It modifies the X and Y scale at the same time."]
    #[doc = ""]
    #[doc = " @param fScaleX     The scale factor on X axis."]
    #[doc = " @param fScaleY     The scale factor on Y axis."]
    #[link_name = "\u{1}?setScale@CCNode@cocos2d@@UEAAXMM@Z"]
    pub fn cocos2d_CCNode_setScale1(this: *mut ::std::os::raw::c_void, fScaleX: f32, fScaleY: f32);
}
extern "C" {
    #[doc = " Changes the position (x,y) of the node in OpenGL coordinates"]
    #[doc = ""]
    #[doc = " Usually we use ccp(x,y) to compose CCPoint object."]
    #[doc = " The original point (0,0) is at the left-bottom corner of screen."]
    #[doc = " For example, this codesnip sets the node in the center of screen."]
    #[doc = " @code"]
    #[doc = " CCSize size = CCDirector::sharedDirector()->getWinSize();"]
    #[doc = " node->setPosition( ccp(size.width/2, size.height/2) )"]
    #[doc = " @endcode"]
    #[doc = ""]
    #[doc = " @param position  The position (x,y) of the node in OpenGL coordinates"]
    #[doc = " @js NA"]
    #[link_name = "\u{1}?setPosition@CCNode@cocos2d@@UEAAXAEBVCCPoint@2@@Z"]
    pub fn cocos2d_CCNode_setPosition(
        this: *mut ::std::os::raw::c_void,
        position: *const cocos2d_CCPoint,
    );
}
extern "C" {
    #[doc = " Gets the position (x,y) of the node in OpenGL coordinates"]
    #[doc = ""]
    #[doc = " @see setPosition(const CCPoint&)"]
    #[doc = ""]
    #[doc = " @return The position (x,y) of the node in OpenGL coordinates"]
    #[link_name = "\u{1}?getPosition@CCNode@cocos2d@@UEAAAEBVCCPoint@2@XZ"]
    pub fn cocos2d_CCNode_getPosition(this: *mut ::std::os::raw::c_void) -> *const cocos2d_CCPoint;
}
extern "C" {
    #[doc = " Sets position in a more efficient way."]
    #[doc = ""]
    #[doc = " Passing two numbers (x,y) is much efficient than passing CCPoint object."]
    #[doc = " This method is binded to lua and javascript."]
    #[doc = " Passing a number is 10 times faster than passing a object from lua to c++"]
    #[doc = ""]
    #[doc = " @code"]
    #[doc = " // sample code in lua"]
    #[doc = " local pos  = node::getPosition()  -- returns CCPoint object from C++"]
    #[doc = " node:setPosition(x, y)            -- pass x, y coordinate to C++"]
    #[doc = " @endcode"]
    #[doc = ""]
    #[doc = " @param x     X coordinate for position"]
    #[doc = " @param y     Y coordinate for position"]
    #[doc = " @js NA"]
    #[link_name = "\u{1}?setPosition@CCNode@cocos2d@@UEAAXMM@Z"]
    pub fn cocos2d_CCNode_setPosition1(this: *mut ::std::os::raw::c_void, x: f32, y: f32);
}
extern "C" {
    #[doc = " Gets position in a more efficient way, returns two number instead of a CCPoint object"]
    #[doc = ""]
    #[doc = " @see setPosition(float, float)"]
    #[link_name = "\u{1}?getPosition@CCNode@cocos2d@@UEAAXPEAM0@Z"]
    pub fn cocos2d_CCNode_getPosition1(this: *mut ::std::os::raw::c_void, x: *mut f32, y: *mut f32);
}
extern "C" {
    #[doc = " Gets/Sets x or y coordinate individually for position."]
    #[doc = " These methods are used in Lua and Javascript Bindings"]
    #[link_name = "\u{1}?setPositionX@CCNode@cocos2d@@UEAAXM@Z"]
    pub fn cocos2d_CCNode_setPositionX(this: *mut ::std::os::raw::c_void, x: f32);
}
extern "C" {
    #[link_name = "\u{1}?getPositionX@CCNode@cocos2d@@UEAAMXZ"]
    pub fn cocos2d_CCNode_getPositionX(this: *mut ::std::os::raw::c_void) -> f32;
}
extern "C" {
    #[link_name = "\u{1}?setPositionY@CCNode@cocos2d@@UEAAXM@Z"]
    pub fn cocos2d_CCNode_setPositionY(this: *mut ::std::os::raw::c_void, y: f32);
}
extern "C" {
    #[link_name = "\u{1}?getPositionY@CCNode@cocos2d@@UEAAMXZ"]
    pub fn cocos2d_CCNode_getPositionY(this: *mut ::std::os::raw::c_void) -> f32;
}
extern "C" {
    #[doc = " Changes the X skew angle of the node in degrees."]
    #[doc = ""]
    #[doc = " This angle describes the shear distortion in the X direction."]
    #[doc = " Thus, it is the angle between the Y axis and the left edge of the shape"]
    #[doc = " The default skewX angle is 0. Positive values distort the node in a CW direction."]
    #[doc = ""]
    #[doc = " @param fSkewX The X skew angle of the node in degrees."]
    #[link_name = "\u{1}?setSkewX@CCNode@cocos2d@@UEAAXM@Z"]
    pub fn cocos2d_CCNode_setSkewX(this: *mut ::std::os::raw::c_void, fSkewX: f32);
}
extern "C" {
    #[doc = " Returns the X skew angle of the node in degrees."]
    #[doc = ""]
    #[doc = " @see setSkewX(float)"]
    #[doc = ""]
    #[doc = " @return The X skew angle of the node in degrees."]
    #[link_name = "\u{1}?getSkewX@CCNode@cocos2d@@UEAAMXZ"]
    pub fn cocos2d_CCNode_getSkewX(this: *mut ::std::os::raw::c_void) -> f32;
}
extern "C" {
    #[doc = " Changes the Y skew angle of the node in degrees."]
    #[doc = ""]
    #[doc = " This angle describes the shear distortion in the Y direction."]
    #[doc = " Thus, it is the angle between the X axis and the bottom edge of the shape"]
    #[doc = " The default skewY angle is 0. Positive values distort the node in a CCW direction."]
    #[doc = ""]
    #[doc = " @param fSkewY    The Y skew angle of the node in degrees."]
    #[link_name = "\u{1}?setSkewY@CCNode@cocos2d@@UEAAXM@Z"]
    pub fn cocos2d_CCNode_setSkewY(this: *mut ::std::os::raw::c_void, fSkewY: f32);
}
extern "C" {
    #[doc = " Returns the Y skew angle of the node in degrees."]
    #[doc = ""]
    #[doc = " @see setSkewY(float)"]
    #[doc = ""]
    #[doc = " @return The Y skew angle of the node in degrees."]
    #[link_name = "\u{1}?getSkewY@CCNode@cocos2d@@UEAAMXZ"]
    pub fn cocos2d_CCNode_getSkewY(this: *mut ::std::os::raw::c_void) -> f32;
}
extern "C" {
    #[doc = " Sets the anchor point in percent."]
    #[doc = ""]
    #[doc = " anchorPoint is the point around which all transformations and positioning manipulations take place."]
    #[doc = " It's like a pin in the node where it is \"attached\" to its parent."]
    #[doc = " The anchorPoint is normalized, like a percentage. (0,0) means the bottom-left corner and (1,1) means the top-right corner."]
    #[doc = " But you can use values higher than (1,1) and lower than (0,0) too."]
    #[doc = " The default anchorPoint is (0.5,0.5), so it starts in the center of the node."]
    #[doc = ""]
    #[doc = " @param anchorPoint   The anchor point of node."]
    #[link_name = "\u{1}?setAnchorPoint@CCNode@cocos2d@@UEAAXAEBVCCPoint@2@@Z"]
    pub fn cocos2d_CCNode_setAnchorPoint(
        this: *mut ::std::os::raw::c_void,
        anchorPoint: *const cocos2d_CCPoint,
    );
}
extern "C" {
    #[doc = " Returns the anchor point in percent."]
    #[doc = ""]
    #[doc = " @see setAnchorPoint(const CCPoint&)"]
    #[doc = ""]
    #[doc = " @return The anchor point of node."]
    #[link_name = "\u{1}?getAnchorPoint@CCNode@cocos2d@@UEAAAEBVCCPoint@2@XZ"]
    pub fn cocos2d_CCNode_getAnchorPoint(
        this: *mut ::std::os::raw::c_void,
    ) -> *const cocos2d_CCPoint;
}
extern "C" {
    #[doc = " Returns the anchorPoint in absolute pixels."]
    #[doc = ""]
    #[doc = " @warning You can only read it. If you wish to modify it, use anchorPoint instead."]
    #[doc = " @see getAnchorPoint()"]
    #[doc = ""]
    #[doc = " @return The anchor point in absolute pixels."]
    #[link_name = "\u{1}?getAnchorPointInPoints@CCNode@cocos2d@@UEAAAEBVCCPoint@2@XZ"]
    pub fn cocos2d_CCNode_getAnchorPointInPoints(
        this: *mut ::std::os::raw::c_void,
    ) -> *const cocos2d_CCPoint;
}
extern "C" {
    #[doc = " Sets the untransformed size of the node."]
    #[doc = ""]
    #[doc = " The contentSize remains the same no matter the node is scaled or rotated."]
    #[doc = " All nodes has a size. Layer and Scene has the same size of the screen."]
    #[doc = ""]
    #[doc = " @param contentSize   The untransformed size of the node."]
    #[link_name = "\u{1}?setContentSize@CCNode@cocos2d@@UEAAXAEBVCCSize@2@@Z"]
    pub fn cocos2d_CCNode_setContentSize(
        this: *mut ::std::os::raw::c_void,
        contentSize: *const cocos2d_CCSize,
    );
}
extern "C" {
    #[doc = " Returns the untransformed size of the node."]
    #[doc = ""]
    #[doc = " @see setContentSize(const CCSize&)"]
    #[doc = ""]
    #[doc = " @return The untransformed size of the node."]
    #[link_name = "\u{1}?getContentSize@CCNode@cocos2d@@UEBAAEBVCCSize@2@XZ"]
    pub fn cocos2d_CCNode_getContentSize(
        this: *mut ::std::os::raw::c_void,
    ) -> *const cocos2d_CCSize;
}
extern "C" {
    #[link_name = "\u{1}?getScaledContentSize@CCNode@cocos2d@@UEAA?AVCCSize@2@XZ"]
    pub fn cocos2d_CCNode_getScaledContentSize(this: *mut ::std::os::raw::c_void)
        -> cocos2d_CCSize;
}
extern "C" {
    #[doc = " Sets whether the node is visible"]
    #[doc = ""]
    #[doc = " The default value is true, a node is default to visible"]
    #[doc = ""]
    #[doc = " @param visible   true if the node is visible, false if the node is hidden."]
    #[link_name = "\u{1}?setVisible@CCNode@cocos2d@@UEAAX_N@Z"]
    pub fn cocos2d_CCNode_setVisible(this: *mut ::std::os::raw::c_void, visible: bool);
}
extern "C" {
    #[doc = " Determines if the node is visible"]
    #[doc = ""]
    #[doc = " @see setVisible(bool)"]
    #[doc = ""]
    #[doc = " @return true if the node is visible, false if the node is hidden."]
    #[link_name = "\u{1}?isVisible@CCNode@cocos2d@@UEAA_NXZ"]
    pub fn cocos2d_CCNode_isVisible(this: *mut ::std::os::raw::c_void) -> bool;
}
extern "C" {
    #[doc = " Sets the rotation (angle) of the node in degrees."]
    #[doc = ""]
    #[doc = " 0 is the default rotation angle."]
    #[doc = " Positive values rotate node clockwise, and negative values for anti-clockwise."]
    #[doc = ""]
    #[doc = " @param fRotation     The roration of the node in degrees."]
    #[link_name = "\u{1}?setRotation@CCNode@cocos2d@@UEAAXM@Z"]
    pub fn cocos2d_CCNode_setRotation(this: *mut ::std::os::raw::c_void, fRotation: f32);
}
extern "C" {
    #[doc = " Returns the rotation of the node in degrees."]
    #[doc = ""]
    #[doc = " @see setRotation(float)"]
    #[doc = ""]
    #[doc = " @return The rotation of the node in degrees."]
    #[link_name = "\u{1}?getRotation@CCNode@cocos2d@@UEAAMXZ"]
    pub fn cocos2d_CCNode_getRotation(this: *mut ::std::os::raw::c_void) -> f32;
}
extern "C" {
    #[doc = " Sets the X rotation (angle) of the node in degrees which performs a horizontal rotational skew."]
    #[doc = ""]
    #[doc = " 0 is the default rotation angle."]
    #[doc = " Positive values rotate node clockwise, and negative values for anti-clockwise."]
    #[doc = ""]
    #[doc = " @param fRotationX    The X rotation in degrees which performs a horizontal rotational skew."]
    #[link_name = "\u{1}?setRotationX@CCNode@cocos2d@@UEAAXM@Z"]
    pub fn cocos2d_CCNode_setRotationX(this: *mut ::std::os::raw::c_void, fRotaionX: f32);
}
extern "C" {
    #[doc = " Gets the X rotation (angle) of the node in degrees which performs a horizontal rotation skew."]
    #[doc = ""]
    #[doc = " @see setRotationX(float)"]
    #[doc = ""]
    #[doc = " @return The X rotation in degrees."]
    #[link_name = "\u{1}?getRotationX@CCNode@cocos2d@@UEAAMXZ"]
    pub fn cocos2d_CCNode_getRotationX(this: *mut ::std::os::raw::c_void) -> f32;
}
extern "C" {
    #[doc = " Sets the Y rotation (angle) of the node in degrees which performs a vertical rotational skew."]
    #[doc = ""]
    #[doc = " 0 is the default rotation angle."]
    #[doc = " Positive values rotate node clockwise, and negative values for anti-clockwise."]
    #[doc = ""]
    #[doc = " @param fRotationY    The Y rotation in degrees."]
    #[link_name = "\u{1}?setRotationY@CCNode@cocos2d@@UEAAXM@Z"]
    pub fn cocos2d_CCNode_setRotationY(this: *mut ::std::os::raw::c_void, fRotationY: f32);
}
extern "C" {
    #[doc = " Gets the Y rotation (angle) of the node in degrees which performs a vertical rotational skew."]
    #[doc = ""]
    #[doc = " @see setRotationY(float)"]
    #[doc = ""]
    #[doc = " @return The Y rotation in degrees."]
    #[link_name = "\u{1}?getRotationY@CCNode@cocos2d@@UEAAMXZ"]
    pub fn cocos2d_CCNode_getRotationY(this: *mut ::std::os::raw::c_void) -> f32;
}
extern "C" {
    #[doc = " Sets the arrival order when this node has a same ZOrder with other children."]
    #[doc = ""]
    #[doc = " A node which called addChild subsequently will take a larger arrival order,"]
    #[doc = " If two children have the same Z order, the child with larger arrival order will be drawn later."]
    #[doc = ""]
    #[doc = " @warning This method is used internally for zOrder sorting, don't change this manually"]
    #[doc = ""]
    #[doc = " @param uOrderOfArrival   The arrival order."]
    #[link_name = "\u{1}?setOrderOfArrival@CCNode@cocos2d@@UEAAXI@Z"]
    pub fn cocos2d_CCNode_setOrderOfArrival(
        this: *mut ::std::os::raw::c_void,
        uOrderOfArrival: ::std::os::raw::c_uint,
    );
}
extern "C" {
    #[doc = " Returns the arrival order, indecates which children is added previously."]
    #[doc = ""]
    #[doc = " @see setOrderOfArrival(unsigned int)"]
    #[doc = ""]
    #[doc = " @return The arrival order."]
    #[link_name = "\u{1}?getOrderOfArrival@CCNode@cocos2d@@UEAAIXZ"]
    pub fn cocos2d_CCNode_getOrderOfArrival(
        this: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " Sets the state of OpenGL server side."]
    #[doc = ""]
    #[doc = " @param glServerState     The state of OpenGL server side."]
    #[doc = " @js NA"]
    #[link_name = "\u{1}?setGLServerState@CCNode@cocos2d@@UEAAXW4ccGLServerState@2@@Z"]
    pub fn cocos2d_CCNode_setGLServerState(
        this: *mut ::std::os::raw::c_void,
        glServerState: cocos2d_ccGLServerState,
    );
}
extern "C" {
    #[doc = " Returns the state of OpenGL server side."]
    #[doc = ""]
    #[doc = " @return The state of OpenGL server side."]
    #[doc = " @js NA"]
    #[link_name = "\u{1}?getGLServerState@CCNode@cocos2d@@UEAA?AW4ccGLServerState@2@XZ"]
    pub fn cocos2d_CCNode_getGLServerState(
        this: *mut ::std::os::raw::c_void,
    ) -> cocos2d_ccGLServerState;
}
extern "C" {
    #[doc = " Sets whether the anchor point will be (0,0) when you position this node."]
    #[doc = ""]
    #[doc = " This is an internal method, only used by CCLayer and CCScene. Don't call it outside framework."]
    #[doc = " The default value is false, while in CCLayer and CCScene are true"]
    #[doc = ""]
    #[doc = " @param ignore    true if anchor point will be (0,0) when you position this node"]
    #[doc = " @todo This method shoud be renamed as setIgnoreAnchorPointForPosition(bool) or something with \"set\""]
    #[link_name = "\u{1}?ignoreAnchorPointForPosition@CCNode@cocos2d@@UEAAX_N@Z"]
    pub fn cocos2d_CCNode_ignoreAnchorPointForPosition(
        this: *mut ::std::os::raw::c_void,
        ignore: bool,
    );
}
extern "C" {
    #[doc = " Gets whether the anchor point will be (0,0) when you position this node."]
    #[doc = ""]
    #[doc = " @see ignoreAnchorPointForPosition(bool)"]
    #[doc = ""]
    #[doc = " @return true if the anchor point will be (0,0) when you position this node."]
    #[link_name = "\u{1}?isIgnoreAnchorPointForPosition@CCNode@cocos2d@@UEAA_NXZ"]
    pub fn cocos2d_CCNode_isIgnoreAnchorPointForPosition(this: *mut ::std::os::raw::c_void)
        -> bool;
}
extern "C" {
    #[doc = " Adds a child to the container with z-order as 0."]
    #[doc = ""]
    #[doc = " If the child is added to a 'running' node, then 'onEnter' and 'onEnterTransitionDidFinish' will be called immediately."]
    #[doc = ""]
    #[doc = " @param child A child node"]
    #[link_name = "\u{1}?addChild@CCNode@cocos2d@@UEAAXPEAV12@@Z"]
    pub fn cocos2d_CCNode_addChild(this: *mut ::std::os::raw::c_void, child: *mut cocos2d_CCNode);
}
extern "C" {
    #[doc = " Adds a child to the container with a z-order"]
    #[doc = ""]
    #[doc = " If the child is added to a 'running' node, then 'onEnter' and 'onEnterTransitionDidFinish' will be called immediately."]
    #[doc = ""]
    #[doc = " @param child     A child node"]
    #[doc = " @param zOrder    Z order for drawing priority. Please refer to setZOrder(int)"]
    #[link_name = "\u{1}?addChild@CCNode@cocos2d@@UEAAXPEAV12@H@Z"]
    pub fn cocos2d_CCNode_addChild1(
        this: *mut ::std::os::raw::c_void,
        child: *mut cocos2d_CCNode,
        zOrder: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " Adds a child to the container with z order and tag"]
    #[doc = ""]
    #[doc = " If the child is added to a 'running' node, then 'onEnter' and 'onEnterTransitionDidFinish' will be called immediately."]
    #[doc = ""]
    #[doc = " @param child     A child node"]
    #[doc = " @param zOrder    Z order for drawing priority. Please refer to setZOrder(int)"]
    #[doc = " @param tag       A interger to identify the node easily. Please refer to setTag(int)"]
    #[link_name = "\u{1}?addChild@CCNode@cocos2d@@UEAAXPEAV12@HH@Z"]
    pub fn cocos2d_CCNode_addChild2(
        this: *mut ::std::os::raw::c_void,
        child: *mut cocos2d_CCNode,
        zOrder: ::std::os::raw::c_int,
        tag: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " Gets a child from the container with its tag"]
    #[doc = ""]
    #[doc = " @param tag   An identifier to find the child node."]
    #[doc = ""]
    #[doc = " @return a CCNode object whose tag equals to the input parameter"]
    #[link_name = "\u{1}?getChildByTag@CCNode@cocos2d@@UEAAPEAV12@H@Z"]
    pub fn cocos2d_CCNode_getChildByTag(
        this: *mut ::std::os::raw::c_void,
        tag: ::std::os::raw::c_int,
    ) -> *mut cocos2d_CCNode;
}
extern "C" {
    #[doc = " Return an array of children"]
    #[doc = ""]
    #[doc = " Composing a \"tree\" structure is a very important feature of CCNode"]
    #[doc = " Here's a sample code of traversing children array:"]
    #[doc = " @code"]
    #[doc = " CCNode* node = NULL;"]
    #[doc = " CCARRAY_FOREACH(parent->getChildren(), node)"]
    #[doc = " {"]
    #[doc = "     node->setPosition(0,0);"]
    #[doc = " }"]
    #[doc = " @endcode"]
    #[doc = " This sample code traverses all children nodes, and set theie position to (0,0)"]
    #[doc = ""]
    #[doc = " @return An array of children"]
    #[link_name = "\u{1}?getChildren@CCNode@cocos2d@@UEAAPEAVCCArray@2@XZ"]
    pub fn cocos2d_CCNode_getChildren(this: *mut ::std::os::raw::c_void) -> *mut cocos2d_CCArray;
}
extern "C" {
    #[doc = " Get the amount of children."]
    #[doc = ""]
    #[doc = " @return The amount of children."]
    #[link_name = "\u{1}?getChildrenCount@CCNode@cocos2d@@UEBAIXZ"]
    pub fn cocos2d_CCNode_getChildrenCount(
        this: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " Sets the parent node"]
    #[doc = ""]
    #[doc = " @param parent    A pointer to the parnet node"]
    #[link_name = "\u{1}?setParent@CCNode@cocos2d@@UEAAXPEAV12@@Z"]
    pub fn cocos2d_CCNode_setParent(this: *mut ::std::os::raw::c_void, parent: *mut cocos2d_CCNode);
}
extern "C" {
    #[doc = " Returns a pointer to the parent node"]
    #[doc = ""]
    #[doc = " @see setParent(CCNode*)"]
    #[doc = ""]
    #[doc = " @returns A pointer to the parnet node"]
    #[link_name = "\u{1}?getParent@CCNode@cocos2d@@UEAAPEAV12@XZ"]
    pub fn cocos2d_CCNode_getParent(this: *mut ::std::os::raw::c_void) -> *mut cocos2d_CCNode;
}
extern "C" {
    #[doc = " Removes this node itself from its parent node with a cleanup."]
    #[doc = " If the node orphan, then nothing happens."]
    #[doc = " @see removeFromParentAndCleanup(bool)"]
    #[link_name = "\u{1}?removeFromParent@CCNode@cocos2d@@UEAAXXZ"]
    pub fn cocos2d_CCNode_removeFromParent(this: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[doc = " Removes this node itself from its parent node."]
    #[doc = " If the node orphan, then nothing happens."]
    #[doc = " @param cleanup   true if all actions and callbacks on this node should be removed, false otherwise."]
    #[doc = " @js removeFromParent"]
    #[link_name = "\u{1}?removeFromParentAndCleanup@CCNode@cocos2d@@UEAAX_N@Z"]
    pub fn cocos2d_CCNode_removeFromParentAndCleanup(
        this: *mut ::std::os::raw::c_void,
        cleanup: bool,
    );
}
extern "C" {
    #[link_name = "\u{1}?removeMeAndCleanup@CCNode@cocos2d@@UEAAXXZ"]
    pub fn cocos2d_CCNode_removeMeAndCleanup(this: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[doc = " Removes a child from the container with a cleanup"]
    #[doc = ""]
    #[doc = " @see removeChild(CCNode, bool)"]
    #[doc = ""]
    #[doc = " @param child     The child node which will be removed."]
    #[link_name = "\u{1}?removeChild@CCNode@cocos2d@@UEAAXPEAV12@@Z"]
    pub fn cocos2d_CCNode_removeChild(
        this: *mut ::std::os::raw::c_void,
        child: *mut cocos2d_CCNode,
    );
}
extern "C" {
    #[doc = " Removes a child from the container. It will also cleanup all running actions depending on the cleanup parameter."]
    #[doc = ""]
    #[doc = " @param child     The child node which will be removed."]
    #[doc = " @param cleanup   true if all running actions and callbacks on the child node will be cleanup, false otherwise."]
    #[link_name = "\u{1}?removeChild@CCNode@cocos2d@@UEAAXPEAV12@_N@Z"]
    pub fn cocos2d_CCNode_removeChild1(
        this: *mut ::std::os::raw::c_void,
        child: *mut cocos2d_CCNode,
        cleanup: bool,
    );
}
extern "C" {
    #[doc = " Removes a child from the container by tag value with a cleanup."]
    #[doc = ""]
    #[doc = " @see removeChildByTag(int, bool)"]
    #[doc = ""]
    #[doc = " @param tag       An interger number that identifies a child node"]
    #[link_name = "\u{1}?removeChildByTag@CCNode@cocos2d@@UEAAXH@Z"]
    pub fn cocos2d_CCNode_removeChildByTag(
        this: *mut ::std::os::raw::c_void,
        tag: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " Removes a child from the container by tag value. It will also cleanup all running actions depending on the cleanup parameter"]
    #[doc = ""]
    #[doc = " @param tag       An interger number that identifies a child node"]
    #[doc = " @param cleanup   true if all running actions and callbacks on the child node will be cleanup, false otherwise."]
    #[link_name = "\u{1}?removeChildByTag@CCNode@cocos2d@@UEAAXH_N@Z"]
    pub fn cocos2d_CCNode_removeChildByTag1(
        this: *mut ::std::os::raw::c_void,
        tag: ::std::os::raw::c_int,
        cleanup: bool,
    );
}
extern "C" {
    #[doc = " Removes all children from the container with a cleanup."]
    #[doc = ""]
    #[doc = " @see removeAllChildrenWithCleanup(bool)"]
    #[link_name = "\u{1}?removeAllChildren@CCNode@cocos2d@@UEAAXXZ"]
    pub fn cocos2d_CCNode_removeAllChildren(this: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[doc = " Removes all children from the container, and do a cleanup to all running actions depending on the cleanup parameter."]
    #[doc = ""]
    #[doc = " @param cleanup   true if all running actions on all children nodes should be cleanup, false oterwise."]
    #[doc = " @js removeAllChildren"]
    #[link_name = "\u{1}?removeAllChildrenWithCleanup@CCNode@cocos2d@@UEAAX_N@Z"]
    pub fn cocos2d_CCNode_removeAllChildrenWithCleanup(
        this: *mut ::std::os::raw::c_void,
        cleanup: bool,
    );
}
extern "C" {
    #[doc = " Reorders a child according to a new z value."]
    #[doc = ""]
    #[doc = " @param child     An already added child node. It MUST be already added."]
    #[doc = " @param zOrder    Z order for drawing priority. Please refer to setZOrder(int)"]
    #[link_name = "\u{1}?reorderChild@CCNode@cocos2d@@UEAAXPEAV12@H@Z"]
    pub fn cocos2d_CCNode_reorderChild(
        this: *mut ::std::os::raw::c_void,
        child: *mut cocos2d_CCNode,
        zOrder: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " Sorts the children array once before drawing, instead of every time when a child is added or reordered."]
    #[doc = " This appraoch can improves the performance massively."]
    #[doc = " @note Don't call this manually unless a child added needs to be removed in the same frame"]
    #[link_name = "\u{1}?sortAllChildren@CCNode@cocos2d@@UEAAXXZ"]
    pub fn cocos2d_CCNode_sortAllChildren(this: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[doc = " Returns a grid object that is used when applying effects"]
    #[doc = ""]
    #[doc = " @return A CCGrid object that is used when applying effects"]
    #[doc = " @js NA"]
    #[link_name = "\u{1}?getGrid@CCNode@cocos2d@@UEAAPEAVCCGridBase@2@XZ"]
    pub fn cocos2d_CCNode_getGrid(this: *mut ::std::os::raw::c_void) -> *mut cocos2d_CCGridBase;
}
extern "C" {
    #[doc = " Changes a grid object that is used when applying effects"]
    #[doc = ""]
    #[doc = " @param A CCGrid object that is used when applying effects"]
    #[link_name = "\u{1}?setGrid@CCNode@cocos2d@@UEAAXPEAVCCGridBase@2@@Z"]
    pub fn cocos2d_CCNode_setGrid(
        this: *mut ::std::os::raw::c_void,
        pGrid: *mut cocos2d_CCGridBase,
    );
}
extern "C" {
    #[doc = " Returns a custom user data pointer"]
    #[doc = ""]
    #[doc = " You can set everything in UserData pointer, a data block, a structure or an object."]
    #[doc = ""]
    #[doc = " @return A custom user data pointer"]
    #[doc = " @js NA"]
    #[link_name = "\u{1}?getUserData@CCNode@cocos2d@@UEAAPEAXXZ"]
    pub fn cocos2d_CCNode_getUserData(
        this: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " Sets a custom user data pointer"]
    #[doc = ""]
    #[doc = " You can set everything in UserData pointer, a data block, a structure or an object, etc."]
    #[doc = " @warning Don't forget to release the memroy manually,"]
    #[doc = "          especially before you change this data pointer, and before this node is autoreleased."]
    #[doc = ""]
    #[doc = " @return A custom user data pointer"]
    #[doc = " @js NA"]
    #[link_name = "\u{1}?setUserData@CCNode@cocos2d@@UEAAXPEAX@Z"]
    pub fn cocos2d_CCNode_setUserData(
        this: *mut ::std::os::raw::c_void,
        pUserData: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    #[doc = " Returns a user assigned CCObject"]
    #[doc = ""]
    #[doc = " Similar to userData, but instead of holding a void* it holds an object"]
    #[doc = ""]
    #[doc = " @return A user assigned CCObject"]
    #[doc = " @js NA"]
    #[link_name = "\u{1}?getUserObject@CCNode@cocos2d@@UEAAPEAVCCObject@2@XZ"]
    pub fn cocos2d_CCNode_getUserObject(this: *mut ::std::os::raw::c_void)
        -> *mut cocos2d_CCObject;
}
extern "C" {
    #[doc = " Returns a user assigned CCObject"]
    #[doc = ""]
    #[doc = " Similar to UserData, but instead of holding a void* it holds an object."]
    #[doc = " The UserObject will be retained once in this method,"]
    #[doc = " and the previous UserObject (if existed) will be relese."]
    #[doc = " The UserObject will be released in CCNode's destructure."]
    #[doc = ""]
    #[doc = " @param A user assigned CCObject"]
    #[link_name = "\u{1}?setUserObject@CCNode@cocos2d@@UEAAXPEAVCCObject@2@@Z"]
    pub fn cocos2d_CCNode_setUserObject(
        this: *mut ::std::os::raw::c_void,
        pUserObject: *mut cocos2d_CCObject,
    );
}
extern "C" {
    #[doc = " @{"]
    #[doc = " @name Shader Program"]
    #[doc = "**"]
    #[doc = "* Return the shader program currently used for this node"]
    #[doc = "*"]
    #[doc = "* @return The shader program currelty used for this node"]
    #[doc = "*/"]
    #[link_name = "\u{1}?getShaderProgram@CCNode@cocos2d@@UEAAPEAVCCGLProgram@2@XZ"]
    pub fn cocos2d_CCNode_getShaderProgram(
        this: *mut ::std::os::raw::c_void,
    ) -> *mut cocos2d_CCGLProgram;
}
extern "C" {
    #[doc = " Sets the shader program for this node"]
    #[doc = ""]
    #[doc = " Since v2.0, each rendering node must set its shader program."]
    #[doc = " It should be set in initialize phase."]
    #[doc = " @code"]
    #[doc = " node->setShaderProgram(CCShaderCache::sharedShaderCache()->programForKey(kCCShader_PositionTextureColor));"]
    #[doc = " @endcode"]
    #[doc = ""]
    #[doc = " @param The shader program which fetchs from CCShaderCache."]
    #[link_name = "\u{1}?setShaderProgram@CCNode@cocos2d@@UEAAXPEAVCCGLProgram@2@@Z"]
    pub fn cocos2d_CCNode_setShaderProgram(
        this: *mut ::std::os::raw::c_void,
        pShaderProgram: *mut cocos2d_CCGLProgram,
    );
}
extern "C" {
    #[doc = " Returns a camera object that lets you move the node using a gluLookAt"]
    #[doc = ""]
    #[doc = " @code"]
    #[doc = " CCCamera* camera = node->getCamera();"]
    #[doc = " camera->setEyeXYZ(0, 0, 415/2);"]
    #[doc = " camera->setCenterXYZ(0, 0, 0);"]
    #[doc = " @endcode"]
    #[doc = ""]
    #[doc = " @return A CCCamera object that lets you move the node using a gluLookAt"]
    #[link_name = "\u{1}?getCamera@CCNode@cocos2d@@UEAAPEAVCCCamera@2@XZ"]
    pub fn cocos2d_CCNode_getCamera(this: *mut ::std::os::raw::c_void) -> *mut cocos2d_CCCamera;
}
extern "C" {
    #[doc = " Returns whether or not the node accepts event callbacks."]
    #[doc = ""]
    #[doc = " Running means the node accept event callbacks like onEnter(), onExit(), update()"]
    #[doc = ""]
    #[doc = " @return Whether or not the node is running."]
    #[link_name = "\u{1}?isRunning@CCNode@cocos2d@@UEAA_NXZ"]
    pub fn cocos2d_CCNode_isRunning(this: *mut ::std::os::raw::c_void) -> bool;
}
extern "C" {
    #[doc = " Registers a script function that will be called in onEnter() & onExit() seires functions."]
    #[doc = ""]
    #[doc = " This handler will be removed automatically after onExit() called."]
    #[doc = " @code"]
    #[doc = " -- lua sample"]
    #[doc = " local function sceneEventHandler(eventType)"]
    #[doc = "     if eventType == kCCNodeOnEnter then"]
    #[doc = "         -- do something"]
    #[doc = "     elseif evetType == kCCNodeOnExit then"]
    #[doc = "         -- do something"]
    #[doc = "     end"]
    #[doc = " end"]
    #[doc = " scene::registerScriptHandler(sceneEventHandler)"]
    #[doc = " @endcode"]
    #[doc = ""]
    #[doc = " @warning This method is for internal usage, don't call it manually."]
    #[doc = " @todo Perhaps we should rename it to get/set/removeScriptHandler acoording to the function name style."]
    #[doc = ""]
    #[doc = " @param handler   A number that indicates a lua function."]
    #[link_name = "\u{1}?registerScriptHandler@CCNode@cocos2d@@UEAAXH@Z"]
    pub fn cocos2d_CCNode_registerScriptHandler(
        this: *mut ::std::os::raw::c_void,
        handler: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " Unregisters a script function that will be called in onEnter() & onExit() series functions."]
    #[doc = ""]
    #[doc = " @see registerScriptHandler(int)"]
    #[link_name = "\u{1}?unregisterScriptHandler@CCNode@cocos2d@@UEAAXXZ"]
    pub fn cocos2d_CCNode_unregisterScriptHandler(this: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[doc = " Event callback that is invoked every time when CCNode enters the 'stage'."]
    #[doc = " If the CCNode enters the 'stage' with a transition, this event is called when the transition starts."]
    #[doc = " During onEnter you can't access a \"sister/brother\" node."]
    #[doc = " If you override onEnter, you shall call its parent's one, e.g., CCNode::onEnter()."]
    #[doc = " @js NA"]
    #[doc = " @lua NA"]
    #[link_name = "\u{1}?onEnter@CCNode@cocos2d@@UEAAXXZ"]
    pub fn cocos2d_CCNode_onEnter(this: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[doc = " Event callback that is invoked when the CCNode enters in the 'stage'."]
    #[doc = " If the CCNode enters the 'stage' with a transition, this event is called when the transition finishes."]
    #[doc = " If you override onEnterTransitionDidFinish, you shall call its parent's one, e.g. CCNode::onEnterTransitionDidFinish()"]
    #[doc = " @js NA"]
    #[doc = " @lua NA"]
    #[link_name = "\u{1}?onEnterTransitionDidFinish@CCNode@cocos2d@@UEAAXXZ"]
    pub fn cocos2d_CCNode_onEnterTransitionDidFinish(this: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[doc = " Event callback that is invoked every time the CCNode leaves the 'stage'."]
    #[doc = " If the CCNode leaves the 'stage' with a transition, this event is called when the transition finishes."]
    #[doc = " During onExit you can't access a sibling node."]
    #[doc = " If you override onExit, you shall call its parent's one, e.g., CCNode::onExit()."]
    #[doc = " @js NA"]
    #[doc = " @lua NA"]
    #[link_name = "\u{1}?onExit@CCNode@cocos2d@@UEAAXXZ"]
    pub fn cocos2d_CCNode_onExit(this: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[doc = " Event callback that is called every time the CCNode leaves the 'stage'."]
    #[doc = " If the CCNode leaves the 'stage' with a transition, this callback is called when the transition starts."]
    #[doc = " @js NA"]
    #[doc = " @lua NA"]
    #[link_name = "\u{1}?onExitTransitionDidStart@CCNode@cocos2d@@UEAAXXZ"]
    pub fn cocos2d_CCNode_onExitTransitionDidStart(this: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[doc = " Stops all running actions and schedulers"]
    #[link_name = "\u{1}?cleanup@CCNode@cocos2d@@UEAAXXZ"]
    pub fn cocos2d_CCNode_cleanup(this: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[doc = " Override this method to draw your own node."]
    #[doc = " The following GL states will be enabled by default:"]
    #[doc = " - glEnableClientState(GL_VERTEX_ARRAY);"]
    #[doc = " - glEnableClientState(GL_COLOR_ARRAY);"]
    #[doc = " - glEnableClientState(GL_TEXTURE_COORD_ARRAY);"]
    #[doc = " - glEnable(GL_TEXTURE_2D);"]
    #[doc = " AND YOU SHOULD NOT DISABLE THEM AFTER DRAWING YOUR NODE"]
    #[doc = " But if you enable any other GL state, you should disable it after drawing your node."]
    #[link_name = "\u{1}?draw@CCNode@cocos2d@@UEAAXXZ"]
    pub fn cocos2d_CCNode_draw(this: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[doc = " Visits this node's children and draw them recursively."]
    #[link_name = "\u{1}?visit@CCNode@cocos2d@@UEAAXXZ"]
    pub fn cocos2d_CCNode_visit(this: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[doc = " Sets the CCActionManager object that is used by all actions."]
    #[doc = ""]
    #[doc = " @warning If you set a new CCActionManager, then previously created actions will be removed."]
    #[doc = ""]
    #[doc = " @param actionManager     A CCActionManager object that is used by all actions."]
    #[link_name = "\u{1}?setActionManager@CCNode@cocos2d@@UEAAXPEAVCCActionManager@2@@Z"]
    pub fn cocos2d_CCNode_setActionManager(
        this: *mut ::std::os::raw::c_void,
        actionManager: *mut cocos2d_CCActionManager,
    );
}
extern "C" {
    #[doc = " Gets the CCActionManager object that is used by all actions."]
    #[doc = " @see setActionManager(CCActionManager*)"]
    #[doc = " @return A CCActionManager object."]
    #[link_name = "\u{1}?getActionManager@CCNode@cocos2d@@UEAAPEAVCCActionManager@2@XZ"]
    pub fn cocos2d_CCNode_getActionManager(
        this: *mut ::std::os::raw::c_void,
    ) -> *mut cocos2d_CCActionManager;
}
extern "C" {
    #[doc = " Sets a CCScheduler object that is used to schedule all \"updates\" and timers."]
    #[doc = ""]
    #[doc = " @warning If you set a new CCScheduler, then previously created timers/update are going to be removed."]
    #[doc = " @param scheduler     A CCShdeduler object that is used to schedule all \"update\" and timers."]
    #[doc = " @js NA"]
    #[link_name = "\u{1}?setScheduler@CCNode@cocos2d@@UEAAXPEAVCCScheduler@2@@Z"]
    pub fn cocos2d_CCNode_setScheduler(
        this: *mut ::std::os::raw::c_void,
        scheduler: *mut cocos2d_CCScheduler,
    );
}
extern "C" {
    #[doc = " Gets a CCSheduler object."]
    #[doc = ""]
    #[doc = " @see setScheduler(CCScheduler*)"]
    #[doc = " @return A CCScheduler object."]
    #[doc = " @js NA"]
    #[link_name = "\u{1}?getScheduler@CCNode@cocos2d@@UEAAPEAVCCScheduler@2@XZ"]
    pub fn cocos2d_CCNode_getScheduler(
        this: *mut ::std::os::raw::c_void,
    ) -> *mut cocos2d_CCScheduler;
}
extern "C" {
    #[link_name = "\u{1}?update@CCNode@cocos2d@@UEAAXM@Z"]
    pub fn cocos2d_CCNode_update(this: *mut ::std::os::raw::c_void, delta: f32);
}
extern "C" {
    #[doc = " Calls children's updateTransform() method recursively."]
    #[doc = ""]
    #[doc = " This method is moved from CCSprite, so it's no longer specific to CCSprite."]
    #[doc = " As the result, you apply CCSpriteBatchNode's optimization on your customed CCNode."]
    #[doc = " e.g., batchNode->addChild(myCustomNode), while you can only addChild(sprite) before."]
    #[link_name = "\u{1}?updateTransform@CCNode@cocos2d@@UEAAXXZ"]
    pub fn cocos2d_CCNode_updateTransform(this: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[link_name = "\u{1}?nodeToParentTransform@CCNode@cocos2d@@UEAA?BUCCAffineTransform@2@XZ"]
    pub fn cocos2d_CCNode_nodeToParentTransform(
        this: *mut ::std::os::raw::c_void,
    ) -> cocos2d_CCAffineTransform;
}
extern "C" {
    #[link_name = "\u{1}?parentToNodeTransform@CCNode@cocos2d@@UEAA?BUCCAffineTransform@2@XZ"]
    pub fn cocos2d_CCNode_parentToNodeTransform(
        this: *mut ::std::os::raw::c_void,
    ) -> cocos2d_CCAffineTransform;
}
extern "C" {
    #[doc = " Returns the world affine transform matrix. The matrix is in Pixels."]
    #[link_name = "\u{1}?nodeToWorldTransform@CCNode@cocos2d@@UEAA?AUCCAffineTransform@2@XZ"]
    pub fn cocos2d_CCNode_nodeToWorldTransform(
        this: *mut ::std::os::raw::c_void,
    ) -> cocos2d_CCAffineTransform;
}
extern "C" {
    #[doc = " Returns the inverse world affine transform matrix. The matrix is in Pixels."]
    #[link_name = "\u{1}?worldToNodeTransform@CCNode@cocos2d@@UEAA?AUCCAffineTransform@2@XZ"]
    pub fn cocos2d_CCNode_worldToNodeTransform(
        this: *mut ::std::os::raw::c_void,
    ) -> cocos2d_CCAffineTransform;
}
extern "C" {
    #[doc = "   adds a component"]
    #[link_name = "\u{1}?addComponent@CCNode@cocos2d@@UEAA_NPEAVCCComponent@2@@Z"]
    pub fn cocos2d_CCNode_addComponent(
        this: *mut ::std::os::raw::c_void,
        pComponent: *mut cocos2d_CCComponent,
    ) -> bool;
}
extern "C" {
    #[doc = "   removes a component by its name"]
    #[link_name = "\u{1}?removeComponent@CCNode@cocos2d@@UEAA_NPEBD@Z"]
    pub fn cocos2d_CCNode_removeComponent(
        this: *mut ::std::os::raw::c_void,
        pName: *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    #[doc = "   removes a component by its pointer"]
    #[link_name = "\u{1}?removeComponent@CCNode@cocos2d@@UEAA_NPEAVCCComponent@2@@Z"]
    pub fn cocos2d_CCNode_removeComponent1(
        this: *mut ::std::os::raw::c_void,
        pComponent: *mut cocos2d_CCComponent,
    ) -> bool;
}
extern "C" {
    #[doc = "   removes all components"]
    #[link_name = "\u{1}?removeAllComponents@CCNode@cocos2d@@UEAAXXZ"]
    pub fn cocos2d_CCNode_removeAllComponents(this: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[link_name = "\u{1}?updateTweenAction@CCNode@cocos2d@@UEAAXMPEBD@Z"]
    pub fn cocos2d_CCNode_updateTweenAction(
        this: *mut ::std::os::raw::c_void,
        arg1: f32,
        arg2: *const ::std::os::raw::c_char,
    );
}
#[doc = " CCNodeRGBA is a subclass of CCNode that implements the CCRGBAProtocol protocol."]
#[doc = ""]
#[doc = "All features from CCNode are valid, plus the following new features:"]
#[doc = "- opacity"]
#[doc = "- RGB colors"]
#[doc = ""]
#[doc = "Opacity/Color propagates into children that conform to the CCRGBAProtocol if cascadeOpacity/cascadeColor is enabled."]
#[doc = "@since v2.1"]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCNodeRGBA {
    pub _base: cocos2d_CCNode,
    pub _base_1: cocos2d_CCRGBAProtocol,
    pub _displayedOpacity: GLubyte,
    pub _realOpacity: GLubyte,
    pub _displayedColor: cocos2d_ccColor3B,
    pub _realColor: cocos2d_ccColor3B,
    pub _cascadeColorEnabled: bool,
    pub _cascadeOpacityEnabled: bool,
}
#[test]
fn bindgen_test_layout_cocos2d_CCNodeRGBA() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCNodeRGBA>(),
        320usize,
        concat!("Size of: ", stringify!(cocos2d_CCNodeRGBA))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCNodeRGBA>(),
        8usize,
        concat!("Alignment of ", stringify!(cocos2d_CCNodeRGBA))
    );
}
extern "C" {
    #[doc = " Allocates and initializes a nodergba."]
    #[doc = " @return A initialized node which is marked as \"autorelease\"."]
    #[link_name = "\u{1}?create@CCNodeRGBA@cocos2d@@SAPEAV12@XZ"]
    pub fn cocos2d_CCNodeRGBA_create() -> *mut cocos2d_CCNodeRGBA;
}
extern "C" {
    #[doc = "  @js ctor"]
    #[link_name = "\u{1}??0CCNodeRGBA@cocos2d@@QEAA@XZ"]
    pub fn cocos2d_CCNodeRGBA_CCNodeRGBA(this: *mut cocos2d_CCNodeRGBA);
}
impl cocos2d_CCNodeRGBA {
    #[inline]
    pub unsafe fn create() -> *mut cocos2d_CCNodeRGBA {
        cocos2d_CCNodeRGBA_create()
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cocos2d_CCNodeRGBA_CCNodeRGBA(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
}
extern "C" {
    #[doc = "  @js NA"]
    #[doc = "  @lua NA"]
    #[link_name = "\u{1}??_DCCNodeRGBA@cocos2d@@QEAAXXZ"]
    pub fn cocos2d_CCNodeRGBA_CCNodeRGBA_destructor(this: *mut cocos2d_CCNodeRGBA);
}
extern "C" {
    #[link_name = "\u{1}?init@CCNodeRGBA@cocos2d@@UEAA_NXZ"]
    pub fn cocos2d_CCNodeRGBA_init(this: *mut ::std::os::raw::c_void) -> bool;
}
extern "C" {
    #[link_name = "\u{1}?getOpacity@CCNodeRGBA@cocos2d@@UEAAEXZ"]
    pub fn cocos2d_CCNodeRGBA_getOpacity(this: *mut ::std::os::raw::c_void) -> GLubyte;
}
extern "C" {
    #[link_name = "\u{1}?getDisplayedOpacity@CCNodeRGBA@cocos2d@@UEAAEXZ"]
    pub fn cocos2d_CCNodeRGBA_getDisplayedOpacity(this: *mut ::std::os::raw::c_void) -> GLubyte;
}
extern "C" {
    #[link_name = "\u{1}?setOpacity@CCNodeRGBA@cocos2d@@UEAAXE@Z"]
    pub fn cocos2d_CCNodeRGBA_setOpacity(this: *mut ::std::os::raw::c_void, opacity: GLubyte);
}
extern "C" {
    #[link_name = "\u{1}?updateDisplayedOpacity@CCNodeRGBA@cocos2d@@UEAAXE@Z"]
    pub fn cocos2d_CCNodeRGBA_updateDisplayedOpacity(
        this: *mut ::std::os::raw::c_void,
        parentOpacity: GLubyte,
    );
}
extern "C" {
    #[link_name = "\u{1}?isCascadeOpacityEnabled@CCNodeRGBA@cocos2d@@UEAA_NXZ"]
    pub fn cocos2d_CCNodeRGBA_isCascadeOpacityEnabled(this: *mut ::std::os::raw::c_void) -> bool;
}
extern "C" {
    #[link_name = "\u{1}?setCascadeOpacityEnabled@CCNodeRGBA@cocos2d@@UEAAX_N@Z"]
    pub fn cocos2d_CCNodeRGBA_setCascadeOpacityEnabled(
        this: *mut ::std::os::raw::c_void,
        cascadeOpacityEnabled: bool,
    );
}
extern "C" {
    #[link_name = "\u{1}?getColor@CCNodeRGBA@cocos2d@@UEAAAEBU_ccColor3B@2@XZ"]
    pub fn cocos2d_CCNodeRGBA_getColor(
        this: *mut ::std::os::raw::c_void,
    ) -> *const cocos2d_ccColor3B;
}
extern "C" {
    #[link_name = "\u{1}?getDisplayedColor@CCNodeRGBA@cocos2d@@UEAAAEBU_ccColor3B@2@XZ"]
    pub fn cocos2d_CCNodeRGBA_getDisplayedColor(
        this: *mut ::std::os::raw::c_void,
    ) -> *const cocos2d_ccColor3B;
}
extern "C" {
    #[link_name = "\u{1}?setColor@CCNodeRGBA@cocos2d@@UEAAXAEBU_ccColor3B@2@@Z"]
    pub fn cocos2d_CCNodeRGBA_setColor(
        this: *mut ::std::os::raw::c_void,
        color: *const cocos2d_ccColor3B,
    );
}
extern "C" {
    #[link_name = "\u{1}?updateDisplayedColor@CCNodeRGBA@cocos2d@@UEAAXAEBU_ccColor3B@2@@Z"]
    pub fn cocos2d_CCNodeRGBA_updateDisplayedColor(
        this: *mut ::std::os::raw::c_void,
        parentColor: *const cocos2d_ccColor3B,
    );
}
extern "C" {
    #[link_name = "\u{1}?isCascadeColorEnabled@CCNodeRGBA@cocos2d@@UEAA_NXZ"]
    pub fn cocos2d_CCNodeRGBA_isCascadeColorEnabled(this: *mut ::std::os::raw::c_void) -> bool;
}
extern "C" {
    #[link_name = "\u{1}?setCascadeColorEnabled@CCNodeRGBA@cocos2d@@UEAAX_N@Z"]
    pub fn cocos2d_CCNodeRGBA_setCascadeColorEnabled(
        this: *mut ::std::os::raw::c_void,
        cascadeColorEnabled: bool,
    );
}
#[doc = " @brief A CCSpriteFrame has:"]
#[doc = "- texture: A CCTexture2D that will be used by the CCSprite"]
#[doc = "- rectangle: A rectangle of the texture"]
#[doc = ""]
#[doc = ""]
#[doc = "You can modify the frame of a CCSprite by doing:"]
#[doc = ""]
#[doc = "CCSpriteFrame *frame = CCSpriteFrame::frameWithTexture(texture, rect, offset);"]
#[doc = "sprite->setDisplayFrame(frame);"]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCSpriteFrame {
    pub _base: cocos2d_CCObject,
    pub m_obOffset: cocos2d_CCPoint,
    pub m_obOriginalSize: cocos2d_CCSize,
    pub m_obRectInPixels: cocos2d_CCRect,
    pub m_bRotated: bool,
    pub m_obRect: cocos2d_CCRect,
    pub m_obOffsetInPixels: cocos2d_CCPoint,
    pub m_obOriginalSizeInPixels: cocos2d_CCSize,
    pub m_pobTexture: *mut cocos2d_CCTexture2D,
    pub m_strTextureFilename: std_string,
}
#[test]
fn bindgen_test_layout_cocos2d_CCSpriteFrame() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCSpriteFrame>(),
        152usize,
        concat!("Size of: ", stringify!(cocos2d_CCSpriteFrame))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCSpriteFrame>(),
        8usize,
        concat!("Alignment of ", stringify!(cocos2d_CCSpriteFrame))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cocos2d_CCSpriteFrame>())).m_obOffset as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCSpriteFrame),
            "::",
            stringify!(m_obOffset)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cocos2d_CCSpriteFrame>())).m_obOriginalSize as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCSpriteFrame),
            "::",
            stringify!(m_obOriginalSize)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cocos2d_CCSpriteFrame>())).m_obRectInPixels as *const _ as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCSpriteFrame),
            "::",
            stringify!(m_obRectInPixels)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cocos2d_CCSpriteFrame>())).m_bRotated as *const _ as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCSpriteFrame),
            "::",
            stringify!(m_bRotated)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cocos2d_CCSpriteFrame>())).m_obRect as *const _ as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCSpriteFrame),
            "::",
            stringify!(m_obRect)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cocos2d_CCSpriteFrame>())).m_obOffsetInPixels as *const _
                as usize
        },
        92usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCSpriteFrame),
            "::",
            stringify!(m_obOffsetInPixels)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cocos2d_CCSpriteFrame>())).m_obOriginalSizeInPixels as *const _
                as usize
        },
        100usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCSpriteFrame),
            "::",
            stringify!(m_obOriginalSizeInPixels)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cocos2d_CCSpriteFrame>())).m_pobTexture as *const _ as usize
        },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCSpriteFrame),
            "::",
            stringify!(m_pobTexture)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cocos2d_CCSpriteFrame>())).m_strTextureFilename as *const _
                as usize
        },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCSpriteFrame),
            "::",
            stringify!(m_strTextureFilename)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}?setRectInPixels@CCSpriteFrame@cocos2d@@QEAAXAEBVCCRect@2@@Z"]
    pub fn cocos2d_CCSpriteFrame_setRectInPixels(
        this: *mut cocos2d_CCSpriteFrame,
        rectInPixels: *const cocos2d_CCRect,
    );
}
extern "C" {
    #[doc = " set rect of the frame"]
    #[link_name = "\u{1}?setRect@CCSpriteFrame@cocos2d@@QEAAXAEBVCCRect@2@@Z"]
    pub fn cocos2d_CCSpriteFrame_setRect(
        this: *mut cocos2d_CCSpriteFrame,
        rect: *const cocos2d_CCRect,
    );
}
extern "C" {
    #[doc = " get offset of the frame"]
    #[link_name = "\u{1}?getOffsetInPixels@CCSpriteFrame@cocos2d@@QEAAAEBVCCPoint@2@XZ"]
    pub fn cocos2d_CCSpriteFrame_getOffsetInPixels(
        this: *mut cocos2d_CCSpriteFrame,
    ) -> *const cocos2d_CCPoint;
}
extern "C" {
    #[doc = " set offset of the frame"]
    #[link_name = "\u{1}?setOffsetInPixels@CCSpriteFrame@cocos2d@@QEAAXAEBVCCPoint@2@@Z"]
    pub fn cocos2d_CCSpriteFrame_setOffsetInPixels(
        this: *mut cocos2d_CCSpriteFrame,
        offsetInPixels: *const cocos2d_CCPoint,
    );
}
extern "C" {
    #[doc = " get texture of the frame"]
    #[link_name = "\u{1}?getTexture@CCSpriteFrame@cocos2d@@QEAAPEAVCCTexture2D@2@XZ"]
    pub fn cocos2d_CCSpriteFrame_getTexture(
        this: *mut cocos2d_CCSpriteFrame,
    ) -> *mut cocos2d_CCTexture2D;
}
extern "C" {
    #[doc = " set texture of the frame, the texture is retained"]
    #[link_name = "\u{1}?setTexture@CCSpriteFrame@cocos2d@@QEAAXPEAVCCTexture2D@2@@Z"]
    pub fn cocos2d_CCSpriteFrame_setTexture(
        this: *mut cocos2d_CCSpriteFrame,
        pobTexture: *mut cocos2d_CCTexture2D,
    );
}
extern "C" {
    #[link_name = "\u{1}?getOffset@CCSpriteFrame@cocos2d@@QEAAAEBVCCPoint@2@XZ"]
    pub fn cocos2d_CCSpriteFrame_getOffset(
        this: *mut cocos2d_CCSpriteFrame,
    ) -> *const cocos2d_CCPoint;
}
extern "C" {
    #[link_name = "\u{1}?setOffset@CCSpriteFrame@cocos2d@@QEAAXAEBVCCPoint@2@@Z"]
    pub fn cocos2d_CCSpriteFrame_setOffset(
        this: *mut cocos2d_CCSpriteFrame,
        offsets: *const cocos2d_CCPoint,
    );
}
extern "C" {
    #[doc = " Create a CCSpriteFrame with a texture filename, rect in points."]
    #[doc = "It is assumed that the frame was not trimmed."]
    #[link_name = "\u{1}?create@CCSpriteFrame@cocos2d@@SAPEAV12@PEBDAEBVCCRect@2@@Z"]
    pub fn cocos2d_CCSpriteFrame_create(
        filename: *const ::std::os::raw::c_char,
        rect: *const cocos2d_CCRect,
    ) -> *mut cocos2d_CCSpriteFrame;
}
extern "C" {
    #[doc = " Create a CCSpriteFrame with a texture filename, rect, rotated, offset and originalSize in pixels."]
    #[doc = "The originalSize is the size in pixels of the frame before being trimmed."]
    #[link_name = "\u{1}?create@CCSpriteFrame@cocos2d@@SAPEAV12@PEBDAEBVCCRect@2@_NAEBVCCPoint@2@AEBVCCSize@2@@Z"]
    pub fn cocos2d_CCSpriteFrame_create1(
        filename: *const ::std::os::raw::c_char,
        rect: *const cocos2d_CCRect,
        rotated: bool,
        offset: *const cocos2d_CCPoint,
        originalSize: *const cocos2d_CCSize,
    ) -> *mut cocos2d_CCSpriteFrame;
}
extern "C" {
    #[doc = " Create a CCSpriteFrame with a texture, rect in points."]
    #[doc = "It is assumed that the frame was not trimmed."]
    #[link_name = "\u{1}?createWithTexture@CCSpriteFrame@cocos2d@@SAPEAV12@PEAVCCTexture2D@2@AEBVCCRect@2@@Z"]
    pub fn cocos2d_CCSpriteFrame_createWithTexture(
        pobTexture: *mut cocos2d_CCTexture2D,
        rect: *const cocos2d_CCRect,
    ) -> *mut cocos2d_CCSpriteFrame;
}
extern "C" {
    #[doc = " Create a CCSpriteFrame with a texture, rect, rotated, offset and originalSize in pixels."]
    #[doc = "The originalSize is the size in points of the frame before being trimmed."]
    #[link_name = "\u{1}?createWithTexture@CCSpriteFrame@cocos2d@@SAPEAV12@PEAVCCTexture2D@2@AEBVCCRect@2@_NAEBVCCPoint@2@AEBVCCSize@2@@Z"]
    pub fn cocos2d_CCSpriteFrame_createWithTexture1(
        pobTexture: *mut cocos2d_CCTexture2D,
        rect: *const cocos2d_CCRect,
        rotated: bool,
        offset: *const cocos2d_CCPoint,
        originalSize: *const cocos2d_CCSize,
    ) -> *mut cocos2d_CCSpriteFrame;
}
extern "C" {
    #[doc = " Initializes a CCSpriteFrame with a texture, rect in points."]
    #[doc = "It is assumed that the frame was not trimmed."]
    #[link_name = "\u{1}?initWithTexture@CCSpriteFrame@cocos2d@@QEAA_NPEAVCCTexture2D@2@AEBVCCRect@2@@Z"]
    pub fn cocos2d_CCSpriteFrame_initWithTexture(
        this: *mut cocos2d_CCSpriteFrame,
        pobTexture: *mut cocos2d_CCTexture2D,
        rect: *const cocos2d_CCRect,
    ) -> bool;
}
extern "C" {
    #[doc = " Initializes a CCSpriteFrame with a texture filename, rect in points;"]
    #[doc = "It is assumed that the frame was not trimmed."]
    #[link_name = "\u{1}?initWithTextureFilename@CCSpriteFrame@cocos2d@@QEAA_NPEBDAEBVCCRect@2@@Z"]
    pub fn cocos2d_CCSpriteFrame_initWithTextureFilename(
        this: *mut cocos2d_CCSpriteFrame,
        filename: *const ::std::os::raw::c_char,
        rect: *const cocos2d_CCRect,
    ) -> bool;
}
extern "C" {
    #[doc = " Initializes a CCSpriteFrame with a texture, rect, rotated, offset and originalSize in pixels."]
    #[doc = "The originalSize is the size in points of the frame before being trimmed."]
    #[link_name = "\u{1}?initWithTexture@CCSpriteFrame@cocos2d@@QEAA_NPEAVCCTexture2D@2@AEBVCCRect@2@_NAEBVCCPoint@2@AEBVCCSize@2@@Z"]
    pub fn cocos2d_CCSpriteFrame_initWithTexture1(
        this: *mut cocos2d_CCSpriteFrame,
        pobTexture: *mut cocos2d_CCTexture2D,
        rect: *const cocos2d_CCRect,
        rotated: bool,
        offset: *const cocos2d_CCPoint,
        originalSize: *const cocos2d_CCSize,
    ) -> bool;
}
extern "C" {
    #[doc = " Initializes a CCSpriteFrame with a texture, rect, rotated, offset and originalSize in pixels."]
    #[doc = "The originalSize is the size in pixels of the frame before being trimmed."]
    #[doc = ""]
    #[doc = "@since v1.1"]
    #[link_name = "\u{1}?initWithTextureFilename@CCSpriteFrame@cocos2d@@QEAA_NPEBDAEBVCCRect@2@_NAEBVCCPoint@2@AEBVCCSize@2@@Z"]
    pub fn cocos2d_CCSpriteFrame_initWithTextureFilename1(
        this: *mut cocos2d_CCSpriteFrame,
        filename: *const ::std::os::raw::c_char,
        rect: *const cocos2d_CCRect,
        rotated: bool,
        offset: *const cocos2d_CCPoint,
        originalSize: *const cocos2d_CCSize,
    ) -> bool;
}
impl cocos2d_CCSpriteFrame {
    #[inline]
    pub unsafe fn setRectInPixels(&mut self, rectInPixels: *const cocos2d_CCRect) {
        cocos2d_CCSpriteFrame_setRectInPixels(self, rectInPixels)
    }
    #[inline]
    pub unsafe fn setRect(&mut self, rect: *const cocos2d_CCRect) {
        cocos2d_CCSpriteFrame_setRect(self, rect)
    }
    #[inline]
    pub unsafe fn getOffsetInPixels(&mut self) -> *const cocos2d_CCPoint {
        cocos2d_CCSpriteFrame_getOffsetInPixels(self)
    }
    #[inline]
    pub unsafe fn setOffsetInPixels(&mut self, offsetInPixels: *const cocos2d_CCPoint) {
        cocos2d_CCSpriteFrame_setOffsetInPixels(self, offsetInPixels)
    }
    #[inline]
    pub unsafe fn getTexture(&mut self) -> *mut cocos2d_CCTexture2D {
        cocos2d_CCSpriteFrame_getTexture(self)
    }
    #[inline]
    pub unsafe fn setTexture(&mut self, pobTexture: *mut cocos2d_CCTexture2D) {
        cocos2d_CCSpriteFrame_setTexture(self, pobTexture)
    }
    #[inline]
    pub unsafe fn getOffset(&mut self) -> *const cocos2d_CCPoint {
        cocos2d_CCSpriteFrame_getOffset(self)
    }
    #[inline]
    pub unsafe fn setOffset(&mut self, offsets: *const cocos2d_CCPoint) {
        cocos2d_CCSpriteFrame_setOffset(self, offsets)
    }
    #[inline]
    pub unsafe fn create(
        filename: *const ::std::os::raw::c_char,
        rect: *const cocos2d_CCRect,
    ) -> *mut cocos2d_CCSpriteFrame {
        cocos2d_CCSpriteFrame_create(filename, rect)
    }
    #[inline]
    pub unsafe fn create1(
        filename: *const ::std::os::raw::c_char,
        rect: *const cocos2d_CCRect,
        rotated: bool,
        offset: *const cocos2d_CCPoint,
        originalSize: *const cocos2d_CCSize,
    ) -> *mut cocos2d_CCSpriteFrame {
        cocos2d_CCSpriteFrame_create1(filename, rect, rotated, offset, originalSize)
    }
    #[inline]
    pub unsafe fn createWithTexture(
        pobTexture: *mut cocos2d_CCTexture2D,
        rect: *const cocos2d_CCRect,
    ) -> *mut cocos2d_CCSpriteFrame {
        cocos2d_CCSpriteFrame_createWithTexture(pobTexture, rect)
    }
    #[inline]
    pub unsafe fn createWithTexture1(
        pobTexture: *mut cocos2d_CCTexture2D,
        rect: *const cocos2d_CCRect,
        rotated: bool,
        offset: *const cocos2d_CCPoint,
        originalSize: *const cocos2d_CCSize,
    ) -> *mut cocos2d_CCSpriteFrame {
        cocos2d_CCSpriteFrame_createWithTexture1(pobTexture, rect, rotated, offset, originalSize)
    }
    #[inline]
    pub unsafe fn initWithTexture(
        &mut self,
        pobTexture: *mut cocos2d_CCTexture2D,
        rect: *const cocos2d_CCRect,
    ) -> bool {
        cocos2d_CCSpriteFrame_initWithTexture(self, pobTexture, rect)
    }
    #[inline]
    pub unsafe fn initWithTextureFilename(
        &mut self,
        filename: *const ::std::os::raw::c_char,
        rect: *const cocos2d_CCRect,
    ) -> bool {
        cocos2d_CCSpriteFrame_initWithTextureFilename(self, filename, rect)
    }
    #[inline]
    pub unsafe fn initWithTexture1(
        &mut self,
        pobTexture: *mut cocos2d_CCTexture2D,
        rect: *const cocos2d_CCRect,
        rotated: bool,
        offset: *const cocos2d_CCPoint,
        originalSize: *const cocos2d_CCSize,
    ) -> bool {
        cocos2d_CCSpriteFrame_initWithTexture1(
            self,
            pobTexture,
            rect,
            rotated,
            offset,
            originalSize,
        )
    }
    #[inline]
    pub unsafe fn initWithTextureFilename1(
        &mut self,
        filename: *const ::std::os::raw::c_char,
        rect: *const cocos2d_CCRect,
        rotated: bool,
        offset: *const cocos2d_CCPoint,
        originalSize: *const cocos2d_CCSize,
    ) -> bool {
        cocos2d_CCSpriteFrame_initWithTextureFilename1(
            self,
            filename,
            rect,
            rotated,
            offset,
            originalSize,
        )
    }
}
extern "C" {
    #[doc = "  @js NA"]
    #[doc = "  @lua NA"]
    #[link_name = "\u{1}??_DCCSpriteFrame@cocos2d@@QEAAXXZ"]
    pub fn cocos2d_CCSpriteFrame_CCSpriteFrame_destructor(this: *mut cocos2d_CCSpriteFrame);
}
extern "C" {
    #[doc = "  @js NA"]
    #[doc = "  @lua NA"]
    #[link_name = "\u{1}?copyWithZone@CCSpriteFrame@cocos2d@@UEAAPEAVCCObject@2@PEAVCCZone@2@@Z"]
    pub fn cocos2d_CCSpriteFrame_copyWithZone(
        this: *mut ::std::os::raw::c_void,
        pZone: *mut cocos2d_CCZone,
    ) -> *mut cocos2d_CCObject;
}
#[doc = " @addtogroup data_structures"]
#[doc = " @{"]
#[doc = " @ js NA"]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCString {
    pub _base: cocos2d_CCObject,
    pub m_sString: std_string,
}
#[test]
fn bindgen_test_layout_cocos2d_CCString() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCString>(),
        72usize,
        concat!("Size of: ", stringify!(cocos2d_CCString))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCString>(),
        8usize,
        concat!("Alignment of ", stringify!(cocos2d_CCString))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cocos2d_CCString>())).m_sString as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCString),
            "::",
            stringify!(m_sString)
        )
    );
}
extern "C" {
    #[doc = " init a string with format, it's similar with the c function 'sprintf'"]
    #[doc = " @lua NA"]
    #[link_name = "\u{1}?initWithFormat@CCString@cocos2d@@QEAA_NPEBDZZ"]
    pub fn cocos2d_CCString_initWithFormat(
        this: *mut cocos2d_CCString,
        format: *const ::std::os::raw::c_char,
        ...
    ) -> bool;
}
extern "C" {
    #[doc = " convert to int value"]
    #[link_name = "\u{1}?intValue@CCString@cocos2d@@QEBAHXZ"]
    pub fn cocos2d_CCString_intValue(this: *const cocos2d_CCString) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " convert to unsigned int value"]
    #[link_name = "\u{1}?uintValue@CCString@cocos2d@@QEBAIXZ"]
    pub fn cocos2d_CCString_uintValue(this: *const cocos2d_CCString) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " convert to float value"]
    #[link_name = "\u{1}?floatValue@CCString@cocos2d@@QEBAMXZ"]
    pub fn cocos2d_CCString_floatValue(this: *const cocos2d_CCString) -> f32;
}
extern "C" {
    #[doc = " convert to double value"]
    #[link_name = "\u{1}?doubleValue@CCString@cocos2d@@QEBANXZ"]
    pub fn cocos2d_CCString_doubleValue(this: *const cocos2d_CCString) -> f64;
}
extern "C" {
    #[doc = " convert to bool value"]
    #[link_name = "\u{1}?boolValue@CCString@cocos2d@@QEBA_NXZ"]
    pub fn cocos2d_CCString_boolValue(this: *const cocos2d_CCString) -> bool;
}
extern "C" {
    #[doc = " get the C string"]
    #[link_name = "\u{1}?getCString@CCString@cocos2d@@QEBAPEBDXZ"]
    pub fn cocos2d_CCString_getCString(
        this: *const cocos2d_CCString,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " get the length of string"]
    #[link_name = "\u{1}?length@CCString@cocos2d@@QEBAIXZ"]
    pub fn cocos2d_CCString_length(this: *const cocos2d_CCString) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " compare to a c string"]
    #[link_name = "\u{1}?compare@CCString@cocos2d@@QEBAHPEBD@Z"]
    pub fn cocos2d_CCString_compare(
        this: *const cocos2d_CCString,
        arg1: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " create a string with std string, you can also pass a c string pointer because the default constructor of std::string can access a c string pointer."]
    #[doc = "  @return A CCString pointer which is an autorelease object pointer,"]
    #[doc = "          it means that you needn't do a release operation unless you retain it."]
    #[link_name = "\u{1}?create@CCString@cocos2d@@SAPEAV12@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z"]
    pub fn cocos2d_CCString_create(str_: *const std_string) -> *mut cocos2d_CCString;
}
extern "C" {
    #[doc = " create a string with format, it's similar with the c function 'sprintf', the default buffer size is (1024*100) bytes,"]
    #[doc = "  if you want to change it, you should modify the kMaxStringLen macro in CCString.cpp file."]
    #[doc = "  @return A CCString pointer which is an autorelease object pointer,"]
    #[doc = "          it means that you needn't do a release operation unless you retain it."]
    #[doc = "  @lua NA"]
    #[link_name = "\u{1}?createWithFormat@CCString@cocos2d@@SAPEAV12@PEBDZZ"]
    pub fn cocos2d_CCString_createWithFormat(
        format: *const ::std::os::raw::c_char,
        ...
    ) -> *mut cocos2d_CCString;
}
extern "C" {
    #[doc = " create a string with binary data"]
    #[doc = "  @return A CCString pointer which is an autorelease object pointer,"]
    #[doc = "          it means that you needn't do a release operation unless you retain it."]
    #[link_name = "\u{1}?createWithData@CCString@cocos2d@@SAPEAV12@PEBEK@Z"]
    pub fn cocos2d_CCString_createWithData(
        pData: *const ::std::os::raw::c_uchar,
        nLen: ::std::os::raw::c_ulong,
    ) -> *mut cocos2d_CCString;
}
extern "C" {
    #[doc = " create a string with a file,"]
    #[doc = "  @return A CCString pointer which is an autorelease object pointer,"]
    #[doc = "          it means that you needn't do a release operation unless you retain it."]
    #[link_name = "\u{1}?createWithContentsOfFile@CCString@cocos2d@@SAPEAV12@PEBD@Z"]
    pub fn cocos2d_CCString_createWithContentsOfFile(
        pszFileName: *const ::std::os::raw::c_char,
    ) -> *mut cocos2d_CCString;
}
extern "C" {
    #[doc = " @lua NA"]
    #[link_name = "\u{1}??0CCString@cocos2d@@QEAA@XZ"]
    pub fn cocos2d_CCString_CCString(this: *mut cocos2d_CCString);
}
extern "C" {
    #[doc = " @lua NA"]
    #[link_name = "\u{1}??0CCString@cocos2d@@QEAA@PEBD@Z"]
    pub fn cocos2d_CCString_CCString1(
        this: *mut cocos2d_CCString,
        str_: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    #[doc = " @lua NA"]
    #[link_name = "\u{1}??0CCString@cocos2d@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z"]
    pub fn cocos2d_CCString_CCString2(this: *mut cocos2d_CCString, str_: *const std_string);
}
extern "C" {
    #[doc = " @lua NA"]
    #[link_name = "\u{1}??0CCString@cocos2d@@QEAA@AEBV01@@Z"]
    pub fn cocos2d_CCString_CCString3(this: *mut cocos2d_CCString, str_: *const cocos2d_CCString);
}
impl cocos2d_CCString {
    #[inline]
    pub unsafe fn intValue(&self) -> ::std::os::raw::c_int {
        cocos2d_CCString_intValue(self)
    }
    #[inline]
    pub unsafe fn uintValue(&self) -> ::std::os::raw::c_uint {
        cocos2d_CCString_uintValue(self)
    }
    #[inline]
    pub unsafe fn floatValue(&self) -> f32 {
        cocos2d_CCString_floatValue(self)
    }
    #[inline]
    pub unsafe fn doubleValue(&self) -> f64 {
        cocos2d_CCString_doubleValue(self)
    }
    #[inline]
    pub unsafe fn boolValue(&self) -> bool {
        cocos2d_CCString_boolValue(self)
    }
    #[inline]
    pub unsafe fn getCString(&self) -> *const ::std::os::raw::c_char {
        cocos2d_CCString_getCString(self)
    }
    #[inline]
    pub unsafe fn length(&self) -> ::std::os::raw::c_uint {
        cocos2d_CCString_length(self)
    }
    #[inline]
    pub unsafe fn compare(&self, arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int {
        cocos2d_CCString_compare(self, arg1)
    }
    #[inline]
    pub unsafe fn create(str_: *const std_string) -> *mut cocos2d_CCString {
        cocos2d_CCString_create(str_)
    }
    #[inline]
    pub unsafe fn createWithData(
        pData: *const ::std::os::raw::c_uchar,
        nLen: ::std::os::raw::c_ulong,
    ) -> *mut cocos2d_CCString {
        cocos2d_CCString_createWithData(pData, nLen)
    }
    #[inline]
    pub unsafe fn createWithContentsOfFile(
        pszFileName: *const ::std::os::raw::c_char,
    ) -> *mut cocos2d_CCString {
        cocos2d_CCString_createWithContentsOfFile(pszFileName)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cocos2d_CCString_CCString(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new1(str_: *const ::std::os::raw::c_char) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cocos2d_CCString_CCString1(__bindgen_tmp.as_mut_ptr(), str_);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new2(str_: *const std_string) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cocos2d_CCString_CCString2(__bindgen_tmp.as_mut_ptr(), str_);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new3(str_: *const cocos2d_CCString) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cocos2d_CCString_CCString3(__bindgen_tmp.as_mut_ptr(), str_);
        __bindgen_tmp.assume_init()
    }
}
extern "C" {
    #[doc = " @lua NA"]
    #[link_name = "\u{1}??_DCCString@cocos2d@@QEAAXXZ"]
    pub fn cocos2d_CCString_CCString_destructor(this: *mut cocos2d_CCString);
}
extern "C" {
    #[link_name = "\u{1}?copyWithZone@CCString@cocos2d@@UEAAPEAVCCObject@2@PEAVCCZone@2@@Z"]
    pub fn cocos2d_CCString_copyWithZone(
        this: *mut ::std::os::raw::c_void,
        pZone: *mut cocos2d_CCZone,
    ) -> *mut cocos2d_CCObject;
}
extern "C" {
    #[link_name = "\u{1}?isEqual@CCString@cocos2d@@UEAA_NPEBVCCObject@2@@Z"]
    pub fn cocos2d_CCString_isEqual(
        this: *mut ::std::os::raw::c_void,
        pObject: *const cocos2d_CCObject,
    ) -> bool;
}
extern "C" {
    #[doc = " @lua NA"]
    #[link_name = "\u{1}?acceptVisitor@CCString@cocos2d@@UEAAXAEAVCCDataVisitor@2@@Z"]
    pub fn cocos2d_CCString_acceptVisitor(
        this: *mut ::std::os::raw::c_void,
        visitor: *mut cocos2d_CCDataVisitor,
    );
}
#[doc = "  CCDictElement is used for traversing CCDictionary."]
#[doc = ""]
#[doc = "  A CCDictElement is one element of CCDictionary, it contains two properties, key and object."]
#[doc = "  Its key has two different type (integer and string)."]
#[doc = ""]
#[doc = "  @note The key type is unique, all the elements in CCDictionary has the same key type(integer or string)."]
#[doc = "  @code"]
#[doc = "  CCDictElement* pElement;"]
#[doc = "  CCDICT_FOREACH(dict, pElement)"]
#[doc = "  {"]
#[doc = "      const char*key = pElement->getStrKey();"]
#[doc = "      // You certainly know the type of value, so we assume that it's a CCSprite."]
#[doc = "      CCSprite* pSprite = (CCSprite*)pElement->getObject();"]
#[doc = "      // ......"]
#[doc = "  }"]
#[doc = "  @endcode"]
#[doc = "  @js NA"]
#[doc = "  @lua NA"]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCDictElement {
    pub m_szKey: [::std::os::raw::c_char; 256usize],
    pub m_iKey: isize,
    pub m_pObject: *mut cocos2d_CCObject,
    pub hh: UT_hash_handle,
}
#[test]
fn bindgen_test_layout_cocos2d_CCDictElement() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCDictElement>(),
        328usize,
        concat!("Size of: ", stringify!(cocos2d_CCDictElement))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCDictElement>(),
        8usize,
        concat!("Alignment of ", stringify!(cocos2d_CCDictElement))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cocos2d_CCDictElement>())).m_szKey as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCDictElement),
            "::",
            stringify!(m_szKey)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cocos2d_CCDictElement>())).m_iKey as *const _ as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCDictElement),
            "::",
            stringify!(m_iKey)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cocos2d_CCDictElement>())).m_pObject as *const _ as usize },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCDictElement),
            "::",
            stringify!(m_pObject)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cocos2d_CCDictElement>())).hh as *const _ as usize },
        272usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCDictElement),
            "::",
            stringify!(hh)
        )
    );
}
extern "C" {
    #[doc = "  The destructor of CCDictElement."]
    #[link_name = "\u{1}??_DCCDictElement@cocos2d@@QEAAXXZ"]
    pub fn cocos2d_CCDictElement_CCDictElement_destructor(this: *mut cocos2d_CCDictElement);
}
impl cocos2d_CCDictElement {
    #[inline]
    pub unsafe fn destruct(&mut self) {
        cocos2d_CCDictElement_CCDictElement_destructor(self)
    }
}
#[doc = "  CCDictionary is a class like NSDictionary in Obj-C ."]
#[doc = ""]
#[doc = "  @note Only the pointer of CCObject or its subclass can be inserted to CCDictionary."]
#[doc = "  @code"]
#[doc = "  // Create a dictionary, return an autorelease object."]
#[doc = "  CCDictionary* pDict = CCDictionary::create();"]
#[doc = ""]
#[doc = "  // Insert objects to dictionary"]
#[doc = "  CCString* pValue1 = CCString::create(\"100\");"]
#[doc = "  CCString* pValue2 = CCString::create(\"120\");"]
#[doc = "  CCInteger* pValue3 = CCInteger::create(200);"]
#[doc = "  pDict->setObject(pValue1, \"key1\");"]
#[doc = "  pDict->setObject(pValue2, \"key2\");"]
#[doc = "  pDict->setObject(pValue3, \"key3\");"]
#[doc = ""]
#[doc = "  // Get the object for key"]
#[doc = "  CCString* pStr1 = (CCString*)pDict->objectForKey(\"key1\");"]
#[doc = "  CCLog(\"{ key1: %s }\", pStr1->getCString());"]
#[doc = "  CCInteger* pInteger = (CCInteger*)pDict->objectForKey(\"key3\");"]
#[doc = "  CCLog(\"{ key3: %d }\", pInteger->getValue());"]
#[doc = "  @endcode"]
#[doc = "  @js NA"]
#[doc = ""]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCDictionary {
    pub _base: cocos2d_CCObject,
    #[doc = "  All the elements in dictionary."]
    #[doc = ""]
    #[doc = "  @note For internal usage, we need to declare this member variable as public since it's used in UT_HASH."]
    pub m_pElements: *mut cocos2d_CCDictElement,
    #[doc = "  The type of dictionary, it's assigned to kCCDictUnknown by default."]
    pub m_eDictType: cocos2d_CCDictionary_CCDictType,
}
pub const cocos2d_CCDictionary_CCDictType_kCCDictUnknown: cocos2d_CCDictionary_CCDictType = 0;
pub const cocos2d_CCDictionary_CCDictType_kCCDictStr: cocos2d_CCDictionary_CCDictType = 1;
pub const cocos2d_CCDictionary_CCDictType_kCCDictInt: cocos2d_CCDictionary_CCDictType = 2;
#[doc = " The support type of dictionary, it's confirmed when setObject is invoked."]
pub type cocos2d_CCDictionary_CCDictType = ::std::os::raw::c_int;
#[test]
fn bindgen_test_layout_cocos2d_CCDictionary() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCDictionary>(),
        56usize,
        concat!("Size of: ", stringify!(cocos2d_CCDictionary))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCDictionary>(),
        8usize,
        concat!("Alignment of ", stringify!(cocos2d_CCDictionary))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cocos2d_CCDictionary>())).m_pElements as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCDictionary),
            "::",
            stringify!(m_pElements)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cocos2d_CCDictionary>())).m_eDictType as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCDictionary),
            "::",
            stringify!(m_eDictType)
        )
    );
}
extern "C" {
    #[doc = "  Get the count of elements in CCDictionary."]
    #[doc = ""]
    #[doc = "  @return  The count of elements."]
    #[link_name = "\u{1}?count@CCDictionary@cocos2d@@QEAAIXZ"]
    pub fn cocos2d_CCDictionary_count(this: *mut cocos2d_CCDictionary) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = "  Return all keys of elements."]
    #[doc = ""]
    #[doc = "  @return  The array contains all keys of elements. It's an autorelease object yet."]
    #[link_name = "\u{1}?allKeys@CCDictionary@cocos2d@@QEAAPEAVCCArray@2@XZ"]
    pub fn cocos2d_CCDictionary_allKeys(this: *mut cocos2d_CCDictionary) -> *mut cocos2d_CCArray;
}
extern "C" {
    #[doc = "  Get all keys according to the specified object."]
    #[doc = "  @warning  We use '==' to compare two objects"]
    #[doc = "  @return   The array contains all keys for the specified object. It's an autorelease object yet."]
    #[link_name = "\u{1}?allKeysForObject@CCDictionary@cocos2d@@QEAAPEAVCCArray@2@PEAVCCObject@2@@Z"]
    pub fn cocos2d_CCDictionary_allKeysForObject(
        this: *mut cocos2d_CCDictionary,
        object: *mut cocos2d_CCObject,
    ) -> *mut cocos2d_CCArray;
}
extern "C" {
    #[doc = "  Get the object according to the specified string key."]
    #[doc = ""]
    #[doc = "  @note The dictionary needs to use string as key. If integer is passed, an assert will appear."]
    #[doc = "  @param key  The string key for searching."]
    #[doc = "  @return The object matches the key. You need to force convert it to the type you know."]
    #[doc = "  @code"]
    #[doc = "     // Assume that the elements are CCString* pointers. Convert it by following code."]
    #[doc = "     CCString* pStr = (CCString*)pDict->objectForKey(\"key1\");"]
    #[doc = "     // Do something about pStr."]
    #[doc = "     // If you don't know the object type, properly you need to use dynamic_cast<SomeType*> to check it."]
    #[doc = "     CCString* pStr2 = dynamic_cast<CCString*>(pDict->objectForKey(\"key1\"));"]
    #[doc = "     if (pStr2 != NULL) {"]
    #[doc = "          // Do something about pStr2"]
    #[doc = "     }"]
    #[doc = "  @endcode"]
    #[doc = "  @see objectForKey(intptr_t)"]
    #[link_name = "\u{1}?objectForKey@CCDictionary@cocos2d@@QEAAPEAVCCObject@2@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z"]
    pub fn cocos2d_CCDictionary_objectForKey(
        this: *mut cocos2d_CCDictionary,
        key: *const std_string,
    ) -> *mut cocos2d_CCObject;
}
extern "C" {
    #[doc = "  Get the object according to the specified integer key."]
    #[doc = ""]
    #[doc = "  @note The dictionary needs to use integer as key. If string is passed, an assert will appear."]
    #[doc = "  @param key  The integer key for searching."]
    #[doc = "  @return The object matches the key."]
    #[doc = "  @see objectForKey(const std::string&)"]
    #[link_name = "\u{1}?objectForKey@CCDictionary@cocos2d@@QEAAPEAVCCObject@2@_J@Z"]
    pub fn cocos2d_CCDictionary_objectForKey1(
        this: *mut cocos2d_CCDictionary,
        key: isize,
    ) -> *mut cocos2d_CCObject;
}
extern "C" {
    #[doc = " Get the value according to the specified string key."]
    #[doc = ""]
    #[doc = "  @note Be careful to use this function since it assumes the objects in the dictionary are CCString pointer."]
    #[doc = "  @param key  The string key for searching"]
    #[doc = "  @return An instance of CCString."]
    #[doc = "          It will return an empty string if the objects aren't CCString pointer or the key wasn't found."]
    #[doc = "  @see valueForKey(intptr_t)"]
    #[link_name = "\u{1}?valueForKey@CCDictionary@cocos2d@@QEAAPEBVCCString@2@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z"]
    pub fn cocos2d_CCDictionary_valueForKey(
        this: *mut cocos2d_CCDictionary,
        key: *const std_string,
    ) -> *const cocos2d_CCString;
}
extern "C" {
    #[doc = " Get the value according to the specified integer key."]
    #[doc = ""]
    #[doc = "  @note Be careful to use this function since it assumes the objects in the dictionary are CCString pointer."]
    #[doc = "  @param key  The string key for searching."]
    #[doc = "  @return An instance of CCString."]
    #[doc = "          It will return an empty string if the objects aren't CCString pointer or the key wasn't found."]
    #[doc = "  @see valueForKey(intptr_t)"]
    #[link_name = "\u{1}?valueForKey@CCDictionary@cocos2d@@QEAAPEBVCCString@2@_J@Z"]
    pub fn cocos2d_CCDictionary_valueForKey1(
        this: *mut cocos2d_CCDictionary,
        key: isize,
    ) -> *const cocos2d_CCString;
}
extern "C" {
    #[doc = " Insert an object to dictionary, and match it with the specified string key."]
    #[doc = ""]
    #[doc = "  @note Whe the first time this method is invoked, the key type will be set to string."]
    #[doc = "        After that you can't setObject with an integer key."]
    #[doc = "        If the dictionary contains the key you passed, the object matching the key will be released and removed from dictionary."]
    #[doc = "        Then the new object will be inserted after that."]
    #[doc = ""]
    #[doc = "  @param pObject  The Object to be inserted."]
    #[doc = "  @param key      The string key for searching."]
    #[doc = "  @see setObject(CCObject*, intptr_t)"]
    #[link_name = "\u{1}?setObject@CCDictionary@cocos2d@@QEAAXPEAVCCObject@2@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z"]
    pub fn cocos2d_CCDictionary_setObject(
        this: *mut cocos2d_CCDictionary,
        pObject: *mut cocos2d_CCObject,
        key: *const std_string,
    );
}
extern "C" {
    #[doc = " Insert an object to dictionary, and match it with the specified string key."]
    #[doc = ""]
    #[doc = "  @note Then the first time this method is invoked, the key type will be set to string."]
    #[doc = "        After that you can't setObject with an integer key."]
    #[doc = "        If the dictionary contains the key you passed, the object matching the key will be released and removed from dictionary."]
    #[doc = "        Then the new object will be inserted after that."]
    #[doc = "  @param pObject  The Object to be inserted."]
    #[doc = "  @param key      The string key for searching."]
    #[doc = "  @see setObject(CCObject*, const std::string&)"]
    #[link_name = "\u{1}?setObject@CCDictionary@cocos2d@@QEAAXPEAVCCObject@2@_J@Z"]
    pub fn cocos2d_CCDictionary_setObject1(
        this: *mut cocos2d_CCDictionary,
        pObject: *mut cocos2d_CCObject,
        key: isize,
    );
}
extern "C" {
    #[doc = "  Remove an object by the specified string key."]
    #[doc = ""]
    #[doc = "  @param key  The string key for searching."]
    #[doc = "  @see removeObjectForKey(intptr_t), removeObjectsForKeys(CCArray*),"]
    #[doc = "       removeObjectForElememt(CCDictElement*), removeAllObjects()."]
    #[link_name = "\u{1}?removeObjectForKey@CCDictionary@cocos2d@@QEAAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z"]
    pub fn cocos2d_CCDictionary_removeObjectForKey(
        this: *mut cocos2d_CCDictionary,
        key: *const std_string,
    );
}
extern "C" {
    #[doc = "  Remove an object by the specified integer key."]
    #[doc = ""]
    #[doc = "  @param key  The integer key for searching."]
    #[doc = "  @see removeObjectForKey(const std::string&), removeObjectsForKeys(CCArray*),"]
    #[doc = "       removeObjectForElememt(CCDictElement*), removeAllObjects()."]
    #[link_name = "\u{1}?removeObjectForKey@CCDictionary@cocos2d@@QEAAX_J@Z"]
    pub fn cocos2d_CCDictionary_removeObjectForKey1(this: *mut cocos2d_CCDictionary, key: isize);
}
extern "C" {
    #[doc = "  Remove objects by an array of keys."]
    #[doc = ""]
    #[doc = "  @param pKeyArray  The array contains keys to be removed."]
    #[doc = "  @see removeObjectForKey(const std::string&), removeObjectForKey(intptr_t),"]
    #[doc = "       removeObjectForElememt(CCDictElement*), removeAllObjects()."]
    #[link_name = "\u{1}?removeObjectsForKeys@CCDictionary@cocos2d@@QEAAXPEAVCCArray@2@@Z"]
    pub fn cocos2d_CCDictionary_removeObjectsForKeys(
        this: *mut cocos2d_CCDictionary,
        pKeyArray: *mut cocos2d_CCArray,
    );
}
extern "C" {
    #[doc = "  Remove an object by an element."]
    #[doc = ""]
    #[doc = "  @param pElement  The element need to be removed."]
    #[doc = "  @see removeObjectForKey(const std::string&), removeObjectForKey(intptr_t),"]
    #[doc = "       removeObjectsForKeys(CCArray*), removeAllObjects()."]
    #[doc = "  @lua NA"]
    #[link_name = "\u{1}?removeObjectForElememt@CCDictionary@cocos2d@@QEAAXPEAVCCDictElement@2@@Z"]
    pub fn cocos2d_CCDictionary_removeObjectForElememt(
        this: *mut cocos2d_CCDictionary,
        pElement: *mut cocos2d_CCDictElement,
    );
}
extern "C" {
    #[doc = "  Remove all objects in the dictionary."]
    #[doc = ""]
    #[doc = "  @see removeObjectForKey(const std::string&), removeObjectForKey(intptr_t),"]
    #[doc = "       removeObjectsForKeys(CCArray*), removeObjectForElememt(CCDictElement*)."]
    #[link_name = "\u{1}?removeAllObjects@CCDictionary@cocos2d@@QEAAXXZ"]
    pub fn cocos2d_CCDictionary_removeAllObjects(this: *mut cocos2d_CCDictionary);
}
extern "C" {
    #[doc = "  Return a random object in the dictionary."]
    #[doc = ""]
    #[doc = "  @return The random object."]
    #[doc = "  @see objectForKey(intptr_t), objectForKey(const std::string&)"]
    #[doc = "  @lua NA"]
    #[link_name = "\u{1}?randomObject@CCDictionary@cocos2d@@QEAAPEAVCCObject@2@XZ"]
    pub fn cocos2d_CCDictionary_randomObject(
        this: *mut cocos2d_CCDictionary,
    ) -> *mut cocos2d_CCObject;
}
extern "C" {
    #[doc = "  Create a dictionary."]
    #[doc = "  @return A dictionary which is an autorelease object."]
    #[doc = "  @see createWithDictionary(CCDictionary*), createWithContentsOfFile(const char*), createWithContentsOfFileThreadSafe(const char*)."]
    #[link_name = "\u{1}?create@CCDictionary@cocos2d@@SAPEAV12@XZ"]
    pub fn cocos2d_CCDictionary_create() -> *mut cocos2d_CCDictionary;
}
extern "C" {
    #[doc = "  Create a dictionary with an existing dictionary."]
    #[doc = ""]
    #[doc = "  @param srcDict The exist dictionary."]
    #[doc = "  @return A dictionary which is an autorelease object."]
    #[doc = "  @see create(), createWithContentsOfFile(const char*), createWithContentsOfFileThreadSafe(const char*)."]
    #[link_name = "\u{1}?createWithDictionary@CCDictionary@cocos2d@@SAPEAV12@PEAV12@@Z"]
    pub fn cocos2d_CCDictionary_createWithDictionary(
        srcDict: *mut cocos2d_CCDictionary,
    ) -> *mut cocos2d_CCDictionary;
}
extern "C" {
    #[doc = "  Create a dictionary with a plist file."]
    #[doc = "  @param  pFileName  The name of the plist file."]
    #[doc = "  @return A dictionary which is an autorelease object."]
    #[doc = "  @see create(), createWithDictionary(CCDictionary*), createWithContentsOfFileThreadSafe(const char*)."]
    #[link_name = "\u{1}?createWithContentsOfFile@CCDictionary@cocos2d@@SAPEAV12@PEBD@Z"]
    pub fn cocos2d_CCDictionary_createWithContentsOfFile(
        pFileName: *const ::std::os::raw::c_char,
    ) -> *mut cocos2d_CCDictionary;
}
extern "C" {
    #[doc = "  Write a dictionary to a plist file."]
    #[doc = "  @param fullPath The full path of the plist file. You can get writeable path by getWritablePath()"]
    #[doc = "  @return true if successed, false if failed"]
    #[doc = "  @lua NA"]
    #[link_name = "\u{1}?writeToFile@CCDictionary@cocos2d@@QEAA_NPEBD@Z"]
    pub fn cocos2d_CCDictionary_writeToFile(
        this: *mut cocos2d_CCDictionary,
        fullPath: *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    #[doc = "  Create a dictionary with a plist file."]
    #[doc = ""]
    #[doc = "  @note the return object isn't an autorelease object."]
    #[doc = "        This can make sure not using autorelease pool in a new thread."]
    #[doc = "        Therefore, you need to manage the lifecycle of the return object."]
    #[doc = "        It means that when you don't need it, CC_SAFE_RELEASE needs to be invoked."]
    #[doc = ""]
    #[doc = "  @param  pFileName  The name of the plist file."]
    #[doc = "  @return A dictionary which isn't an autorelease object."]
    #[doc = "  @lua NA"]
    #[link_name = "\u{1}?createWithContentsOfFileThreadSafe@CCDictionary@cocos2d@@SAPEAV12@PEBD@Z"]
    pub fn cocos2d_CCDictionary_createWithContentsOfFileThreadSafe(
        pFileName: *const ::std::os::raw::c_char,
    ) -> *mut cocos2d_CCDictionary;
}
extern "C" {
    #[doc = " The constructor of CCDictionary."]
    #[doc = " @lua NA"]
    #[link_name = "\u{1}??0CCDictionary@cocos2d@@QEAA@XZ"]
    pub fn cocos2d_CCDictionary_CCDictionary(this: *mut cocos2d_CCDictionary);
}
impl cocos2d_CCDictionary {
    #[inline]
    pub unsafe fn count(&mut self) -> ::std::os::raw::c_uint {
        cocos2d_CCDictionary_count(self)
    }
    #[inline]
    pub unsafe fn allKeys(&mut self) -> *mut cocos2d_CCArray {
        cocos2d_CCDictionary_allKeys(self)
    }
    #[inline]
    pub unsafe fn allKeysForObject(
        &mut self,
        object: *mut cocos2d_CCObject,
    ) -> *mut cocos2d_CCArray {
        cocos2d_CCDictionary_allKeysForObject(self, object)
    }
    #[inline]
    pub unsafe fn objectForKey(&mut self, key: *const std_string) -> *mut cocos2d_CCObject {
        cocos2d_CCDictionary_objectForKey(self, key)
    }
    #[inline]
    pub unsafe fn objectForKey1(&mut self, key: isize) -> *mut cocos2d_CCObject {
        cocos2d_CCDictionary_objectForKey1(self, key)
    }
    #[inline]
    pub unsafe fn valueForKey(&mut self, key: *const std_string) -> *const cocos2d_CCString {
        cocos2d_CCDictionary_valueForKey(self, key)
    }
    #[inline]
    pub unsafe fn valueForKey1(&mut self, key: isize) -> *const cocos2d_CCString {
        cocos2d_CCDictionary_valueForKey1(self, key)
    }
    #[inline]
    pub unsafe fn setObject(&mut self, pObject: *mut cocos2d_CCObject, key: *const std_string) {
        cocos2d_CCDictionary_setObject(self, pObject, key)
    }
    #[inline]
    pub unsafe fn setObject1(&mut self, pObject: *mut cocos2d_CCObject, key: isize) {
        cocos2d_CCDictionary_setObject1(self, pObject, key)
    }
    #[inline]
    pub unsafe fn removeObjectForKey(&mut self, key: *const std_string) {
        cocos2d_CCDictionary_removeObjectForKey(self, key)
    }
    #[inline]
    pub unsafe fn removeObjectForKey1(&mut self, key: isize) {
        cocos2d_CCDictionary_removeObjectForKey1(self, key)
    }
    #[inline]
    pub unsafe fn removeObjectsForKeys(&mut self, pKeyArray: *mut cocos2d_CCArray) {
        cocos2d_CCDictionary_removeObjectsForKeys(self, pKeyArray)
    }
    #[inline]
    pub unsafe fn removeObjectForElememt(&mut self, pElement: *mut cocos2d_CCDictElement) {
        cocos2d_CCDictionary_removeObjectForElememt(self, pElement)
    }
    #[inline]
    pub unsafe fn removeAllObjects(&mut self) {
        cocos2d_CCDictionary_removeAllObjects(self)
    }
    #[inline]
    pub unsafe fn randomObject(&mut self) -> *mut cocos2d_CCObject {
        cocos2d_CCDictionary_randomObject(self)
    }
    #[inline]
    pub unsafe fn create() -> *mut cocos2d_CCDictionary {
        cocos2d_CCDictionary_create()
    }
    #[inline]
    pub unsafe fn createWithDictionary(
        srcDict: *mut cocos2d_CCDictionary,
    ) -> *mut cocos2d_CCDictionary {
        cocos2d_CCDictionary_createWithDictionary(srcDict)
    }
    #[inline]
    pub unsafe fn createWithContentsOfFile(
        pFileName: *const ::std::os::raw::c_char,
    ) -> *mut cocos2d_CCDictionary {
        cocos2d_CCDictionary_createWithContentsOfFile(pFileName)
    }
    #[inline]
    pub unsafe fn writeToFile(&mut self, fullPath: *const ::std::os::raw::c_char) -> bool {
        cocos2d_CCDictionary_writeToFile(self, fullPath)
    }
    #[inline]
    pub unsafe fn createWithContentsOfFileThreadSafe(
        pFileName: *const ::std::os::raw::c_char,
    ) -> *mut cocos2d_CCDictionary {
        cocos2d_CCDictionary_createWithContentsOfFileThreadSafe(pFileName)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cocos2d_CCDictionary_CCDictionary(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
}
extern "C" {
    #[doc = " The destructor of CCDictionary"]
    #[doc = " @lua NA"]
    #[link_name = "\u{1}??_DCCDictionary@cocos2d@@QEAAXXZ"]
    pub fn cocos2d_CCDictionary_CCDictionary_destructor(this: *mut cocos2d_CCDictionary);
}
extern "C" {
    #[doc = " @{"]
    #[doc = " @name Function override"]
    #[doc = "**"]
    #[doc = "*  This function is used for deepcopy elements from source dictionary to destination dictionary."]
    #[doc = "*  You shouldn't invoke this function manually since it's called by CCObject::copy."]
    #[doc = "*  @lua NA"]
    #[doc = "*  @js  NA"]
    #[doc = "*/"]
    #[link_name = "\u{1}?copyWithZone@CCDictionary@cocos2d@@UEAAPEAVCCObject@2@PEAVCCZone@2@@Z"]
    pub fn cocos2d_CCDictionary_copyWithZone(
        this: *mut ::std::os::raw::c_void,
        pZone: *mut cocos2d_CCZone,
    ) -> *mut cocos2d_CCObject;
}
extern "C" {
    #[link_name = "\u{1}?acceptVisitor@CCDictionary@cocos2d@@UEAAXAEAVCCDataVisitor@2@@Z"]
    pub fn cocos2d_CCDictionary_acceptVisitor(
        this: *mut ::std::os::raw::c_void,
        visitor: *mut cocos2d_CCDataVisitor,
    );
}
#[doc = " CCAnimationFrame"]
#[doc = "A frame of the animation. It contains information like:"]
#[doc = "- sprite frame name"]
#[doc = "- # of delay units."]
#[doc = "- offset"]
#[doc = ""]
#[doc = "@since v2.0"]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCAnimationFrame {
    pub _base: cocos2d_CCObject,
    pub m_pSpriteFrame: *mut cocos2d_CCSpriteFrame,
    pub m_fDelayUnits: f32,
    pub m_pUserInfo: *mut cocos2d_CCDictionary,
}
#[test]
fn bindgen_test_layout_cocos2d_CCAnimationFrame() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCAnimationFrame>(),
        64usize,
        concat!("Size of: ", stringify!(cocos2d_CCAnimationFrame))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCAnimationFrame>(),
        8usize,
        concat!("Alignment of ", stringify!(cocos2d_CCAnimationFrame))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cocos2d_CCAnimationFrame>())).m_pSpriteFrame as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCAnimationFrame),
            "::",
            stringify!(m_pSpriteFrame)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cocos2d_CCAnimationFrame>())).m_fDelayUnits as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCAnimationFrame),
            "::",
            stringify!(m_fDelayUnits)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cocos2d_CCAnimationFrame>())).m_pUserInfo as *const _ as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCAnimationFrame),
            "::",
            stringify!(m_pUserInfo)
        )
    );
}
extern "C" {
    #[doc = " initializes the animation frame with a spriteframe, number of delay units and a notification user info"]
    #[link_name = "\u{1}?initWithSpriteFrame@CCAnimationFrame@cocos2d@@QEAA_NPEAVCCSpriteFrame@2@MPEAVCCDictionary@2@@Z"]
    pub fn cocos2d_CCAnimationFrame_initWithSpriteFrame(
        this: *mut cocos2d_CCAnimationFrame,
        spriteFrame: *mut cocos2d_CCSpriteFrame,
        delayUnits: f32,
        userInfo: *mut cocos2d_CCDictionary,
    ) -> bool;
}
extern "C" {
    #[doc = " @js ctor"]
    #[link_name = "\u{1}??0CCAnimationFrame@cocos2d@@QEAA@XZ"]
    pub fn cocos2d_CCAnimationFrame_CCAnimationFrame(this: *mut cocos2d_CCAnimationFrame);
}
impl cocos2d_CCAnimationFrame {
    #[inline]
    pub unsafe fn initWithSpriteFrame(
        &mut self,
        spriteFrame: *mut cocos2d_CCSpriteFrame,
        delayUnits: f32,
        userInfo: *mut cocos2d_CCDictionary,
    ) -> bool {
        cocos2d_CCAnimationFrame_initWithSpriteFrame(self, spriteFrame, delayUnits, userInfo)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cocos2d_CCAnimationFrame_CCAnimationFrame(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
}
extern "C" {
    #[doc = "  @js NA"]
    #[doc = "  @lua NA"]
    #[link_name = "\u{1}??_DCCAnimationFrame@cocos2d@@QEAAXXZ"]
    pub fn cocos2d_CCAnimationFrame_CCAnimationFrame_destructor(
        this: *mut cocos2d_CCAnimationFrame,
    );
}
extern "C" {
    #[doc = "  @js NA"]
    #[doc = "  @lua NA"]
    #[link_name = "\u{1}?copyWithZone@CCAnimationFrame@cocos2d@@UEAAPEAVCCObject@2@PEAVCCZone@2@@Z"]
    pub fn cocos2d_CCAnimationFrame_copyWithZone(
        this: *mut ::std::os::raw::c_void,
        pZone: *mut cocos2d_CCZone,
    ) -> *mut cocos2d_CCObject;
}
#[doc = " A CCAnimation object is used to perform animations on the CCSprite objects."]
#[doc = ""]
#[doc = "The CCAnimation object contains CCAnimationFrame objects, and a possible delay between the frames."]
#[doc = "You can animate a CCAnimation object by using the CCAnimate action. Example:"]
#[doc = ""]
#[doc = "[sprite runAction:[CCAnimate actionWithAnimation:animation]];"]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCAnimation {
    pub _base: cocos2d_CCObject,
    pub m_fTotalDelayUnits: f32,
    pub m_fDelayPerUnit: f32,
    pub m_fDuration: f32,
    pub m_pFrames: *mut cocos2d_CCArray,
    pub m_bRestoreOriginalFrame: bool,
    pub m_uLoops: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_cocos2d_CCAnimation() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCAnimation>(),
        72usize,
        concat!("Size of: ", stringify!(cocos2d_CCAnimation))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCAnimation>(),
        8usize,
        concat!("Alignment of ", stringify!(cocos2d_CCAnimation))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cocos2d_CCAnimation>())).m_fTotalDelayUnits as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCAnimation),
            "::",
            stringify!(m_fTotalDelayUnits)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cocos2d_CCAnimation>())).m_fDelayPerUnit as *const _ as usize
        },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCAnimation),
            "::",
            stringify!(m_fDelayPerUnit)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cocos2d_CCAnimation>())).m_fDuration as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCAnimation),
            "::",
            stringify!(m_fDuration)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cocos2d_CCAnimation>())).m_pFrames as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCAnimation),
            "::",
            stringify!(m_pFrames)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cocos2d_CCAnimation>())).m_bRestoreOriginalFrame as *const _
                as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCAnimation),
            "::",
            stringify!(m_bRestoreOriginalFrame)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cocos2d_CCAnimation>())).m_uLoops as *const _ as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCAnimation),
            "::",
            stringify!(m_uLoops)
        )
    );
}
extern "C" {
    #[doc = " Creates an animation"]
    #[doc = "@since v0.99.5"]
    #[link_name = "\u{1}?create@CCAnimation@cocos2d@@SAPEAV12@XZ"]
    pub fn cocos2d_CCAnimation_create() -> *mut cocos2d_CCAnimation;
}
extern "C" {
    #[link_name = "\u{1}?createWithSpriteFrames@CCAnimation@cocos2d@@SAPEAV12@PEAVCCArray@2@M@Z"]
    pub fn cocos2d_CCAnimation_createWithSpriteFrames(
        arrayOfSpriteFrameNames: *mut cocos2d_CCArray,
        delay: f32,
    ) -> *mut cocos2d_CCAnimation;
}
extern "C" {
    #[link_name = "\u{1}?create@CCAnimation@cocos2d@@SAPEAV12@PEAVCCArray@2@MI@Z"]
    pub fn cocos2d_CCAnimation_create1(
        arrayOfAnimationFrameNames: *mut cocos2d_CCArray,
        delayPerUnit: f32,
        loops: ::std::os::raw::c_uint,
    ) -> *mut cocos2d_CCAnimation;
}
extern "C" {
    #[doc = " Adds a CCSpriteFrame to a CCAnimation."]
    #[doc = "The frame will be added with one \"delay unit\"."]
    #[link_name = "\u{1}?addSpriteFrame@CCAnimation@cocos2d@@QEAAXPEAVCCSpriteFrame@2@@Z"]
    pub fn cocos2d_CCAnimation_addSpriteFrame(
        this: *mut cocos2d_CCAnimation,
        pFrame: *mut cocos2d_CCSpriteFrame,
    );
}
extern "C" {
    #[doc = " Adds a frame with an image filename. Internally it will create a CCSpriteFrame and it will add it."]
    #[doc = "The frame will be added with one \"delay unit\"."]
    #[doc = "Added to facilitate the migration from v0.8 to v0.9."]
    #[doc = " @js addSpriteFrameWithFile"]
    #[link_name = "\u{1}?addSpriteFrameWithFileName@CCAnimation@cocos2d@@QEAAXPEBD@Z"]
    pub fn cocos2d_CCAnimation_addSpriteFrameWithFileName(
        this: *mut cocos2d_CCAnimation,
        pszFileName: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    #[doc = " Adds a frame with a texture and a rect. Internally it will create a CCSpriteFrame and it will add it."]
    #[doc = "The frame will be added with one \"delay unit\"."]
    #[doc = "Added to facilitate the migration from v0.8 to v0.9."]
    #[link_name = "\u{1}?addSpriteFrameWithTexture@CCAnimation@cocos2d@@QEAAXPEAVCCTexture2D@2@AEBVCCRect@2@@Z"]
    pub fn cocos2d_CCAnimation_addSpriteFrameWithTexture(
        this: *mut cocos2d_CCAnimation,
        pobTexture: *mut cocos2d_CCTexture2D,
        rect: *const cocos2d_CCRect,
    );
}
extern "C" {
    #[doc = " @lua NA"]
    #[link_name = "\u{1}?init@CCAnimation@cocos2d@@QEAA_NXZ"]
    pub fn cocos2d_CCAnimation_init(this: *mut cocos2d_CCAnimation) -> bool;
}
extern "C" {
    #[doc = " Initializes a CCAnimation with frames and a delay between frames"]
    #[doc = "@since v0.99.5"]
    #[doc = "@lua NA"]
    #[link_name = "\u{1}?initWithSpriteFrames@CCAnimation@cocos2d@@QEAA_NPEAVCCArray@2@M@Z"]
    pub fn cocos2d_CCAnimation_initWithSpriteFrames(
        this: *mut cocos2d_CCAnimation,
        pFrames: *mut cocos2d_CCArray,
        delay: f32,
    ) -> bool;
}
extern "C" {
    #[doc = " Initializes a CCAnimation with CCAnimationFrame"]
    #[doc = "@since v2.0"]
    #[doc = "@lua NA"]
    #[link_name = "\u{1}?initWithAnimationFrames@CCAnimation@cocos2d@@QEAA_NPEAVCCArray@2@MI@Z"]
    pub fn cocos2d_CCAnimation_initWithAnimationFrames(
        this: *mut cocos2d_CCAnimation,
        arrayOfAnimationFrames: *mut cocos2d_CCArray,
        delayPerUnit: f32,
        loops: ::std::os::raw::c_uint,
    ) -> bool;
}
extern "C" {
    #[doc = " @js ctor"]
    #[link_name = "\u{1}??0CCAnimation@cocos2d@@QEAA@XZ"]
    pub fn cocos2d_CCAnimation_CCAnimation(this: *mut cocos2d_CCAnimation);
}
impl cocos2d_CCAnimation {
    #[inline]
    pub unsafe fn create() -> *mut cocos2d_CCAnimation {
        cocos2d_CCAnimation_create()
    }
    #[inline]
    pub unsafe fn createWithSpriteFrames(
        arrayOfSpriteFrameNames: *mut cocos2d_CCArray,
        delay: f32,
    ) -> *mut cocos2d_CCAnimation {
        cocos2d_CCAnimation_createWithSpriteFrames(arrayOfSpriteFrameNames, delay)
    }
    #[inline]
    pub unsafe fn create1(
        arrayOfAnimationFrameNames: *mut cocos2d_CCArray,
        delayPerUnit: f32,
        loops: ::std::os::raw::c_uint,
    ) -> *mut cocos2d_CCAnimation {
        cocos2d_CCAnimation_create1(arrayOfAnimationFrameNames, delayPerUnit, loops)
    }
    #[inline]
    pub unsafe fn addSpriteFrame(&mut self, pFrame: *mut cocos2d_CCSpriteFrame) {
        cocos2d_CCAnimation_addSpriteFrame(self, pFrame)
    }
    #[inline]
    pub unsafe fn addSpriteFrameWithFileName(
        &mut self,
        pszFileName: *const ::std::os::raw::c_char,
    ) {
        cocos2d_CCAnimation_addSpriteFrameWithFileName(self, pszFileName)
    }
    #[inline]
    pub unsafe fn addSpriteFrameWithTexture(
        &mut self,
        pobTexture: *mut cocos2d_CCTexture2D,
        rect: *const cocos2d_CCRect,
    ) {
        cocos2d_CCAnimation_addSpriteFrameWithTexture(self, pobTexture, rect)
    }
    #[inline]
    pub unsafe fn init(&mut self) -> bool {
        cocos2d_CCAnimation_init(self)
    }
    #[inline]
    pub unsafe fn initWithSpriteFrames(
        &mut self,
        pFrames: *mut cocos2d_CCArray,
        delay: f32,
    ) -> bool {
        cocos2d_CCAnimation_initWithSpriteFrames(self, pFrames, delay)
    }
    #[inline]
    pub unsafe fn initWithAnimationFrames(
        &mut self,
        arrayOfAnimationFrames: *mut cocos2d_CCArray,
        delayPerUnit: f32,
        loops: ::std::os::raw::c_uint,
    ) -> bool {
        cocos2d_CCAnimation_initWithAnimationFrames(
            self,
            arrayOfAnimationFrames,
            delayPerUnit,
            loops,
        )
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cocos2d_CCAnimation_CCAnimation(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
}
extern "C" {
    #[doc = " @js NA"]
    #[doc = " @lua NA"]
    #[link_name = "\u{1}??_DCCAnimation@cocos2d@@QEAAXXZ"]
    pub fn cocos2d_CCAnimation_CCAnimation_destructor(this: *mut cocos2d_CCAnimation);
}
extern "C" {
    #[doc = " @js NA"]
    #[doc = " @lua NA"]
    #[link_name = "\u{1}?copyWithZone@CCAnimation@cocos2d@@UEAAPEAVCCObject@2@PEAVCCZone@2@@Z"]
    pub fn cocos2d_CCAnimation_copyWithZone(
        this: *mut ::std::os::raw::c_void,
        pZone: *mut cocos2d_CCZone,
    ) -> *mut cocos2d_CCObject;
}
extern "C" {
    #[link_name = "\u{1}?getDuration@CCAnimation@cocos2d@@UEAAMXZ"]
    pub fn cocos2d_CCAnimation_getDuration(this: *mut ::std::os::raw::c_void) -> f32;
}
#[doc = " @addtogroup transition"]
#[doc = " @{"]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCActionInterval {
    pub _base: cocos2d_CCFiniteTimeAction,
    pub m_elapsed: f32,
    pub m_bFirstTick: bool,
}
#[test]
fn bindgen_test_layout_cocos2d_CCActionInterval() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCActionInterval>(),
        80usize,
        concat!("Size of: ", stringify!(cocos2d_CCActionInterval))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCActionInterval>(),
        8usize,
        concat!("Alignment of ", stringify!(cocos2d_CCActionInterval))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cocos2d_CCActionInterval>())).m_elapsed as *const _ as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCActionInterval),
            "::",
            stringify!(m_elapsed)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cocos2d_CCActionInterval>())).m_bFirstTick as *const _ as usize
        },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCActionInterval),
            "::",
            stringify!(m_bFirstTick)
        )
    );
}
extern "C" {
    #[doc = " initializes the action"]
    #[link_name = "\u{1}?initWithDuration@CCActionInterval@cocos2d@@QEAA_NM@Z"]
    pub fn cocos2d_CCActionInterval_initWithDuration(
        this: *mut cocos2d_CCActionInterval,
        d: f32,
    ) -> bool;
}
extern "C" {
    #[doc = " creates the action"]
    #[link_name = "\u{1}?create@CCActionInterval@cocos2d@@SAPEAV12@M@Z"]
    pub fn cocos2d_CCActionInterval_create(d: f32) -> *mut cocos2d_CCActionInterval;
}
extern "C" {
    #[link_name = "\u{1}?setAmplitudeRate@CCActionInterval@cocos2d@@QEAAXM@Z"]
    pub fn cocos2d_CCActionInterval_setAmplitudeRate(this: *mut cocos2d_CCActionInterval, amp: f32);
}
extern "C" {
    #[link_name = "\u{1}?getAmplitudeRate@CCActionInterval@cocos2d@@QEAAMXZ"]
    pub fn cocos2d_CCActionInterval_getAmplitudeRate(this: *mut cocos2d_CCActionInterval) -> f32;
}
impl cocos2d_CCActionInterval {
    #[inline]
    pub unsafe fn initWithDuration(&mut self, d: f32) -> bool {
        cocos2d_CCActionInterval_initWithDuration(self, d)
    }
    #[inline]
    pub unsafe fn create(d: f32) -> *mut cocos2d_CCActionInterval {
        cocos2d_CCActionInterval_create(d)
    }
    #[inline]
    pub unsafe fn setAmplitudeRate(&mut self, amp: f32) {
        cocos2d_CCActionInterval_setAmplitudeRate(self, amp)
    }
    #[inline]
    pub unsafe fn getAmplitudeRate(&mut self) -> f32 {
        cocos2d_CCActionInterval_getAmplitudeRate(self)
    }
}
extern "C" {
    #[doc = " returns true if the action has finished"]
    #[link_name = "\u{1}?isDone@CCActionInterval@cocos2d@@UEAA_NXZ"]
    pub fn cocos2d_CCActionInterval_isDone(this: *mut ::std::os::raw::c_void) -> bool;
}
extern "C" {
    #[doc = "  @js NA"]
    #[doc = "  @lua NA"]
    #[link_name = "\u{1}?copyWithZone@CCActionInterval@cocos2d@@UEAAPEAVCCObject@2@PEAVCCZone@2@@Z"]
    pub fn cocos2d_CCActionInterval_copyWithZone(
        this: *mut ::std::os::raw::c_void,
        pZone: *mut cocos2d_CCZone,
    ) -> *mut cocos2d_CCObject;
}
extern "C" {
    #[link_name = "\u{1}?step@CCActionInterval@cocos2d@@UEAAXM@Z"]
    pub fn cocos2d_CCActionInterval_step(this: *mut ::std::os::raw::c_void, dt: f32);
}
extern "C" {
    #[link_name = "\u{1}?startWithTarget@CCActionInterval@cocos2d@@UEAAXPEAVCCNode@2@@Z"]
    pub fn cocos2d_CCActionInterval_startWithTarget(
        this: *mut ::std::os::raw::c_void,
        pTarget: *mut cocos2d_CCNode,
    );
}
extern "C" {
    #[doc = " returns a reversed action"]
    #[link_name = "\u{1}?reverse@CCActionInterval@cocos2d@@UEAAPEAV12@XZ"]
    pub fn cocos2d_CCActionInterval_reverse(
        this: *mut ::std::os::raw::c_void,
    ) -> *mut cocos2d_CCActionInterval;
}
#[doc = " @brief Runs actions sequentially, one after another"]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCSequence {
    pub _base: cocos2d_CCActionInterval,
    pub m_pActions: [*mut cocos2d_CCFiniteTimeAction; 2usize],
    pub m_split: f32,
    pub m_last: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_cocos2d_CCSequence() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCSequence>(),
        104usize,
        concat!("Size of: ", stringify!(cocos2d_CCSequence))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCSequence>(),
        8usize,
        concat!("Alignment of ", stringify!(cocos2d_CCSequence))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cocos2d_CCSequence>())).m_pActions as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCSequence),
            "::",
            stringify!(m_pActions)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cocos2d_CCSequence>())).m_split as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCSequence),
            "::",
            stringify!(m_split)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cocos2d_CCSequence>())).m_last as *const _ as usize },
        100usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCSequence),
            "::",
            stringify!(m_last)
        )
    );
}
extern "C" {
    #[doc = " initializes the action"]
    #[doc = " @lua NA"]
    #[link_name = "\u{1}?initWithTwoActions@CCSequence@cocos2d@@QEAA_NPEAVCCFiniteTimeAction@2@0@Z"]
    pub fn cocos2d_CCSequence_initWithTwoActions(
        this: *mut cocos2d_CCSequence,
        pActionOne: *mut cocos2d_CCFiniteTimeAction,
        pActionTwo: *mut cocos2d_CCFiniteTimeAction,
    ) -> bool;
}
extern "C" {
    #[doc = " helper constructor to create an array of sequenceable actions"]
    #[doc = " @lua NA"]
    #[link_name = "\u{1}?create@CCSequence@cocos2d@@SAPEAV12@PEAVCCFiniteTimeAction@2@ZZ"]
    pub fn cocos2d_CCSequence_create(
        pAction1: *mut cocos2d_CCFiniteTimeAction,
        ...
    ) -> *mut cocos2d_CCSequence;
}
extern "C" {
    #[doc = " helper constructor to create an array of sequenceable actions given an array"]
    #[doc = " @js NA"]
    #[link_name = "\u{1}?create@CCSequence@cocos2d@@SAPEAV12@PEAVCCArray@2@@Z"]
    pub fn cocos2d_CCSequence_create1(
        arrayOfActions: *mut cocos2d_CCArray,
    ) -> *mut cocos2d_CCSequence;
}
extern "C" {
    #[doc = " helper constructor to create an array of sequence-able actions"]
    #[doc = " @js NA"]
    #[doc = " @lua NA"]
    #[link_name = "\u{1}?createWithVariableList@CCSequence@cocos2d@@SAPEAV12@PEAVCCFiniteTimeAction@2@PEAD@Z"]
    pub fn cocos2d_CCSequence_createWithVariableList(
        pAction1: *mut cocos2d_CCFiniteTimeAction,
        args: va_list,
    ) -> *mut cocos2d_CCSequence;
}
extern "C" {
    #[doc = " creates the action"]
    #[doc = " @js NA"]
    #[link_name = "\u{1}?createWithTwoActions@CCSequence@cocos2d@@SAPEAV12@PEAVCCFiniteTimeAction@2@0@Z"]
    pub fn cocos2d_CCSequence_createWithTwoActions(
        pActionOne: *mut cocos2d_CCFiniteTimeAction,
        pActionTwo: *mut cocos2d_CCFiniteTimeAction,
    ) -> *mut cocos2d_CCSequence;
}
impl cocos2d_CCSequence {
    #[inline]
    pub unsafe fn initWithTwoActions(
        &mut self,
        pActionOne: *mut cocos2d_CCFiniteTimeAction,
        pActionTwo: *mut cocos2d_CCFiniteTimeAction,
    ) -> bool {
        cocos2d_CCSequence_initWithTwoActions(self, pActionOne, pActionTwo)
    }
    #[inline]
    pub unsafe fn create(arrayOfActions: *mut cocos2d_CCArray) -> *mut cocos2d_CCSequence {
        cocos2d_CCSequence_create1(arrayOfActions)
    }
    #[inline]
    pub unsafe fn createWithVariableList(
        pAction1: *mut cocos2d_CCFiniteTimeAction,
        args: va_list,
    ) -> *mut cocos2d_CCSequence {
        cocos2d_CCSequence_createWithVariableList(pAction1, args)
    }
    #[inline]
    pub unsafe fn createWithTwoActions(
        pActionOne: *mut cocos2d_CCFiniteTimeAction,
        pActionTwo: *mut cocos2d_CCFiniteTimeAction,
    ) -> *mut cocos2d_CCSequence {
        cocos2d_CCSequence_createWithTwoActions(pActionOne, pActionTwo)
    }
}
extern "C" {
    #[doc = " @js NA"]
    #[doc = " @lua NA"]
    #[link_name = "\u{1}??_DCCSequence@cocos2d@@QEAAXXZ"]
    pub fn cocos2d_CCSequence_CCSequence_destructor(this: *mut cocos2d_CCSequence);
}
extern "C" {
    #[doc = "  @js NA"]
    #[doc = "  @lua NA"]
    #[link_name = "\u{1}?copyWithZone@CCSequence@cocos2d@@UEAAPEAVCCObject@2@PEAVCCZone@2@@Z"]
    pub fn cocos2d_CCSequence_copyWithZone(
        this: *mut ::std::os::raw::c_void,
        pZone: *mut cocos2d_CCZone,
    ) -> *mut cocos2d_CCObject;
}
extern "C" {
    #[doc = " @lua NA"]
    #[link_name = "\u{1}?startWithTarget@CCSequence@cocos2d@@UEAAXPEAVCCNode@2@@Z"]
    pub fn cocos2d_CCSequence_startWithTarget(
        this: *mut ::std::os::raw::c_void,
        pTarget: *mut cocos2d_CCNode,
    );
}
extern "C" {
    #[doc = " @lua NA"]
    #[link_name = "\u{1}?stop@CCSequence@cocos2d@@UEAAXXZ"]
    pub fn cocos2d_CCSequence_stop(this: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[doc = " @lua NA"]
    #[link_name = "\u{1}?update@CCSequence@cocos2d@@UEAAXM@Z"]
    pub fn cocos2d_CCSequence_update(this: *mut ::std::os::raw::c_void, t: f32);
}
extern "C" {
    #[link_name = "\u{1}?reverse@CCSequence@cocos2d@@UEAAPEAVCCActionInterval@2@XZ"]
    pub fn cocos2d_CCSequence_reverse(
        this: *mut ::std::os::raw::c_void,
    ) -> *mut cocos2d_CCActionInterval;
}
#[doc = " @brief Repeats an action a number of times."]
#[doc = " To repeat an action forever use the CCRepeatForever action."]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCRepeat {
    pub _base: cocos2d_CCActionInterval,
    pub m_uTimes: ::std::os::raw::c_uint,
    pub m_uTotal: ::std::os::raw::c_uint,
    pub m_fNextDt: f32,
    pub m_bActionInstant: bool,
    #[doc = " Inner action"]
    pub m_pInnerAction: *mut cocos2d_CCFiniteTimeAction,
}
#[test]
fn bindgen_test_layout_cocos2d_CCRepeat() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCRepeat>(),
        104usize,
        concat!("Size of: ", stringify!(cocos2d_CCRepeat))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCRepeat>(),
        8usize,
        concat!("Alignment of ", stringify!(cocos2d_CCRepeat))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cocos2d_CCRepeat>())).m_uTimes as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCRepeat),
            "::",
            stringify!(m_uTimes)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cocos2d_CCRepeat>())).m_uTotal as *const _ as usize },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCRepeat),
            "::",
            stringify!(m_uTotal)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cocos2d_CCRepeat>())).m_fNextDt as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCRepeat),
            "::",
            stringify!(m_fNextDt)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cocos2d_CCRepeat>())).m_bActionInstant as *const _ as usize
        },
        92usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCRepeat),
            "::",
            stringify!(m_bActionInstant)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cocos2d_CCRepeat>())).m_pInnerAction as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCRepeat),
            "::",
            stringify!(m_pInnerAction)
        )
    );
}
extern "C" {
    #[doc = " initializes a CCRepeat action. Times is an unsigned integer between 1 and pow(2,30)"]
    #[link_name = "\u{1}?initWithAction@CCRepeat@cocos2d@@QEAA_NPEAVCCFiniteTimeAction@2@I@Z"]
    pub fn cocos2d_CCRepeat_initWithAction(
        this: *mut cocos2d_CCRepeat,
        pAction: *mut cocos2d_CCFiniteTimeAction,
        times: ::std::os::raw::c_uint,
    ) -> bool;
}
extern "C" {
    #[doc = " creates a CCRepeat action. Times is an unsigned integer between 1 and pow(2,30)"]
    #[link_name = "\u{1}?create@CCRepeat@cocos2d@@SAPEAV12@PEAVCCFiniteTimeAction@2@I@Z"]
    pub fn cocos2d_CCRepeat_create(
        pAction: *mut cocos2d_CCFiniteTimeAction,
        times: ::std::os::raw::c_uint,
    ) -> *mut cocos2d_CCRepeat;
}
impl cocos2d_CCRepeat {
    #[inline]
    pub unsafe fn initWithAction(
        &mut self,
        pAction: *mut cocos2d_CCFiniteTimeAction,
        times: ::std::os::raw::c_uint,
    ) -> bool {
        cocos2d_CCRepeat_initWithAction(self, pAction, times)
    }
    #[inline]
    pub unsafe fn create(
        pAction: *mut cocos2d_CCFiniteTimeAction,
        times: ::std::os::raw::c_uint,
    ) -> *mut cocos2d_CCRepeat {
        cocos2d_CCRepeat_create(pAction, times)
    }
}
extern "C" {
    #[doc = "  @js NA"]
    #[doc = "  @lua NA"]
    #[link_name = "\u{1}??_DCCRepeat@cocos2d@@QEAAXXZ"]
    pub fn cocos2d_CCRepeat_CCRepeat_destructor(this: *mut cocos2d_CCRepeat);
}
extern "C" {
    #[doc = "  @js NA"]
    #[doc = "  @lua NA"]
    #[link_name = "\u{1}?copyWithZone@CCRepeat@cocos2d@@UEAAPEAVCCObject@2@PEAVCCZone@2@@Z"]
    pub fn cocos2d_CCRepeat_copyWithZone(
        this: *mut ::std::os::raw::c_void,
        pZone: *mut cocos2d_CCZone,
    ) -> *mut cocos2d_CCObject;
}
extern "C" {
    #[link_name = "\u{1}?startWithTarget@CCRepeat@cocos2d@@UEAAXPEAVCCNode@2@@Z"]
    pub fn cocos2d_CCRepeat_startWithTarget(
        this: *mut ::std::os::raw::c_void,
        pTarget: *mut cocos2d_CCNode,
    );
}
extern "C" {
    #[link_name = "\u{1}?stop@CCRepeat@cocos2d@@UEAAXXZ"]
    pub fn cocos2d_CCRepeat_stop(this: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[link_name = "\u{1}?update@CCRepeat@cocos2d@@UEAAXM@Z"]
    pub fn cocos2d_CCRepeat_update(this: *mut ::std::os::raw::c_void, dt: f32);
}
extern "C" {
    #[link_name = "\u{1}?isDone@CCRepeat@cocos2d@@UEAA_NXZ"]
    pub fn cocos2d_CCRepeat_isDone(this: *mut ::std::os::raw::c_void) -> bool;
}
extern "C" {
    #[link_name = "\u{1}?reverse@CCRepeat@cocos2d@@UEAAPEAVCCActionInterval@2@XZ"]
    pub fn cocos2d_CCRepeat_reverse(
        this: *mut ::std::os::raw::c_void,
    ) -> *mut cocos2d_CCActionInterval;
}
#[doc = " @brief Repeats an action for ever."]
#[doc = "To repeat the an action for a limited number of times use the Repeat action."]
#[doc = "@warning This action can't be Sequenceable because it is not an IntervalAction"]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCRepeatForever {
    pub _base: cocos2d_CCActionInterval,
    #[doc = " Inner action"]
    pub m_pInnerAction: *mut cocos2d_CCActionInterval,
}
#[test]
fn bindgen_test_layout_cocos2d_CCRepeatForever() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCRepeatForever>(),
        88usize,
        concat!("Size of: ", stringify!(cocos2d_CCRepeatForever))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCRepeatForever>(),
        8usize,
        concat!("Alignment of ", stringify!(cocos2d_CCRepeatForever))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cocos2d_CCRepeatForever>())).m_pInnerAction as *const _ as usize
        },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCRepeatForever),
            "::",
            stringify!(m_pInnerAction)
        )
    );
}
extern "C" {
    #[doc = " initializes the action"]
    #[link_name = "\u{1}?initWithAction@CCRepeatForever@cocos2d@@QEAA_NPEAVCCActionInterval@2@@Z"]
    pub fn cocos2d_CCRepeatForever_initWithAction(
        this: *mut cocos2d_CCRepeatForever,
        pAction: *mut cocos2d_CCActionInterval,
    ) -> bool;
}
extern "C" {
    #[doc = " creates the action"]
    #[link_name = "\u{1}?create@CCRepeatForever@cocos2d@@SAPEAV12@PEAVCCActionInterval@2@@Z"]
    pub fn cocos2d_CCRepeatForever_create(
        pAction: *mut cocos2d_CCActionInterval,
    ) -> *mut cocos2d_CCRepeatForever;
}
impl cocos2d_CCRepeatForever {
    #[inline]
    pub unsafe fn initWithAction(&mut self, pAction: *mut cocos2d_CCActionInterval) -> bool {
        cocos2d_CCRepeatForever_initWithAction(self, pAction)
    }
    #[inline]
    pub unsafe fn create(pAction: *mut cocos2d_CCActionInterval) -> *mut cocos2d_CCRepeatForever {
        cocos2d_CCRepeatForever_create(pAction)
    }
}
extern "C" {
    #[doc = "  @js NA"]
    #[doc = "  @lua NA"]
    #[link_name = "\u{1}??_DCCRepeatForever@cocos2d@@QEAAXXZ"]
    pub fn cocos2d_CCRepeatForever_CCRepeatForever_destructor(this: *mut cocos2d_CCRepeatForever);
}
extern "C" {
    #[doc = "  @js NA"]
    #[doc = "  @lua NA"]
    #[link_name = "\u{1}?copyWithZone@CCRepeatForever@cocos2d@@UEAAPEAVCCObject@2@PEAVCCZone@2@@Z"]
    pub fn cocos2d_CCRepeatForever_copyWithZone(
        this: *mut ::std::os::raw::c_void,
        pZone: *mut cocos2d_CCZone,
    ) -> *mut cocos2d_CCObject;
}
extern "C" {
    #[link_name = "\u{1}?startWithTarget@CCRepeatForever@cocos2d@@UEAAXPEAVCCNode@2@@Z"]
    pub fn cocos2d_CCRepeatForever_startWithTarget(
        this: *mut ::std::os::raw::c_void,
        pTarget: *mut cocos2d_CCNode,
    );
}
extern "C" {
    #[link_name = "\u{1}?step@CCRepeatForever@cocos2d@@UEAAXM@Z"]
    pub fn cocos2d_CCRepeatForever_step(this: *mut ::std::os::raw::c_void, dt: f32);
}
extern "C" {
    #[link_name = "\u{1}?isDone@CCRepeatForever@cocos2d@@UEAA_NXZ"]
    pub fn cocos2d_CCRepeatForever_isDone(this: *mut ::std::os::raw::c_void) -> bool;
}
extern "C" {
    #[link_name = "\u{1}?reverse@CCRepeatForever@cocos2d@@UEAAPEAVCCActionInterval@2@XZ"]
    pub fn cocos2d_CCRepeatForever_reverse(
        this: *mut ::std::os::raw::c_void,
    ) -> *mut cocos2d_CCActionInterval;
}
#[doc = " @brief Spawn a new action immediately"]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCSpawn {
    pub _base: cocos2d_CCActionInterval,
    pub m_pOne: *mut cocos2d_CCFiniteTimeAction,
    pub m_pTwo: *mut cocos2d_CCFiniteTimeAction,
}
#[test]
fn bindgen_test_layout_cocos2d_CCSpawn() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCSpawn>(),
        96usize,
        concat!("Size of: ", stringify!(cocos2d_CCSpawn))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCSpawn>(),
        8usize,
        concat!("Alignment of ", stringify!(cocos2d_CCSpawn))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cocos2d_CCSpawn>())).m_pOne as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCSpawn),
            "::",
            stringify!(m_pOne)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cocos2d_CCSpawn>())).m_pTwo as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCSpawn),
            "::",
            stringify!(m_pTwo)
        )
    );
}
extern "C" {
    #[doc = " initializes the Spawn action with the 2 actions to spawn"]
    #[doc = " @lua NA"]
    #[link_name = "\u{1}?initWithTwoActions@CCSpawn@cocos2d@@QEAA_NPEAVCCFiniteTimeAction@2@0@Z"]
    pub fn cocos2d_CCSpawn_initWithTwoActions(
        this: *mut cocos2d_CCSpawn,
        pAction1: *mut cocos2d_CCFiniteTimeAction,
        pAction2: *mut cocos2d_CCFiniteTimeAction,
    ) -> bool;
}
extern "C" {
    #[doc = " helper constructor to create an array of spawned actions"]
    #[doc = " @lua NA"]
    #[link_name = "\u{1}?create@CCSpawn@cocos2d@@SAPEAV12@PEAVCCFiniteTimeAction@2@ZZ"]
    pub fn cocos2d_CCSpawn_create(
        pAction1: *mut cocos2d_CCFiniteTimeAction,
        ...
    ) -> *mut cocos2d_CCSpawn;
}
extern "C" {
    #[doc = " helper constructor to create an array of spawned actions"]
    #[doc = " @js  NA"]
    #[doc = " @lua NA"]
    #[link_name = "\u{1}?createWithVariableList@CCSpawn@cocos2d@@SAPEAV12@PEAVCCFiniteTimeAction@2@PEAD@Z"]
    pub fn cocos2d_CCSpawn_createWithVariableList(
        pAction1: *mut cocos2d_CCFiniteTimeAction,
        args: va_list,
    ) -> *mut cocos2d_CCSpawn;
}
extern "C" {
    #[doc = " helper constructor to create an array of spawned actions given an array"]
    #[doc = " @js NA"]
    #[link_name = "\u{1}?create@CCSpawn@cocos2d@@SAPEAV12@PEAVCCArray@2@@Z"]
    pub fn cocos2d_CCSpawn_create1(arrayOfActions: *mut cocos2d_CCArray) -> *mut cocos2d_CCSpawn;
}
extern "C" {
    #[doc = " creates the Spawn action"]
    #[doc = " @js NA"]
    #[link_name = "\u{1}?createWithTwoActions@CCSpawn@cocos2d@@SAPEAV12@PEAVCCFiniteTimeAction@2@0@Z"]
    pub fn cocos2d_CCSpawn_createWithTwoActions(
        pAction1: *mut cocos2d_CCFiniteTimeAction,
        pAction2: *mut cocos2d_CCFiniteTimeAction,
    ) -> *mut cocos2d_CCSpawn;
}
impl cocos2d_CCSpawn {
    #[inline]
    pub unsafe fn initWithTwoActions(
        &mut self,
        pAction1: *mut cocos2d_CCFiniteTimeAction,
        pAction2: *mut cocos2d_CCFiniteTimeAction,
    ) -> bool {
        cocos2d_CCSpawn_initWithTwoActions(self, pAction1, pAction2)
    }
    #[inline]
    pub unsafe fn createWithVariableList(
        pAction1: *mut cocos2d_CCFiniteTimeAction,
        args: va_list,
    ) -> *mut cocos2d_CCSpawn {
        cocos2d_CCSpawn_createWithVariableList(pAction1, args)
    }
    #[inline]
    pub unsafe fn create(arrayOfActions: *mut cocos2d_CCArray) -> *mut cocos2d_CCSpawn {
        cocos2d_CCSpawn_create1(arrayOfActions)
    }
    #[inline]
    pub unsafe fn createWithTwoActions(
        pAction1: *mut cocos2d_CCFiniteTimeAction,
        pAction2: *mut cocos2d_CCFiniteTimeAction,
    ) -> *mut cocos2d_CCSpawn {
        cocos2d_CCSpawn_createWithTwoActions(pAction1, pAction2)
    }
}
extern "C" {
    #[doc = " @js NA"]
    #[doc = " @lua NA"]
    #[link_name = "\u{1}??_DCCSpawn@cocos2d@@QEAAXXZ"]
    pub fn cocos2d_CCSpawn_CCSpawn_destructor(this: *mut cocos2d_CCSpawn);
}
extern "C" {
    #[doc = "  @js NA"]
    #[doc = "  @lua NA"]
    #[link_name = "\u{1}?copyWithZone@CCSpawn@cocos2d@@UEAAPEAVCCObject@2@PEAVCCZone@2@@Z"]
    pub fn cocos2d_CCSpawn_copyWithZone(
        this: *mut ::std::os::raw::c_void,
        pZone: *mut cocos2d_CCZone,
    ) -> *mut cocos2d_CCObject;
}
extern "C" {
    #[doc = " @lua NA"]
    #[link_name = "\u{1}?startWithTarget@CCSpawn@cocos2d@@UEAAXPEAVCCNode@2@@Z"]
    pub fn cocos2d_CCSpawn_startWithTarget(
        this: *mut ::std::os::raw::c_void,
        pTarget: *mut cocos2d_CCNode,
    );
}
extern "C" {
    #[doc = " @lua NA"]
    #[link_name = "\u{1}?stop@CCSpawn@cocos2d@@UEAAXXZ"]
    pub fn cocos2d_CCSpawn_stop(this: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[doc = " @lua NA"]
    #[link_name = "\u{1}?update@CCSpawn@cocos2d@@UEAAXM@Z"]
    pub fn cocos2d_CCSpawn_update(this: *mut ::std::os::raw::c_void, time: f32);
}
extern "C" {
    #[link_name = "\u{1}?reverse@CCSpawn@cocos2d@@UEAAPEAVCCActionInterval@2@XZ"]
    pub fn cocos2d_CCSpawn_reverse(
        this: *mut ::std::os::raw::c_void,
    ) -> *mut cocos2d_CCActionInterval;
}
#[doc = " @brief Rotates a CCNode object to a certain angle by modifying it's"]
#[doc = "rotation attribute."]
#[doc = "The direction will be decided by the shortest angle."]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCRotateTo {
    pub _base: cocos2d_CCActionInterval,
    pub m_fDstAngleX: f32,
    pub m_fStartAngleX: f32,
    pub m_fDiffAngleX: f32,
    pub m_fDstAngleY: f32,
    pub m_fStartAngleY: f32,
    pub m_fDiffAngleY: f32,
}
#[test]
fn bindgen_test_layout_cocos2d_CCRotateTo() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCRotateTo>(),
        104usize,
        concat!("Size of: ", stringify!(cocos2d_CCRotateTo))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCRotateTo>(),
        8usize,
        concat!("Alignment of ", stringify!(cocos2d_CCRotateTo))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cocos2d_CCRotateTo>())).m_fDstAngleX as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCRotateTo),
            "::",
            stringify!(m_fDstAngleX)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cocos2d_CCRotateTo>())).m_fStartAngleX as *const _ as usize
        },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCRotateTo),
            "::",
            stringify!(m_fStartAngleX)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cocos2d_CCRotateTo>())).m_fDiffAngleX as *const _ as usize
        },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCRotateTo),
            "::",
            stringify!(m_fDiffAngleX)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cocos2d_CCRotateTo>())).m_fDstAngleY as *const _ as usize },
        92usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCRotateTo),
            "::",
            stringify!(m_fDstAngleY)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cocos2d_CCRotateTo>())).m_fStartAngleY as *const _ as usize
        },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCRotateTo),
            "::",
            stringify!(m_fStartAngleY)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cocos2d_CCRotateTo>())).m_fDiffAngleY as *const _ as usize
        },
        100usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCRotateTo),
            "::",
            stringify!(m_fDiffAngleY)
        )
    );
}
extern "C" {
    #[doc = " creates the action"]
    #[link_name = "\u{1}?create@CCRotateTo@cocos2d@@SAPEAV12@MM@Z"]
    pub fn cocos2d_CCRotateTo_create(fDuration: f32, fDeltaAngle: f32) -> *mut cocos2d_CCRotateTo;
}
extern "C" {
    #[doc = " initializes the action"]
    #[link_name = "\u{1}?initWithDuration@CCRotateTo@cocos2d@@QEAA_NMM@Z"]
    pub fn cocos2d_CCRotateTo_initWithDuration(
        this: *mut cocos2d_CCRotateTo,
        fDuration: f32,
        fDeltaAngle: f32,
    ) -> bool;
}
extern "C" {
    #[doc = " creates the action with separate rotation angles"]
    #[link_name = "\u{1}?create@CCRotateTo@cocos2d@@SAPEAV12@MMM@Z"]
    pub fn cocos2d_CCRotateTo_create1(
        fDuration: f32,
        fDeltaAngleX: f32,
        fDeltaAngleY: f32,
    ) -> *mut cocos2d_CCRotateTo;
}
impl cocos2d_CCRotateTo {
    #[inline]
    pub unsafe fn create(fDuration: f32, fDeltaAngle: f32) -> *mut cocos2d_CCRotateTo {
        cocos2d_CCRotateTo_create(fDuration, fDeltaAngle)
    }
    #[inline]
    pub unsafe fn initWithDuration(&mut self, fDuration: f32, fDeltaAngle: f32) -> bool {
        cocos2d_CCRotateTo_initWithDuration(self, fDuration, fDeltaAngle)
    }
    #[inline]
    pub unsafe fn create1(
        fDuration: f32,
        fDeltaAngleX: f32,
        fDeltaAngleY: f32,
    ) -> *mut cocos2d_CCRotateTo {
        cocos2d_CCRotateTo_create1(fDuration, fDeltaAngleX, fDeltaAngleY)
    }
}
extern "C" {
    #[link_name = "\u{1}?initWithDuration@CCRotateTo@cocos2d@@UEAA_NMMM@Z"]
    pub fn cocos2d_CCRotateTo_initWithDuration1(
        this: *mut ::std::os::raw::c_void,
        fDuration: f32,
        fDeltaAngleX: f32,
        fDeltaAngleY: f32,
    ) -> bool;
}
extern "C" {
    #[doc = "  @js NA"]
    #[doc = "  @lua NA"]
    #[link_name = "\u{1}?copyWithZone@CCRotateTo@cocos2d@@UEAAPEAVCCObject@2@PEAVCCZone@2@@Z"]
    pub fn cocos2d_CCRotateTo_copyWithZone(
        this: *mut ::std::os::raw::c_void,
        pZone: *mut cocos2d_CCZone,
    ) -> *mut cocos2d_CCObject;
}
extern "C" {
    #[link_name = "\u{1}?startWithTarget@CCRotateTo@cocos2d@@UEAAXPEAVCCNode@2@@Z"]
    pub fn cocos2d_CCRotateTo_startWithTarget(
        this: *mut ::std::os::raw::c_void,
        pTarget: *mut cocos2d_CCNode,
    );
}
extern "C" {
    #[link_name = "\u{1}?update@CCRotateTo@cocos2d@@UEAAXM@Z"]
    pub fn cocos2d_CCRotateTo_update(this: *mut ::std::os::raw::c_void, time: f32);
}
#[doc = " @brief Rotates a CCNode object clockwise a number of degrees by modifying it's rotation attribute."]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCRotateBy {
    pub _base: cocos2d_CCActionInterval,
    pub m_fAngleX: f32,
    pub m_fStartAngleX: f32,
    pub m_fAngleY: f32,
    pub m_fStartAngleY: f32,
}
#[test]
fn bindgen_test_layout_cocos2d_CCRotateBy() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCRotateBy>(),
        96usize,
        concat!("Size of: ", stringify!(cocos2d_CCRotateBy))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCRotateBy>(),
        8usize,
        concat!("Alignment of ", stringify!(cocos2d_CCRotateBy))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cocos2d_CCRotateBy>())).m_fAngleX as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCRotateBy),
            "::",
            stringify!(m_fAngleX)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cocos2d_CCRotateBy>())).m_fStartAngleX as *const _ as usize
        },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCRotateBy),
            "::",
            stringify!(m_fStartAngleX)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cocos2d_CCRotateBy>())).m_fAngleY as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCRotateBy),
            "::",
            stringify!(m_fAngleY)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cocos2d_CCRotateBy>())).m_fStartAngleY as *const _ as usize
        },
        92usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCRotateBy),
            "::",
            stringify!(m_fStartAngleY)
        )
    );
}
extern "C" {
    #[doc = " creates the action"]
    #[link_name = "\u{1}?create@CCRotateBy@cocos2d@@SAPEAV12@MM@Z"]
    pub fn cocos2d_CCRotateBy_create(fDuration: f32, fDeltaAngle: f32) -> *mut cocos2d_CCRotateBy;
}
extern "C" {
    #[doc = " initializes the action"]
    #[link_name = "\u{1}?initWithDuration@CCRotateBy@cocos2d@@QEAA_NMM@Z"]
    pub fn cocos2d_CCRotateBy_initWithDuration(
        this: *mut cocos2d_CCRotateBy,
        fDuration: f32,
        fDeltaAngle: f32,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}?create@CCRotateBy@cocos2d@@SAPEAV12@MMM@Z"]
    pub fn cocos2d_CCRotateBy_create1(
        fDuration: f32,
        fDeltaAngleX: f32,
        fDeltaAngleY: f32,
    ) -> *mut cocos2d_CCRotateBy;
}
extern "C" {
    #[link_name = "\u{1}?initWithDuration@CCRotateBy@cocos2d@@QEAA_NMMM@Z"]
    pub fn cocos2d_CCRotateBy_initWithDuration1(
        this: *mut cocos2d_CCRotateBy,
        fDuration: f32,
        fDeltaAngleX: f32,
        fDeltaAngleY: f32,
    ) -> bool;
}
impl cocos2d_CCRotateBy {
    #[inline]
    pub unsafe fn create(fDuration: f32, fDeltaAngle: f32) -> *mut cocos2d_CCRotateBy {
        cocos2d_CCRotateBy_create(fDuration, fDeltaAngle)
    }
    #[inline]
    pub unsafe fn initWithDuration(&mut self, fDuration: f32, fDeltaAngle: f32) -> bool {
        cocos2d_CCRotateBy_initWithDuration(self, fDuration, fDeltaAngle)
    }
    #[inline]
    pub unsafe fn create1(
        fDuration: f32,
        fDeltaAngleX: f32,
        fDeltaAngleY: f32,
    ) -> *mut cocos2d_CCRotateBy {
        cocos2d_CCRotateBy_create1(fDuration, fDeltaAngleX, fDeltaAngleY)
    }
    #[inline]
    pub unsafe fn initWithDuration1(
        &mut self,
        fDuration: f32,
        fDeltaAngleX: f32,
        fDeltaAngleY: f32,
    ) -> bool {
        cocos2d_CCRotateBy_initWithDuration1(self, fDuration, fDeltaAngleX, fDeltaAngleY)
    }
}
extern "C" {
    #[doc = "  @js NA"]
    #[doc = "  @lua NA"]
    #[link_name = "\u{1}?copyWithZone@CCRotateBy@cocos2d@@UEAAPEAVCCObject@2@PEAVCCZone@2@@Z"]
    pub fn cocos2d_CCRotateBy_copyWithZone(
        this: *mut ::std::os::raw::c_void,
        pZone: *mut cocos2d_CCZone,
    ) -> *mut cocos2d_CCObject;
}
extern "C" {
    #[link_name = "\u{1}?startWithTarget@CCRotateBy@cocos2d@@UEAAXPEAVCCNode@2@@Z"]
    pub fn cocos2d_CCRotateBy_startWithTarget(
        this: *mut ::std::os::raw::c_void,
        pTarget: *mut cocos2d_CCNode,
    );
}
extern "C" {
    #[link_name = "\u{1}?update@CCRotateBy@cocos2d@@UEAAXM@Z"]
    pub fn cocos2d_CCRotateBy_update(this: *mut ::std::os::raw::c_void, time: f32);
}
extern "C" {
    #[link_name = "\u{1}?reverse@CCRotateBy@cocos2d@@UEAAPEAVCCActionInterval@2@XZ"]
    pub fn cocos2d_CCRotateBy_reverse(
        this: *mut ::std::os::raw::c_void,
    ) -> *mut cocos2d_CCActionInterval;
}
#[doc = "  Moves a CCNode object x,y pixels by modifying it's position attribute."]
#[doc = "x and y are relative to the position of the object."]
#[doc = "Several CCMoveBy actions can be concurrently called, and the resulting"]
#[doc = "movement will be the sum of individual movements."]
#[doc = "@since v2.1beta2-custom"]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCMoveBy {
    pub _base: cocos2d_CCActionInterval,
    pub m_positionDelta: cocos2d_CCPoint,
    pub m_startPosition: cocos2d_CCPoint,
    pub m_previousPosition: cocos2d_CCPoint,
}
#[test]
fn bindgen_test_layout_cocos2d_CCMoveBy() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCMoveBy>(),
        104usize,
        concat!("Size of: ", stringify!(cocos2d_CCMoveBy))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCMoveBy>(),
        8usize,
        concat!("Alignment of ", stringify!(cocos2d_CCMoveBy))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cocos2d_CCMoveBy>())).m_positionDelta as *const _ as usize
        },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCMoveBy),
            "::",
            stringify!(m_positionDelta)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cocos2d_CCMoveBy>())).m_startPosition as *const _ as usize
        },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCMoveBy),
            "::",
            stringify!(m_startPosition)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cocos2d_CCMoveBy>())).m_previousPosition as *const _ as usize
        },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCMoveBy),
            "::",
            stringify!(m_previousPosition)
        )
    );
}
extern "C" {
    #[doc = " initializes the action"]
    #[link_name = "\u{1}?initWithDuration@CCMoveBy@cocos2d@@QEAA_NMAEBVCCPoint@2@@Z"]
    pub fn cocos2d_CCMoveBy_initWithDuration(
        this: *mut cocos2d_CCMoveBy,
        duration: f32,
        deltaPosition: *const cocos2d_CCPoint,
    ) -> bool;
}
extern "C" {
    #[doc = " creates the action"]
    #[link_name = "\u{1}?create@CCMoveBy@cocos2d@@SAPEAV12@MAEBVCCPoint@2@@Z"]
    pub fn cocos2d_CCMoveBy_create(
        duration: f32,
        deltaPosition: *const cocos2d_CCPoint,
    ) -> *mut cocos2d_CCMoveBy;
}
impl cocos2d_CCMoveBy {
    #[inline]
    pub unsafe fn initWithDuration(
        &mut self,
        duration: f32,
        deltaPosition: *const cocos2d_CCPoint,
    ) -> bool {
        cocos2d_CCMoveBy_initWithDuration(self, duration, deltaPosition)
    }
    #[inline]
    pub unsafe fn create(
        duration: f32,
        deltaPosition: *const cocos2d_CCPoint,
    ) -> *mut cocos2d_CCMoveBy {
        cocos2d_CCMoveBy_create(duration, deltaPosition)
    }
}
extern "C" {
    #[doc = "  @js NA"]
    #[doc = "  @lua NA"]
    #[link_name = "\u{1}?copyWithZone@CCMoveBy@cocos2d@@UEAAPEAVCCObject@2@PEAVCCZone@2@@Z"]
    pub fn cocos2d_CCMoveBy_copyWithZone(
        this: *mut ::std::os::raw::c_void,
        pZone: *mut cocos2d_CCZone,
    ) -> *mut cocos2d_CCObject;
}
extern "C" {
    #[link_name = "\u{1}?startWithTarget@CCMoveBy@cocos2d@@UEAAXPEAVCCNode@2@@Z"]
    pub fn cocos2d_CCMoveBy_startWithTarget(
        this: *mut ::std::os::raw::c_void,
        pTarget: *mut cocos2d_CCNode,
    );
}
extern "C" {
    #[link_name = "\u{1}?reverse@CCMoveBy@cocos2d@@UEAAPEAVCCActionInterval@2@XZ"]
    pub fn cocos2d_CCMoveBy_reverse(
        this: *mut ::std::os::raw::c_void,
    ) -> *mut cocos2d_CCActionInterval;
}
extern "C" {
    #[link_name = "\u{1}?update@CCMoveBy@cocos2d@@UEAAXM@Z"]
    pub fn cocos2d_CCMoveBy_update(this: *mut ::std::os::raw::c_void, time: f32);
}
#[doc = " Moves a CCNode object to the position x,y. x and y are absolute coordinates by modifying it's position attribute."]
#[doc = "Several CCMoveTo actions can be concurrently called, and the resulting"]
#[doc = "movement will be the sum of individual movements."]
#[doc = "@since v2.1beta2-custom"]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCMoveTo {
    pub _base: cocos2d_CCMoveBy,
    pub m_endPosition: cocos2d_CCPoint,
}
#[test]
fn bindgen_test_layout_cocos2d_CCMoveTo() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCMoveTo>(),
        112usize,
        concat!("Size of: ", stringify!(cocos2d_CCMoveTo))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCMoveTo>(),
        8usize,
        concat!("Alignment of ", stringify!(cocos2d_CCMoveTo))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cocos2d_CCMoveTo>())).m_endPosition as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCMoveTo),
            "::",
            stringify!(m_endPosition)
        )
    );
}
extern "C" {
    #[doc = " initializes the action"]
    #[link_name = "\u{1}?initWithDuration@CCMoveTo@cocos2d@@QEAA_NMAEBVCCPoint@2@@Z"]
    pub fn cocos2d_CCMoveTo_initWithDuration(
        this: *mut cocos2d_CCMoveTo,
        duration: f32,
        position: *const cocos2d_CCPoint,
    ) -> bool;
}
extern "C" {
    #[doc = " creates the action"]
    #[link_name = "\u{1}?create@CCMoveTo@cocos2d@@SAPEAV12@MAEBVCCPoint@2@@Z"]
    pub fn cocos2d_CCMoveTo_create(
        duration: f32,
        position: *const cocos2d_CCPoint,
    ) -> *mut cocos2d_CCMoveTo;
}
impl cocos2d_CCMoveTo {
    #[inline]
    pub unsafe fn initWithDuration(
        &mut self,
        duration: f32,
        position: *const cocos2d_CCPoint,
    ) -> bool {
        cocos2d_CCMoveTo_initWithDuration(self, duration, position)
    }
    #[inline]
    pub unsafe fn create(duration: f32, position: *const cocos2d_CCPoint) -> *mut cocos2d_CCMoveTo {
        cocos2d_CCMoveTo_create(duration, position)
    }
}
extern "C" {
    #[doc = "  @js NA"]
    #[doc = "  @lua NA"]
    #[link_name = "\u{1}?copyWithZone@CCMoveTo@cocos2d@@UEAAPEAVCCObject@2@PEAVCCZone@2@@Z"]
    pub fn cocos2d_CCMoveTo_copyWithZone(
        this: *mut ::std::os::raw::c_void,
        pZone: *mut cocos2d_CCZone,
    ) -> *mut cocos2d_CCObject;
}
extern "C" {
    #[link_name = "\u{1}?startWithTarget@CCMoveTo@cocos2d@@UEAAXPEAVCCNode@2@@Z"]
    pub fn cocos2d_CCMoveTo_startWithTarget(
        this: *mut ::std::os::raw::c_void,
        pTarget: *mut cocos2d_CCNode,
    );
}
#[doc = " Skews a CCNode object to given angles by modifying it's skewX and skewY attributes"]
#[doc = "@since v1.0"]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCSkewTo {
    pub _base: cocos2d_CCActionInterval,
    pub m_fSkewX: f32,
    pub m_fSkewY: f32,
    pub m_fStartSkewX: f32,
    pub m_fStartSkewY: f32,
    pub m_fEndSkewX: f32,
    pub m_fEndSkewY: f32,
    pub m_fDeltaX: f32,
    pub m_fDeltaY: f32,
}
#[test]
fn bindgen_test_layout_cocos2d_CCSkewTo() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCSkewTo>(),
        112usize,
        concat!("Size of: ", stringify!(cocos2d_CCSkewTo))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCSkewTo>(),
        8usize,
        concat!("Alignment of ", stringify!(cocos2d_CCSkewTo))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cocos2d_CCSkewTo>())).m_fSkewX as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCSkewTo),
            "::",
            stringify!(m_fSkewX)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cocos2d_CCSkewTo>())).m_fSkewY as *const _ as usize },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCSkewTo),
            "::",
            stringify!(m_fSkewY)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cocos2d_CCSkewTo>())).m_fStartSkewX as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCSkewTo),
            "::",
            stringify!(m_fStartSkewX)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cocos2d_CCSkewTo>())).m_fStartSkewY as *const _ as usize },
        92usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCSkewTo),
            "::",
            stringify!(m_fStartSkewY)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cocos2d_CCSkewTo>())).m_fEndSkewX as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCSkewTo),
            "::",
            stringify!(m_fEndSkewX)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cocos2d_CCSkewTo>())).m_fEndSkewY as *const _ as usize },
        100usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCSkewTo),
            "::",
            stringify!(m_fEndSkewY)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cocos2d_CCSkewTo>())).m_fDeltaX as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCSkewTo),
            "::",
            stringify!(m_fDeltaX)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cocos2d_CCSkewTo>())).m_fDeltaY as *const _ as usize },
        108usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCSkewTo),
            "::",
            stringify!(m_fDeltaY)
        )
    );
}
extern "C" {
    #[doc = " creates the action"]
    #[link_name = "\u{1}?create@CCSkewTo@cocos2d@@SAPEAV12@MMM@Z"]
    pub fn cocos2d_CCSkewTo_create(t: f32, sx: f32, sy: f32) -> *mut cocos2d_CCSkewTo;
}
extern "C" {
    #[doc = "  @js ctor"]
    #[link_name = "\u{1}??0CCSkewTo@cocos2d@@QEAA@XZ"]
    pub fn cocos2d_CCSkewTo_CCSkewTo(this: *mut cocos2d_CCSkewTo);
}
impl cocos2d_CCSkewTo {
    #[inline]
    pub unsafe fn create(t: f32, sx: f32, sy: f32) -> *mut cocos2d_CCSkewTo {
        cocos2d_CCSkewTo_create(t, sx, sy)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cocos2d_CCSkewTo_CCSkewTo(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
}
extern "C" {
    #[link_name = "\u{1}?initWithDuration@CCSkewTo@cocos2d@@UEAA_NMMM@Z"]
    pub fn cocos2d_CCSkewTo_initWithDuration(
        this: *mut ::std::os::raw::c_void,
        t: f32,
        sx: f32,
        sy: f32,
    ) -> bool;
}
extern "C" {
    #[doc = "  @js NA"]
    #[doc = "  @lua NA"]
    #[link_name = "\u{1}?copyWithZone@CCSkewTo@cocos2d@@UEAAPEAVCCObject@2@PEAVCCZone@2@@Z"]
    pub fn cocos2d_CCSkewTo_copyWithZone(
        this: *mut ::std::os::raw::c_void,
        pZone: *mut cocos2d_CCZone,
    ) -> *mut cocos2d_CCObject;
}
extern "C" {
    #[link_name = "\u{1}?startWithTarget@CCSkewTo@cocos2d@@UEAAXPEAVCCNode@2@@Z"]
    pub fn cocos2d_CCSkewTo_startWithTarget(
        this: *mut ::std::os::raw::c_void,
        pTarget: *mut cocos2d_CCNode,
    );
}
extern "C" {
    #[link_name = "\u{1}?update@CCSkewTo@cocos2d@@UEAAXM@Z"]
    pub fn cocos2d_CCSkewTo_update(this: *mut ::std::os::raw::c_void, time: f32);
}
#[doc = " Skews a CCNode object by skewX and skewY degrees"]
#[doc = "@since v1.0"]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCSkewBy {
    pub _base: cocos2d_CCSkewTo,
}
#[test]
fn bindgen_test_layout_cocos2d_CCSkewBy() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCSkewBy>(),
        112usize,
        concat!("Size of: ", stringify!(cocos2d_CCSkewBy))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCSkewBy>(),
        8usize,
        concat!("Alignment of ", stringify!(cocos2d_CCSkewBy))
    );
}
extern "C" {
    #[doc = " creates the action"]
    #[link_name = "\u{1}?create@CCSkewBy@cocos2d@@SAPEAV12@MMM@Z"]
    pub fn cocos2d_CCSkewBy_create(
        t: f32,
        deltaSkewX: f32,
        deltaSkewY: f32,
    ) -> *mut cocos2d_CCSkewBy;
}
impl cocos2d_CCSkewBy {
    #[inline]
    pub unsafe fn create(t: f32, deltaSkewX: f32, deltaSkewY: f32) -> *mut cocos2d_CCSkewBy {
        cocos2d_CCSkewBy_create(t, deltaSkewX, deltaSkewY)
    }
}
extern "C" {
    #[link_name = "\u{1}?initWithDuration@CCSkewBy@cocos2d@@UEAA_NMMM@Z"]
    pub fn cocos2d_CCSkewBy_initWithDuration(
        this: *mut ::std::os::raw::c_void,
        t: f32,
        sx: f32,
        sy: f32,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}?startWithTarget@CCSkewBy@cocos2d@@UEAAXPEAVCCNode@2@@Z"]
    pub fn cocos2d_CCSkewBy_startWithTarget(
        this: *mut ::std::os::raw::c_void,
        pTarget: *mut cocos2d_CCNode,
    );
}
extern "C" {
    #[link_name = "\u{1}?reverse@CCSkewBy@cocos2d@@UEAAPEAVCCActionInterval@2@XZ"]
    pub fn cocos2d_CCSkewBy_reverse(
        this: *mut ::std::os::raw::c_void,
    ) -> *mut cocos2d_CCActionInterval;
}
#[doc = " @brief Moves a CCNode object simulating a parabolic jump movement by modifying it's position attribute."]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCJumpBy {
    pub _base: cocos2d_CCActionInterval,
    pub m_startPosition: cocos2d_CCPoint,
    pub m_delta: cocos2d_CCPoint,
    pub m_height: f32,
    pub m_nJumps: ::std::os::raw::c_uint,
    pub m_previousPos: cocos2d_CCPoint,
}
#[test]
fn bindgen_test_layout_cocos2d_CCJumpBy() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCJumpBy>(),
        112usize,
        concat!("Size of: ", stringify!(cocos2d_CCJumpBy))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCJumpBy>(),
        8usize,
        concat!("Alignment of ", stringify!(cocos2d_CCJumpBy))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cocos2d_CCJumpBy>())).m_startPosition as *const _ as usize
        },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCJumpBy),
            "::",
            stringify!(m_startPosition)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cocos2d_CCJumpBy>())).m_delta as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCJumpBy),
            "::",
            stringify!(m_delta)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cocos2d_CCJumpBy>())).m_height as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCJumpBy),
            "::",
            stringify!(m_height)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cocos2d_CCJumpBy>())).m_nJumps as *const _ as usize },
        100usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCJumpBy),
            "::",
            stringify!(m_nJumps)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cocos2d_CCJumpBy>())).m_previousPos as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCJumpBy),
            "::",
            stringify!(m_previousPos)
        )
    );
}
extern "C" {
    #[doc = " initializes the action"]
    #[link_name = "\u{1}?initWithDuration@CCJumpBy@cocos2d@@QEAA_NMAEBVCCPoint@2@MI@Z"]
    pub fn cocos2d_CCJumpBy_initWithDuration(
        this: *mut cocos2d_CCJumpBy,
        duration: f32,
        position: *const cocos2d_CCPoint,
        height: f32,
        jumps: ::std::os::raw::c_uint,
    ) -> bool;
}
extern "C" {
    #[doc = " creates the action"]
    #[link_name = "\u{1}?create@CCJumpBy@cocos2d@@SAPEAV12@MAEBVCCPoint@2@MI@Z"]
    pub fn cocos2d_CCJumpBy_create(
        duration: f32,
        position: *const cocos2d_CCPoint,
        height: f32,
        jumps: ::std::os::raw::c_uint,
    ) -> *mut cocos2d_CCJumpBy;
}
impl cocos2d_CCJumpBy {
    #[inline]
    pub unsafe fn initWithDuration(
        &mut self,
        duration: f32,
        position: *const cocos2d_CCPoint,
        height: f32,
        jumps: ::std::os::raw::c_uint,
    ) -> bool {
        cocos2d_CCJumpBy_initWithDuration(self, duration, position, height, jumps)
    }
    #[inline]
    pub unsafe fn create(
        duration: f32,
        position: *const cocos2d_CCPoint,
        height: f32,
        jumps: ::std::os::raw::c_uint,
    ) -> *mut cocos2d_CCJumpBy {
        cocos2d_CCJumpBy_create(duration, position, height, jumps)
    }
}
extern "C" {
    #[doc = "  @js NA"]
    #[doc = "  @lua NA"]
    #[link_name = "\u{1}?copyWithZone@CCJumpBy@cocos2d@@UEAAPEAVCCObject@2@PEAVCCZone@2@@Z"]
    pub fn cocos2d_CCJumpBy_copyWithZone(
        this: *mut ::std::os::raw::c_void,
        pZone: *mut cocos2d_CCZone,
    ) -> *mut cocos2d_CCObject;
}
extern "C" {
    #[link_name = "\u{1}?startWithTarget@CCJumpBy@cocos2d@@UEAAXPEAVCCNode@2@@Z"]
    pub fn cocos2d_CCJumpBy_startWithTarget(
        this: *mut ::std::os::raw::c_void,
        pTarget: *mut cocos2d_CCNode,
    );
}
extern "C" {
    #[link_name = "\u{1}?update@CCJumpBy@cocos2d@@UEAAXM@Z"]
    pub fn cocos2d_CCJumpBy_update(this: *mut ::std::os::raw::c_void, time: f32);
}
extern "C" {
    #[link_name = "\u{1}?reverse@CCJumpBy@cocos2d@@UEAAPEAVCCActionInterval@2@XZ"]
    pub fn cocos2d_CCJumpBy_reverse(
        this: *mut ::std::os::raw::c_void,
    ) -> *mut cocos2d_CCActionInterval;
}
#[doc = " @brief Moves a CCNode object to a parabolic position simulating a jump movement by modifying it's position attribute."]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCJumpTo {
    pub _base: cocos2d_CCJumpBy,
}
#[test]
fn bindgen_test_layout_cocos2d_CCJumpTo() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCJumpTo>(),
        112usize,
        concat!("Size of: ", stringify!(cocos2d_CCJumpTo))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCJumpTo>(),
        8usize,
        concat!("Alignment of ", stringify!(cocos2d_CCJumpTo))
    );
}
extern "C" {
    #[doc = " creates the action"]
    #[link_name = "\u{1}?create@CCJumpTo@cocos2d@@SAPEAV12@MAEBVCCPoint@2@MH@Z"]
    pub fn cocos2d_CCJumpTo_create(
        duration: f32,
        position: *const cocos2d_CCPoint,
        height: f32,
        jumps: ::std::os::raw::c_int,
    ) -> *mut cocos2d_CCJumpTo;
}
impl cocos2d_CCJumpTo {
    #[inline]
    pub unsafe fn create(
        duration: f32,
        position: *const cocos2d_CCPoint,
        height: f32,
        jumps: ::std::os::raw::c_int,
    ) -> *mut cocos2d_CCJumpTo {
        cocos2d_CCJumpTo_create(duration, position, height, jumps)
    }
}
extern "C" {
    #[link_name = "\u{1}?startWithTarget@CCJumpTo@cocos2d@@UEAAXPEAVCCNode@2@@Z"]
    pub fn cocos2d_CCJumpTo_startWithTarget(
        this: *mut ::std::os::raw::c_void,
        pTarget: *mut cocos2d_CCNode,
    );
}
extern "C" {
    #[doc = "  @js NA"]
    #[doc = "  @lua NA"]
    #[link_name = "\u{1}?copyWithZone@CCJumpTo@cocos2d@@UEAAPEAVCCObject@2@PEAVCCZone@2@@Z"]
    pub fn cocos2d_CCJumpTo_copyWithZone(
        this: *mut ::std::os::raw::c_void,
        pZone: *mut cocos2d_CCZone,
    ) -> *mut cocos2d_CCObject;
}
#[doc = " @typedef bezier configuration structure"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cocos2d__ccBezierConfig {
    #[doc = "! end position of the bezier"]
    pub endPosition: cocos2d_CCPoint,
    #[doc = "! Bezier control point 1"]
    pub controlPoint_1: cocos2d_CCPoint,
    #[doc = "! Bezier control point 2"]
    pub controlPoint_2: cocos2d_CCPoint,
}
#[test]
fn bindgen_test_layout_cocos2d__ccBezierConfig() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d__ccBezierConfig>(),
        24usize,
        concat!("Size of: ", stringify!(cocos2d__ccBezierConfig))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d__ccBezierConfig>(),
        4usize,
        concat!("Alignment of ", stringify!(cocos2d__ccBezierConfig))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cocos2d__ccBezierConfig>())).endPosition as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d__ccBezierConfig),
            "::",
            stringify!(endPosition)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cocos2d__ccBezierConfig>())).controlPoint_1 as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d__ccBezierConfig),
            "::",
            stringify!(controlPoint_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cocos2d__ccBezierConfig>())).controlPoint_2 as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d__ccBezierConfig),
            "::",
            stringify!(controlPoint_2)
        )
    );
}
#[doc = " @typedef bezier configuration structure"]
pub type cocos2d_ccBezierConfig = cocos2d__ccBezierConfig;
#[doc = " @brief An action that moves the target with a cubic Bezier curve by a certain distance."]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCBezierBy {
    pub _base: cocos2d_CCActionInterval,
    pub m_sConfig: cocos2d_ccBezierConfig,
    pub m_startPosition: cocos2d_CCPoint,
    pub m_previousPosition: cocos2d_CCPoint,
}
#[test]
fn bindgen_test_layout_cocos2d_CCBezierBy() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCBezierBy>(),
        120usize,
        concat!("Size of: ", stringify!(cocos2d_CCBezierBy))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCBezierBy>(),
        8usize,
        concat!("Alignment of ", stringify!(cocos2d_CCBezierBy))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cocos2d_CCBezierBy>())).m_sConfig as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCBezierBy),
            "::",
            stringify!(m_sConfig)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cocos2d_CCBezierBy>())).m_startPosition as *const _ as usize
        },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCBezierBy),
            "::",
            stringify!(m_startPosition)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cocos2d_CCBezierBy>())).m_previousPosition as *const _ as usize
        },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCBezierBy),
            "::",
            stringify!(m_previousPosition)
        )
    );
}
extern "C" {
    #[doc = " initializes the action with a duration and a bezier configuration"]
    #[doc = "  @lua NA"]
    #[link_name = "\u{1}?initWithDuration@CCBezierBy@cocos2d@@QEAA_NMAEBU_ccBezierConfig@2@@Z"]
    pub fn cocos2d_CCBezierBy_initWithDuration(
        this: *mut cocos2d_CCBezierBy,
        t: f32,
        c: *const cocos2d_ccBezierConfig,
    ) -> bool;
}
extern "C" {
    #[doc = " creates the action with a duration and a bezier configuration"]
    #[doc = "  @code"]
    #[doc = "  when this function bound to js,the input params are changed"]
    #[doc = "  js: var create(var t, var pointTable)"]
    #[doc = "  @endcode"]
    #[link_name = "\u{1}?create@CCBezierBy@cocos2d@@SAPEAV12@MAEBU_ccBezierConfig@2@@Z"]
    pub fn cocos2d_CCBezierBy_create(
        t: f32,
        c: *const cocos2d_ccBezierConfig,
    ) -> *mut cocos2d_CCBezierBy;
}
impl cocos2d_CCBezierBy {
    #[inline]
    pub unsafe fn initWithDuration(&mut self, t: f32, c: *const cocos2d_ccBezierConfig) -> bool {
        cocos2d_CCBezierBy_initWithDuration(self, t, c)
    }
    #[inline]
    pub unsafe fn create(t: f32, c: *const cocos2d_ccBezierConfig) -> *mut cocos2d_CCBezierBy {
        cocos2d_CCBezierBy_create(t, c)
    }
}
extern "C" {
    #[doc = "  @js NA"]
    #[doc = "  @lua NA"]
    #[link_name = "\u{1}?copyWithZone@CCBezierBy@cocos2d@@UEAAPEAVCCObject@2@PEAVCCZone@2@@Z"]
    pub fn cocos2d_CCBezierBy_copyWithZone(
        this: *mut ::std::os::raw::c_void,
        pZone: *mut cocos2d_CCZone,
    ) -> *mut cocos2d_CCObject;
}
extern "C" {
    #[doc = "  @lua NA"]
    #[link_name = "\u{1}?startWithTarget@CCBezierBy@cocos2d@@UEAAXPEAVCCNode@2@@Z"]
    pub fn cocos2d_CCBezierBy_startWithTarget(
        this: *mut ::std::os::raw::c_void,
        pTarget: *mut cocos2d_CCNode,
    );
}
extern "C" {
    #[doc = "  @lua NA"]
    #[link_name = "\u{1}?update@CCBezierBy@cocos2d@@UEAAXM@Z"]
    pub fn cocos2d_CCBezierBy_update(this: *mut ::std::os::raw::c_void, time: f32);
}
extern "C" {
    #[link_name = "\u{1}?reverse@CCBezierBy@cocos2d@@UEAAPEAVCCActionInterval@2@XZ"]
    pub fn cocos2d_CCBezierBy_reverse(
        this: *mut ::std::os::raw::c_void,
    ) -> *mut cocos2d_CCActionInterval;
}
#[doc = " @brief An action that moves the target with a cubic Bezier curve to a destination point."]
#[doc = "@since v0.8.2"]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCBezierTo {
    pub _base: cocos2d_CCBezierBy,
    pub m_sToConfig: cocos2d_ccBezierConfig,
}
#[test]
fn bindgen_test_layout_cocos2d_CCBezierTo() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCBezierTo>(),
        144usize,
        concat!("Size of: ", stringify!(cocos2d_CCBezierTo))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCBezierTo>(),
        8usize,
        concat!("Alignment of ", stringify!(cocos2d_CCBezierTo))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cocos2d_CCBezierTo>())).m_sToConfig as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCBezierTo),
            "::",
            stringify!(m_sToConfig)
        )
    );
}
extern "C" {
    #[doc = " creates the action with a duration and a bezier configuration"]
    #[doc = "  @code"]
    #[doc = "  when this function bound to js,the input params are changed"]
    #[doc = "  js: var create(var t, var pointTable)"]
    #[doc = "  @endcode"]
    #[link_name = "\u{1}?create@CCBezierTo@cocos2d@@SAPEAV12@MAEBU_ccBezierConfig@2@@Z"]
    pub fn cocos2d_CCBezierTo_create(
        t: f32,
        c: *const cocos2d_ccBezierConfig,
    ) -> *mut cocos2d_CCBezierTo;
}
extern "C" {
    #[doc = "  @lua NA"]
    #[link_name = "\u{1}?initWithDuration@CCBezierTo@cocos2d@@QEAA_NMAEBU_ccBezierConfig@2@@Z"]
    pub fn cocos2d_CCBezierTo_initWithDuration(
        this: *mut cocos2d_CCBezierTo,
        t: f32,
        c: *const cocos2d_ccBezierConfig,
    ) -> bool;
}
impl cocos2d_CCBezierTo {
    #[inline]
    pub unsafe fn create(t: f32, c: *const cocos2d_ccBezierConfig) -> *mut cocos2d_CCBezierTo {
        cocos2d_CCBezierTo_create(t, c)
    }
    #[inline]
    pub unsafe fn initWithDuration(&mut self, t: f32, c: *const cocos2d_ccBezierConfig) -> bool {
        cocos2d_CCBezierTo_initWithDuration(self, t, c)
    }
}
extern "C" {
    #[doc = "  @lua NA"]
    #[link_name = "\u{1}?startWithTarget@CCBezierTo@cocos2d@@UEAAXPEAVCCNode@2@@Z"]
    pub fn cocos2d_CCBezierTo_startWithTarget(
        this: *mut ::std::os::raw::c_void,
        pTarget: *mut cocos2d_CCNode,
    );
}
extern "C" {
    #[doc = "  @js NA"]
    #[doc = "  @lua NA"]
    #[link_name = "\u{1}?copyWithZone@CCBezierTo@cocos2d@@UEAAPEAVCCObject@2@PEAVCCZone@2@@Z"]
    pub fn cocos2d_CCBezierTo_copyWithZone(
        this: *mut ::std::os::raw::c_void,
        pZone: *mut cocos2d_CCZone,
    ) -> *mut cocos2d_CCObject;
}
#[doc = " @brief Scales a CCNode object to a zoom factor by modifying it's scale attribute."]
#[doc = "@warning This action doesn't support \"reverse\""]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCScaleTo {
    pub _base: cocos2d_CCActionInterval,
    pub m_fScaleX: f32,
    pub m_fScaleY: f32,
    pub m_fStartScaleX: f32,
    pub m_fStartScaleY: f32,
    pub m_fEndScaleX: f32,
    pub m_fEndScaleY: f32,
    pub m_fDeltaX: f32,
    pub m_fDeltaY: f32,
}
#[test]
fn bindgen_test_layout_cocos2d_CCScaleTo() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCScaleTo>(),
        112usize,
        concat!("Size of: ", stringify!(cocos2d_CCScaleTo))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCScaleTo>(),
        8usize,
        concat!("Alignment of ", stringify!(cocos2d_CCScaleTo))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cocos2d_CCScaleTo>())).m_fScaleX as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCScaleTo),
            "::",
            stringify!(m_fScaleX)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cocos2d_CCScaleTo>())).m_fScaleY as *const _ as usize },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCScaleTo),
            "::",
            stringify!(m_fScaleY)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cocos2d_CCScaleTo>())).m_fStartScaleX as *const _ as usize
        },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCScaleTo),
            "::",
            stringify!(m_fStartScaleX)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cocos2d_CCScaleTo>())).m_fStartScaleY as *const _ as usize
        },
        92usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCScaleTo),
            "::",
            stringify!(m_fStartScaleY)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cocos2d_CCScaleTo>())).m_fEndScaleX as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCScaleTo),
            "::",
            stringify!(m_fEndScaleX)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cocos2d_CCScaleTo>())).m_fEndScaleY as *const _ as usize },
        100usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCScaleTo),
            "::",
            stringify!(m_fEndScaleY)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cocos2d_CCScaleTo>())).m_fDeltaX as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCScaleTo),
            "::",
            stringify!(m_fDeltaX)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cocos2d_CCScaleTo>())).m_fDeltaY as *const _ as usize },
        108usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCScaleTo),
            "::",
            stringify!(m_fDeltaY)
        )
    );
}
extern "C" {
    #[doc = " initializes the action with the same scale factor for X and Y"]
    #[link_name = "\u{1}?initWithDuration@CCScaleTo@cocos2d@@QEAA_NMM@Z"]
    pub fn cocos2d_CCScaleTo_initWithDuration(
        this: *mut cocos2d_CCScaleTo,
        duration: f32,
        s: f32,
    ) -> bool;
}
extern "C" {
    #[doc = " initializes the action with and X factor and a Y factor"]
    #[link_name = "\u{1}?initWithDuration@CCScaleTo@cocos2d@@QEAA_NMMM@Z"]
    pub fn cocos2d_CCScaleTo_initWithDuration1(
        this: *mut cocos2d_CCScaleTo,
        duration: f32,
        sx: f32,
        sy: f32,
    ) -> bool;
}
extern "C" {
    #[doc = " creates the action with the same scale factor for X and Y"]
    #[link_name = "\u{1}?create@CCScaleTo@cocos2d@@SAPEAV12@MM@Z"]
    pub fn cocos2d_CCScaleTo_create(duration: f32, s: f32) -> *mut cocos2d_CCScaleTo;
}
extern "C" {
    #[doc = " creates the action with and X factor and a Y factor"]
    #[link_name = "\u{1}?create@CCScaleTo@cocos2d@@SAPEAV12@MMM@Z"]
    pub fn cocos2d_CCScaleTo_create1(duration: f32, sx: f32, sy: f32) -> *mut cocos2d_CCScaleTo;
}
impl cocos2d_CCScaleTo {
    #[inline]
    pub unsafe fn initWithDuration(&mut self, duration: f32, s: f32) -> bool {
        cocos2d_CCScaleTo_initWithDuration(self, duration, s)
    }
    #[inline]
    pub unsafe fn initWithDuration1(&mut self, duration: f32, sx: f32, sy: f32) -> bool {
        cocos2d_CCScaleTo_initWithDuration1(self, duration, sx, sy)
    }
    #[inline]
    pub unsafe fn create(duration: f32, s: f32) -> *mut cocos2d_CCScaleTo {
        cocos2d_CCScaleTo_create(duration, s)
    }
    #[inline]
    pub unsafe fn create1(duration: f32, sx: f32, sy: f32) -> *mut cocos2d_CCScaleTo {
        cocos2d_CCScaleTo_create1(duration, sx, sy)
    }
}
extern "C" {
    #[doc = "  @js NA"]
    #[doc = "  @lua NA"]
    #[link_name = "\u{1}?copyWithZone@CCScaleTo@cocos2d@@UEAAPEAVCCObject@2@PEAVCCZone@2@@Z"]
    pub fn cocos2d_CCScaleTo_copyWithZone(
        this: *mut ::std::os::raw::c_void,
        pZone: *mut cocos2d_CCZone,
    ) -> *mut cocos2d_CCObject;
}
extern "C" {
    #[link_name = "\u{1}?startWithTarget@CCScaleTo@cocos2d@@UEAAXPEAVCCNode@2@@Z"]
    pub fn cocos2d_CCScaleTo_startWithTarget(
        this: *mut ::std::os::raw::c_void,
        pTarget: *mut cocos2d_CCNode,
    );
}
extern "C" {
    #[link_name = "\u{1}?update@CCScaleTo@cocos2d@@UEAAXM@Z"]
    pub fn cocos2d_CCScaleTo_update(this: *mut ::std::os::raw::c_void, time: f32);
}
#[doc = " @brief Scales a CCNode object a zoom factor by modifying it's scale attribute."]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCScaleBy {
    pub _base: cocos2d_CCScaleTo,
}
#[test]
fn bindgen_test_layout_cocos2d_CCScaleBy() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCScaleBy>(),
        112usize,
        concat!("Size of: ", stringify!(cocos2d_CCScaleBy))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCScaleBy>(),
        8usize,
        concat!("Alignment of ", stringify!(cocos2d_CCScaleBy))
    );
}
extern "C" {
    #[doc = " creates the action with the same scale factor for X and Y"]
    #[link_name = "\u{1}?create@CCScaleBy@cocos2d@@SAPEAV12@MM@Z"]
    pub fn cocos2d_CCScaleBy_create(duration: f32, s: f32) -> *mut cocos2d_CCScaleBy;
}
extern "C" {
    #[doc = " creates the action with and X factor and a Y factor"]
    #[link_name = "\u{1}?create@CCScaleBy@cocos2d@@SAPEAV12@MMM@Z"]
    pub fn cocos2d_CCScaleBy_create1(duration: f32, sx: f32, sy: f32) -> *mut cocos2d_CCScaleBy;
}
impl cocos2d_CCScaleBy {
    #[inline]
    pub unsafe fn create(duration: f32, s: f32) -> *mut cocos2d_CCScaleBy {
        cocos2d_CCScaleBy_create(duration, s)
    }
    #[inline]
    pub unsafe fn create1(duration: f32, sx: f32, sy: f32) -> *mut cocos2d_CCScaleBy {
        cocos2d_CCScaleBy_create1(duration, sx, sy)
    }
}
extern "C" {
    #[link_name = "\u{1}?startWithTarget@CCScaleBy@cocos2d@@UEAAXPEAVCCNode@2@@Z"]
    pub fn cocos2d_CCScaleBy_startWithTarget(
        this: *mut ::std::os::raw::c_void,
        pTarget: *mut cocos2d_CCNode,
    );
}
extern "C" {
    #[link_name = "\u{1}?reverse@CCScaleBy@cocos2d@@UEAAPEAVCCActionInterval@2@XZ"]
    pub fn cocos2d_CCScaleBy_reverse(
        this: *mut ::std::os::raw::c_void,
    ) -> *mut cocos2d_CCActionInterval;
}
extern "C" {
    #[doc = "  @js NA"]
    #[doc = "  @lua NA"]
    #[link_name = "\u{1}?copyWithZone@CCScaleBy@cocos2d@@UEAAPEAVCCObject@2@PEAVCCZone@2@@Z"]
    pub fn cocos2d_CCScaleBy_copyWithZone(
        this: *mut ::std::os::raw::c_void,
        pZone: *mut cocos2d_CCZone,
    ) -> *mut cocos2d_CCObject;
}
#[doc = " @brief Blinks a CCNode object by modifying it's visible attribute"]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCBlink {
    pub _base: cocos2d_CCActionInterval,
    pub m_nTimes: ::std::os::raw::c_uint,
    pub m_bOriginalState: bool,
}
#[test]
fn bindgen_test_layout_cocos2d_CCBlink() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCBlink>(),
        88usize,
        concat!("Size of: ", stringify!(cocos2d_CCBlink))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCBlink>(),
        8usize,
        concat!("Alignment of ", stringify!(cocos2d_CCBlink))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cocos2d_CCBlink>())).m_nTimes as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCBlink),
            "::",
            stringify!(m_nTimes)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cocos2d_CCBlink>())).m_bOriginalState as *const _ as usize
        },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCBlink),
            "::",
            stringify!(m_bOriginalState)
        )
    );
}
extern "C" {
    #[doc = " initializes the action"]
    #[link_name = "\u{1}?initWithDuration@CCBlink@cocos2d@@QEAA_NMI@Z"]
    pub fn cocos2d_CCBlink_initWithDuration(
        this: *mut cocos2d_CCBlink,
        duration: f32,
        uBlinks: ::std::os::raw::c_uint,
    ) -> bool;
}
extern "C" {
    #[doc = " creates the action"]
    #[link_name = "\u{1}?create@CCBlink@cocos2d@@SAPEAV12@MI@Z"]
    pub fn cocos2d_CCBlink_create(
        duration: f32,
        uBlinks: ::std::os::raw::c_uint,
    ) -> *mut cocos2d_CCBlink;
}
impl cocos2d_CCBlink {
    #[inline]
    pub unsafe fn initWithDuration(
        &mut self,
        duration: f32,
        uBlinks: ::std::os::raw::c_uint,
    ) -> bool {
        cocos2d_CCBlink_initWithDuration(self, duration, uBlinks)
    }
    #[inline]
    pub unsafe fn create(duration: f32, uBlinks: ::std::os::raw::c_uint) -> *mut cocos2d_CCBlink {
        cocos2d_CCBlink_create(duration, uBlinks)
    }
}
extern "C" {
    #[doc = "  @js NA"]
    #[doc = "  @lua NA"]
    #[link_name = "\u{1}?copyWithZone@CCBlink@cocos2d@@UEAAPEAVCCObject@2@PEAVCCZone@2@@Z"]
    pub fn cocos2d_CCBlink_copyWithZone(
        this: *mut ::std::os::raw::c_void,
        pZone: *mut cocos2d_CCZone,
    ) -> *mut cocos2d_CCObject;
}
extern "C" {
    #[link_name = "\u{1}?update@CCBlink@cocos2d@@UEAAXM@Z"]
    pub fn cocos2d_CCBlink_update(this: *mut ::std::os::raw::c_void, time: f32);
}
extern "C" {
    #[link_name = "\u{1}?reverse@CCBlink@cocos2d@@UEAAPEAVCCActionInterval@2@XZ"]
    pub fn cocos2d_CCBlink_reverse(
        this: *mut ::std::os::raw::c_void,
    ) -> *mut cocos2d_CCActionInterval;
}
extern "C" {
    #[link_name = "\u{1}?startWithTarget@CCBlink@cocos2d@@UEAAXPEAVCCNode@2@@Z"]
    pub fn cocos2d_CCBlink_startWithTarget(
        this: *mut ::std::os::raw::c_void,
        pTarget: *mut cocos2d_CCNode,
    );
}
extern "C" {
    #[link_name = "\u{1}?stop@CCBlink@cocos2d@@UEAAXXZ"]
    pub fn cocos2d_CCBlink_stop(this: *mut ::std::os::raw::c_void);
}
#[doc = " @brief Fades In an object that implements the CCRGBAProtocol protocol. It modifies the opacity from 0 to 255."]
#[doc = "The \"reverse\" of this action is FadeOut"]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCFadeIn {
    pub _base: cocos2d_CCActionInterval,
}
#[test]
fn bindgen_test_layout_cocos2d_CCFadeIn() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCFadeIn>(),
        80usize,
        concat!("Size of: ", stringify!(cocos2d_CCFadeIn))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCFadeIn>(),
        8usize,
        concat!("Alignment of ", stringify!(cocos2d_CCFadeIn))
    );
}
extern "C" {
    #[doc = " creates the action"]
    #[link_name = "\u{1}?create@CCFadeIn@cocos2d@@SAPEAV12@M@Z"]
    pub fn cocos2d_CCFadeIn_create(d: f32) -> *mut cocos2d_CCFadeIn;
}
impl cocos2d_CCFadeIn {
    #[inline]
    pub unsafe fn create(d: f32) -> *mut cocos2d_CCFadeIn {
        cocos2d_CCFadeIn_create(d)
    }
}
extern "C" {
    #[link_name = "\u{1}?update@CCFadeIn@cocos2d@@UEAAXM@Z"]
    pub fn cocos2d_CCFadeIn_update(this: *mut ::std::os::raw::c_void, time: f32);
}
extern "C" {
    #[link_name = "\u{1}?reverse@CCFadeIn@cocos2d@@UEAAPEAVCCActionInterval@2@XZ"]
    pub fn cocos2d_CCFadeIn_reverse(
        this: *mut ::std::os::raw::c_void,
    ) -> *mut cocos2d_CCActionInterval;
}
extern "C" {
    #[doc = "  @js NA"]
    #[doc = "  @lua NA"]
    #[link_name = "\u{1}?copyWithZone@CCFadeIn@cocos2d@@UEAAPEAVCCObject@2@PEAVCCZone@2@@Z"]
    pub fn cocos2d_CCFadeIn_copyWithZone(
        this: *mut ::std::os::raw::c_void,
        pZone: *mut cocos2d_CCZone,
    ) -> *mut cocos2d_CCObject;
}
#[doc = " @brief Fades Out an object that implements the CCRGBAProtocol protocol. It modifies the opacity from 255 to 0."]
#[doc = "The \"reverse\" of this action is FadeIn"]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCFadeOut {
    pub _base: cocos2d_CCActionInterval,
}
#[test]
fn bindgen_test_layout_cocos2d_CCFadeOut() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCFadeOut>(),
        80usize,
        concat!("Size of: ", stringify!(cocos2d_CCFadeOut))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCFadeOut>(),
        8usize,
        concat!("Alignment of ", stringify!(cocos2d_CCFadeOut))
    );
}
extern "C" {
    #[doc = " creates the action"]
    #[link_name = "\u{1}?create@CCFadeOut@cocos2d@@SAPEAV12@M@Z"]
    pub fn cocos2d_CCFadeOut_create(d: f32) -> *mut cocos2d_CCFadeOut;
}
impl cocos2d_CCFadeOut {
    #[inline]
    pub unsafe fn create(d: f32) -> *mut cocos2d_CCFadeOut {
        cocos2d_CCFadeOut_create(d)
    }
}
extern "C" {
    #[link_name = "\u{1}?update@CCFadeOut@cocos2d@@UEAAXM@Z"]
    pub fn cocos2d_CCFadeOut_update(this: *mut ::std::os::raw::c_void, time: f32);
}
extern "C" {
    #[link_name = "\u{1}?reverse@CCFadeOut@cocos2d@@UEAAPEAVCCActionInterval@2@XZ"]
    pub fn cocos2d_CCFadeOut_reverse(
        this: *mut ::std::os::raw::c_void,
    ) -> *mut cocos2d_CCActionInterval;
}
extern "C" {
    #[doc = "  @js NA"]
    #[doc = "  @lua NA"]
    #[link_name = "\u{1}?copyWithZone@CCFadeOut@cocos2d@@UEAAPEAVCCObject@2@PEAVCCZone@2@@Z"]
    pub fn cocos2d_CCFadeOut_copyWithZone(
        this: *mut ::std::os::raw::c_void,
        pZone: *mut cocos2d_CCZone,
    ) -> *mut cocos2d_CCObject;
}
#[doc = " @brief Fades an object that implements the CCRGBAProtocol protocol. It modifies the opacity from the current value to a custom one."]
#[doc = "@warning This action doesn't support \"reverse\""]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCFadeTo {
    pub _base: cocos2d_CCActionInterval,
    pub m_toOpacity: GLubyte,
    pub m_fromOpacity: GLubyte,
}
#[test]
fn bindgen_test_layout_cocos2d_CCFadeTo() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCFadeTo>(),
        88usize,
        concat!("Size of: ", stringify!(cocos2d_CCFadeTo))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCFadeTo>(),
        8usize,
        concat!("Alignment of ", stringify!(cocos2d_CCFadeTo))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cocos2d_CCFadeTo>())).m_toOpacity as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCFadeTo),
            "::",
            stringify!(m_toOpacity)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cocos2d_CCFadeTo>())).m_fromOpacity as *const _ as usize },
        81usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCFadeTo),
            "::",
            stringify!(m_fromOpacity)
        )
    );
}
extern "C" {
    #[doc = " initializes the action with duration and opacity"]
    #[link_name = "\u{1}?initWithDuration@CCFadeTo@cocos2d@@QEAA_NME@Z"]
    pub fn cocos2d_CCFadeTo_initWithDuration(
        this: *mut cocos2d_CCFadeTo,
        duration: f32,
        opacity: GLubyte,
    ) -> bool;
}
extern "C" {
    #[doc = " creates an action with duration and opacity"]
    #[link_name = "\u{1}?create@CCFadeTo@cocos2d@@SAPEAV12@ME@Z"]
    pub fn cocos2d_CCFadeTo_create(duration: f32, opacity: GLubyte) -> *mut cocos2d_CCFadeTo;
}
impl cocos2d_CCFadeTo {
    #[inline]
    pub unsafe fn initWithDuration(&mut self, duration: f32, opacity: GLubyte) -> bool {
        cocos2d_CCFadeTo_initWithDuration(self, duration, opacity)
    }
    #[inline]
    pub unsafe fn create(duration: f32, opacity: GLubyte) -> *mut cocos2d_CCFadeTo {
        cocos2d_CCFadeTo_create(duration, opacity)
    }
}
extern "C" {
    #[doc = "  @js NA"]
    #[doc = "  @lua NA"]
    #[link_name = "\u{1}?copyWithZone@CCFadeTo@cocos2d@@UEAAPEAVCCObject@2@PEAVCCZone@2@@Z"]
    pub fn cocos2d_CCFadeTo_copyWithZone(
        this: *mut ::std::os::raw::c_void,
        pZone: *mut cocos2d_CCZone,
    ) -> *mut cocos2d_CCObject;
}
extern "C" {
    #[link_name = "\u{1}?startWithTarget@CCFadeTo@cocos2d@@UEAAXPEAVCCNode@2@@Z"]
    pub fn cocos2d_CCFadeTo_startWithTarget(
        this: *mut ::std::os::raw::c_void,
        pTarget: *mut cocos2d_CCNode,
    );
}
extern "C" {
    #[link_name = "\u{1}?update@CCFadeTo@cocos2d@@UEAAXM@Z"]
    pub fn cocos2d_CCFadeTo_update(this: *mut ::std::os::raw::c_void, time: f32);
}
#[doc = " @brief Tints a CCNode that implements the CCNodeRGB protocol from current tint to a custom one."]
#[doc = "@warning This action doesn't support \"reverse\""]
#[doc = "@since v0.7.2"]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCTintTo {
    pub _base: cocos2d_CCActionInterval,
    pub m_to: cocos2d_ccColor3B,
    pub m_from: cocos2d_ccColor3B,
}
#[test]
fn bindgen_test_layout_cocos2d_CCTintTo() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCTintTo>(),
        88usize,
        concat!("Size of: ", stringify!(cocos2d_CCTintTo))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCTintTo>(),
        8usize,
        concat!("Alignment of ", stringify!(cocos2d_CCTintTo))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cocos2d_CCTintTo>())).m_to as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCTintTo),
            "::",
            stringify!(m_to)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cocos2d_CCTintTo>())).m_from as *const _ as usize },
        83usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCTintTo),
            "::",
            stringify!(m_from)
        )
    );
}
extern "C" {
    #[doc = " initializes the action with duration and color"]
    #[link_name = "\u{1}?initWithDuration@CCTintTo@cocos2d@@QEAA_NMEEE@Z"]
    pub fn cocos2d_CCTintTo_initWithDuration(
        this: *mut cocos2d_CCTintTo,
        duration: f32,
        red: GLubyte,
        green: GLubyte,
        blue: GLubyte,
    ) -> bool;
}
extern "C" {
    #[doc = " creates an action with duration and color"]
    #[link_name = "\u{1}?create@CCTintTo@cocos2d@@SAPEAV12@MEEE@Z"]
    pub fn cocos2d_CCTintTo_create(
        duration: f32,
        red: GLubyte,
        green: GLubyte,
        blue: GLubyte,
    ) -> *mut cocos2d_CCTintTo;
}
impl cocos2d_CCTintTo {
    #[inline]
    pub unsafe fn initWithDuration(
        &mut self,
        duration: f32,
        red: GLubyte,
        green: GLubyte,
        blue: GLubyte,
    ) -> bool {
        cocos2d_CCTintTo_initWithDuration(self, duration, red, green, blue)
    }
    #[inline]
    pub unsafe fn create(
        duration: f32,
        red: GLubyte,
        green: GLubyte,
        blue: GLubyte,
    ) -> *mut cocos2d_CCTintTo {
        cocos2d_CCTintTo_create(duration, red, green, blue)
    }
}
extern "C" {
    #[doc = "  @js NA"]
    #[doc = "  @lua NA"]
    #[link_name = "\u{1}?copyWithZone@CCTintTo@cocos2d@@UEAAPEAVCCObject@2@PEAVCCZone@2@@Z"]
    pub fn cocos2d_CCTintTo_copyWithZone(
        this: *mut ::std::os::raw::c_void,
        pZone: *mut cocos2d_CCZone,
    ) -> *mut cocos2d_CCObject;
}
extern "C" {
    #[link_name = "\u{1}?startWithTarget@CCTintTo@cocos2d@@UEAAXPEAVCCNode@2@@Z"]
    pub fn cocos2d_CCTintTo_startWithTarget(
        this: *mut ::std::os::raw::c_void,
        pTarget: *mut cocos2d_CCNode,
    );
}
extern "C" {
    #[link_name = "\u{1}?update@CCTintTo@cocos2d@@UEAAXM@Z"]
    pub fn cocos2d_CCTintTo_update(this: *mut ::std::os::raw::c_void, time: f32);
}
#[doc = " @brief Tints a CCNode that implements the CCNodeRGB protocol from current tint to a custom one."]
#[doc = "@since v0.7.2"]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCTintBy {
    pub _base: cocos2d_CCActionInterval,
    pub m_deltaR: GLshort,
    pub m_deltaG: GLshort,
    pub m_deltaB: GLshort,
    pub m_fromR: GLshort,
    pub m_fromG: GLshort,
    pub m_fromB: GLshort,
}
#[test]
fn bindgen_test_layout_cocos2d_CCTintBy() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCTintBy>(),
        96usize,
        concat!("Size of: ", stringify!(cocos2d_CCTintBy))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCTintBy>(),
        8usize,
        concat!("Alignment of ", stringify!(cocos2d_CCTintBy))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cocos2d_CCTintBy>())).m_deltaR as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCTintBy),
            "::",
            stringify!(m_deltaR)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cocos2d_CCTintBy>())).m_deltaG as *const _ as usize },
        82usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCTintBy),
            "::",
            stringify!(m_deltaG)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cocos2d_CCTintBy>())).m_deltaB as *const _ as usize },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCTintBy),
            "::",
            stringify!(m_deltaB)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cocos2d_CCTintBy>())).m_fromR as *const _ as usize },
        86usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCTintBy),
            "::",
            stringify!(m_fromR)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cocos2d_CCTintBy>())).m_fromG as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCTintBy),
            "::",
            stringify!(m_fromG)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cocos2d_CCTintBy>())).m_fromB as *const _ as usize },
        90usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCTintBy),
            "::",
            stringify!(m_fromB)
        )
    );
}
extern "C" {
    #[doc = " initializes the action with duration and color"]
    #[link_name = "\u{1}?initWithDuration@CCTintBy@cocos2d@@QEAA_NMFFF@Z"]
    pub fn cocos2d_CCTintBy_initWithDuration(
        this: *mut cocos2d_CCTintBy,
        duration: f32,
        deltaRed: GLshort,
        deltaGreen: GLshort,
        deltaBlue: GLshort,
    ) -> bool;
}
extern "C" {
    #[doc = " creates an action with duration and color"]
    #[link_name = "\u{1}?create@CCTintBy@cocos2d@@SAPEAV12@MFFF@Z"]
    pub fn cocos2d_CCTintBy_create(
        duration: f32,
        deltaRed: GLshort,
        deltaGreen: GLshort,
        deltaBlue: GLshort,
    ) -> *mut cocos2d_CCTintBy;
}
impl cocos2d_CCTintBy {
    #[inline]
    pub unsafe fn initWithDuration(
        &mut self,
        duration: f32,
        deltaRed: GLshort,
        deltaGreen: GLshort,
        deltaBlue: GLshort,
    ) -> bool {
        cocos2d_CCTintBy_initWithDuration(self, duration, deltaRed, deltaGreen, deltaBlue)
    }
    #[inline]
    pub unsafe fn create(
        duration: f32,
        deltaRed: GLshort,
        deltaGreen: GLshort,
        deltaBlue: GLshort,
    ) -> *mut cocos2d_CCTintBy {
        cocos2d_CCTintBy_create(duration, deltaRed, deltaGreen, deltaBlue)
    }
}
extern "C" {
    #[doc = "  @js NA"]
    #[doc = "  @lua NA"]
    #[link_name = "\u{1}?copyWithZone@CCTintBy@cocos2d@@UEAAPEAVCCObject@2@PEAVCCZone@2@@Z"]
    pub fn cocos2d_CCTintBy_copyWithZone(
        this: *mut ::std::os::raw::c_void,
        pZone: *mut cocos2d_CCZone,
    ) -> *mut cocos2d_CCObject;
}
extern "C" {
    #[link_name = "\u{1}?startWithTarget@CCTintBy@cocos2d@@UEAAXPEAVCCNode@2@@Z"]
    pub fn cocos2d_CCTintBy_startWithTarget(
        this: *mut ::std::os::raw::c_void,
        pTarget: *mut cocos2d_CCNode,
    );
}
extern "C" {
    #[link_name = "\u{1}?update@CCTintBy@cocos2d@@UEAAXM@Z"]
    pub fn cocos2d_CCTintBy_update(this: *mut ::std::os::raw::c_void, time: f32);
}
extern "C" {
    #[link_name = "\u{1}?reverse@CCTintBy@cocos2d@@UEAAPEAVCCActionInterval@2@XZ"]
    pub fn cocos2d_CCTintBy_reverse(
        this: *mut ::std::os::raw::c_void,
    ) -> *mut cocos2d_CCActionInterval;
}
#[doc = " @brief Delays the action a certain amount of seconds"]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCDelayTime {
    pub _base: cocos2d_CCActionInterval,
}
#[test]
fn bindgen_test_layout_cocos2d_CCDelayTime() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCDelayTime>(),
        80usize,
        concat!("Size of: ", stringify!(cocos2d_CCDelayTime))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCDelayTime>(),
        8usize,
        concat!("Alignment of ", stringify!(cocos2d_CCDelayTime))
    );
}
extern "C" {
    #[doc = " creates the action"]
    #[link_name = "\u{1}?create@CCDelayTime@cocos2d@@SAPEAV12@M@Z"]
    pub fn cocos2d_CCDelayTime_create(d: f32) -> *mut cocos2d_CCDelayTime;
}
impl cocos2d_CCDelayTime {
    #[inline]
    pub unsafe fn create(d: f32) -> *mut cocos2d_CCDelayTime {
        cocos2d_CCDelayTime_create(d)
    }
}
extern "C" {
    #[link_name = "\u{1}?update@CCDelayTime@cocos2d@@UEAAXM@Z"]
    pub fn cocos2d_CCDelayTime_update(this: *mut ::std::os::raw::c_void, time: f32);
}
extern "C" {
    #[link_name = "\u{1}?reverse@CCDelayTime@cocos2d@@UEAAPEAVCCActionInterval@2@XZ"]
    pub fn cocos2d_CCDelayTime_reverse(
        this: *mut ::std::os::raw::c_void,
    ) -> *mut cocos2d_CCActionInterval;
}
extern "C" {
    #[doc = "  @js NA"]
    #[doc = "  @lua NA"]
    #[link_name = "\u{1}?copyWithZone@CCDelayTime@cocos2d@@UEAAPEAVCCObject@2@PEAVCCZone@2@@Z"]
    pub fn cocos2d_CCDelayTime_copyWithZone(
        this: *mut ::std::os::raw::c_void,
        pZone: *mut cocos2d_CCZone,
    ) -> *mut cocos2d_CCObject;
}
#[doc = " @brief Executes an action in reverse order, from time=duration to time=0"]
#[doc = ""]
#[doc = "@warning Use this action carefully. This action is not"]
#[doc = "sequenceable. Use it as the default \"reversed\" method"]
#[doc = "of your own actions, but using it outside the \"reversed\""]
#[doc = "scope is not recommended."]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCReverseTime {
    pub _base: cocos2d_CCActionInterval,
    pub m_pOther: *mut cocos2d_CCFiniteTimeAction,
}
#[test]
fn bindgen_test_layout_cocos2d_CCReverseTime() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCReverseTime>(),
        88usize,
        concat!("Size of: ", stringify!(cocos2d_CCReverseTime))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCReverseTime>(),
        8usize,
        concat!("Alignment of ", stringify!(cocos2d_CCReverseTime))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cocos2d_CCReverseTime>())).m_pOther as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCReverseTime),
            "::",
            stringify!(m_pOther)
        )
    );
}
extern "C" {
    #[doc = " initializes the action"]
    #[link_name = "\u{1}?initWithAction@CCReverseTime@cocos2d@@QEAA_NPEAVCCFiniteTimeAction@2@@Z"]
    pub fn cocos2d_CCReverseTime_initWithAction(
        this: *mut cocos2d_CCReverseTime,
        pAction: *mut cocos2d_CCFiniteTimeAction,
    ) -> bool;
}
extern "C" {
    #[doc = " creates the action"]
    #[link_name = "\u{1}?create@CCReverseTime@cocos2d@@SAPEAV12@PEAVCCFiniteTimeAction@2@@Z"]
    pub fn cocos2d_CCReverseTime_create(
        pAction: *mut cocos2d_CCFiniteTimeAction,
    ) -> *mut cocos2d_CCReverseTime;
}
extern "C" {
    #[doc = "  @js NA"]
    #[doc = "  @lua NA"]
    #[link_name = "\u{1}??0CCReverseTime@cocos2d@@QEAA@XZ"]
    pub fn cocos2d_CCReverseTime_CCReverseTime(this: *mut cocos2d_CCReverseTime);
}
impl cocos2d_CCReverseTime {
    #[inline]
    pub unsafe fn initWithAction(&mut self, pAction: *mut cocos2d_CCFiniteTimeAction) -> bool {
        cocos2d_CCReverseTime_initWithAction(self, pAction)
    }
    #[inline]
    pub unsafe fn create(pAction: *mut cocos2d_CCFiniteTimeAction) -> *mut cocos2d_CCReverseTime {
        cocos2d_CCReverseTime_create(pAction)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cocos2d_CCReverseTime_CCReverseTime(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
}
extern "C" {
    #[doc = "  @js ctor"]
    #[link_name = "\u{1}??_DCCReverseTime@cocos2d@@QEAAXXZ"]
    pub fn cocos2d_CCReverseTime_CCReverseTime_destructor(this: *mut cocos2d_CCReverseTime);
}
extern "C" {
    #[doc = "  @js NA"]
    #[doc = "  @lua NA"]
    #[link_name = "\u{1}?copyWithZone@CCReverseTime@cocos2d@@UEAAPEAVCCObject@2@PEAVCCZone@2@@Z"]
    pub fn cocos2d_CCReverseTime_copyWithZone(
        this: *mut ::std::os::raw::c_void,
        pZone: *mut cocos2d_CCZone,
    ) -> *mut cocos2d_CCObject;
}
extern "C" {
    #[link_name = "\u{1}?startWithTarget@CCReverseTime@cocos2d@@UEAAXPEAVCCNode@2@@Z"]
    pub fn cocos2d_CCReverseTime_startWithTarget(
        this: *mut ::std::os::raw::c_void,
        pTarget: *mut cocos2d_CCNode,
    );
}
extern "C" {
    #[link_name = "\u{1}?stop@CCReverseTime@cocos2d@@UEAAXXZ"]
    pub fn cocos2d_CCReverseTime_stop(this: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[link_name = "\u{1}?update@CCReverseTime@cocos2d@@UEAAXM@Z"]
    pub fn cocos2d_CCReverseTime_update(this: *mut ::std::os::raw::c_void, time: f32);
}
extern "C" {
    #[link_name = "\u{1}?reverse@CCReverseTime@cocos2d@@UEAAPEAVCCActionInterval@2@XZ"]
    pub fn cocos2d_CCReverseTime_reverse(
        this: *mut ::std::os::raw::c_void,
    ) -> *mut cocos2d_CCActionInterval;
}
#[doc = " @brief Animates a sprite given the name of an Animation"]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCAnimate {
    pub _base: cocos2d_CCActionInterval,
    pub m_pAnimation: *mut cocos2d_CCAnimation,
    pub m_pSplitTimes: *mut u8,
    pub m_nNextFrame: ::std::os::raw::c_int,
    pub m_pOrigFrame: *mut cocos2d_CCSpriteFrame,
    pub m_uExecutedLoops: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_cocos2d_CCAnimate() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCAnimate>(),
        120usize,
        concat!("Size of: ", stringify!(cocos2d_CCAnimate))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCAnimate>(),
        8usize,
        concat!("Alignment of ", stringify!(cocos2d_CCAnimate))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cocos2d_CCAnimate>())).m_pAnimation as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCAnimate),
            "::",
            stringify!(m_pAnimation)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cocos2d_CCAnimate>())).m_pSplitTimes as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCAnimate),
            "::",
            stringify!(m_pSplitTimes)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cocos2d_CCAnimate>())).m_nNextFrame as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCAnimate),
            "::",
            stringify!(m_nNextFrame)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cocos2d_CCAnimate>())).m_pOrigFrame as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCAnimate),
            "::",
            stringify!(m_pOrigFrame)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cocos2d_CCAnimate>())).m_uExecutedLoops as *const _ as usize
        },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCAnimate),
            "::",
            stringify!(m_uExecutedLoops)
        )
    );
}
extern "C" {
    #[doc = " initializes the action with an Animation and will restore the original frame when the animation is over"]
    #[link_name = "\u{1}?initWithAnimation@CCAnimate@cocos2d@@QEAA_NPEAVCCAnimation@2@@Z"]
    pub fn cocos2d_CCAnimate_initWithAnimation(
        this: *mut cocos2d_CCAnimate,
        pAnimation: *mut cocos2d_CCAnimation,
    ) -> bool;
}
extern "C" {
    #[doc = " creates the action with an Animation and will restore the original frame when the animation is over"]
    #[link_name = "\u{1}?create@CCAnimate@cocos2d@@SAPEAV12@PEAVCCAnimation@2@@Z"]
    pub fn cocos2d_CCAnimate_create(pAnimation: *mut cocos2d_CCAnimation)
        -> *mut cocos2d_CCAnimate;
}
extern "C" {
    #[doc = "  @js ctor"]
    #[link_name = "\u{1}??0CCAnimate@cocos2d@@QEAA@XZ"]
    pub fn cocos2d_CCAnimate_CCAnimate(this: *mut cocos2d_CCAnimate);
}
impl cocos2d_CCAnimate {
    #[inline]
    pub unsafe fn initWithAnimation(&mut self, pAnimation: *mut cocos2d_CCAnimation) -> bool {
        cocos2d_CCAnimate_initWithAnimation(self, pAnimation)
    }
    #[inline]
    pub unsafe fn create(pAnimation: *mut cocos2d_CCAnimation) -> *mut cocos2d_CCAnimate {
        cocos2d_CCAnimate_create(pAnimation)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cocos2d_CCAnimate_CCAnimate(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
}
extern "C" {
    #[doc = "  @js NA"]
    #[doc = "  @lua NA"]
    #[link_name = "\u{1}??_DCCAnimate@cocos2d@@QEAAXXZ"]
    pub fn cocos2d_CCAnimate_CCAnimate_destructor(this: *mut cocos2d_CCAnimate);
}
extern "C" {
    #[doc = "  @js NA"]
    #[doc = "  @lua NA"]
    #[link_name = "\u{1}?copyWithZone@CCAnimate@cocos2d@@UEAAPEAVCCObject@2@PEAVCCZone@2@@Z"]
    pub fn cocos2d_CCAnimate_copyWithZone(
        this: *mut ::std::os::raw::c_void,
        pZone: *mut cocos2d_CCZone,
    ) -> *mut cocos2d_CCObject;
}
extern "C" {
    #[link_name = "\u{1}?startWithTarget@CCAnimate@cocos2d@@UEAAXPEAVCCNode@2@@Z"]
    pub fn cocos2d_CCAnimate_startWithTarget(
        this: *mut ::std::os::raw::c_void,
        pTarget: *mut cocos2d_CCNode,
    );
}
extern "C" {
    #[link_name = "\u{1}?stop@CCAnimate@cocos2d@@UEAAXXZ"]
    pub fn cocos2d_CCAnimate_stop(this: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[link_name = "\u{1}?update@CCAnimate@cocos2d@@UEAAXM@Z"]
    pub fn cocos2d_CCAnimate_update(this: *mut ::std::os::raw::c_void, t: f32);
}
extern "C" {
    #[link_name = "\u{1}?reverse@CCAnimate@cocos2d@@UEAAPEAVCCActionInterval@2@XZ"]
    pub fn cocos2d_CCAnimate_reverse(
        this: *mut ::std::os::raw::c_void,
    ) -> *mut cocos2d_CCActionInterval;
}
#[doc = " Overrides the target of an action so that it always runs on the target"]
#[doc = " specified at action creation rather than the one specified by runAction."]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCTargetedAction {
    pub _base: cocos2d_CCActionInterval,
    pub m_pForcedTarget: *mut cocos2d_CCNode,
    pub m_pAction: *mut cocos2d_CCFiniteTimeAction,
}
#[test]
fn bindgen_test_layout_cocos2d_CCTargetedAction() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCTargetedAction>(),
        96usize,
        concat!("Size of: ", stringify!(cocos2d_CCTargetedAction))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCTargetedAction>(),
        8usize,
        concat!("Alignment of ", stringify!(cocos2d_CCTargetedAction))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cocos2d_CCTargetedAction>())).m_pForcedTarget as *const _
                as usize
        },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCTargetedAction),
            "::",
            stringify!(m_pForcedTarget)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cocos2d_CCTargetedAction>())).m_pAction as *const _ as usize
        },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCTargetedAction),
            "::",
            stringify!(m_pAction)
        )
    );
}
extern "C" {
    #[doc = " Create an action with the specified action and forced target"]
    #[link_name = "\u{1}?create@CCTargetedAction@cocos2d@@SAPEAV12@PEAVCCNode@2@PEAVCCFiniteTimeAction@2@@Z"]
    pub fn cocos2d_CCTargetedAction_create(
        pTarget: *mut cocos2d_CCNode,
        pAction: *mut cocos2d_CCFiniteTimeAction,
    ) -> *mut cocos2d_CCTargetedAction;
}
extern "C" {
    #[doc = " Init an action with the specified action and forced target"]
    #[link_name = "\u{1}?initWithTarget@CCTargetedAction@cocos2d@@QEAA_NPEAVCCNode@2@PEAVCCFiniteTimeAction@2@@Z"]
    pub fn cocos2d_CCTargetedAction_initWithTarget(
        this: *mut cocos2d_CCTargetedAction,
        pTarget: *mut cocos2d_CCNode,
        pAction: *mut cocos2d_CCFiniteTimeAction,
    ) -> bool;
}
extern "C" {
    #[doc = "  @js ctor"]
    #[link_name = "\u{1}??0CCTargetedAction@cocos2d@@QEAA@XZ"]
    pub fn cocos2d_CCTargetedAction_CCTargetedAction(this: *mut cocos2d_CCTargetedAction);
}
impl cocos2d_CCTargetedAction {
    #[inline]
    pub unsafe fn create(
        pTarget: *mut cocos2d_CCNode,
        pAction: *mut cocos2d_CCFiniteTimeAction,
    ) -> *mut cocos2d_CCTargetedAction {
        cocos2d_CCTargetedAction_create(pTarget, pAction)
    }
    #[inline]
    pub unsafe fn initWithTarget(
        &mut self,
        pTarget: *mut cocos2d_CCNode,
        pAction: *mut cocos2d_CCFiniteTimeAction,
    ) -> bool {
        cocos2d_CCTargetedAction_initWithTarget(self, pTarget, pAction)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cocos2d_CCTargetedAction_CCTargetedAction(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
}
extern "C" {
    #[doc = "  @js NA"]
    #[doc = "  @lua NA"]
    #[link_name = "\u{1}??_DCCTargetedAction@cocos2d@@QEAAXXZ"]
    pub fn cocos2d_CCTargetedAction_CCTargetedAction_destructor(
        this: *mut cocos2d_CCTargetedAction,
    );
}
extern "C" {
    #[doc = "  @js NA"]
    #[doc = "  @lua NA"]
    #[link_name = "\u{1}?copyWithZone@CCTargetedAction@cocos2d@@UEAAPEAVCCObject@2@PEAVCCZone@2@@Z"]
    pub fn cocos2d_CCTargetedAction_copyWithZone(
        this: *mut ::std::os::raw::c_void,
        pZone: *mut cocos2d_CCZone,
    ) -> *mut cocos2d_CCObject;
}
extern "C" {
    #[link_name = "\u{1}?startWithTarget@CCTargetedAction@cocos2d@@UEAAXPEAVCCNode@2@@Z"]
    pub fn cocos2d_CCTargetedAction_startWithTarget(
        this: *mut ::std::os::raw::c_void,
        pTarget: *mut cocos2d_CCNode,
    );
}
extern "C" {
    #[link_name = "\u{1}?stop@CCTargetedAction@cocos2d@@UEAAXXZ"]
    pub fn cocos2d_CCTargetedAction_stop(this: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[link_name = "\u{1}?update@CCTargetedAction@cocos2d@@UEAAXM@Z"]
    pub fn cocos2d_CCTargetedAction_update(this: *mut ::std::os::raw::c_void, time: f32);
}
#[doc = "@brief Base class for CCCamera actions"]
#[doc = "@ingroup Actions"]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCActionCamera {
    pub _base: cocos2d_CCActionInterval,
    pub m_fCenterXOrig: f32,
    pub m_fCenterYOrig: f32,
    pub m_fCenterZOrig: f32,
    pub m_fEyeXOrig: f32,
    pub m_fEyeYOrig: f32,
    pub m_fEyeZOrig: f32,
    pub m_fUpXOrig: f32,
    pub m_fUpYOrig: f32,
    pub m_fUpZOrig: f32,
}
#[test]
fn bindgen_test_layout_cocos2d_CCActionCamera() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCActionCamera>(),
        120usize,
        concat!("Size of: ", stringify!(cocos2d_CCActionCamera))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCActionCamera>(),
        8usize,
        concat!("Alignment of ", stringify!(cocos2d_CCActionCamera))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cocos2d_CCActionCamera>())).m_fCenterXOrig as *const _ as usize
        },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCActionCamera),
            "::",
            stringify!(m_fCenterXOrig)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cocos2d_CCActionCamera>())).m_fCenterYOrig as *const _ as usize
        },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCActionCamera),
            "::",
            stringify!(m_fCenterYOrig)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cocos2d_CCActionCamera>())).m_fCenterZOrig as *const _ as usize
        },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCActionCamera),
            "::",
            stringify!(m_fCenterZOrig)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cocos2d_CCActionCamera>())).m_fEyeXOrig as *const _ as usize
        },
        92usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCActionCamera),
            "::",
            stringify!(m_fEyeXOrig)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cocos2d_CCActionCamera>())).m_fEyeYOrig as *const _ as usize
        },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCActionCamera),
            "::",
            stringify!(m_fEyeYOrig)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cocos2d_CCActionCamera>())).m_fEyeZOrig as *const _ as usize
        },
        100usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCActionCamera),
            "::",
            stringify!(m_fEyeZOrig)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cocos2d_CCActionCamera>())).m_fUpXOrig as *const _ as usize
        },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCActionCamera),
            "::",
            stringify!(m_fUpXOrig)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cocos2d_CCActionCamera>())).m_fUpYOrig as *const _ as usize
        },
        108usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCActionCamera),
            "::",
            stringify!(m_fUpYOrig)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cocos2d_CCActionCamera>())).m_fUpZOrig as *const _ as usize
        },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCActionCamera),
            "::",
            stringify!(m_fUpZOrig)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}?startWithTarget@CCActionCamera@cocos2d@@UEAAXPEAVCCNode@2@@Z"]
    pub fn cocos2d_CCActionCamera_startWithTarget(
        this: *mut ::std::os::raw::c_void,
        pTarget: *mut cocos2d_CCNode,
    );
}
extern "C" {
    #[link_name = "\u{1}?reverse@CCActionCamera@cocos2d@@UEAAPEAVCCActionInterval@2@XZ"]
    pub fn cocos2d_CCActionCamera_reverse(
        this: *mut ::std::os::raw::c_void,
    ) -> *mut cocos2d_CCActionInterval;
}
#[doc = "@brief CCOrbitCamera action"]
#[doc = "Orbits the camera around the center of the screen using spherical coordinates"]
#[doc = "@ingroup Actions"]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCOrbitCamera {
    pub _base: cocos2d_CCActionCamera,
    pub m_fRadius: f32,
    pub m_fDeltaRadius: f32,
    pub m_fAngleZ: f32,
    pub m_fDeltaAngleZ: f32,
    pub m_fAngleX: f32,
    pub m_fDeltaAngleX: f32,
    pub m_fRadZ: f32,
    pub m_fRadDeltaZ: f32,
    pub m_fRadX: f32,
    pub m_fRadDeltaX: f32,
}
#[test]
fn bindgen_test_layout_cocos2d_CCOrbitCamera() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCOrbitCamera>(),
        160usize,
        concat!("Size of: ", stringify!(cocos2d_CCOrbitCamera))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCOrbitCamera>(),
        8usize,
        concat!("Alignment of ", stringify!(cocos2d_CCOrbitCamera))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cocos2d_CCOrbitCamera>())).m_fRadius as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCOrbitCamera),
            "::",
            stringify!(m_fRadius)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cocos2d_CCOrbitCamera>())).m_fDeltaRadius as *const _ as usize
        },
        124usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCOrbitCamera),
            "::",
            stringify!(m_fDeltaRadius)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cocos2d_CCOrbitCamera>())).m_fAngleZ as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCOrbitCamera),
            "::",
            stringify!(m_fAngleZ)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cocos2d_CCOrbitCamera>())).m_fDeltaAngleZ as *const _ as usize
        },
        132usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCOrbitCamera),
            "::",
            stringify!(m_fDeltaAngleZ)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cocos2d_CCOrbitCamera>())).m_fAngleX as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCOrbitCamera),
            "::",
            stringify!(m_fAngleX)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cocos2d_CCOrbitCamera>())).m_fDeltaAngleX as *const _ as usize
        },
        140usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCOrbitCamera),
            "::",
            stringify!(m_fDeltaAngleX)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cocos2d_CCOrbitCamera>())).m_fRadZ as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCOrbitCamera),
            "::",
            stringify!(m_fRadZ)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cocos2d_CCOrbitCamera>())).m_fRadDeltaZ as *const _ as usize
        },
        148usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCOrbitCamera),
            "::",
            stringify!(m_fRadDeltaZ)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cocos2d_CCOrbitCamera>())).m_fRadX as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCOrbitCamera),
            "::",
            stringify!(m_fRadX)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cocos2d_CCOrbitCamera>())).m_fRadDeltaX as *const _ as usize
        },
        156usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCOrbitCamera),
            "::",
            stringify!(m_fRadDeltaX)
        )
    );
}
extern "C" {
    #[doc = " creates a CCOrbitCamera action with radius, delta-radius,  z, deltaZ, x, deltaX"]
    #[link_name = "\u{1}?create@CCOrbitCamera@cocos2d@@SAPEAV12@MMMMMMM@Z"]
    pub fn cocos2d_CCOrbitCamera_create(
        t: f32,
        radius: f32,
        deltaRadius: f32,
        angleZ: f32,
        deltaAngleZ: f32,
        angleX: f32,
        deltaAngleX: f32,
    ) -> *mut cocos2d_CCOrbitCamera;
}
extern "C" {
    #[doc = " initializes a CCOrbitCamera action with radius, delta-radius,  z, deltaZ, x, deltaX"]
    #[link_name = "\u{1}?initWithDuration@CCOrbitCamera@cocos2d@@QEAA_NMMMMMMM@Z"]
    pub fn cocos2d_CCOrbitCamera_initWithDuration(
        this: *mut cocos2d_CCOrbitCamera,
        t: f32,
        radius: f32,
        deltaRadius: f32,
        angleZ: f32,
        deltaAngleZ: f32,
        angleX: f32,
        deltaAngleX: f32,
    ) -> bool;
}
extern "C" {
    #[doc = " positions the camera according to spherical coordinates"]
    #[link_name = "\u{1}?sphericalRadius@CCOrbitCamera@cocos2d@@QEAAXPEAM00@Z"]
    pub fn cocos2d_CCOrbitCamera_sphericalRadius(
        this: *mut cocos2d_CCOrbitCamera,
        r: *mut f32,
        zenith: *mut f32,
        azimuth: *mut f32,
    );
}
impl cocos2d_CCOrbitCamera {
    #[inline]
    pub unsafe fn create(
        t: f32,
        radius: f32,
        deltaRadius: f32,
        angleZ: f32,
        deltaAngleZ: f32,
        angleX: f32,
        deltaAngleX: f32,
    ) -> *mut cocos2d_CCOrbitCamera {
        cocos2d_CCOrbitCamera_create(
            t,
            radius,
            deltaRadius,
            angleZ,
            deltaAngleZ,
            angleX,
            deltaAngleX,
        )
    }
    #[inline]
    pub unsafe fn initWithDuration(
        &mut self,
        t: f32,
        radius: f32,
        deltaRadius: f32,
        angleZ: f32,
        deltaAngleZ: f32,
        angleX: f32,
        deltaAngleX: f32,
    ) -> bool {
        cocos2d_CCOrbitCamera_initWithDuration(
            self,
            t,
            radius,
            deltaRadius,
            angleZ,
            deltaAngleZ,
            angleX,
            deltaAngleX,
        )
    }
    #[inline]
    pub unsafe fn sphericalRadius(&mut self, r: *mut f32, zenith: *mut f32, azimuth: *mut f32) {
        cocos2d_CCOrbitCamera_sphericalRadius(self, r, zenith, azimuth)
    }
}
extern "C" {
    #[doc = "  @js NA"]
    #[doc = "  @lua NA"]
    #[link_name = "\u{1}?copyWithZone@CCOrbitCamera@cocos2d@@UEAAPEAVCCObject@2@PEAVCCZone@2@@Z"]
    pub fn cocos2d_CCOrbitCamera_copyWithZone(
        this: *mut ::std::os::raw::c_void,
        pZone: *mut cocos2d_CCZone,
    ) -> *mut cocos2d_CCObject;
}
extern "C" {
    #[link_name = "\u{1}?startWithTarget@CCOrbitCamera@cocos2d@@UEAAXPEAVCCNode@2@@Z"]
    pub fn cocos2d_CCOrbitCamera_startWithTarget(
        this: *mut ::std::os::raw::c_void,
        pTarget: *mut cocos2d_CCNode,
    );
}
extern "C" {
    #[link_name = "\u{1}?update@CCOrbitCamera@cocos2d@@UEAAXM@Z"]
    pub fn cocos2d_CCOrbitCamera_update(this: *mut ::std::os::raw::c_void, time: f32);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cocos2d__hashElement {
    _unused: [u8; 0],
}
#[doc = "@brief CCActionManager is a singleton that manages all the actions."]
#[doc = "Normally you won't need to use this singleton directly. 99% of the cases you will use the CCNode interface,"]
#[doc = "which uses this singleton."]
#[doc = "But there are some cases where you might need to use this singleton."]
#[doc = "Examples:"]
#[doc = "- When you want to run an action where the target is different from a CCNode."]
#[doc = "- When you want to pause / resume the actions"]
#[doc = ""]
#[doc = "@since v0.8"]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCActionManager {
    pub _base: cocos2d_CCObject,
    pub m_pTargets: *mut cocos2d__hashElement,
    pub m_pCurrentTarget: *mut cocos2d__hashElement,
    pub m_bCurrentTargetSalvaged: bool,
}
#[test]
fn bindgen_test_layout_cocos2d_CCActionManager() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCActionManager>(),
        64usize,
        concat!("Size of: ", stringify!(cocos2d_CCActionManager))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCActionManager>(),
        8usize,
        concat!("Alignment of ", stringify!(cocos2d_CCActionManager))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cocos2d_CCActionManager>())).m_pTargets as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCActionManager),
            "::",
            stringify!(m_pTargets)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cocos2d_CCActionManager>())).m_pCurrentTarget as *const _
                as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCActionManager),
            "::",
            stringify!(m_pCurrentTarget)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cocos2d_CCActionManager>())).m_bCurrentTargetSalvaged as *const _
                as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCActionManager),
            "::",
            stringify!(m_bCurrentTargetSalvaged)
        )
    );
}
extern "C" {
    #[doc = " Adds an action with a target."]
    #[doc = "If the target is already present, then the action will be added to the existing target."]
    #[doc = "If the target is not present, a new instance of this target will be created either paused or not, and the action will be added to the newly created target."]
    #[doc = "When the target is paused, the queued actions won't be 'ticked'."]
    #[link_name = "\u{1}?addAction@CCActionManager@cocos2d@@QEAAXPEAVCCAction@2@PEAVCCNode@2@_N@Z"]
    pub fn cocos2d_CCActionManager_addAction(
        this: *mut cocos2d_CCActionManager,
        pAction: *mut cocos2d_CCAction,
        pTarget: *mut cocos2d_CCNode,
        paused: bool,
    );
}
extern "C" {
    #[doc = " Removes all actions from all the targets."]
    #[link_name = "\u{1}?removeAllActions@CCActionManager@cocos2d@@QEAAXXZ"]
    pub fn cocos2d_CCActionManager_removeAllActions(this: *mut cocos2d_CCActionManager);
}
extern "C" {
    #[doc = " Removes all actions from a certain target."]
    #[doc = "All the actions that belongs to the target will be removed."]
    #[link_name = "\u{1}?removeAllActionsFromTarget@CCActionManager@cocos2d@@QEAAXPEAVCCObject@2@@Z"]
    pub fn cocos2d_CCActionManager_removeAllActionsFromTarget(
        this: *mut cocos2d_CCActionManager,
        pTarget: *mut cocos2d_CCObject,
    );
}
extern "C" {
    #[doc = " Removes an action given an action reference."]
    #[link_name = "\u{1}?removeAction@CCActionManager@cocos2d@@QEAAXPEAVCCAction@2@@Z"]
    pub fn cocos2d_CCActionManager_removeAction(
        this: *mut cocos2d_CCActionManager,
        pAction: *mut cocos2d_CCAction,
    );
}
extern "C" {
    #[doc = " Removes an action given its tag and the target"]
    #[link_name = "\u{1}?removeActionByTag@CCActionManager@cocos2d@@QEAAXIPEAVCCObject@2@@Z"]
    pub fn cocos2d_CCActionManager_removeActionByTag(
        this: *mut cocos2d_CCActionManager,
        tag: ::std::os::raw::c_uint,
        pTarget: *mut cocos2d_CCObject,
    );
}
extern "C" {
    #[doc = " Gets an action given its tag an a target"]
    #[doc = "@return the Action the with the given tag"]
    #[link_name = "\u{1}?getActionByTag@CCActionManager@cocos2d@@QEAAPEAVCCAction@2@IPEAVCCObject@2@@Z"]
    pub fn cocos2d_CCActionManager_getActionByTag(
        this: *mut cocos2d_CCActionManager,
        tag: ::std::os::raw::c_uint,
        pTarget: *mut cocos2d_CCObject,
    ) -> *mut cocos2d_CCAction;
}
extern "C" {
    #[doc = " Returns the numbers of actions that are running in a certain target."]
    #[doc = " Composable actions are counted as 1 action. Example:"]
    #[doc = " - If you are running 1 Sequence of 7 actions, it will return 1."]
    #[doc = " - If you are running 7 Sequences of 2 actions, it will return 7."]
    #[link_name = "\u{1}?numberOfRunningActionsInTarget@CCActionManager@cocos2d@@QEAAIPEAVCCObject@2@@Z"]
    pub fn cocos2d_CCActionManager_numberOfRunningActionsInTarget(
        this: *mut cocos2d_CCActionManager,
        pTarget: *mut cocos2d_CCObject,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " Pauses the target: all running actions and newly added actions will be paused."]
    #[link_name = "\u{1}?pauseTarget@CCActionManager@cocos2d@@QEAAXPEAVCCObject@2@@Z"]
    pub fn cocos2d_CCActionManager_pauseTarget(
        this: *mut cocos2d_CCActionManager,
        pTarget: *mut cocos2d_CCObject,
    );
}
extern "C" {
    #[doc = " Resumes the target. All queued actions will be resumed."]
    #[link_name = "\u{1}?resumeTarget@CCActionManager@cocos2d@@QEAAXPEAVCCObject@2@@Z"]
    pub fn cocos2d_CCActionManager_resumeTarget(
        this: *mut cocos2d_CCActionManager,
        pTarget: *mut cocos2d_CCObject,
    );
}
extern "C" {
    #[doc = " Pauses all running actions, returning a list of targets whose actions were paused."]
    #[link_name = "\u{1}?pauseAllRunningActions@CCActionManager@cocos2d@@QEAAPEAVCCSet@2@XZ"]
    pub fn cocos2d_CCActionManager_pauseAllRunningActions(
        this: *mut cocos2d_CCActionManager,
    ) -> *mut cocos2d_CCSet;
}
extern "C" {
    #[doc = " Resume a set of targets (convenience function to reverse a pauseAllRunningActions call)"]
    #[link_name = "\u{1}?resumeTargets@CCActionManager@cocos2d@@QEAAXPEAVCCSet@2@@Z"]
    pub fn cocos2d_CCActionManager_resumeTargets(
        this: *mut cocos2d_CCActionManager,
        targetsToResume: *mut cocos2d_CCSet,
    );
}
extern "C" {
    #[link_name = "\u{1}?removeActionAtIndex@CCActionManager@cocos2d@@IEAAXIPEAU_hashElement@2@@Z"]
    pub fn cocos2d_CCActionManager_removeActionAtIndex(
        this: *mut cocos2d_CCActionManager,
        uIndex: ::std::os::raw::c_uint,
        pElement: *mut cocos2d__hashElement,
    );
}
extern "C" {
    #[link_name = "\u{1}?deleteHashElement@CCActionManager@cocos2d@@IEAAXPEAU_hashElement@2@@Z"]
    pub fn cocos2d_CCActionManager_deleteHashElement(
        this: *mut cocos2d_CCActionManager,
        pElement: *mut cocos2d__hashElement,
    );
}
extern "C" {
    #[link_name = "\u{1}?actionAllocWithHashElement@CCActionManager@cocos2d@@IEAAXPEAU_hashElement@2@@Z"]
    pub fn cocos2d_CCActionManager_actionAllocWithHashElement(
        this: *mut cocos2d_CCActionManager,
        pElement: *mut cocos2d__hashElement,
    );
}
extern "C" {
    #[doc = "  @js ctor"]
    #[link_name = "\u{1}??0CCActionManager@cocos2d@@QEAA@XZ"]
    pub fn cocos2d_CCActionManager_CCActionManager(this: *mut cocos2d_CCActionManager);
}
impl cocos2d_CCActionManager {
    #[inline]
    pub unsafe fn addAction(
        &mut self,
        pAction: *mut cocos2d_CCAction,
        pTarget: *mut cocos2d_CCNode,
        paused: bool,
    ) {
        cocos2d_CCActionManager_addAction(self, pAction, pTarget, paused)
    }
    #[inline]
    pub unsafe fn removeAllActions(&mut self) {
        cocos2d_CCActionManager_removeAllActions(self)
    }
    #[inline]
    pub unsafe fn removeAllActionsFromTarget(&mut self, pTarget: *mut cocos2d_CCObject) {
        cocos2d_CCActionManager_removeAllActionsFromTarget(self, pTarget)
    }
    #[inline]
    pub unsafe fn removeAction(&mut self, pAction: *mut cocos2d_CCAction) {
        cocos2d_CCActionManager_removeAction(self, pAction)
    }
    #[inline]
    pub unsafe fn removeActionByTag(
        &mut self,
        tag: ::std::os::raw::c_uint,
        pTarget: *mut cocos2d_CCObject,
    ) {
        cocos2d_CCActionManager_removeActionByTag(self, tag, pTarget)
    }
    #[inline]
    pub unsafe fn getActionByTag(
        &mut self,
        tag: ::std::os::raw::c_uint,
        pTarget: *mut cocos2d_CCObject,
    ) -> *mut cocos2d_CCAction {
        cocos2d_CCActionManager_getActionByTag(self, tag, pTarget)
    }
    #[inline]
    pub unsafe fn numberOfRunningActionsInTarget(
        &mut self,
        pTarget: *mut cocos2d_CCObject,
    ) -> ::std::os::raw::c_uint {
        cocos2d_CCActionManager_numberOfRunningActionsInTarget(self, pTarget)
    }
    #[inline]
    pub unsafe fn pauseTarget(&mut self, pTarget: *mut cocos2d_CCObject) {
        cocos2d_CCActionManager_pauseTarget(self, pTarget)
    }
    #[inline]
    pub unsafe fn resumeTarget(&mut self, pTarget: *mut cocos2d_CCObject) {
        cocos2d_CCActionManager_resumeTarget(self, pTarget)
    }
    #[inline]
    pub unsafe fn pauseAllRunningActions(&mut self) -> *mut cocos2d_CCSet {
        cocos2d_CCActionManager_pauseAllRunningActions(self)
    }
    #[inline]
    pub unsafe fn resumeTargets(&mut self, targetsToResume: *mut cocos2d_CCSet) {
        cocos2d_CCActionManager_resumeTargets(self, targetsToResume)
    }
    #[inline]
    pub unsafe fn removeActionAtIndex(
        &mut self,
        uIndex: ::std::os::raw::c_uint,
        pElement: *mut cocos2d__hashElement,
    ) {
        cocos2d_CCActionManager_removeActionAtIndex(self, uIndex, pElement)
    }
    #[inline]
    pub unsafe fn deleteHashElement(&mut self, pElement: *mut cocos2d__hashElement) {
        cocos2d_CCActionManager_deleteHashElement(self, pElement)
    }
    #[inline]
    pub unsafe fn actionAllocWithHashElement(&mut self, pElement: *mut cocos2d__hashElement) {
        cocos2d_CCActionManager_actionAllocWithHashElement(self, pElement)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cocos2d_CCActionManager_CCActionManager(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
}
extern "C" {
    #[doc = "  @js NA"]
    #[doc = "  @lua NA"]
    #[link_name = "\u{1}??_DCCActionManager@cocos2d@@QEAAXXZ"]
    pub fn cocos2d_CCActionManager_CCActionManager_destructor(this: *mut cocos2d_CCActionManager);
}
extern "C" {
    #[link_name = "\u{1}?update@CCActionManager@cocos2d@@MEAAXM@Z"]
    pub fn cocos2d_CCActionManager_update(this: *mut ::std::os::raw::c_void, dt: f32);
}
#[doc = "@brief Base class for Easing actions"]
#[doc = "@ingroup Actions"]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCActionEase {
    pub _base: cocos2d_CCActionInterval,
    #[doc = " The inner action"]
    pub m_pInner: *mut cocos2d_CCActionInterval,
}
#[test]
fn bindgen_test_layout_cocos2d_CCActionEase() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCActionEase>(),
        88usize,
        concat!("Size of: ", stringify!(cocos2d_CCActionEase))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCActionEase>(),
        8usize,
        concat!("Alignment of ", stringify!(cocos2d_CCActionEase))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cocos2d_CCActionEase>())).m_pInner as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCActionEase),
            "::",
            stringify!(m_pInner)
        )
    );
}
extern "C" {
    #[doc = " initializes the action"]
    #[link_name = "\u{1}?initWithAction@CCActionEase@cocos2d@@QEAA_NPEAVCCActionInterval@2@@Z"]
    pub fn cocos2d_CCActionEase_initWithAction(
        this: *mut cocos2d_CCActionEase,
        pAction: *mut cocos2d_CCActionInterval,
    ) -> bool;
}
extern "C" {
    #[doc = " creates the action"]
    #[link_name = "\u{1}?create@CCActionEase@cocos2d@@SAPEAV12@PEAVCCActionInterval@2@@Z"]
    pub fn cocos2d_CCActionEase_create(
        pAction: *mut cocos2d_CCActionInterval,
    ) -> *mut cocos2d_CCActionEase;
}
impl cocos2d_CCActionEase {
    #[inline]
    pub unsafe fn initWithAction(&mut self, pAction: *mut cocos2d_CCActionInterval) -> bool {
        cocos2d_CCActionEase_initWithAction(self, pAction)
    }
    #[inline]
    pub unsafe fn create(pAction: *mut cocos2d_CCActionInterval) -> *mut cocos2d_CCActionEase {
        cocos2d_CCActionEase_create(pAction)
    }
}
extern "C" {
    #[doc = "  @js NA"]
    #[doc = "  @lua NA"]
    #[link_name = "\u{1}??_DCCActionEase@cocos2d@@QEAAXXZ"]
    pub fn cocos2d_CCActionEase_CCActionEase_destructor(this: *mut cocos2d_CCActionEase);
}
extern "C" {
    #[doc = "  @js NA"]
    #[doc = "  @lua NA"]
    #[link_name = "\u{1}?copyWithZone@CCActionEase@cocos2d@@UEAAPEAVCCObject@2@PEAVCCZone@2@@Z"]
    pub fn cocos2d_CCActionEase_copyWithZone(
        this: *mut ::std::os::raw::c_void,
        pZone: *mut cocos2d_CCZone,
    ) -> *mut cocos2d_CCObject;
}
extern "C" {
    #[link_name = "\u{1}?startWithTarget@CCActionEase@cocos2d@@UEAAXPEAVCCNode@2@@Z"]
    pub fn cocos2d_CCActionEase_startWithTarget(
        this: *mut ::std::os::raw::c_void,
        pTarget: *mut cocos2d_CCNode,
    );
}
extern "C" {
    #[link_name = "\u{1}?stop@CCActionEase@cocos2d@@UEAAXXZ"]
    pub fn cocos2d_CCActionEase_stop(this: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[link_name = "\u{1}?update@CCActionEase@cocos2d@@UEAAXM@Z"]
    pub fn cocos2d_CCActionEase_update(this: *mut ::std::os::raw::c_void, time: f32);
}
extern "C" {
    #[link_name = "\u{1}?reverse@CCActionEase@cocos2d@@UEAAPEAVCCActionInterval@2@XZ"]
    pub fn cocos2d_CCActionEase_reverse(
        this: *mut ::std::os::raw::c_void,
    ) -> *mut cocos2d_CCActionInterval;
}
extern "C" {
    #[link_name = "\u{1}?getInnerAction@CCActionEase@cocos2d@@UEAAPEAVCCActionInterval@2@XZ"]
    pub fn cocos2d_CCActionEase_getInnerAction(
        this: *mut ::std::os::raw::c_void,
    ) -> *mut cocos2d_CCActionInterval;
}
#[doc = "@brief Base class for Easing actions with rate parameters"]
#[doc = "@ingroup Actions"]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCEaseRateAction {
    pub _base: cocos2d_CCActionEase,
    pub m_fRate: f32,
}
#[test]
fn bindgen_test_layout_cocos2d_CCEaseRateAction() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCEaseRateAction>(),
        96usize,
        concat!("Size of: ", stringify!(cocos2d_CCEaseRateAction))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCEaseRateAction>(),
        8usize,
        concat!("Alignment of ", stringify!(cocos2d_CCEaseRateAction))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cocos2d_CCEaseRateAction>())).m_fRate as *const _ as usize
        },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCEaseRateAction),
            "::",
            stringify!(m_fRate)
        )
    );
}
extern "C" {
    #[doc = " Initializes the action with the inner action and the rate parameter"]
    #[link_name = "\u{1}?initWithAction@CCEaseRateAction@cocos2d@@QEAA_NPEAVCCActionInterval@2@M@Z"]
    pub fn cocos2d_CCEaseRateAction_initWithAction(
        this: *mut cocos2d_CCEaseRateAction,
        pAction: *mut cocos2d_CCActionInterval,
        fRate: f32,
    ) -> bool;
}
extern "C" {
    #[doc = " Creates the action with the inner action and the rate parameter"]
    #[link_name = "\u{1}?create@CCEaseRateAction@cocos2d@@SAPEAV12@PEAVCCActionInterval@2@M@Z"]
    pub fn cocos2d_CCEaseRateAction_create(
        pAction: *mut cocos2d_CCActionInterval,
        fRate: f32,
    ) -> *mut cocos2d_CCEaseRateAction;
}
impl cocos2d_CCEaseRateAction {
    #[inline]
    pub unsafe fn initWithAction(
        &mut self,
        pAction: *mut cocos2d_CCActionInterval,
        fRate: f32,
    ) -> bool {
        cocos2d_CCEaseRateAction_initWithAction(self, pAction, fRate)
    }
    #[inline]
    pub unsafe fn create(
        pAction: *mut cocos2d_CCActionInterval,
        fRate: f32,
    ) -> *mut cocos2d_CCEaseRateAction {
        cocos2d_CCEaseRateAction_create(pAction, fRate)
    }
}
extern "C" {
    #[doc = "  @js NA"]
    #[doc = "  @lua NA"]
    #[link_name = "\u{1}??_DCCEaseRateAction@cocos2d@@QEAAXXZ"]
    pub fn cocos2d_CCEaseRateAction_CCEaseRateAction_destructor(
        this: *mut cocos2d_CCEaseRateAction,
    );
}
extern "C" {
    #[doc = "  @js NA"]
    #[doc = "  @lua NA"]
    #[link_name = "\u{1}?copyWithZone@CCEaseRateAction@cocos2d@@UEAAPEAVCCObject@2@PEAVCCZone@2@@Z"]
    pub fn cocos2d_CCEaseRateAction_copyWithZone(
        this: *mut ::std::os::raw::c_void,
        pZone: *mut cocos2d_CCZone,
    ) -> *mut cocos2d_CCObject;
}
extern "C" {
    #[link_name = "\u{1}?reverse@CCEaseRateAction@cocos2d@@UEAAPEAVCCActionInterval@2@XZ"]
    pub fn cocos2d_CCEaseRateAction_reverse(
        this: *mut ::std::os::raw::c_void,
    ) -> *mut cocos2d_CCActionInterval;
}
#[doc = "@brief CCEaseIn action with a rate"]
#[doc = "@ingroup Actions"]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCEaseIn {
    pub _base: cocos2d_CCEaseRateAction,
}
#[test]
fn bindgen_test_layout_cocos2d_CCEaseIn() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCEaseIn>(),
        96usize,
        concat!("Size of: ", stringify!(cocos2d_CCEaseIn))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCEaseIn>(),
        8usize,
        concat!("Alignment of ", stringify!(cocos2d_CCEaseIn))
    );
}
extern "C" {
    #[doc = " Creates the action with the inner action and the rate parameter"]
    #[link_name = "\u{1}?create@CCEaseIn@cocos2d@@SAPEAV12@PEAVCCActionInterval@2@M@Z"]
    pub fn cocos2d_CCEaseIn_create(
        pAction: *mut cocos2d_CCActionInterval,
        fRate: f32,
    ) -> *mut cocos2d_CCEaseIn;
}
impl cocos2d_CCEaseIn {
    #[inline]
    pub unsafe fn create(
        pAction: *mut cocos2d_CCActionInterval,
        fRate: f32,
    ) -> *mut cocos2d_CCEaseIn {
        cocos2d_CCEaseIn_create(pAction, fRate)
    }
}
extern "C" {
    #[link_name = "\u{1}?update@CCEaseIn@cocos2d@@UEAAXM@Z"]
    pub fn cocos2d_CCEaseIn_update(this: *mut ::std::os::raw::c_void, time: f32);
}
extern "C" {
    #[link_name = "\u{1}?reverse@CCEaseIn@cocos2d@@UEAAPEAVCCActionInterval@2@XZ"]
    pub fn cocos2d_CCEaseIn_reverse(
        this: *mut ::std::os::raw::c_void,
    ) -> *mut cocos2d_CCActionInterval;
}
extern "C" {
    #[doc = "  @js NA"]
    #[doc = "  @lua NA"]
    #[link_name = "\u{1}?copyWithZone@CCEaseIn@cocos2d@@UEAAPEAVCCObject@2@PEAVCCZone@2@@Z"]
    pub fn cocos2d_CCEaseIn_copyWithZone(
        this: *mut ::std::os::raw::c_void,
        pZone: *mut cocos2d_CCZone,
    ) -> *mut cocos2d_CCObject;
}
#[doc = "@brief CCEaseOut action with a rate"]
#[doc = "@ingroup Actions"]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCEaseOut {
    pub _base: cocos2d_CCEaseRateAction,
}
#[test]
fn bindgen_test_layout_cocos2d_CCEaseOut() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCEaseOut>(),
        96usize,
        concat!("Size of: ", stringify!(cocos2d_CCEaseOut))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCEaseOut>(),
        8usize,
        concat!("Alignment of ", stringify!(cocos2d_CCEaseOut))
    );
}
extern "C" {
    #[doc = " Creates the action with the inner action and the rate parameter"]
    #[link_name = "\u{1}?create@CCEaseOut@cocos2d@@SAPEAV12@PEAVCCActionInterval@2@M@Z"]
    pub fn cocos2d_CCEaseOut_create(
        pAction: *mut cocos2d_CCActionInterval,
        fRate: f32,
    ) -> *mut cocos2d_CCEaseOut;
}
impl cocos2d_CCEaseOut {
    #[inline]
    pub unsafe fn create(
        pAction: *mut cocos2d_CCActionInterval,
        fRate: f32,
    ) -> *mut cocos2d_CCEaseOut {
        cocos2d_CCEaseOut_create(pAction, fRate)
    }
}
extern "C" {
    #[link_name = "\u{1}?update@CCEaseOut@cocos2d@@UEAAXM@Z"]
    pub fn cocos2d_CCEaseOut_update(this: *mut ::std::os::raw::c_void, time: f32);
}
extern "C" {
    #[link_name = "\u{1}?reverse@CCEaseOut@cocos2d@@UEAAPEAVCCActionInterval@2@XZ"]
    pub fn cocos2d_CCEaseOut_reverse(
        this: *mut ::std::os::raw::c_void,
    ) -> *mut cocos2d_CCActionInterval;
}
extern "C" {
    #[doc = "  @js NA"]
    #[doc = "  @lua NA"]
    #[link_name = "\u{1}?copyWithZone@CCEaseOut@cocos2d@@UEAAPEAVCCObject@2@PEAVCCZone@2@@Z"]
    pub fn cocos2d_CCEaseOut_copyWithZone(
        this: *mut ::std::os::raw::c_void,
        pZone: *mut cocos2d_CCZone,
    ) -> *mut cocos2d_CCObject;
}
#[doc = "@brief CCEaseInOut action with a rate"]
#[doc = "@ingroup Actions"]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCEaseInOut {
    pub _base: cocos2d_CCEaseRateAction,
}
#[test]
fn bindgen_test_layout_cocos2d_CCEaseInOut() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCEaseInOut>(),
        96usize,
        concat!("Size of: ", stringify!(cocos2d_CCEaseInOut))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCEaseInOut>(),
        8usize,
        concat!("Alignment of ", stringify!(cocos2d_CCEaseInOut))
    );
}
extern "C" {
    #[doc = " Creates the action with the inner action and the rate parameter"]
    #[link_name = "\u{1}?create@CCEaseInOut@cocos2d@@SAPEAV12@PEAVCCActionInterval@2@M@Z"]
    pub fn cocos2d_CCEaseInOut_create(
        pAction: *mut cocos2d_CCActionInterval,
        fRate: f32,
    ) -> *mut cocos2d_CCEaseInOut;
}
impl cocos2d_CCEaseInOut {
    #[inline]
    pub unsafe fn create(
        pAction: *mut cocos2d_CCActionInterval,
        fRate: f32,
    ) -> *mut cocos2d_CCEaseInOut {
        cocos2d_CCEaseInOut_create(pAction, fRate)
    }
}
extern "C" {
    #[link_name = "\u{1}?update@CCEaseInOut@cocos2d@@UEAAXM@Z"]
    pub fn cocos2d_CCEaseInOut_update(this: *mut ::std::os::raw::c_void, time: f32);
}
extern "C" {
    #[doc = "  @js NA"]
    #[doc = "  @lua NA"]
    #[link_name = "\u{1}?copyWithZone@CCEaseInOut@cocos2d@@UEAAPEAVCCObject@2@PEAVCCZone@2@@Z"]
    pub fn cocos2d_CCEaseInOut_copyWithZone(
        this: *mut ::std::os::raw::c_void,
        pZone: *mut cocos2d_CCZone,
    ) -> *mut cocos2d_CCObject;
}
extern "C" {
    #[link_name = "\u{1}?reverse@CCEaseInOut@cocos2d@@UEAAPEAVCCActionInterval@2@XZ"]
    pub fn cocos2d_CCEaseInOut_reverse(
        this: *mut ::std::os::raw::c_void,
    ) -> *mut cocos2d_CCActionInterval;
}
#[doc = "@brief CCEase Exponential In"]
#[doc = "@ingroup Actions"]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCEaseExponentialIn {
    pub _base: cocos2d_CCActionEase,
}
#[test]
fn bindgen_test_layout_cocos2d_CCEaseExponentialIn() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCEaseExponentialIn>(),
        88usize,
        concat!("Size of: ", stringify!(cocos2d_CCEaseExponentialIn))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCEaseExponentialIn>(),
        8usize,
        concat!("Alignment of ", stringify!(cocos2d_CCEaseExponentialIn))
    );
}
extern "C" {
    #[doc = " creates the action"]
    #[link_name = "\u{1}?create@CCEaseExponentialIn@cocos2d@@SAPEAV12@PEAVCCActionInterval@2@@Z"]
    pub fn cocos2d_CCEaseExponentialIn_create(
        pAction: *mut cocos2d_CCActionInterval,
    ) -> *mut cocos2d_CCEaseExponentialIn;
}
impl cocos2d_CCEaseExponentialIn {
    #[inline]
    pub unsafe fn create(
        pAction: *mut cocos2d_CCActionInterval,
    ) -> *mut cocos2d_CCEaseExponentialIn {
        cocos2d_CCEaseExponentialIn_create(pAction)
    }
}
extern "C" {
    #[link_name = "\u{1}?update@CCEaseExponentialIn@cocos2d@@UEAAXM@Z"]
    pub fn cocos2d_CCEaseExponentialIn_update(this: *mut ::std::os::raw::c_void, time: f32);
}
extern "C" {
    #[link_name = "\u{1}?reverse@CCEaseExponentialIn@cocos2d@@UEAAPEAVCCActionInterval@2@XZ"]
    pub fn cocos2d_CCEaseExponentialIn_reverse(
        this: *mut ::std::os::raw::c_void,
    ) -> *mut cocos2d_CCActionInterval;
}
extern "C" {
    #[doc = "  @js NA"]
    #[doc = "  @lua NA"]
    #[link_name = "\u{1}?copyWithZone@CCEaseExponentialIn@cocos2d@@UEAAPEAVCCObject@2@PEAVCCZone@2@@Z"]
    pub fn cocos2d_CCEaseExponentialIn_copyWithZone(
        this: *mut ::std::os::raw::c_void,
        pZone: *mut cocos2d_CCZone,
    ) -> *mut cocos2d_CCObject;
}
#[doc = "@brief Ease Exponential Out"]
#[doc = "@ingroup Actions"]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCEaseExponentialOut {
    pub _base: cocos2d_CCActionEase,
}
#[test]
fn bindgen_test_layout_cocos2d_CCEaseExponentialOut() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCEaseExponentialOut>(),
        88usize,
        concat!("Size of: ", stringify!(cocos2d_CCEaseExponentialOut))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCEaseExponentialOut>(),
        8usize,
        concat!("Alignment of ", stringify!(cocos2d_CCEaseExponentialOut))
    );
}
extern "C" {
    #[doc = " creates the action"]
    #[link_name = "\u{1}?create@CCEaseExponentialOut@cocos2d@@SAPEAV12@PEAVCCActionInterval@2@@Z"]
    pub fn cocos2d_CCEaseExponentialOut_create(
        pAction: *mut cocos2d_CCActionInterval,
    ) -> *mut cocos2d_CCEaseExponentialOut;
}
impl cocos2d_CCEaseExponentialOut {
    #[inline]
    pub unsafe fn create(
        pAction: *mut cocos2d_CCActionInterval,
    ) -> *mut cocos2d_CCEaseExponentialOut {
        cocos2d_CCEaseExponentialOut_create(pAction)
    }
}
extern "C" {
    #[link_name = "\u{1}?update@CCEaseExponentialOut@cocos2d@@UEAAXM@Z"]
    pub fn cocos2d_CCEaseExponentialOut_update(this: *mut ::std::os::raw::c_void, time: f32);
}
extern "C" {
    #[link_name = "\u{1}?reverse@CCEaseExponentialOut@cocos2d@@UEAAPEAVCCActionInterval@2@XZ"]
    pub fn cocos2d_CCEaseExponentialOut_reverse(
        this: *mut ::std::os::raw::c_void,
    ) -> *mut cocos2d_CCActionInterval;
}
extern "C" {
    #[doc = "  @js NA"]
    #[doc = "  @lua NA"]
    #[link_name = "\u{1}?copyWithZone@CCEaseExponentialOut@cocos2d@@UEAAPEAVCCObject@2@PEAVCCZone@2@@Z"]
    pub fn cocos2d_CCEaseExponentialOut_copyWithZone(
        this: *mut ::std::os::raw::c_void,
        pZone: *mut cocos2d_CCZone,
    ) -> *mut cocos2d_CCObject;
}
#[doc = "@brief Ease Exponential InOut"]
#[doc = "@ingroup Actions"]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCEaseExponentialInOut {
    pub _base: cocos2d_CCActionEase,
}
#[test]
fn bindgen_test_layout_cocos2d_CCEaseExponentialInOut() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCEaseExponentialInOut>(),
        88usize,
        concat!("Size of: ", stringify!(cocos2d_CCEaseExponentialInOut))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCEaseExponentialInOut>(),
        8usize,
        concat!("Alignment of ", stringify!(cocos2d_CCEaseExponentialInOut))
    );
}
extern "C" {
    #[doc = " creates the action"]
    #[link_name = "\u{1}?create@CCEaseExponentialInOut@cocos2d@@SAPEAV12@PEAVCCActionInterval@2@@Z"]
    pub fn cocos2d_CCEaseExponentialInOut_create(
        pAction: *mut cocos2d_CCActionInterval,
    ) -> *mut cocos2d_CCEaseExponentialInOut;
}
impl cocos2d_CCEaseExponentialInOut {
    #[inline]
    pub unsafe fn create(
        pAction: *mut cocos2d_CCActionInterval,
    ) -> *mut cocos2d_CCEaseExponentialInOut {
        cocos2d_CCEaseExponentialInOut_create(pAction)
    }
}
extern "C" {
    #[link_name = "\u{1}?update@CCEaseExponentialInOut@cocos2d@@UEAAXM@Z"]
    pub fn cocos2d_CCEaseExponentialInOut_update(this: *mut ::std::os::raw::c_void, time: f32);
}
extern "C" {
    #[doc = "  @js NA"]
    #[doc = "  @lua NA"]
    #[link_name = "\u{1}?copyWithZone@CCEaseExponentialInOut@cocos2d@@UEAAPEAVCCObject@2@PEAVCCZone@2@@Z"]
    pub fn cocos2d_CCEaseExponentialInOut_copyWithZone(
        this: *mut ::std::os::raw::c_void,
        pZone: *mut cocos2d_CCZone,
    ) -> *mut cocos2d_CCObject;
}
extern "C" {
    #[link_name = "\u{1}?reverse@CCEaseExponentialInOut@cocos2d@@UEAAPEAVCCActionInterval@2@XZ"]
    pub fn cocos2d_CCEaseExponentialInOut_reverse(
        this: *mut ::std::os::raw::c_void,
    ) -> *mut cocos2d_CCActionInterval;
}
#[doc = "@brief Ease Sine In"]
#[doc = "@ingroup Actions"]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCEaseSineIn {
    pub _base: cocos2d_CCActionEase,
}
#[test]
fn bindgen_test_layout_cocos2d_CCEaseSineIn() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCEaseSineIn>(),
        88usize,
        concat!("Size of: ", stringify!(cocos2d_CCEaseSineIn))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCEaseSineIn>(),
        8usize,
        concat!("Alignment of ", stringify!(cocos2d_CCEaseSineIn))
    );
}
extern "C" {
    #[doc = " creates the action"]
    #[link_name = "\u{1}?create@CCEaseSineIn@cocos2d@@SAPEAV12@PEAVCCActionInterval@2@@Z"]
    pub fn cocos2d_CCEaseSineIn_create(
        pAction: *mut cocos2d_CCActionInterval,
    ) -> *mut cocos2d_CCEaseSineIn;
}
impl cocos2d_CCEaseSineIn {
    #[inline]
    pub unsafe fn create(pAction: *mut cocos2d_CCActionInterval) -> *mut cocos2d_CCEaseSineIn {
        cocos2d_CCEaseSineIn_create(pAction)
    }
}
extern "C" {
    #[link_name = "\u{1}?update@CCEaseSineIn@cocos2d@@UEAAXM@Z"]
    pub fn cocos2d_CCEaseSineIn_update(this: *mut ::std::os::raw::c_void, time: f32);
}
extern "C" {
    #[link_name = "\u{1}?reverse@CCEaseSineIn@cocos2d@@UEAAPEAVCCActionInterval@2@XZ"]
    pub fn cocos2d_CCEaseSineIn_reverse(
        this: *mut ::std::os::raw::c_void,
    ) -> *mut cocos2d_CCActionInterval;
}
extern "C" {
    #[doc = "  @js NA"]
    #[doc = "  @lua NA"]
    #[link_name = "\u{1}?copyWithZone@CCEaseSineIn@cocos2d@@UEAAPEAVCCObject@2@PEAVCCZone@2@@Z"]
    pub fn cocos2d_CCEaseSineIn_copyWithZone(
        this: *mut ::std::os::raw::c_void,
        pZone: *mut cocos2d_CCZone,
    ) -> *mut cocos2d_CCObject;
}
#[doc = "@brief Ease Sine Out"]
#[doc = "@ingroup Actions"]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCEaseSineOut {
    pub _base: cocos2d_CCActionEase,
}
#[test]
fn bindgen_test_layout_cocos2d_CCEaseSineOut() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCEaseSineOut>(),
        88usize,
        concat!("Size of: ", stringify!(cocos2d_CCEaseSineOut))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCEaseSineOut>(),
        8usize,
        concat!("Alignment of ", stringify!(cocos2d_CCEaseSineOut))
    );
}
extern "C" {
    #[doc = " creates the action"]
    #[link_name = "\u{1}?create@CCEaseSineOut@cocos2d@@SAPEAV12@PEAVCCActionInterval@2@@Z"]
    pub fn cocos2d_CCEaseSineOut_create(
        pAction: *mut cocos2d_CCActionInterval,
    ) -> *mut cocos2d_CCEaseSineOut;
}
impl cocos2d_CCEaseSineOut {
    #[inline]
    pub unsafe fn create(pAction: *mut cocos2d_CCActionInterval) -> *mut cocos2d_CCEaseSineOut {
        cocos2d_CCEaseSineOut_create(pAction)
    }
}
extern "C" {
    #[link_name = "\u{1}?update@CCEaseSineOut@cocos2d@@UEAAXM@Z"]
    pub fn cocos2d_CCEaseSineOut_update(this: *mut ::std::os::raw::c_void, time: f32);
}
extern "C" {
    #[link_name = "\u{1}?reverse@CCEaseSineOut@cocos2d@@UEAAPEAVCCActionInterval@2@XZ"]
    pub fn cocos2d_CCEaseSineOut_reverse(
        this: *mut ::std::os::raw::c_void,
    ) -> *mut cocos2d_CCActionInterval;
}
extern "C" {
    #[doc = "  @js NA"]
    #[doc = "  @lua NA"]
    #[link_name = "\u{1}?copyWithZone@CCEaseSineOut@cocos2d@@UEAAPEAVCCObject@2@PEAVCCZone@2@@Z"]
    pub fn cocos2d_CCEaseSineOut_copyWithZone(
        this: *mut ::std::os::raw::c_void,
        pZone: *mut cocos2d_CCZone,
    ) -> *mut cocos2d_CCObject;
}
#[doc = "@brief Ease Sine InOut"]
#[doc = "@ingroup Actions"]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCEaseSineInOut {
    pub _base: cocos2d_CCActionEase,
}
#[test]
fn bindgen_test_layout_cocos2d_CCEaseSineInOut() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCEaseSineInOut>(),
        88usize,
        concat!("Size of: ", stringify!(cocos2d_CCEaseSineInOut))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCEaseSineInOut>(),
        8usize,
        concat!("Alignment of ", stringify!(cocos2d_CCEaseSineInOut))
    );
}
extern "C" {
    #[doc = " creates the action"]
    #[link_name = "\u{1}?create@CCEaseSineInOut@cocos2d@@SAPEAV12@PEAVCCActionInterval@2@@Z"]
    pub fn cocos2d_CCEaseSineInOut_create(
        pAction: *mut cocos2d_CCActionInterval,
    ) -> *mut cocos2d_CCEaseSineInOut;
}
impl cocos2d_CCEaseSineInOut {
    #[inline]
    pub unsafe fn create(pAction: *mut cocos2d_CCActionInterval) -> *mut cocos2d_CCEaseSineInOut {
        cocos2d_CCEaseSineInOut_create(pAction)
    }
}
extern "C" {
    #[link_name = "\u{1}?update@CCEaseSineInOut@cocos2d@@UEAAXM@Z"]
    pub fn cocos2d_CCEaseSineInOut_update(this: *mut ::std::os::raw::c_void, time: f32);
}
extern "C" {
    #[doc = "  @js NA"]
    #[doc = "  @lua NA"]
    #[link_name = "\u{1}?copyWithZone@CCEaseSineInOut@cocos2d@@UEAAPEAVCCObject@2@PEAVCCZone@2@@Z"]
    pub fn cocos2d_CCEaseSineInOut_copyWithZone(
        this: *mut ::std::os::raw::c_void,
        pZone: *mut cocos2d_CCZone,
    ) -> *mut cocos2d_CCObject;
}
extern "C" {
    #[link_name = "\u{1}?reverse@CCEaseSineInOut@cocos2d@@UEAAPEAVCCActionInterval@2@XZ"]
    pub fn cocos2d_CCEaseSineInOut_reverse(
        this: *mut ::std::os::raw::c_void,
    ) -> *mut cocos2d_CCActionInterval;
}
#[doc = "@brief Ease Elastic abstract class"]
#[doc = "@since v0.8.2"]
#[doc = "@ingroup Actions"]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCEaseElastic {
    pub _base: cocos2d_CCActionEase,
    pub m_fPeriod: f32,
}
#[test]
fn bindgen_test_layout_cocos2d_CCEaseElastic() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCEaseElastic>(),
        96usize,
        concat!("Size of: ", stringify!(cocos2d_CCEaseElastic))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCEaseElastic>(),
        8usize,
        concat!("Alignment of ", stringify!(cocos2d_CCEaseElastic))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cocos2d_CCEaseElastic>())).m_fPeriod as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCEaseElastic),
            "::",
            stringify!(m_fPeriod)
        )
    );
}
extern "C" {
    #[doc = " Initializes the action with the inner action and the period in radians (default is 0.3)"]
    #[link_name = "\u{1}?initWithAction@CCEaseElastic@cocos2d@@QEAA_NPEAVCCActionInterval@2@M@Z"]
    pub fn cocos2d_CCEaseElastic_initWithAction(
        this: *mut cocos2d_CCEaseElastic,
        pAction: *mut cocos2d_CCActionInterval,
        fPeriod: f32,
    ) -> bool;
}
extern "C" {
    #[doc = " Creates the action with the inner action and the period in radians (default is 0.3)"]
    #[link_name = "\u{1}?create@CCEaseElastic@cocos2d@@SAPEAV12@PEAVCCActionInterval@2@M@Z"]
    pub fn cocos2d_CCEaseElastic_create(
        pAction: *mut cocos2d_CCActionInterval,
        fPeriod: f32,
    ) -> *mut cocos2d_CCEaseElastic;
}
extern "C" {
    #[link_name = "\u{1}?create@CCEaseElastic@cocos2d@@SAPEAV12@PEAVCCActionInterval@2@@Z"]
    pub fn cocos2d_CCEaseElastic_create1(
        pAction: *mut cocos2d_CCActionInterval,
    ) -> *mut cocos2d_CCEaseElastic;
}
impl cocos2d_CCEaseElastic {
    #[inline]
    pub unsafe fn initWithAction(
        &mut self,
        pAction: *mut cocos2d_CCActionInterval,
        fPeriod: f32,
    ) -> bool {
        cocos2d_CCEaseElastic_initWithAction(self, pAction, fPeriod)
    }
    #[inline]
    pub unsafe fn create(
        pAction: *mut cocos2d_CCActionInterval,
        fPeriod: f32,
    ) -> *mut cocos2d_CCEaseElastic {
        cocos2d_CCEaseElastic_create(pAction, fPeriod)
    }
    #[inline]
    pub unsafe fn create1(pAction: *mut cocos2d_CCActionInterval) -> *mut cocos2d_CCEaseElastic {
        cocos2d_CCEaseElastic_create1(pAction)
    }
}
extern "C" {
    #[link_name = "\u{1}?reverse@CCEaseElastic@cocos2d@@UEAAPEAVCCActionInterval@2@XZ"]
    pub fn cocos2d_CCEaseElastic_reverse(
        this: *mut ::std::os::raw::c_void,
    ) -> *mut cocos2d_CCActionInterval;
}
extern "C" {
    #[doc = "  @js NA"]
    #[doc = "  @lua NA"]
    #[link_name = "\u{1}?copyWithZone@CCEaseElastic@cocos2d@@UEAAPEAVCCObject@2@PEAVCCZone@2@@Z"]
    pub fn cocos2d_CCEaseElastic_copyWithZone(
        this: *mut ::std::os::raw::c_void,
        pZone: *mut cocos2d_CCZone,
    ) -> *mut cocos2d_CCObject;
}
#[doc = "@brief Ease Elastic In action."]
#[doc = "@warning This action doesn't use a bijective function. Actions like Sequence might have an unexpected result when used with this action."]
#[doc = "@since v0.8.2"]
#[doc = "@ingroup Actions"]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCEaseElasticIn {
    pub _base: cocos2d_CCEaseElastic,
}
#[test]
fn bindgen_test_layout_cocos2d_CCEaseElasticIn() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCEaseElasticIn>(),
        96usize,
        concat!("Size of: ", stringify!(cocos2d_CCEaseElasticIn))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCEaseElasticIn>(),
        8usize,
        concat!("Alignment of ", stringify!(cocos2d_CCEaseElasticIn))
    );
}
extern "C" {
    #[doc = " Creates the action with the inner action and the period in radians (default is 0.3)"]
    #[link_name = "\u{1}?create@CCEaseElasticIn@cocos2d@@SAPEAV12@PEAVCCActionInterval@2@M@Z"]
    pub fn cocos2d_CCEaseElasticIn_create(
        pAction: *mut cocos2d_CCActionInterval,
        fPeriod: f32,
    ) -> *mut cocos2d_CCEaseElasticIn;
}
extern "C" {
    #[link_name = "\u{1}?create@CCEaseElasticIn@cocos2d@@SAPEAV12@PEAVCCActionInterval@2@@Z"]
    pub fn cocos2d_CCEaseElasticIn_create1(
        pAction: *mut cocos2d_CCActionInterval,
    ) -> *mut cocos2d_CCEaseElasticIn;
}
impl cocos2d_CCEaseElasticIn {
    #[inline]
    pub unsafe fn create(
        pAction: *mut cocos2d_CCActionInterval,
        fPeriod: f32,
    ) -> *mut cocos2d_CCEaseElasticIn {
        cocos2d_CCEaseElasticIn_create(pAction, fPeriod)
    }
    #[inline]
    pub unsafe fn create1(pAction: *mut cocos2d_CCActionInterval) -> *mut cocos2d_CCEaseElasticIn {
        cocos2d_CCEaseElasticIn_create1(pAction)
    }
}
extern "C" {
    #[link_name = "\u{1}?update@CCEaseElasticIn@cocos2d@@UEAAXM@Z"]
    pub fn cocos2d_CCEaseElasticIn_update(this: *mut ::std::os::raw::c_void, time: f32);
}
extern "C" {
    #[link_name = "\u{1}?reverse@CCEaseElasticIn@cocos2d@@UEAAPEAVCCActionInterval@2@XZ"]
    pub fn cocos2d_CCEaseElasticIn_reverse(
        this: *mut ::std::os::raw::c_void,
    ) -> *mut cocos2d_CCActionInterval;
}
extern "C" {
    #[doc = "  @js NA"]
    #[doc = "  @lua NA"]
    #[link_name = "\u{1}?copyWithZone@CCEaseElasticIn@cocos2d@@UEAAPEAVCCObject@2@PEAVCCZone@2@@Z"]
    pub fn cocos2d_CCEaseElasticIn_copyWithZone(
        this: *mut ::std::os::raw::c_void,
        pZone: *mut cocos2d_CCZone,
    ) -> *mut cocos2d_CCObject;
}
#[doc = "@brief Ease Elastic Out action."]
#[doc = "@warning This action doesn't use a bijective function. Actions like Sequence might have an unexpected result when used with this action."]
#[doc = "@since v0.8.2"]
#[doc = "@ingroup Actions"]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCEaseElasticOut {
    pub _base: cocos2d_CCEaseElastic,
}
#[test]
fn bindgen_test_layout_cocos2d_CCEaseElasticOut() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCEaseElasticOut>(),
        96usize,
        concat!("Size of: ", stringify!(cocos2d_CCEaseElasticOut))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCEaseElasticOut>(),
        8usize,
        concat!("Alignment of ", stringify!(cocos2d_CCEaseElasticOut))
    );
}
extern "C" {
    #[doc = " Creates the action with the inner action and the period in radians (default is 0.3)"]
    #[link_name = "\u{1}?create@CCEaseElasticOut@cocos2d@@SAPEAV12@PEAVCCActionInterval@2@M@Z"]
    pub fn cocos2d_CCEaseElasticOut_create(
        pAction: *mut cocos2d_CCActionInterval,
        fPeriod: f32,
    ) -> *mut cocos2d_CCEaseElasticOut;
}
extern "C" {
    #[link_name = "\u{1}?create@CCEaseElasticOut@cocos2d@@SAPEAV12@PEAVCCActionInterval@2@@Z"]
    pub fn cocos2d_CCEaseElasticOut_create1(
        pAction: *mut cocos2d_CCActionInterval,
    ) -> *mut cocos2d_CCEaseElasticOut;
}
impl cocos2d_CCEaseElasticOut {
    #[inline]
    pub unsafe fn create(
        pAction: *mut cocos2d_CCActionInterval,
        fPeriod: f32,
    ) -> *mut cocos2d_CCEaseElasticOut {
        cocos2d_CCEaseElasticOut_create(pAction, fPeriod)
    }
    #[inline]
    pub unsafe fn create1(pAction: *mut cocos2d_CCActionInterval) -> *mut cocos2d_CCEaseElasticOut {
        cocos2d_CCEaseElasticOut_create1(pAction)
    }
}
extern "C" {
    #[link_name = "\u{1}?update@CCEaseElasticOut@cocos2d@@UEAAXM@Z"]
    pub fn cocos2d_CCEaseElasticOut_update(this: *mut ::std::os::raw::c_void, time: f32);
}
extern "C" {
    #[link_name = "\u{1}?reverse@CCEaseElasticOut@cocos2d@@UEAAPEAVCCActionInterval@2@XZ"]
    pub fn cocos2d_CCEaseElasticOut_reverse(
        this: *mut ::std::os::raw::c_void,
    ) -> *mut cocos2d_CCActionInterval;
}
extern "C" {
    #[doc = "  @js NA"]
    #[doc = "  @lua NA"]
    #[link_name = "\u{1}?copyWithZone@CCEaseElasticOut@cocos2d@@UEAAPEAVCCObject@2@PEAVCCZone@2@@Z"]
    pub fn cocos2d_CCEaseElasticOut_copyWithZone(
        this: *mut ::std::os::raw::c_void,
        pZone: *mut cocos2d_CCZone,
    ) -> *mut cocos2d_CCObject;
}
#[doc = "@brief Ease Elastic InOut action."]
#[doc = "@warning This action doesn't use a bijective function. Actions like Sequence might have an unexpected result when used with this action."]
#[doc = "@since v0.8.2"]
#[doc = "@ingroup Actions"]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCEaseElasticInOut {
    pub _base: cocos2d_CCEaseElastic,
}
#[test]
fn bindgen_test_layout_cocos2d_CCEaseElasticInOut() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCEaseElasticInOut>(),
        96usize,
        concat!("Size of: ", stringify!(cocos2d_CCEaseElasticInOut))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCEaseElasticInOut>(),
        8usize,
        concat!("Alignment of ", stringify!(cocos2d_CCEaseElasticInOut))
    );
}
extern "C" {
    #[doc = " Creates the action with the inner action and the period in radians (default is 0.3)"]
    #[link_name = "\u{1}?create@CCEaseElasticInOut@cocos2d@@SAPEAV12@PEAVCCActionInterval@2@M@Z"]
    pub fn cocos2d_CCEaseElasticInOut_create(
        pAction: *mut cocos2d_CCActionInterval,
        fPeriod: f32,
    ) -> *mut cocos2d_CCEaseElasticInOut;
}
extern "C" {
    #[link_name = "\u{1}?create@CCEaseElasticInOut@cocos2d@@SAPEAV12@PEAVCCActionInterval@2@@Z"]
    pub fn cocos2d_CCEaseElasticInOut_create1(
        pAction: *mut cocos2d_CCActionInterval,
    ) -> *mut cocos2d_CCEaseElasticInOut;
}
impl cocos2d_CCEaseElasticInOut {
    #[inline]
    pub unsafe fn create(
        pAction: *mut cocos2d_CCActionInterval,
        fPeriod: f32,
    ) -> *mut cocos2d_CCEaseElasticInOut {
        cocos2d_CCEaseElasticInOut_create(pAction, fPeriod)
    }
    #[inline]
    pub unsafe fn create1(
        pAction: *mut cocos2d_CCActionInterval,
    ) -> *mut cocos2d_CCEaseElasticInOut {
        cocos2d_CCEaseElasticInOut_create1(pAction)
    }
}
extern "C" {
    #[link_name = "\u{1}?update@CCEaseElasticInOut@cocos2d@@UEAAXM@Z"]
    pub fn cocos2d_CCEaseElasticInOut_update(this: *mut ::std::os::raw::c_void, time: f32);
}
extern "C" {
    #[link_name = "\u{1}?reverse@CCEaseElasticInOut@cocos2d@@UEAAPEAVCCActionInterval@2@XZ"]
    pub fn cocos2d_CCEaseElasticInOut_reverse(
        this: *mut ::std::os::raw::c_void,
    ) -> *mut cocos2d_CCActionInterval;
}
extern "C" {
    #[doc = "  @js NA"]
    #[doc = "  @lua NA"]
    #[link_name = "\u{1}?copyWithZone@CCEaseElasticInOut@cocos2d@@UEAAPEAVCCObject@2@PEAVCCZone@2@@Z"]
    pub fn cocos2d_CCEaseElasticInOut_copyWithZone(
        this: *mut ::std::os::raw::c_void,
        pZone: *mut cocos2d_CCZone,
    ) -> *mut cocos2d_CCObject;
}
#[doc = "@brief CCEaseBounce abstract class."]
#[doc = "@since v0.8.2"]
#[doc = "@ingroup Actions"]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCEaseBounce {
    pub _base: cocos2d_CCActionEase,
}
#[test]
fn bindgen_test_layout_cocos2d_CCEaseBounce() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCEaseBounce>(),
        88usize,
        concat!("Size of: ", stringify!(cocos2d_CCEaseBounce))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCEaseBounce>(),
        8usize,
        concat!("Alignment of ", stringify!(cocos2d_CCEaseBounce))
    );
}
extern "C" {
    #[link_name = "\u{1}?bounceTime@CCEaseBounce@cocos2d@@QEAAMM@Z"]
    pub fn cocos2d_CCEaseBounce_bounceTime(this: *mut cocos2d_CCEaseBounce, time: f32) -> f32;
}
extern "C" {
    #[doc = " creates the action"]
    #[link_name = "\u{1}?create@CCEaseBounce@cocos2d@@SAPEAV12@PEAVCCActionInterval@2@@Z"]
    pub fn cocos2d_CCEaseBounce_create(
        pAction: *mut cocos2d_CCActionInterval,
    ) -> *mut cocos2d_CCEaseBounce;
}
impl cocos2d_CCEaseBounce {
    #[inline]
    pub unsafe fn bounceTime(&mut self, time: f32) -> f32 {
        cocos2d_CCEaseBounce_bounceTime(self, time)
    }
    #[inline]
    pub unsafe fn create(pAction: *mut cocos2d_CCActionInterval) -> *mut cocos2d_CCEaseBounce {
        cocos2d_CCEaseBounce_create(pAction)
    }
}
extern "C" {
    #[doc = "  @js NA"]
    #[doc = "  @lua NA"]
    #[link_name = "\u{1}?copyWithZone@CCEaseBounce@cocos2d@@UEAAPEAVCCObject@2@PEAVCCZone@2@@Z"]
    pub fn cocos2d_CCEaseBounce_copyWithZone(
        this: *mut ::std::os::raw::c_void,
        pZone: *mut cocos2d_CCZone,
    ) -> *mut cocos2d_CCObject;
}
extern "C" {
    #[link_name = "\u{1}?reverse@CCEaseBounce@cocos2d@@UEAAPEAVCCActionInterval@2@XZ"]
    pub fn cocos2d_CCEaseBounce_reverse(
        this: *mut ::std::os::raw::c_void,
    ) -> *mut cocos2d_CCActionInterval;
}
#[doc = "@brief CCEaseBounceIn action."]
#[doc = "@warning This action doesn't use a bijective function. Actions like Sequence might have an unexpected result when used with this action."]
#[doc = "@since v0.8.2"]
#[doc = "@ingroup Actions"]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCEaseBounceIn {
    pub _base: cocos2d_CCEaseBounce,
}
#[test]
fn bindgen_test_layout_cocos2d_CCEaseBounceIn() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCEaseBounceIn>(),
        88usize,
        concat!("Size of: ", stringify!(cocos2d_CCEaseBounceIn))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCEaseBounceIn>(),
        8usize,
        concat!("Alignment of ", stringify!(cocos2d_CCEaseBounceIn))
    );
}
extern "C" {
    #[doc = " creates the action"]
    #[link_name = "\u{1}?create@CCEaseBounceIn@cocos2d@@SAPEAV12@PEAVCCActionInterval@2@@Z"]
    pub fn cocos2d_CCEaseBounceIn_create(
        pAction: *mut cocos2d_CCActionInterval,
    ) -> *mut cocos2d_CCEaseBounceIn;
}
impl cocos2d_CCEaseBounceIn {
    #[inline]
    pub unsafe fn create(pAction: *mut cocos2d_CCActionInterval) -> *mut cocos2d_CCEaseBounceIn {
        cocos2d_CCEaseBounceIn_create(pAction)
    }
}
extern "C" {
    #[link_name = "\u{1}?update@CCEaseBounceIn@cocos2d@@UEAAXM@Z"]
    pub fn cocos2d_CCEaseBounceIn_update(this: *mut ::std::os::raw::c_void, time: f32);
}
extern "C" {
    #[link_name = "\u{1}?reverse@CCEaseBounceIn@cocos2d@@UEAAPEAVCCActionInterval@2@XZ"]
    pub fn cocos2d_CCEaseBounceIn_reverse(
        this: *mut ::std::os::raw::c_void,
    ) -> *mut cocos2d_CCActionInterval;
}
extern "C" {
    #[doc = "  @js NA"]
    #[doc = "  @lua NA"]
    #[link_name = "\u{1}?copyWithZone@CCEaseBounceIn@cocos2d@@UEAAPEAVCCObject@2@PEAVCCZone@2@@Z"]
    pub fn cocos2d_CCEaseBounceIn_copyWithZone(
        this: *mut ::std::os::raw::c_void,
        pZone: *mut cocos2d_CCZone,
    ) -> *mut cocos2d_CCObject;
}
#[doc = "@brief EaseBounceOut action."]
#[doc = "@warning This action doesn't use a bijective function. Actions like Sequence might have an unexpected result when used with this action."]
#[doc = "@since v0.8.2"]
#[doc = "@ingroup Actions"]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCEaseBounceOut {
    pub _base: cocos2d_CCEaseBounce,
}
#[test]
fn bindgen_test_layout_cocos2d_CCEaseBounceOut() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCEaseBounceOut>(),
        88usize,
        concat!("Size of: ", stringify!(cocos2d_CCEaseBounceOut))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCEaseBounceOut>(),
        8usize,
        concat!("Alignment of ", stringify!(cocos2d_CCEaseBounceOut))
    );
}
extern "C" {
    #[doc = " creates the action"]
    #[link_name = "\u{1}?create@CCEaseBounceOut@cocos2d@@SAPEAV12@PEAVCCActionInterval@2@@Z"]
    pub fn cocos2d_CCEaseBounceOut_create(
        pAction: *mut cocos2d_CCActionInterval,
    ) -> *mut cocos2d_CCEaseBounceOut;
}
impl cocos2d_CCEaseBounceOut {
    #[inline]
    pub unsafe fn create(pAction: *mut cocos2d_CCActionInterval) -> *mut cocos2d_CCEaseBounceOut {
        cocos2d_CCEaseBounceOut_create(pAction)
    }
}
extern "C" {
    #[link_name = "\u{1}?update@CCEaseBounceOut@cocos2d@@UEAAXM@Z"]
    pub fn cocos2d_CCEaseBounceOut_update(this: *mut ::std::os::raw::c_void, time: f32);
}
extern "C" {
    #[link_name = "\u{1}?reverse@CCEaseBounceOut@cocos2d@@UEAAPEAVCCActionInterval@2@XZ"]
    pub fn cocos2d_CCEaseBounceOut_reverse(
        this: *mut ::std::os::raw::c_void,
    ) -> *mut cocos2d_CCActionInterval;
}
extern "C" {
    #[doc = "  @js NA"]
    #[doc = "  @lua NA"]
    #[link_name = "\u{1}?copyWithZone@CCEaseBounceOut@cocos2d@@UEAAPEAVCCObject@2@PEAVCCZone@2@@Z"]
    pub fn cocos2d_CCEaseBounceOut_copyWithZone(
        this: *mut ::std::os::raw::c_void,
        pZone: *mut cocos2d_CCZone,
    ) -> *mut cocos2d_CCObject;
}
#[doc = "@brief CCEaseBounceInOut action."]
#[doc = "@warning This action doesn't use a bijective function. Actions like Sequence might have an unexpected result when used with this action."]
#[doc = "@since v0.8.2"]
#[doc = "@ingroup Actions"]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCEaseBounceInOut {
    pub _base: cocos2d_CCEaseBounce,
}
#[test]
fn bindgen_test_layout_cocos2d_CCEaseBounceInOut() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCEaseBounceInOut>(),
        88usize,
        concat!("Size of: ", stringify!(cocos2d_CCEaseBounceInOut))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCEaseBounceInOut>(),
        8usize,
        concat!("Alignment of ", stringify!(cocos2d_CCEaseBounceInOut))
    );
}
extern "C" {
    #[doc = " creates the action"]
    #[link_name = "\u{1}?create@CCEaseBounceInOut@cocos2d@@SAPEAV12@PEAVCCActionInterval@2@@Z"]
    pub fn cocos2d_CCEaseBounceInOut_create(
        pAction: *mut cocos2d_CCActionInterval,
    ) -> *mut cocos2d_CCEaseBounceInOut;
}
impl cocos2d_CCEaseBounceInOut {
    #[inline]
    pub unsafe fn create(pAction: *mut cocos2d_CCActionInterval) -> *mut cocos2d_CCEaseBounceInOut {
        cocos2d_CCEaseBounceInOut_create(pAction)
    }
}
extern "C" {
    #[link_name = "\u{1}?update@CCEaseBounceInOut@cocos2d@@UEAAXM@Z"]
    pub fn cocos2d_CCEaseBounceInOut_update(this: *mut ::std::os::raw::c_void, time: f32);
}
extern "C" {
    #[doc = "  @js NA"]
    #[doc = "  @lua NA"]
    #[link_name = "\u{1}?copyWithZone@CCEaseBounceInOut@cocos2d@@UEAAPEAVCCObject@2@PEAVCCZone@2@@Z"]
    pub fn cocos2d_CCEaseBounceInOut_copyWithZone(
        this: *mut ::std::os::raw::c_void,
        pZone: *mut cocos2d_CCZone,
    ) -> *mut cocos2d_CCObject;
}
extern "C" {
    #[link_name = "\u{1}?reverse@CCEaseBounceInOut@cocos2d@@UEAAPEAVCCActionInterval@2@XZ"]
    pub fn cocos2d_CCEaseBounceInOut_reverse(
        this: *mut ::std::os::raw::c_void,
    ) -> *mut cocos2d_CCActionInterval;
}
#[doc = "@brief CCEaseBackIn action."]
#[doc = "@warning This action doesn't use a bijective function. Actions like Sequence might have an unexpected result when used with this action."]
#[doc = "@since v0.8.2"]
#[doc = "@ingroup Actions"]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCEaseBackIn {
    pub _base: cocos2d_CCActionEase,
}
#[test]
fn bindgen_test_layout_cocos2d_CCEaseBackIn() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCEaseBackIn>(),
        88usize,
        concat!("Size of: ", stringify!(cocos2d_CCEaseBackIn))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCEaseBackIn>(),
        8usize,
        concat!("Alignment of ", stringify!(cocos2d_CCEaseBackIn))
    );
}
extern "C" {
    #[doc = " creates the action"]
    #[link_name = "\u{1}?create@CCEaseBackIn@cocos2d@@SAPEAV12@PEAVCCActionInterval@2@@Z"]
    pub fn cocos2d_CCEaseBackIn_create(
        pAction: *mut cocos2d_CCActionInterval,
    ) -> *mut cocos2d_CCEaseBackIn;
}
impl cocos2d_CCEaseBackIn {
    #[inline]
    pub unsafe fn create(pAction: *mut cocos2d_CCActionInterval) -> *mut cocos2d_CCEaseBackIn {
        cocos2d_CCEaseBackIn_create(pAction)
    }
}
extern "C" {
    #[link_name = "\u{1}?update@CCEaseBackIn@cocos2d@@UEAAXM@Z"]
    pub fn cocos2d_CCEaseBackIn_update(this: *mut ::std::os::raw::c_void, time: f32);
}
extern "C" {
    #[link_name = "\u{1}?reverse@CCEaseBackIn@cocos2d@@UEAAPEAVCCActionInterval@2@XZ"]
    pub fn cocos2d_CCEaseBackIn_reverse(
        this: *mut ::std::os::raw::c_void,
    ) -> *mut cocos2d_CCActionInterval;
}
extern "C" {
    #[doc = "  @js NA"]
    #[doc = "  @lua NA"]
    #[link_name = "\u{1}?copyWithZone@CCEaseBackIn@cocos2d@@UEAAPEAVCCObject@2@PEAVCCZone@2@@Z"]
    pub fn cocos2d_CCEaseBackIn_copyWithZone(
        this: *mut ::std::os::raw::c_void,
        pZone: *mut cocos2d_CCZone,
    ) -> *mut cocos2d_CCObject;
}
#[doc = "@brief CCEaseBackOut action."]
#[doc = "@warning This action doesn't use a bijective function. Actions like Sequence might have an unexpected result when used with this action."]
#[doc = "@since v0.8.2"]
#[doc = "@ingroup Actions"]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCEaseBackOut {
    pub _base: cocos2d_CCActionEase,
}
#[test]
fn bindgen_test_layout_cocos2d_CCEaseBackOut() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCEaseBackOut>(),
        88usize,
        concat!("Size of: ", stringify!(cocos2d_CCEaseBackOut))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCEaseBackOut>(),
        8usize,
        concat!("Alignment of ", stringify!(cocos2d_CCEaseBackOut))
    );
}
extern "C" {
    #[doc = " creates the action"]
    #[link_name = "\u{1}?create@CCEaseBackOut@cocos2d@@SAPEAV12@PEAVCCActionInterval@2@@Z"]
    pub fn cocos2d_CCEaseBackOut_create(
        pAction: *mut cocos2d_CCActionInterval,
    ) -> *mut cocos2d_CCEaseBackOut;
}
impl cocos2d_CCEaseBackOut {
    #[inline]
    pub unsafe fn create(pAction: *mut cocos2d_CCActionInterval) -> *mut cocos2d_CCEaseBackOut {
        cocos2d_CCEaseBackOut_create(pAction)
    }
}
extern "C" {
    #[link_name = "\u{1}?update@CCEaseBackOut@cocos2d@@UEAAXM@Z"]
    pub fn cocos2d_CCEaseBackOut_update(this: *mut ::std::os::raw::c_void, time: f32);
}
extern "C" {
    #[link_name = "\u{1}?reverse@CCEaseBackOut@cocos2d@@UEAAPEAVCCActionInterval@2@XZ"]
    pub fn cocos2d_CCEaseBackOut_reverse(
        this: *mut ::std::os::raw::c_void,
    ) -> *mut cocos2d_CCActionInterval;
}
extern "C" {
    #[doc = "  @js NA"]
    #[doc = "  @lua NA"]
    #[link_name = "\u{1}?copyWithZone@CCEaseBackOut@cocos2d@@UEAAPEAVCCObject@2@PEAVCCZone@2@@Z"]
    pub fn cocos2d_CCEaseBackOut_copyWithZone(
        this: *mut ::std::os::raw::c_void,
        pZone: *mut cocos2d_CCZone,
    ) -> *mut cocos2d_CCObject;
}
#[doc = "@brief CCEaseBackInOut action."]
#[doc = "@warning This action doesn't use a bijective function. Actions like Sequence might have an unexpected result when used with this action."]
#[doc = "@since v0.8.2"]
#[doc = "@ingroup Actions"]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCEaseBackInOut {
    pub _base: cocos2d_CCActionEase,
}
#[test]
fn bindgen_test_layout_cocos2d_CCEaseBackInOut() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCEaseBackInOut>(),
        88usize,
        concat!("Size of: ", stringify!(cocos2d_CCEaseBackInOut))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCEaseBackInOut>(),
        8usize,
        concat!("Alignment of ", stringify!(cocos2d_CCEaseBackInOut))
    );
}
extern "C" {
    #[doc = " creates the action"]
    #[link_name = "\u{1}?create@CCEaseBackInOut@cocos2d@@SAPEAV12@PEAVCCActionInterval@2@@Z"]
    pub fn cocos2d_CCEaseBackInOut_create(
        pAction: *mut cocos2d_CCActionInterval,
    ) -> *mut cocos2d_CCEaseBackInOut;
}
impl cocos2d_CCEaseBackInOut {
    #[inline]
    pub unsafe fn create(pAction: *mut cocos2d_CCActionInterval) -> *mut cocos2d_CCEaseBackInOut {
        cocos2d_CCEaseBackInOut_create(pAction)
    }
}
extern "C" {
    #[link_name = "\u{1}?update@CCEaseBackInOut@cocos2d@@UEAAXM@Z"]
    pub fn cocos2d_CCEaseBackInOut_update(this: *mut ::std::os::raw::c_void, time: f32);
}
extern "C" {
    #[doc = "  @js NA"]
    #[doc = "  @lua NA"]
    #[link_name = "\u{1}?copyWithZone@CCEaseBackInOut@cocos2d@@UEAAPEAVCCObject@2@PEAVCCZone@2@@Z"]
    pub fn cocos2d_CCEaseBackInOut_copyWithZone(
        this: *mut ::std::os::raw::c_void,
        pZone: *mut cocos2d_CCZone,
    ) -> *mut cocos2d_CCObject;
}
extern "C" {
    #[link_name = "\u{1}?reverse@CCEaseBackInOut@cocos2d@@UEAAPEAVCCActionInterval@2@XZ"]
    pub fn cocos2d_CCEaseBackInOut_reverse(
        this: *mut ::std::os::raw::c_void,
    ) -> *mut cocos2d_CCActionInterval;
}
#[repr(C)]
pub struct cocos2d_TypeInfo__bindgen_vtable(::std::os::raw::c_void);
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cocos2d_TypeInfo {
    pub vtable_: *const cocos2d_TypeInfo__bindgen_vtable,
}
#[test]
fn bindgen_test_layout_cocos2d_TypeInfo() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d_TypeInfo>(),
        8usize,
        concat!("Size of: ", stringify!(cocos2d_TypeInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_TypeInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(cocos2d_TypeInfo))
    );
}
#[doc = "@brief Instant actions are immediate actions. They don't have a duration like"]
#[doc = "the CCIntervalAction actions."]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCActionInstant {
    pub _base: cocos2d_CCFiniteTimeAction,
}
#[test]
fn bindgen_test_layout_cocos2d_CCActionInstant() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCActionInstant>(),
        72usize,
        concat!("Size of: ", stringify!(cocos2d_CCActionInstant))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCActionInstant>(),
        8usize,
        concat!("Alignment of ", stringify!(cocos2d_CCActionInstant))
    );
}
extern "C" {
    #[doc = "  @js ctor"]
    #[link_name = "\u{1}??0CCActionInstant@cocos2d@@QEAA@XZ"]
    pub fn cocos2d_CCActionInstant_CCActionInstant(this: *mut cocos2d_CCActionInstant);
}
impl cocos2d_CCActionInstant {
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cocos2d_CCActionInstant_CCActionInstant(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
}
extern "C" {
    #[doc = "  @js NA"]
    #[doc = "  @lua NA"]
    #[link_name = "\u{1}?copyWithZone@CCActionInstant@cocos2d@@UEAAPEAVCCObject@2@PEAVCCZone@2@@Z"]
    pub fn cocos2d_CCActionInstant_copyWithZone(
        this: *mut ::std::os::raw::c_void,
        pZone: *mut cocos2d_CCZone,
    ) -> *mut cocos2d_CCObject;
}
extern "C" {
    #[link_name = "\u{1}?isDone@CCActionInstant@cocos2d@@UEAA_NXZ"]
    pub fn cocos2d_CCActionInstant_isDone(this: *mut ::std::os::raw::c_void) -> bool;
}
extern "C" {
    #[link_name = "\u{1}?step@CCActionInstant@cocos2d@@UEAAXM@Z"]
    pub fn cocos2d_CCActionInstant_step(this: *mut ::std::os::raw::c_void, dt: f32);
}
extern "C" {
    #[link_name = "\u{1}?update@CCActionInstant@cocos2d@@UEAAXM@Z"]
    pub fn cocos2d_CCActionInstant_update(this: *mut ::std::os::raw::c_void, time: f32);
}
extern "C" {
    #[link_name = "\u{1}?reverse@CCActionInstant@cocos2d@@UEAAPEAVCCFiniteTimeAction@2@XZ"]
    pub fn cocos2d_CCActionInstant_reverse(
        this: *mut ::std::os::raw::c_void,
    ) -> *mut cocos2d_CCFiniteTimeAction;
}
#[doc = " @brief Show the node"]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCShow {
    pub _base: cocos2d_CCActionInstant,
}
#[test]
fn bindgen_test_layout_cocos2d_CCShow() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCShow>(),
        72usize,
        concat!("Size of: ", stringify!(cocos2d_CCShow))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCShow>(),
        8usize,
        concat!("Alignment of ", stringify!(cocos2d_CCShow))
    );
}
extern "C" {
    #[doc = " Allocates and initializes the action"]
    #[link_name = "\u{1}?create@CCShow@cocos2d@@SAPEAV12@XZ"]
    pub fn cocos2d_CCShow_create() -> *mut cocos2d_CCShow;
}
impl cocos2d_CCShow {
    #[inline]
    pub unsafe fn create() -> *mut cocos2d_CCShow {
        cocos2d_CCShow_create()
    }
}
extern "C" {
    #[link_name = "\u{1}?update@CCShow@cocos2d@@UEAAXM@Z"]
    pub fn cocos2d_CCShow_update(this: *mut ::std::os::raw::c_void, time: f32);
}
extern "C" {
    #[link_name = "\u{1}?reverse@CCShow@cocos2d@@UEAAPEAVCCFiniteTimeAction@2@XZ"]
    pub fn cocos2d_CCShow_reverse(
        this: *mut ::std::os::raw::c_void,
    ) -> *mut cocos2d_CCFiniteTimeAction;
}
extern "C" {
    #[doc = "  @js NA"]
    #[doc = "  @lua NA"]
    #[link_name = "\u{1}?copyWithZone@CCShow@cocos2d@@UEAAPEAVCCObject@2@PEAVCCZone@2@@Z"]
    pub fn cocos2d_CCShow_copyWithZone(
        this: *mut ::std::os::raw::c_void,
        pZone: *mut cocos2d_CCZone,
    ) -> *mut cocos2d_CCObject;
}
#[doc = "@brief Hide the node"]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCHide {
    pub _base: cocos2d_CCActionInstant,
}
#[test]
fn bindgen_test_layout_cocos2d_CCHide() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCHide>(),
        72usize,
        concat!("Size of: ", stringify!(cocos2d_CCHide))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCHide>(),
        8usize,
        concat!("Alignment of ", stringify!(cocos2d_CCHide))
    );
}
extern "C" {
    #[doc = " Allocates and initializes the action"]
    #[link_name = "\u{1}?create@CCHide@cocos2d@@SAPEAV12@XZ"]
    pub fn cocos2d_CCHide_create() -> *mut cocos2d_CCHide;
}
impl cocos2d_CCHide {
    #[inline]
    pub unsafe fn create() -> *mut cocos2d_CCHide {
        cocos2d_CCHide_create()
    }
}
extern "C" {
    #[doc = "  @lua NA"]
    #[link_name = "\u{1}?update@CCHide@cocos2d@@UEAAXM@Z"]
    pub fn cocos2d_CCHide_update(this: *mut ::std::os::raw::c_void, time: f32);
}
extern "C" {
    #[link_name = "\u{1}?reverse@CCHide@cocos2d@@UEAAPEAVCCFiniteTimeAction@2@XZ"]
    pub fn cocos2d_CCHide_reverse(
        this: *mut ::std::os::raw::c_void,
    ) -> *mut cocos2d_CCFiniteTimeAction;
}
extern "C" {
    #[doc = "  @js NA"]
    #[doc = "  @lua NA"]
    #[link_name = "\u{1}?copyWithZone@CCHide@cocos2d@@UEAAPEAVCCObject@2@PEAVCCZone@2@@Z"]
    pub fn cocos2d_CCHide_copyWithZone(
        this: *mut ::std::os::raw::c_void,
        pZone: *mut cocos2d_CCZone,
    ) -> *mut cocos2d_CCObject;
}
#[doc = " @brief Toggles the visibility of a node"]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCToggleVisibility {
    pub _base: cocos2d_CCActionInstant,
}
#[test]
fn bindgen_test_layout_cocos2d_CCToggleVisibility() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCToggleVisibility>(),
        72usize,
        concat!("Size of: ", stringify!(cocos2d_CCToggleVisibility))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCToggleVisibility>(),
        8usize,
        concat!("Alignment of ", stringify!(cocos2d_CCToggleVisibility))
    );
}
extern "C" {
    #[doc = " Allocates and initializes the action"]
    #[link_name = "\u{1}?create@CCToggleVisibility@cocos2d@@SAPEAV12@XZ"]
    pub fn cocos2d_CCToggleVisibility_create() -> *mut cocos2d_CCToggleVisibility;
}
impl cocos2d_CCToggleVisibility {
    #[inline]
    pub unsafe fn create() -> *mut cocos2d_CCToggleVisibility {
        cocos2d_CCToggleVisibility_create()
    }
}
extern "C" {
    #[link_name = "\u{1}?update@CCToggleVisibility@cocos2d@@UEAAXM@Z"]
    pub fn cocos2d_CCToggleVisibility_update(this: *mut ::std::os::raw::c_void, time: f32);
}
extern "C" {
    #[doc = "  @js NA"]
    #[doc = "  @lua NA"]
    #[link_name = "\u{1}?copyWithZone@CCToggleVisibility@cocos2d@@UEAAPEAVCCObject@2@PEAVCCZone@2@@Z"]
    pub fn cocos2d_CCToggleVisibility_copyWithZone(
        this: *mut ::std::os::raw::c_void,
        pZone: *mut cocos2d_CCZone,
    ) -> *mut cocos2d_CCObject;
}
#[doc = "@brief Remove the node"]
#[doc = "@js NA"]
#[doc = "@lua NA"]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCRemoveSelf {
    pub _base: cocos2d_CCActionInstant,
    pub m_bIsNeedCleanUp: bool,
}
#[test]
fn bindgen_test_layout_cocos2d_CCRemoveSelf() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCRemoveSelf>(),
        80usize,
        concat!("Size of: ", stringify!(cocos2d_CCRemoveSelf))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCRemoveSelf>(),
        8usize,
        concat!("Alignment of ", stringify!(cocos2d_CCRemoveSelf))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cocos2d_CCRemoveSelf>())).m_bIsNeedCleanUp as *const _ as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCRemoveSelf),
            "::",
            stringify!(m_bIsNeedCleanUp)
        )
    );
}
extern "C" {
    #[doc = " create the action"]
    #[link_name = "\u{1}?create@CCRemoveSelf@cocos2d@@SAPEAV12@_N@Z"]
    pub fn cocos2d_CCRemoveSelf_create(isNeedCleanUp: bool) -> *mut cocos2d_CCRemoveSelf;
}
extern "C" {
    #[doc = " init the action"]
    #[link_name = "\u{1}?init@CCRemoveSelf@cocos2d@@QEAA_N_N@Z"]
    pub fn cocos2d_CCRemoveSelf_init(this: *mut cocos2d_CCRemoveSelf, isNeedCleanUp: bool) -> bool;
}
impl cocos2d_CCRemoveSelf {
    #[inline]
    pub unsafe fn create(isNeedCleanUp: bool) -> *mut cocos2d_CCRemoveSelf {
        cocos2d_CCRemoveSelf_create(isNeedCleanUp)
    }
    #[inline]
    pub unsafe fn init(&mut self, isNeedCleanUp: bool) -> bool {
        cocos2d_CCRemoveSelf_init(self, isNeedCleanUp)
    }
}
extern "C" {
    #[link_name = "\u{1}?update@CCRemoveSelf@cocos2d@@UEAAXM@Z"]
    pub fn cocos2d_CCRemoveSelf_update(this: *mut ::std::os::raw::c_void, time: f32);
}
extern "C" {
    #[link_name = "\u{1}?reverse@CCRemoveSelf@cocos2d@@UEAAPEAVCCFiniteTimeAction@2@XZ"]
    pub fn cocos2d_CCRemoveSelf_reverse(
        this: *mut ::std::os::raw::c_void,
    ) -> *mut cocos2d_CCFiniteTimeAction;
}
extern "C" {
    #[link_name = "\u{1}?copyWithZone@CCRemoveSelf@cocos2d@@UEAAPEAVCCObject@2@PEAVCCZone@2@@Z"]
    pub fn cocos2d_CCRemoveSelf_copyWithZone(
        this: *mut ::std::os::raw::c_void,
        pZone: *mut cocos2d_CCZone,
    ) -> *mut cocos2d_CCObject;
}
#[doc = "@brief Flips the sprite horizontally"]
#[doc = "@since v0.99.0"]
#[doc = "@js NA"]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCFlipX {
    pub _base: cocos2d_CCActionInstant,
    pub m_bFlipX: bool,
}
#[test]
fn bindgen_test_layout_cocos2d_CCFlipX() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCFlipX>(),
        80usize,
        concat!("Size of: ", stringify!(cocos2d_CCFlipX))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCFlipX>(),
        8usize,
        concat!("Alignment of ", stringify!(cocos2d_CCFlipX))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cocos2d_CCFlipX>())).m_bFlipX as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCFlipX),
            "::",
            stringify!(m_bFlipX)
        )
    );
}
extern "C" {
    #[doc = " create the action"]
    #[link_name = "\u{1}?create@CCFlipX@cocos2d@@SAPEAV12@_N@Z"]
    pub fn cocos2d_CCFlipX_create(x: bool) -> *mut cocos2d_CCFlipX;
}
extern "C" {
    #[doc = " init the action"]
    #[link_name = "\u{1}?initWithFlipX@CCFlipX@cocos2d@@QEAA_N_N@Z"]
    pub fn cocos2d_CCFlipX_initWithFlipX(this: *mut cocos2d_CCFlipX, x: bool) -> bool;
}
impl cocos2d_CCFlipX {
    #[inline]
    pub unsafe fn create(x: bool) -> *mut cocos2d_CCFlipX {
        cocos2d_CCFlipX_create(x)
    }
    #[inline]
    pub unsafe fn initWithFlipX(&mut self, x: bool) -> bool {
        cocos2d_CCFlipX_initWithFlipX(self, x)
    }
}
extern "C" {
    #[link_name = "\u{1}?update@CCFlipX@cocos2d@@UEAAXM@Z"]
    pub fn cocos2d_CCFlipX_update(this: *mut ::std::os::raw::c_void, time: f32);
}
extern "C" {
    #[link_name = "\u{1}?reverse@CCFlipX@cocos2d@@UEAAPEAVCCFiniteTimeAction@2@XZ"]
    pub fn cocos2d_CCFlipX_reverse(
        this: *mut ::std::os::raw::c_void,
    ) -> *mut cocos2d_CCFiniteTimeAction;
}
extern "C" {
    #[doc = "  @lua NA"]
    #[link_name = "\u{1}?copyWithZone@CCFlipX@cocos2d@@UEAAPEAVCCObject@2@PEAVCCZone@2@@Z"]
    pub fn cocos2d_CCFlipX_copyWithZone(
        this: *mut ::std::os::raw::c_void,
        pZone: *mut cocos2d_CCZone,
    ) -> *mut cocos2d_CCObject;
}
#[doc = "@brief Flips the sprite vertically"]
#[doc = "@since v0.99.0"]
#[doc = "@js NA"]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCFlipY {
    pub _base: cocos2d_CCActionInstant,
    pub m_bFlipY: bool,
}
#[test]
fn bindgen_test_layout_cocos2d_CCFlipY() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCFlipY>(),
        80usize,
        concat!("Size of: ", stringify!(cocos2d_CCFlipY))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCFlipY>(),
        8usize,
        concat!("Alignment of ", stringify!(cocos2d_CCFlipY))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cocos2d_CCFlipY>())).m_bFlipY as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCFlipY),
            "::",
            stringify!(m_bFlipY)
        )
    );
}
extern "C" {
    #[doc = " create the action"]
    #[link_name = "\u{1}?create@CCFlipY@cocos2d@@SAPEAV12@_N@Z"]
    pub fn cocos2d_CCFlipY_create(y: bool) -> *mut cocos2d_CCFlipY;
}
extern "C" {
    #[doc = " init the action"]
    #[link_name = "\u{1}?initWithFlipY@CCFlipY@cocos2d@@QEAA_N_N@Z"]
    pub fn cocos2d_CCFlipY_initWithFlipY(this: *mut cocos2d_CCFlipY, y: bool) -> bool;
}
impl cocos2d_CCFlipY {
    #[inline]
    pub unsafe fn create(y: bool) -> *mut cocos2d_CCFlipY {
        cocos2d_CCFlipY_create(y)
    }
    #[inline]
    pub unsafe fn initWithFlipY(&mut self, y: bool) -> bool {
        cocos2d_CCFlipY_initWithFlipY(self, y)
    }
}
extern "C" {
    #[link_name = "\u{1}?update@CCFlipY@cocos2d@@UEAAXM@Z"]
    pub fn cocos2d_CCFlipY_update(this: *mut ::std::os::raw::c_void, time: f32);
}
extern "C" {
    #[link_name = "\u{1}?reverse@CCFlipY@cocos2d@@UEAAPEAVCCFiniteTimeAction@2@XZ"]
    pub fn cocos2d_CCFlipY_reverse(
        this: *mut ::std::os::raw::c_void,
    ) -> *mut cocos2d_CCFiniteTimeAction;
}
extern "C" {
    #[doc = "  @lua NA"]
    #[link_name = "\u{1}?copyWithZone@CCFlipY@cocos2d@@UEAAPEAVCCObject@2@PEAVCCZone@2@@Z"]
    pub fn cocos2d_CCFlipY_copyWithZone(
        this: *mut ::std::os::raw::c_void,
        pZone: *mut cocos2d_CCZone,
    ) -> *mut cocos2d_CCObject;
}
#[doc = " @brief Places the node in a certain position"]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCPlace {
    pub _base: cocos2d_CCActionInstant,
    pub m_tPosition: cocos2d_CCPoint,
}
#[test]
fn bindgen_test_layout_cocos2d_CCPlace() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCPlace>(),
        80usize,
        concat!("Size of: ", stringify!(cocos2d_CCPlace))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCPlace>(),
        8usize,
        concat!("Alignment of ", stringify!(cocos2d_CCPlace))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cocos2d_CCPlace>())).m_tPosition as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCPlace),
            "::",
            stringify!(m_tPosition)
        )
    );
}
extern "C" {
    #[doc = " creates a Place action with a position"]
    #[link_name = "\u{1}?create@CCPlace@cocos2d@@SAPEAV12@AEBVCCPoint@2@@Z"]
    pub fn cocos2d_CCPlace_create(pos: *const cocos2d_CCPoint) -> *mut cocos2d_CCPlace;
}
extern "C" {
    #[doc = " Initializes a Place action with a position"]
    #[link_name = "\u{1}?initWithPosition@CCPlace@cocos2d@@QEAA_NAEBVCCPoint@2@@Z"]
    pub fn cocos2d_CCPlace_initWithPosition(
        this: *mut cocos2d_CCPlace,
        pos: *const cocos2d_CCPoint,
    ) -> bool;
}
impl cocos2d_CCPlace {
    #[inline]
    pub unsafe fn create(pos: *const cocos2d_CCPoint) -> *mut cocos2d_CCPlace {
        cocos2d_CCPlace_create(pos)
    }
    #[inline]
    pub unsafe fn initWithPosition(&mut self, pos: *const cocos2d_CCPoint) -> bool {
        cocos2d_CCPlace_initWithPosition(self, pos)
    }
}
extern "C" {
    #[link_name = "\u{1}?update@CCPlace@cocos2d@@UEAAXM@Z"]
    pub fn cocos2d_CCPlace_update(this: *mut ::std::os::raw::c_void, time: f32);
}
extern "C" {
    #[doc = "  @js NA"]
    #[doc = "  @lua NA"]
    #[link_name = "\u{1}?copyWithZone@CCPlace@cocos2d@@UEAAPEAVCCObject@2@PEAVCCZone@2@@Z"]
    pub fn cocos2d_CCPlace_copyWithZone(
        this: *mut ::std::os::raw::c_void,
        pZone: *mut cocos2d_CCZone,
    ) -> *mut cocos2d_CCObject;
}
#[doc = " @brief Calls a 'callback'"]
#[repr(C)]
pub struct cocos2d_CCCallFunc {
    pub _base: cocos2d_CCActionInstant,
    #[doc = " Target that will be called"]
    pub m_pSelectorTarget: *mut cocos2d_CCObject,
    pub m_nScriptHandler: ::std::os::raw::c_int,
    pub __bindgen_anon_1: cocos2d_CCCallFunc__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union cocos2d_CCCallFunc__bindgen_ty_1 {
    pub m_pCallFunc: cocos2d_SEL_CallFunc,
    pub m_pCallFuncN: cocos2d_SEL_CallFuncN,
    pub m_pCallFuncND: cocos2d_SEL_CallFuncND,
    pub m_pCallFuncO: cocos2d_SEL_CallFuncO,
}
#[test]
fn bindgen_test_layout_cocos2d_CCCallFunc__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCCallFunc__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(cocos2d_CCCallFunc__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCCallFunc__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(cocos2d_CCCallFunc__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cocos2d_CCCallFunc__bindgen_ty_1>())).m_pCallFunc as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCCallFunc__bindgen_ty_1),
            "::",
            stringify!(m_pCallFunc)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cocos2d_CCCallFunc__bindgen_ty_1>())).m_pCallFuncN as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCCallFunc__bindgen_ty_1),
            "::",
            stringify!(m_pCallFuncN)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cocos2d_CCCallFunc__bindgen_ty_1>())).m_pCallFuncND as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCCallFunc__bindgen_ty_1),
            "::",
            stringify!(m_pCallFuncND)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cocos2d_CCCallFunc__bindgen_ty_1>())).m_pCallFuncO as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCCallFunc__bindgen_ty_1),
            "::",
            stringify!(m_pCallFuncO)
        )
    );
}
#[test]
fn bindgen_test_layout_cocos2d_CCCallFunc() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCCallFunc>(),
        96usize,
        concat!("Size of: ", stringify!(cocos2d_CCCallFunc))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCCallFunc>(),
        8usize,
        concat!("Alignment of ", stringify!(cocos2d_CCCallFunc))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cocos2d_CCCallFunc>())).m_pSelectorTarget as *const _ as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCCallFunc),
            "::",
            stringify!(m_pSelectorTarget)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cocos2d_CCCallFunc>())).m_nScriptHandler as *const _ as usize
        },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCCallFunc),
            "::",
            stringify!(m_nScriptHandler)
        )
    );
}
extern "C" {
    #[doc = " creates the action with the callback"]
    #[doc = ""]
    #[doc = " typedef void (CCObject::*SEL_CallFunc)();"]
    #[doc = " @lua NA"]
    #[link_name = "\u{1}?create@CCCallFunc@cocos2d@@SAPEAV12@PEAVCCObject@2@P832@EAAXXZ@Z"]
    pub fn cocos2d_CCCallFunc_create(
        pSelectorTarget: *mut cocos2d_CCObject,
        selector: cocos2d_SEL_CallFunc,
    ) -> *mut cocos2d_CCCallFunc;
}
extern "C" {
    #[doc = " creates the action with the handler script function"]
    #[doc = " @js NA"]
    #[link_name = "\u{1}?create@CCCallFunc@cocos2d@@SAPEAV12@H@Z"]
    pub fn cocos2d_CCCallFunc_create1(nHandler: ::std::os::raw::c_int) -> *mut cocos2d_CCCallFunc;
}
impl cocos2d_CCCallFunc {
    #[inline]
    pub unsafe fn create(
        pSelectorTarget: *mut cocos2d_CCObject,
        selector: cocos2d_SEL_CallFunc,
    ) -> *mut cocos2d_CCCallFunc {
        cocos2d_CCCallFunc_create(pSelectorTarget, selector)
    }
    #[inline]
    pub unsafe fn create1(nHandler: ::std::os::raw::c_int) -> *mut cocos2d_CCCallFunc {
        cocos2d_CCCallFunc_create1(nHandler)
    }
}
extern "C" {
    #[doc = " @js NA"]
    #[doc = " @lua NA"]
    #[link_name = "\u{1}??_DCCCallFunc@cocos2d@@QEAAXXZ"]
    pub fn cocos2d_CCCallFunc_CCCallFunc_destructor(this: *mut cocos2d_CCCallFunc);
}
extern "C" {
    #[doc = " initializes the action with the callback"]
    #[doc = ""]
    #[doc = " typedef void (CCObject::*SEL_CallFunc)();"]
    #[doc = " @lua NA"]
    #[link_name = "\u{1}?initWithTarget@CCCallFunc@cocos2d@@UEAA_NPEAVCCObject@2@@Z"]
    pub fn cocos2d_CCCallFunc_initWithTarget(
        this: *mut ::std::os::raw::c_void,
        pSelectorTarget: *mut cocos2d_CCObject,
    ) -> bool;
}
extern "C" {
    #[doc = " executes the callback"]
    #[doc = " @lua NA"]
    #[link_name = "\u{1}?execute@CCCallFunc@cocos2d@@UEAAXXZ"]
    pub fn cocos2d_CCCallFunc_execute(this: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[doc = " super methods"]
    #[doc = " @lua NA"]
    #[link_name = "\u{1}?update@CCCallFunc@cocos2d@@UEAAXM@Z"]
    pub fn cocos2d_CCCallFunc_update(this: *mut ::std::os::raw::c_void, time: f32);
}
extern "C" {
    #[doc = " @js  NA"]
    #[doc = " @lua NA"]
    #[link_name = "\u{1}?copyWithZone@CCCallFunc@cocos2d@@UEAAPEAVCCObject@2@PEAVCCZone@2@@Z"]
    pub fn cocos2d_CCCallFunc_copyWithZone(
        this: *mut ::std::os::raw::c_void,
        pZone: *mut cocos2d_CCZone,
    ) -> *mut cocos2d_CCObject;
}
#[doc = "@brief Calls a 'callback' with the node as the first argument"]
#[doc = "N means Node"]
#[doc = " @js NA"]
#[repr(C)]
pub struct cocos2d_CCCallFuncN {
    pub _base: cocos2d_CCCallFunc,
    pub _base_1: cocos2d_TypeInfo,
}
#[test]
fn bindgen_test_layout_cocos2d_CCCallFuncN() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCCallFuncN>(),
        104usize,
        concat!("Size of: ", stringify!(cocos2d_CCCallFuncN))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCCallFuncN>(),
        8usize,
        concat!("Alignment of ", stringify!(cocos2d_CCCallFuncN))
    );
}
extern "C" {
    #[doc = " creates the action with the callback"]
    #[doc = ""]
    #[doc = " typedef void (CCObject::*SEL_CallFuncN)(CCNode*);"]
    #[doc = " @lua NA"]
    #[link_name = "\u{1}?create@CCCallFuncN@cocos2d@@SAPEAV12@PEAVCCObject@2@P832@EAAXPEAVCCNode@2@@Z@Z"]
    pub fn cocos2d_CCCallFuncN_create(
        pSelectorTarget: *mut cocos2d_CCObject,
        selector: cocos2d_SEL_CallFuncN,
    ) -> *mut cocos2d_CCCallFuncN;
}
extern "C" {
    #[doc = " creates the action with the handler script function"]
    #[link_name = "\u{1}?create@CCCallFuncN@cocos2d@@SAPEAV12@H@Z"]
    pub fn cocos2d_CCCallFuncN_create1(nHandler: ::std::os::raw::c_int)
        -> *mut cocos2d_CCCallFuncN;
}
impl cocos2d_CCCallFuncN {
    #[inline]
    pub unsafe fn create(
        pSelectorTarget: *mut cocos2d_CCObject,
        selector: cocos2d_SEL_CallFuncN,
    ) -> *mut cocos2d_CCCallFuncN {
        cocos2d_CCCallFuncN_create(pSelectorTarget, selector)
    }
    #[inline]
    pub unsafe fn create1(nHandler: ::std::os::raw::c_int) -> *mut cocos2d_CCCallFuncN {
        cocos2d_CCCallFuncN_create1(nHandler)
    }
}
extern "C" {
    #[doc = " initializes the action with the callback"]
    #[doc = ""]
    #[doc = " typedef void (CCObject::*SEL_CallFuncN)(CCNode*);"]
    #[doc = " @lua NA"]
    #[link_name = "\u{1}?initWithTarget@CCCallFuncN@cocos2d@@UEAA_NPEAVCCObject@2@P832@EAAXPEAVCCNode@2@@Z@Z"]
    pub fn cocos2d_CCCallFuncN_initWithTarget(
        this: *mut ::std::os::raw::c_void,
        pSelectorTarget: *mut cocos2d_CCObject,
        selector: cocos2d_SEL_CallFuncN,
    ) -> bool;
}
extern "C" {
    #[doc = " super methods"]
    #[doc = " @js  NA"]
    #[doc = " @lua NA"]
    #[link_name = "\u{1}?copyWithZone@CCCallFuncN@cocos2d@@UEAAPEAVCCObject@2@PEAVCCZone@2@@Z"]
    pub fn cocos2d_CCCallFuncN_copyWithZone(
        this: *mut ::std::os::raw::c_void,
        pZone: *mut cocos2d_CCZone,
    ) -> *mut cocos2d_CCObject;
}
extern "C" {
    #[doc = " @lua NA"]
    #[link_name = "\u{1}?execute@CCCallFuncN@cocos2d@@UEAAXXZ"]
    pub fn cocos2d_CCCallFuncN_execute(this: *mut ::std::os::raw::c_void);
}
#[doc = " @brief Calls a 'callback' with the node as the first argument and the 2nd argument is data"]
#[doc = " ND means: Node and Data. Data is void *, so it could be anything."]
#[doc = " @js NA"]
#[doc = " @lua NA"]
#[repr(C)]
pub struct cocos2d_CCCallFuncND {
    pub _base: cocos2d_CCCallFuncN,
    pub m_pData: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_cocos2d_CCCallFuncND() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCCallFuncND>(),
        112usize,
        concat!("Size of: ", stringify!(cocos2d_CCCallFuncND))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCCallFuncND>(),
        8usize,
        concat!("Alignment of ", stringify!(cocos2d_CCCallFuncND))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cocos2d_CCCallFuncND>())).m_pData as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCCallFuncND),
            "::",
            stringify!(m_pData)
        )
    );
}
extern "C" {
    #[doc = " creates the action with the callback and the data to pass as an argument"]
    #[link_name = "\u{1}?create@CCCallFuncND@cocos2d@@SAPEAV12@PEAVCCObject@2@P832@EAAXPEAVCCNode@2@PEAX@Z2@Z"]
    pub fn cocos2d_CCCallFuncND_create(
        pSelectorTarget: *mut cocos2d_CCObject,
        selector: cocos2d_SEL_CallFuncND,
        d: *mut ::std::os::raw::c_void,
    ) -> *mut cocos2d_CCCallFuncND;
}
impl cocos2d_CCCallFuncND {
    #[inline]
    pub unsafe fn create(
        pSelectorTarget: *mut cocos2d_CCObject,
        selector: cocos2d_SEL_CallFuncND,
        d: *mut ::std::os::raw::c_void,
    ) -> *mut cocos2d_CCCallFuncND {
        cocos2d_CCCallFuncND_create(pSelectorTarget, selector, d)
    }
}
extern "C" {
    #[doc = " initializes the action with the callback and the data to pass as an argument"]
    #[link_name = "\u{1}?initWithTarget@CCCallFuncND@cocos2d@@UEAA_NPEAVCCObject@2@P832@EAAXPEAVCCNode@2@PEAX@Z2@Z"]
    pub fn cocos2d_CCCallFuncND_initWithTarget(
        this: *mut ::std::os::raw::c_void,
        pSelectorTarget: *mut cocos2d_CCObject,
        selector: cocos2d_SEL_CallFuncND,
        d: *mut ::std::os::raw::c_void,
    ) -> bool;
}
extern "C" {
    #[doc = "  @js NA"]
    #[doc = "  @lua NA"]
    #[link_name = "\u{1}?copyWithZone@CCCallFuncND@cocos2d@@UEAAPEAVCCObject@2@PEAVCCZone@2@@Z"]
    pub fn cocos2d_CCCallFuncND_copyWithZone(
        this: *mut ::std::os::raw::c_void,
        pZone: *mut cocos2d_CCZone,
    ) -> *mut cocos2d_CCObject;
}
extern "C" {
    #[link_name = "\u{1}?execute@CCCallFuncND@cocos2d@@UEAAXXZ"]
    pub fn cocos2d_CCCallFuncND_execute(this: *mut ::std::os::raw::c_void);
}
#[doc = "@brief Calls a 'callback' with an object as the first argument."]
#[doc = "O means Object."]
#[doc = "@since v0.99.5"]
#[doc = "@js NA"]
#[doc = "@lua NA"]
#[repr(C)]
pub struct cocos2d_CCCallFuncO {
    pub _base: cocos2d_CCCallFunc,
    pub _base_1: cocos2d_TypeInfo,
    #[doc = " object to be passed as argument"]
    pub m_pObject: *mut cocos2d_CCObject,
}
#[test]
fn bindgen_test_layout_cocos2d_CCCallFuncO() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCCallFuncO>(),
        112usize,
        concat!("Size of: ", stringify!(cocos2d_CCCallFuncO))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCCallFuncO>(),
        8usize,
        concat!("Alignment of ", stringify!(cocos2d_CCCallFuncO))
    );
}
extern "C" {
    #[doc = " creates the action with the callback"]
    #[doc = ""]
    #[doc = "typedef void (CCObject::*SEL_CallFuncO)(CCObject*);"]
    #[link_name = "\u{1}?create@CCCallFuncO@cocos2d@@SAPEAV12@PEAVCCObject@2@P832@EAAX0@Z0@Z"]
    pub fn cocos2d_CCCallFuncO_create(
        pSelectorTarget: *mut cocos2d_CCObject,
        selector: cocos2d_SEL_CallFuncO,
        pObject: *mut cocos2d_CCObject,
    ) -> *mut cocos2d_CCCallFuncO;
}
extern "C" {
    #[link_name = "\u{1}??0CCCallFuncO@cocos2d@@QEAA@XZ"]
    pub fn cocos2d_CCCallFuncO_CCCallFuncO(this: *mut cocos2d_CCCallFuncO);
}
impl cocos2d_CCCallFuncO {
    #[inline]
    pub unsafe fn create(
        pSelectorTarget: *mut cocos2d_CCObject,
        selector: cocos2d_SEL_CallFuncO,
        pObject: *mut cocos2d_CCObject,
    ) -> *mut cocos2d_CCCallFuncO {
        cocos2d_CCCallFuncO_create(pSelectorTarget, selector, pObject)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cocos2d_CCCallFuncO_CCCallFuncO(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
}
extern "C" {
    #[link_name = "\u{1}??_DCCCallFuncO@cocos2d@@QEAAXXZ"]
    pub fn cocos2d_CCCallFuncO_CCCallFuncO_destructor(this: *mut cocos2d_CCCallFuncO);
}
extern "C" {
    #[doc = " initializes the action with the callback"]
    #[doc = ""]
    #[doc = "typedef void (CCObject::*SEL_CallFuncO)(CCObject*);"]
    #[link_name = "\u{1}?initWithTarget@CCCallFuncO@cocos2d@@UEAA_NPEAVCCObject@2@P832@EAAX0@Z0@Z"]
    pub fn cocos2d_CCCallFuncO_initWithTarget(
        this: *mut ::std::os::raw::c_void,
        pSelectorTarget: *mut cocos2d_CCObject,
        selector: cocos2d_SEL_CallFuncO,
        pObject: *mut cocos2d_CCObject,
    ) -> bool;
}
extern "C" {
    #[doc = "  @js NA"]
    #[doc = "  @lua NA"]
    #[link_name = "\u{1}?copyWithZone@CCCallFuncO@cocos2d@@UEAAPEAVCCObject@2@PEAVCCZone@2@@Z"]
    pub fn cocos2d_CCCallFuncO_copyWithZone(
        this: *mut ::std::os::raw::c_void,
        pZone: *mut cocos2d_CCZone,
    ) -> *mut cocos2d_CCObject;
}
extern "C" {
    #[link_name = "\u{1}?execute@CCCallFuncO@cocos2d@@UEAAXXZ"]
    pub fn cocos2d_CCCallFuncO_execute(this: *mut ::std::os::raw::c_void);
}
#[doc = " @brief Base class for Grid actions"]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCGridAction {
    pub _base: cocos2d_CCActionInterval,
    pub m_sGridSize: cocos2d_CCSize,
}
#[test]
fn bindgen_test_layout_cocos2d_CCGridAction() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCGridAction>(),
        88usize,
        concat!("Size of: ", stringify!(cocos2d_CCGridAction))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCGridAction>(),
        8usize,
        concat!("Alignment of ", stringify!(cocos2d_CCGridAction))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cocos2d_CCGridAction>())).m_sGridSize as *const _ as usize
        },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCGridAction),
            "::",
            stringify!(m_sGridSize)
        )
    );
}
extern "C" {
    #[doc = " creates the action with size and duration"]
    #[link_name = "\u{1}?create@CCGridAction@cocos2d@@SAPEAV12@MAEBVCCSize@2@@Z"]
    pub fn cocos2d_CCGridAction_create(
        duration: f32,
        gridSize: *const cocos2d_CCSize,
    ) -> *mut cocos2d_CCGridAction;
}
impl cocos2d_CCGridAction {
    #[inline]
    pub unsafe fn create(
        duration: f32,
        gridSize: *const cocos2d_CCSize,
    ) -> *mut cocos2d_CCGridAction {
        cocos2d_CCGridAction_create(duration, gridSize)
    }
}
extern "C" {
    #[doc = "  @js NA"]
    #[doc = "  @lua NA"]
    #[link_name = "\u{1}?copyWithZone@CCGridAction@cocos2d@@UEAAPEAVCCObject@2@PEAVCCZone@2@@Z"]
    pub fn cocos2d_CCGridAction_copyWithZone(
        this: *mut ::std::os::raw::c_void,
        pZone: *mut cocos2d_CCZone,
    ) -> *mut cocos2d_CCObject;
}
extern "C" {
    #[link_name = "\u{1}?startWithTarget@CCGridAction@cocos2d@@UEAAXPEAVCCNode@2@@Z"]
    pub fn cocos2d_CCGridAction_startWithTarget(
        this: *mut ::std::os::raw::c_void,
        pTarget: *mut cocos2d_CCNode,
    );
}
extern "C" {
    #[link_name = "\u{1}?reverse@CCGridAction@cocos2d@@UEAAPEAVCCActionInterval@2@XZ"]
    pub fn cocos2d_CCGridAction_reverse(
        this: *mut ::std::os::raw::c_void,
    ) -> *mut cocos2d_CCActionInterval;
}
extern "C" {
    #[doc = " initializes the action with size and duration"]
    #[link_name = "\u{1}?initWithDuration@CCGridAction@cocos2d@@UEAA_NMAEBVCCSize@2@@Z"]
    pub fn cocos2d_CCGridAction_initWithDuration(
        this: *mut ::std::os::raw::c_void,
        duration: f32,
        gridSize: *const cocos2d_CCSize,
    ) -> bool;
}
extern "C" {
    #[doc = " returns the grid"]
    #[link_name = "\u{1}?getGrid@CCGridAction@cocos2d@@UEAAPEAVCCGridBase@2@XZ"]
    pub fn cocos2d_CCGridAction_getGrid(
        this: *mut ::std::os::raw::c_void,
    ) -> *mut cocos2d_CCGridBase;
}
#[doc = "@brief Base class for CCGrid3D actions."]
#[doc = "Grid3D actions can modify a non-tiled grid."]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCGrid3DAction {
    pub _base: cocos2d_CCGridAction,
}
#[test]
fn bindgen_test_layout_cocos2d_CCGrid3DAction() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCGrid3DAction>(),
        88usize,
        concat!("Size of: ", stringify!(cocos2d_CCGrid3DAction))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCGrid3DAction>(),
        8usize,
        concat!("Alignment of ", stringify!(cocos2d_CCGrid3DAction))
    );
}
extern "C" {
    #[doc = " returns the vertex than belongs to certain position in the grid"]
    #[link_name = "\u{1}?vertex@CCGrid3DAction@cocos2d@@QEAA?AU_ccVertex3F@2@AEBVCCPoint@2@@Z"]
    pub fn cocos2d_CCGrid3DAction_vertex(
        this: *mut cocos2d_CCGrid3DAction,
        position: *const cocos2d_CCPoint,
    ) -> cocos2d_ccVertex3F;
}
extern "C" {
    #[doc = " returns the non-transformed vertex than belongs to certain position in the grid"]
    #[link_name = "\u{1}?originalVertex@CCGrid3DAction@cocos2d@@QEAA?AU_ccVertex3F@2@AEBVCCPoint@2@@Z"]
    pub fn cocos2d_CCGrid3DAction_originalVertex(
        this: *mut cocos2d_CCGrid3DAction,
        position: *const cocos2d_CCPoint,
    ) -> cocos2d_ccVertex3F;
}
extern "C" {
    #[doc = " sets a new vertex to a certain position of the grid"]
    #[link_name = "\u{1}?setVertex@CCGrid3DAction@cocos2d@@QEAAXAEBVCCPoint@2@AEBU_ccVertex3F@2@@Z"]
    pub fn cocos2d_CCGrid3DAction_setVertex(
        this: *mut cocos2d_CCGrid3DAction,
        position: *const cocos2d_CCPoint,
        vertex: *const cocos2d_ccVertex3F,
    );
}
extern "C" {
    #[doc = " creates the action with size and duration"]
    #[doc = "  @js NA"]
    #[doc = "  @lua NA"]
    #[link_name = "\u{1}?create@CCGrid3DAction@cocos2d@@SAPEAV12@MAEBVCCSize@2@@Z"]
    pub fn cocos2d_CCGrid3DAction_create(
        duration: f32,
        gridSize: *const cocos2d_CCSize,
    ) -> *mut cocos2d_CCGrid3DAction;
}
impl cocos2d_CCGrid3DAction {
    #[inline]
    pub unsafe fn vertex(&mut self, position: *const cocos2d_CCPoint) -> cocos2d_ccVertex3F {
        cocos2d_CCGrid3DAction_vertex(self, position)
    }
    #[inline]
    pub unsafe fn originalVertex(
        &mut self,
        position: *const cocos2d_CCPoint,
    ) -> cocos2d_ccVertex3F {
        cocos2d_CCGrid3DAction_originalVertex(self, position)
    }
    #[inline]
    pub unsafe fn setVertex(
        &mut self,
        position: *const cocos2d_CCPoint,
        vertex: *const cocos2d_ccVertex3F,
    ) {
        cocos2d_CCGrid3DAction_setVertex(self, position, vertex)
    }
    #[inline]
    pub unsafe fn create(
        duration: f32,
        gridSize: *const cocos2d_CCSize,
    ) -> *mut cocos2d_CCGrid3DAction {
        cocos2d_CCGrid3DAction_create(duration, gridSize)
    }
}
extern "C" {
    #[doc = " returns the grid"]
    #[link_name = "\u{1}?getGrid@CCGrid3DAction@cocos2d@@UEAAPEAVCCGridBase@2@XZ"]
    pub fn cocos2d_CCGrid3DAction_getGrid(
        this: *mut ::std::os::raw::c_void,
    ) -> *mut cocos2d_CCGridBase;
}
#[doc = " @brief Base class for CCTiledGrid3D actions"]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCTiledGrid3DAction {
    pub _base: cocos2d_CCGridAction,
}
#[test]
fn bindgen_test_layout_cocos2d_CCTiledGrid3DAction() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCTiledGrid3DAction>(),
        88usize,
        concat!("Size of: ", stringify!(cocos2d_CCTiledGrid3DAction))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCTiledGrid3DAction>(),
        8usize,
        concat!("Alignment of ", stringify!(cocos2d_CCTiledGrid3DAction))
    );
}
extern "C" {
    #[doc = " returns the tile that belongs to a certain position of the grid"]
    #[link_name = "\u{1}?tile@CCTiledGrid3DAction@cocos2d@@QEAA?AU_ccQuad3@2@AEBVCCPoint@2@@Z"]
    pub fn cocos2d_CCTiledGrid3DAction_tile(
        this: *mut cocos2d_CCTiledGrid3DAction,
        position: *const cocos2d_CCPoint,
    ) -> cocos2d_ccQuad3;
}
extern "C" {
    #[doc = " returns the non-transformed tile that belongs to a certain position of the grid"]
    #[link_name = "\u{1}?originalTile@CCTiledGrid3DAction@cocos2d@@QEAA?AU_ccQuad3@2@AEBVCCPoint@2@@Z"]
    pub fn cocos2d_CCTiledGrid3DAction_originalTile(
        this: *mut cocos2d_CCTiledGrid3DAction,
        position: *const cocos2d_CCPoint,
    ) -> cocos2d_ccQuad3;
}
extern "C" {
    #[doc = " sets a new tile to a certain position of the grid"]
    #[link_name = "\u{1}?setTile@CCTiledGrid3DAction@cocos2d@@QEAAXAEBVCCPoint@2@AEBU_ccQuad3@2@@Z"]
    pub fn cocos2d_CCTiledGrid3DAction_setTile(
        this: *mut cocos2d_CCTiledGrid3DAction,
        position: *const cocos2d_CCPoint,
        coords: *const cocos2d_ccQuad3,
    );
}
extern "C" {
    #[doc = " creates the action with size and duration"]
    #[doc = "  @js NA"]
    #[doc = "  @lua NA"]
    #[link_name = "\u{1}?create@CCTiledGrid3DAction@cocos2d@@SAPEAV12@MAEBVCCSize@2@@Z"]
    pub fn cocos2d_CCTiledGrid3DAction_create(
        duration: f32,
        gridSize: *const cocos2d_CCSize,
    ) -> *mut cocos2d_CCTiledGrid3DAction;
}
impl cocos2d_CCTiledGrid3DAction {
    #[inline]
    pub unsafe fn tile(&mut self, position: *const cocos2d_CCPoint) -> cocos2d_ccQuad3 {
        cocos2d_CCTiledGrid3DAction_tile(self, position)
    }
    #[inline]
    pub unsafe fn originalTile(&mut self, position: *const cocos2d_CCPoint) -> cocos2d_ccQuad3 {
        cocos2d_CCTiledGrid3DAction_originalTile(self, position)
    }
    #[inline]
    pub unsafe fn setTile(
        &mut self,
        position: *const cocos2d_CCPoint,
        coords: *const cocos2d_ccQuad3,
    ) {
        cocos2d_CCTiledGrid3DAction_setTile(self, position, coords)
    }
    #[inline]
    pub unsafe fn create(
        duration: f32,
        gridSize: *const cocos2d_CCSize,
    ) -> *mut cocos2d_CCTiledGrid3DAction {
        cocos2d_CCTiledGrid3DAction_create(duration, gridSize)
    }
}
extern "C" {
    #[doc = " returns the grid"]
    #[link_name = "\u{1}?getGrid@CCTiledGrid3DAction@cocos2d@@UEAAPEAVCCGridBase@2@XZ"]
    pub fn cocos2d_CCTiledGrid3DAction_getGrid(
        this: *mut ::std::os::raw::c_void,
    ) -> *mut cocos2d_CCGridBase;
}
#[doc = " @brief CCAccelDeccelAmplitude action"]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCAccelDeccelAmplitude {
    pub _base: cocos2d_CCActionInterval,
    pub m_fRate: f32,
    pub m_pOther: *mut cocos2d_CCActionInterval,
}
#[test]
fn bindgen_test_layout_cocos2d_CCAccelDeccelAmplitude() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCAccelDeccelAmplitude>(),
        96usize,
        concat!("Size of: ", stringify!(cocos2d_CCAccelDeccelAmplitude))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCAccelDeccelAmplitude>(),
        8usize,
        concat!("Alignment of ", stringify!(cocos2d_CCAccelDeccelAmplitude))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cocos2d_CCAccelDeccelAmplitude>())).m_fRate as *const _ as usize
        },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCAccelDeccelAmplitude),
            "::",
            stringify!(m_fRate)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cocos2d_CCAccelDeccelAmplitude>())).m_pOther as *const _ as usize
        },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCAccelDeccelAmplitude),
            "::",
            stringify!(m_pOther)
        )
    );
}
extern "C" {
    #[doc = " initializes the action with an inner action that has the amplitude property, and a duration time"]
    #[link_name = "\u{1}?initWithAction@CCAccelDeccelAmplitude@cocos2d@@QEAA_NPEAVCCAction@2@M@Z"]
    pub fn cocos2d_CCAccelDeccelAmplitude_initWithAction(
        this: *mut cocos2d_CCAccelDeccelAmplitude,
        pAction: *mut cocos2d_CCAction,
        duration: f32,
    ) -> bool;
}
extern "C" {
    #[doc = " creates the action with an inner action that has the amplitude property, and a duration time"]
    #[link_name = "\u{1}?create@CCAccelDeccelAmplitude@cocos2d@@SAPEAV12@PEAVCCAction@2@M@Z"]
    pub fn cocos2d_CCAccelDeccelAmplitude_create(
        pAction: *mut cocos2d_CCAction,
        duration: f32,
    ) -> *mut cocos2d_CCAccelDeccelAmplitude;
}
impl cocos2d_CCAccelDeccelAmplitude {
    #[inline]
    pub unsafe fn initWithAction(&mut self, pAction: *mut cocos2d_CCAction, duration: f32) -> bool {
        cocos2d_CCAccelDeccelAmplitude_initWithAction(self, pAction, duration)
    }
    #[inline]
    pub unsafe fn create(
        pAction: *mut cocos2d_CCAction,
        duration: f32,
    ) -> *mut cocos2d_CCAccelDeccelAmplitude {
        cocos2d_CCAccelDeccelAmplitude_create(pAction, duration)
    }
}
extern "C" {
    #[doc = "  @js NA"]
    #[doc = "  @lua NA"]
    #[link_name = "\u{1}??_DCCAccelDeccelAmplitude@cocos2d@@QEAAXXZ"]
    pub fn cocos2d_CCAccelDeccelAmplitude_CCAccelDeccelAmplitude_destructor(
        this: *mut cocos2d_CCAccelDeccelAmplitude,
    );
}
extern "C" {
    #[link_name = "\u{1}?startWithTarget@CCAccelDeccelAmplitude@cocos2d@@UEAAXPEAVCCNode@2@@Z"]
    pub fn cocos2d_CCAccelDeccelAmplitude_startWithTarget(
        this: *mut ::std::os::raw::c_void,
        pTarget: *mut cocos2d_CCNode,
    );
}
extern "C" {
    #[link_name = "\u{1}?update@CCAccelDeccelAmplitude@cocos2d@@UEAAXM@Z"]
    pub fn cocos2d_CCAccelDeccelAmplitude_update(this: *mut ::std::os::raw::c_void, time: f32);
}
extern "C" {
    #[link_name = "\u{1}?reverse@CCAccelDeccelAmplitude@cocos2d@@UEAAPEAVCCActionInterval@2@XZ"]
    pub fn cocos2d_CCAccelDeccelAmplitude_reverse(
        this: *mut ::std::os::raw::c_void,
    ) -> *mut cocos2d_CCActionInterval;
}
#[doc = " @brief CCAccelAmplitude action"]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCAccelAmplitude {
    pub _base: cocos2d_CCActionInterval,
    pub m_fRate: f32,
    pub m_pOther: *mut cocos2d_CCActionInterval,
}
#[test]
fn bindgen_test_layout_cocos2d_CCAccelAmplitude() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCAccelAmplitude>(),
        96usize,
        concat!("Size of: ", stringify!(cocos2d_CCAccelAmplitude))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCAccelAmplitude>(),
        8usize,
        concat!("Alignment of ", stringify!(cocos2d_CCAccelAmplitude))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cocos2d_CCAccelAmplitude>())).m_fRate as *const _ as usize
        },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCAccelAmplitude),
            "::",
            stringify!(m_fRate)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cocos2d_CCAccelAmplitude>())).m_pOther as *const _ as usize
        },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCAccelAmplitude),
            "::",
            stringify!(m_pOther)
        )
    );
}
extern "C" {
    #[doc = " initializes the action with an inner action that has the amplitude property, and a duration time"]
    #[link_name = "\u{1}?initWithAction@CCAccelAmplitude@cocos2d@@QEAA_NPEAVCCAction@2@M@Z"]
    pub fn cocos2d_CCAccelAmplitude_initWithAction(
        this: *mut cocos2d_CCAccelAmplitude,
        pAction: *mut cocos2d_CCAction,
        duration: f32,
    ) -> bool;
}
extern "C" {
    #[doc = " creates the action with an inner action that has the amplitude property, and a duration time"]
    #[link_name = "\u{1}?create@CCAccelAmplitude@cocos2d@@SAPEAV12@PEAVCCAction@2@M@Z"]
    pub fn cocos2d_CCAccelAmplitude_create(
        pAction: *mut cocos2d_CCAction,
        duration: f32,
    ) -> *mut cocos2d_CCAccelAmplitude;
}
impl cocos2d_CCAccelAmplitude {
    #[inline]
    pub unsafe fn initWithAction(&mut self, pAction: *mut cocos2d_CCAction, duration: f32) -> bool {
        cocos2d_CCAccelAmplitude_initWithAction(self, pAction, duration)
    }
    #[inline]
    pub unsafe fn create(
        pAction: *mut cocos2d_CCAction,
        duration: f32,
    ) -> *mut cocos2d_CCAccelAmplitude {
        cocos2d_CCAccelAmplitude_create(pAction, duration)
    }
}
extern "C" {
    #[doc = "  @js NA"]
    #[doc = "  @lua NA"]
    #[link_name = "\u{1}??_DCCAccelAmplitude@cocos2d@@QEAAXXZ"]
    pub fn cocos2d_CCAccelAmplitude_CCAccelAmplitude_destructor(
        this: *mut cocos2d_CCAccelAmplitude,
    );
}
extern "C" {
    #[link_name = "\u{1}?startWithTarget@CCAccelAmplitude@cocos2d@@UEAAXPEAVCCNode@2@@Z"]
    pub fn cocos2d_CCAccelAmplitude_startWithTarget(
        this: *mut ::std::os::raw::c_void,
        pTarget: *mut cocos2d_CCNode,
    );
}
extern "C" {
    #[link_name = "\u{1}?update@CCAccelAmplitude@cocos2d@@UEAAXM@Z"]
    pub fn cocos2d_CCAccelAmplitude_update(this: *mut ::std::os::raw::c_void, time: f32);
}
extern "C" {
    #[link_name = "\u{1}?reverse@CCAccelAmplitude@cocos2d@@UEAAPEAVCCActionInterval@2@XZ"]
    pub fn cocos2d_CCAccelAmplitude_reverse(
        this: *mut ::std::os::raw::c_void,
    ) -> *mut cocos2d_CCActionInterval;
}
#[doc = " @brief CCDeccelAmplitude action"]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCDeccelAmplitude {
    pub _base: cocos2d_CCActionInterval,
    pub m_fRate: f32,
    pub m_pOther: *mut cocos2d_CCActionInterval,
}
#[test]
fn bindgen_test_layout_cocos2d_CCDeccelAmplitude() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCDeccelAmplitude>(),
        96usize,
        concat!("Size of: ", stringify!(cocos2d_CCDeccelAmplitude))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCDeccelAmplitude>(),
        8usize,
        concat!("Alignment of ", stringify!(cocos2d_CCDeccelAmplitude))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cocos2d_CCDeccelAmplitude>())).m_fRate as *const _ as usize
        },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCDeccelAmplitude),
            "::",
            stringify!(m_fRate)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cocos2d_CCDeccelAmplitude>())).m_pOther as *const _ as usize
        },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCDeccelAmplitude),
            "::",
            stringify!(m_pOther)
        )
    );
}
extern "C" {
    #[doc = " initializes the action with an inner action that has the amplitude property, and a duration time"]
    #[link_name = "\u{1}?initWithAction@CCDeccelAmplitude@cocos2d@@QEAA_NPEAVCCAction@2@M@Z"]
    pub fn cocos2d_CCDeccelAmplitude_initWithAction(
        this: *mut cocos2d_CCDeccelAmplitude,
        pAction: *mut cocos2d_CCAction,
        duration: f32,
    ) -> bool;
}
extern "C" {
    #[doc = " creates the action with an inner action that has the amplitude property, and a duration time"]
    #[link_name = "\u{1}?create@CCDeccelAmplitude@cocos2d@@SAPEAV12@PEAVCCAction@2@M@Z"]
    pub fn cocos2d_CCDeccelAmplitude_create(
        pAction: *mut cocos2d_CCAction,
        duration: f32,
    ) -> *mut cocos2d_CCDeccelAmplitude;
}
impl cocos2d_CCDeccelAmplitude {
    #[inline]
    pub unsafe fn initWithAction(&mut self, pAction: *mut cocos2d_CCAction, duration: f32) -> bool {
        cocos2d_CCDeccelAmplitude_initWithAction(self, pAction, duration)
    }
    #[inline]
    pub unsafe fn create(
        pAction: *mut cocos2d_CCAction,
        duration: f32,
    ) -> *mut cocos2d_CCDeccelAmplitude {
        cocos2d_CCDeccelAmplitude_create(pAction, duration)
    }
}
extern "C" {
    #[doc = "  @js NA"]
    #[doc = "  @lua NA"]
    #[link_name = "\u{1}??_DCCDeccelAmplitude@cocos2d@@QEAAXXZ"]
    pub fn cocos2d_CCDeccelAmplitude_CCDeccelAmplitude_destructor(
        this: *mut cocos2d_CCDeccelAmplitude,
    );
}
extern "C" {
    #[link_name = "\u{1}?startWithTarget@CCDeccelAmplitude@cocos2d@@UEAAXPEAVCCNode@2@@Z"]
    pub fn cocos2d_CCDeccelAmplitude_startWithTarget(
        this: *mut ::std::os::raw::c_void,
        pTarget: *mut cocos2d_CCNode,
    );
}
extern "C" {
    #[link_name = "\u{1}?update@CCDeccelAmplitude@cocos2d@@UEAAXM@Z"]
    pub fn cocos2d_CCDeccelAmplitude_update(this: *mut ::std::os::raw::c_void, time: f32);
}
extern "C" {
    #[link_name = "\u{1}?reverse@CCDeccelAmplitude@cocos2d@@UEAAPEAVCCActionInterval@2@XZ"]
    pub fn cocos2d_CCDeccelAmplitude_reverse(
        this: *mut ::std::os::raw::c_void,
    ) -> *mut cocos2d_CCActionInterval;
}
#[doc = " @brief CCStopGrid action."]
#[doc = "@warning Don't call this action if another grid action is active."]
#[doc = "Call if you want to remove the the grid effect. Example:"]
#[doc = "CCSequence::actions(Lens::action(...), CCStopGrid::action(...), NULL);"]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCStopGrid {
    pub _base: cocos2d_CCActionInstant,
}
#[test]
fn bindgen_test_layout_cocos2d_CCStopGrid() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCStopGrid>(),
        72usize,
        concat!("Size of: ", stringify!(cocos2d_CCStopGrid))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCStopGrid>(),
        8usize,
        concat!("Alignment of ", stringify!(cocos2d_CCStopGrid))
    );
}
extern "C" {
    #[doc = " Allocates and initializes the action"]
    #[link_name = "\u{1}?create@CCStopGrid@cocos2d@@SAPEAV12@XZ"]
    pub fn cocos2d_CCStopGrid_create() -> *mut cocos2d_CCStopGrid;
}
impl cocos2d_CCStopGrid {
    #[inline]
    pub unsafe fn create() -> *mut cocos2d_CCStopGrid {
        cocos2d_CCStopGrid_create()
    }
}
extern "C" {
    #[link_name = "\u{1}?startWithTarget@CCStopGrid@cocos2d@@UEAAXPEAVCCNode@2@@Z"]
    pub fn cocos2d_CCStopGrid_startWithTarget(
        this: *mut ::std::os::raw::c_void,
        pTarget: *mut cocos2d_CCNode,
    );
}
#[doc = " @brief CCReuseGrid action"]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCReuseGrid {
    pub _base: cocos2d_CCActionInstant,
    pub m_nTimes: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_cocos2d_CCReuseGrid() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCReuseGrid>(),
        80usize,
        concat!("Size of: ", stringify!(cocos2d_CCReuseGrid))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCReuseGrid>(),
        8usize,
        concat!("Alignment of ", stringify!(cocos2d_CCReuseGrid))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cocos2d_CCReuseGrid>())).m_nTimes as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCReuseGrid),
            "::",
            stringify!(m_nTimes)
        )
    );
}
extern "C" {
    #[doc = " initializes an action with the number of times that the current grid will be reused"]
    #[link_name = "\u{1}?initWithTimes@CCReuseGrid@cocos2d@@QEAA_NH@Z"]
    pub fn cocos2d_CCReuseGrid_initWithTimes(
        this: *mut cocos2d_CCReuseGrid,
        times: ::std::os::raw::c_int,
    ) -> bool;
}
extern "C" {
    #[doc = " creates an action with the number of times that the current grid will be reused"]
    #[link_name = "\u{1}?create@CCReuseGrid@cocos2d@@SAPEAV12@H@Z"]
    pub fn cocos2d_CCReuseGrid_create(times: ::std::os::raw::c_int) -> *mut cocos2d_CCReuseGrid;
}
impl cocos2d_CCReuseGrid {
    #[inline]
    pub unsafe fn initWithTimes(&mut self, times: ::std::os::raw::c_int) -> bool {
        cocos2d_CCReuseGrid_initWithTimes(self, times)
    }
    #[inline]
    pub unsafe fn create(times: ::std::os::raw::c_int) -> *mut cocos2d_CCReuseGrid {
        cocos2d_CCReuseGrid_create(times)
    }
}
extern "C" {
    #[link_name = "\u{1}?startWithTarget@CCReuseGrid@cocos2d@@UEAAXPEAVCCNode@2@@Z"]
    pub fn cocos2d_CCReuseGrid_startWithTarget(
        this: *mut ::std::os::raw::c_void,
        pTarget: *mut cocos2d_CCNode,
    );
}
#[doc = "@brief CCWaves3D action"]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCWaves3D {
    pub _base: cocos2d_CCGrid3DAction,
    pub m_nWaves: ::std::os::raw::c_uint,
    pub m_fAmplitude: f32,
    pub m_fAmplitudeRate: f32,
}
#[test]
fn bindgen_test_layout_cocos2d_CCWaves3D() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCWaves3D>(),
        104usize,
        concat!("Size of: ", stringify!(cocos2d_CCWaves3D))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCWaves3D>(),
        8usize,
        concat!("Alignment of ", stringify!(cocos2d_CCWaves3D))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cocos2d_CCWaves3D>())).m_nWaves as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCWaves3D),
            "::",
            stringify!(m_nWaves)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cocos2d_CCWaves3D>())).m_fAmplitude as *const _ as usize },
        92usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCWaves3D),
            "::",
            stringify!(m_fAmplitude)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cocos2d_CCWaves3D>())).m_fAmplitudeRate as *const _ as usize
        },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCWaves3D),
            "::",
            stringify!(m_fAmplitudeRate)
        )
    );
}
extern "C" {
    #[doc = " initializes an action with duration, grid size, waves and amplitude"]
    #[link_name = "\u{1}?initWithDuration@CCWaves3D@cocos2d@@QEAA_NMAEBVCCSize@2@IM@Z"]
    pub fn cocos2d_CCWaves3D_initWithDuration(
        this: *mut cocos2d_CCWaves3D,
        duration: f32,
        gridSize: *const cocos2d_CCSize,
        waves: ::std::os::raw::c_uint,
        amplitude: f32,
    ) -> bool;
}
extern "C" {
    #[doc = " creates an action with duration, grid size, waves and amplitude"]
    #[link_name = "\u{1}?create@CCWaves3D@cocos2d@@SAPEAV12@MAEBVCCSize@2@IM@Z"]
    pub fn cocos2d_CCWaves3D_create(
        duration: f32,
        gridSize: *const cocos2d_CCSize,
        waves: ::std::os::raw::c_uint,
        amplitude: f32,
    ) -> *mut cocos2d_CCWaves3D;
}
impl cocos2d_CCWaves3D {
    #[inline]
    pub unsafe fn initWithDuration(
        &mut self,
        duration: f32,
        gridSize: *const cocos2d_CCSize,
        waves: ::std::os::raw::c_uint,
        amplitude: f32,
    ) -> bool {
        cocos2d_CCWaves3D_initWithDuration(self, duration, gridSize, waves, amplitude)
    }
    #[inline]
    pub unsafe fn create(
        duration: f32,
        gridSize: *const cocos2d_CCSize,
        waves: ::std::os::raw::c_uint,
        amplitude: f32,
    ) -> *mut cocos2d_CCWaves3D {
        cocos2d_CCWaves3D_create(duration, gridSize, waves, amplitude)
    }
}
extern "C" {
    #[doc = "  @js NA"]
    #[doc = "  @lua NA"]
    #[link_name = "\u{1}?copyWithZone@CCWaves3D@cocos2d@@UEAAPEAVCCObject@2@PEAVCCZone@2@@Z"]
    pub fn cocos2d_CCWaves3D_copyWithZone(
        this: *mut ::std::os::raw::c_void,
        pZone: *mut cocos2d_CCZone,
    ) -> *mut cocos2d_CCObject;
}
extern "C" {
    #[link_name = "\u{1}?update@CCWaves3D@cocos2d@@UEAAXM@Z"]
    pub fn cocos2d_CCWaves3D_update(this: *mut ::std::os::raw::c_void, time: f32);
}
#[doc = " @brief CCFlipX3D action"]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCFlipX3D {
    pub _base: cocos2d_CCGrid3DAction,
}
#[test]
fn bindgen_test_layout_cocos2d_CCFlipX3D() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCFlipX3D>(),
        88usize,
        concat!("Size of: ", stringify!(cocos2d_CCFlipX3D))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCFlipX3D>(),
        8usize,
        concat!("Alignment of ", stringify!(cocos2d_CCFlipX3D))
    );
}
extern "C" {
    #[doc = " creates the action with duration"]
    #[link_name = "\u{1}?create@CCFlipX3D@cocos2d@@SAPEAV12@M@Z"]
    pub fn cocos2d_CCFlipX3D_create(duration: f32) -> *mut cocos2d_CCFlipX3D;
}
impl cocos2d_CCFlipX3D {
    #[inline]
    pub unsafe fn create(duration: f32) -> *mut cocos2d_CCFlipX3D {
        cocos2d_CCFlipX3D_create(duration)
    }
}
extern "C" {
    #[doc = " initializes the action with duration"]
    #[link_name = "\u{1}?initWithDuration@CCFlipX3D@cocos2d@@UEAA_NM@Z"]
    pub fn cocos2d_CCFlipX3D_initWithDuration(
        this: *mut ::std::os::raw::c_void,
        duration: f32,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}?initWithSize@CCFlipX3D@cocos2d@@UEAA_NAEBVCCSize@2@M@Z"]
    pub fn cocos2d_CCFlipX3D_initWithSize(
        this: *mut ::std::os::raw::c_void,
        gridSize: *const cocos2d_CCSize,
        duration: f32,
    ) -> bool;
}
extern "C" {
    #[doc = "  @js NA"]
    #[doc = "  @lua NA"]
    #[link_name = "\u{1}?copyWithZone@CCFlipX3D@cocos2d@@UEAAPEAVCCObject@2@PEAVCCZone@2@@Z"]
    pub fn cocos2d_CCFlipX3D_copyWithZone(
        this: *mut ::std::os::raw::c_void,
        pZone: *mut cocos2d_CCZone,
    ) -> *mut cocos2d_CCObject;
}
extern "C" {
    #[link_name = "\u{1}?update@CCFlipX3D@cocos2d@@UEAAXM@Z"]
    pub fn cocos2d_CCFlipX3D_update(this: *mut ::std::os::raw::c_void, time: f32);
}
#[doc = " @brief CCFlipY3D action"]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCFlipY3D {
    pub _base: cocos2d_CCFlipX3D,
}
#[test]
fn bindgen_test_layout_cocos2d_CCFlipY3D() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCFlipY3D>(),
        88usize,
        concat!("Size of: ", stringify!(cocos2d_CCFlipY3D))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCFlipY3D>(),
        8usize,
        concat!("Alignment of ", stringify!(cocos2d_CCFlipY3D))
    );
}
extern "C" {
    #[doc = " creates the action with duration"]
    #[link_name = "\u{1}?create@CCFlipY3D@cocos2d@@SAPEAV12@M@Z"]
    pub fn cocos2d_CCFlipY3D_create(duration: f32) -> *mut cocos2d_CCFlipY3D;
}
impl cocos2d_CCFlipY3D {
    #[inline]
    pub unsafe fn create(duration: f32) -> *mut cocos2d_CCFlipY3D {
        cocos2d_CCFlipY3D_create(duration)
    }
}
extern "C" {
    #[link_name = "\u{1}?update@CCFlipY3D@cocos2d@@UEAAXM@Z"]
    pub fn cocos2d_CCFlipY3D_update(this: *mut ::std::os::raw::c_void, time: f32);
}
extern "C" {
    #[doc = "  @js NA"]
    #[doc = "  @lua NA"]
    #[link_name = "\u{1}?copyWithZone@CCFlipY3D@cocos2d@@UEAAPEAVCCObject@2@PEAVCCZone@2@@Z"]
    pub fn cocos2d_CCFlipY3D_copyWithZone(
        this: *mut ::std::os::raw::c_void,
        pZone: *mut cocos2d_CCZone,
    ) -> *mut cocos2d_CCObject;
}
#[doc = " @brief CCLens3D action"]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCLens3D {
    pub _base: cocos2d_CCGrid3DAction,
    pub m_position: cocos2d_CCPoint,
    pub m_fRadius: f32,
    #[doc = " lens effect. Defaults to 0.7 - 0 means no effect, 1 is very strong effect"]
    pub m_fLensEffect: f32,
    #[doc = " lens is concave. (true = concave, false = convex) default is convex i.e. false"]
    pub m_bConcave: bool,
    pub m_bDirty: bool,
}
#[test]
fn bindgen_test_layout_cocos2d_CCLens3D() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCLens3D>(),
        112usize,
        concat!("Size of: ", stringify!(cocos2d_CCLens3D))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCLens3D>(),
        8usize,
        concat!("Alignment of ", stringify!(cocos2d_CCLens3D))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cocos2d_CCLens3D>())).m_position as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCLens3D),
            "::",
            stringify!(m_position)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cocos2d_CCLens3D>())).m_fRadius as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCLens3D),
            "::",
            stringify!(m_fRadius)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cocos2d_CCLens3D>())).m_fLensEffect as *const _ as usize },
        100usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCLens3D),
            "::",
            stringify!(m_fLensEffect)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cocos2d_CCLens3D>())).m_bConcave as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCLens3D),
            "::",
            stringify!(m_bConcave)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cocos2d_CCLens3D>())).m_bDirty as *const _ as usize },
        105usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCLens3D),
            "::",
            stringify!(m_bDirty)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}?setPosition@CCLens3D@cocos2d@@QEAAXAEBVCCPoint@2@@Z"]
    pub fn cocos2d_CCLens3D_setPosition(
        this: *mut cocos2d_CCLens3D,
        position: *const cocos2d_CCPoint,
    );
}
extern "C" {
    #[doc = " initializes the action with center position, radius, a grid size and duration"]
    #[link_name = "\u{1}?initWithDuration@CCLens3D@cocos2d@@QEAA_NMAEBVCCSize@2@AEBVCCPoint@2@M@Z"]
    pub fn cocos2d_CCLens3D_initWithDuration(
        this: *mut cocos2d_CCLens3D,
        duration: f32,
        gridSize: *const cocos2d_CCSize,
        position: *const cocos2d_CCPoint,
        radius: f32,
    ) -> bool;
}
extern "C" {
    #[doc = " creates the action with center position, radius, a grid size and duration"]
    #[link_name = "\u{1}?create@CCLens3D@cocos2d@@SAPEAV12@MAEBVCCSize@2@AEBVCCPoint@2@M@Z"]
    pub fn cocos2d_CCLens3D_create(
        duration: f32,
        gridSize: *const cocos2d_CCSize,
        position: *const cocos2d_CCPoint,
        radius: f32,
    ) -> *mut cocos2d_CCLens3D;
}
impl cocos2d_CCLens3D {
    #[inline]
    pub unsafe fn setPosition(&mut self, position: *const cocos2d_CCPoint) {
        cocos2d_CCLens3D_setPosition(self, position)
    }
    #[inline]
    pub unsafe fn initWithDuration(
        &mut self,
        duration: f32,
        gridSize: *const cocos2d_CCSize,
        position: *const cocos2d_CCPoint,
        radius: f32,
    ) -> bool {
        cocos2d_CCLens3D_initWithDuration(self, duration, gridSize, position, radius)
    }
    #[inline]
    pub unsafe fn create(
        duration: f32,
        gridSize: *const cocos2d_CCSize,
        position: *const cocos2d_CCPoint,
        radius: f32,
    ) -> *mut cocos2d_CCLens3D {
        cocos2d_CCLens3D_create(duration, gridSize, position, radius)
    }
}
extern "C" {
    #[doc = "  @js NA"]
    #[doc = "  @lua NA"]
    #[link_name = "\u{1}?copyWithZone@CCLens3D@cocos2d@@UEAAPEAVCCObject@2@PEAVCCZone@2@@Z"]
    pub fn cocos2d_CCLens3D_copyWithZone(
        this: *mut ::std::os::raw::c_void,
        pZone: *mut cocos2d_CCZone,
    ) -> *mut cocos2d_CCObject;
}
extern "C" {
    #[link_name = "\u{1}?update@CCLens3D@cocos2d@@UEAAXM@Z"]
    pub fn cocos2d_CCLens3D_update(this: *mut ::std::os::raw::c_void, time: f32);
}
#[doc = " @brief CCRipple3D action"]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCRipple3D {
    pub _base: cocos2d_CCGrid3DAction,
    pub m_position: cocos2d_CCPoint,
    pub m_fRadius: f32,
    pub m_nWaves: ::std::os::raw::c_uint,
    pub m_fAmplitude: f32,
    pub m_fAmplitudeRate: f32,
}
#[test]
fn bindgen_test_layout_cocos2d_CCRipple3D() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCRipple3D>(),
        112usize,
        concat!("Size of: ", stringify!(cocos2d_CCRipple3D))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCRipple3D>(),
        8usize,
        concat!("Alignment of ", stringify!(cocos2d_CCRipple3D))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cocos2d_CCRipple3D>())).m_position as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCRipple3D),
            "::",
            stringify!(m_position)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cocos2d_CCRipple3D>())).m_fRadius as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCRipple3D),
            "::",
            stringify!(m_fRadius)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cocos2d_CCRipple3D>())).m_nWaves as *const _ as usize },
        100usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCRipple3D),
            "::",
            stringify!(m_nWaves)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cocos2d_CCRipple3D>())).m_fAmplitude as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCRipple3D),
            "::",
            stringify!(m_fAmplitude)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cocos2d_CCRipple3D>())).m_fAmplitudeRate as *const _ as usize
        },
        108usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCRipple3D),
            "::",
            stringify!(m_fAmplitudeRate)
        )
    );
}
extern "C" {
    #[doc = " set center position"]
    #[link_name = "\u{1}?setPosition@CCRipple3D@cocos2d@@QEAAXAEBVCCPoint@2@@Z"]
    pub fn cocos2d_CCRipple3D_setPosition(
        this: *mut cocos2d_CCRipple3D,
        position: *const cocos2d_CCPoint,
    );
}
extern "C" {
    #[doc = " initializes the action with radius, number of waves, amplitude, a grid size and duration"]
    #[link_name = "\u{1}?initWithDuration@CCRipple3D@cocos2d@@QEAA_NMAEBVCCSize@2@AEBVCCPoint@2@MIM@Z"]
    pub fn cocos2d_CCRipple3D_initWithDuration(
        this: *mut cocos2d_CCRipple3D,
        duration: f32,
        gridSize: *const cocos2d_CCSize,
        position: *const cocos2d_CCPoint,
        radius: f32,
        waves: ::std::os::raw::c_uint,
        amplitude: f32,
    ) -> bool;
}
extern "C" {
    #[doc = " creates the action with radius, number of waves, amplitude, a grid size and duration"]
    #[link_name = "\u{1}?create@CCRipple3D@cocos2d@@SAPEAV12@MAEBVCCSize@2@AEBVCCPoint@2@MIM@Z"]
    pub fn cocos2d_CCRipple3D_create(
        duration: f32,
        gridSize: *const cocos2d_CCSize,
        position: *const cocos2d_CCPoint,
        radius: f32,
        waves: ::std::os::raw::c_uint,
        amplitude: f32,
    ) -> *mut cocos2d_CCRipple3D;
}
impl cocos2d_CCRipple3D {
    #[inline]
    pub unsafe fn setPosition(&mut self, position: *const cocos2d_CCPoint) {
        cocos2d_CCRipple3D_setPosition(self, position)
    }
    #[inline]
    pub unsafe fn initWithDuration(
        &mut self,
        duration: f32,
        gridSize: *const cocos2d_CCSize,
        position: *const cocos2d_CCPoint,
        radius: f32,
        waves: ::std::os::raw::c_uint,
        amplitude: f32,
    ) -> bool {
        cocos2d_CCRipple3D_initWithDuration(
            self, duration, gridSize, position, radius, waves, amplitude,
        )
    }
    #[inline]
    pub unsafe fn create(
        duration: f32,
        gridSize: *const cocos2d_CCSize,
        position: *const cocos2d_CCPoint,
        radius: f32,
        waves: ::std::os::raw::c_uint,
        amplitude: f32,
    ) -> *mut cocos2d_CCRipple3D {
        cocos2d_CCRipple3D_create(duration, gridSize, position, radius, waves, amplitude)
    }
}
extern "C" {
    #[doc = "  @js NA"]
    #[doc = "  @lua NA"]
    #[link_name = "\u{1}?copyWithZone@CCRipple3D@cocos2d@@UEAAPEAVCCObject@2@PEAVCCZone@2@@Z"]
    pub fn cocos2d_CCRipple3D_copyWithZone(
        this: *mut ::std::os::raw::c_void,
        pZone: *mut cocos2d_CCZone,
    ) -> *mut cocos2d_CCObject;
}
extern "C" {
    #[link_name = "\u{1}?update@CCRipple3D@cocos2d@@UEAAXM@Z"]
    pub fn cocos2d_CCRipple3D_update(this: *mut ::std::os::raw::c_void, time: f32);
}
#[doc = " @brief CCShaky3D action"]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCShaky3D {
    pub _base: cocos2d_CCGrid3DAction,
    pub m_nRandrange: ::std::os::raw::c_int,
    pub m_bShakeZ: bool,
}
#[test]
fn bindgen_test_layout_cocos2d_CCShaky3D() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCShaky3D>(),
        96usize,
        concat!("Size of: ", stringify!(cocos2d_CCShaky3D))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCShaky3D>(),
        8usize,
        concat!("Alignment of ", stringify!(cocos2d_CCShaky3D))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cocos2d_CCShaky3D>())).m_nRandrange as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCShaky3D),
            "::",
            stringify!(m_nRandrange)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cocos2d_CCShaky3D>())).m_bShakeZ as *const _ as usize },
        92usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCShaky3D),
            "::",
            stringify!(m_bShakeZ)
        )
    );
}
extern "C" {
    #[doc = " initializes the action with a range, shake Z vertices, a grid and duration"]
    #[link_name = "\u{1}?initWithDuration@CCShaky3D@cocos2d@@QEAA_NMAEBVCCSize@2@H_N@Z"]
    pub fn cocos2d_CCShaky3D_initWithDuration(
        this: *mut cocos2d_CCShaky3D,
        duration: f32,
        gridSize: *const cocos2d_CCSize,
        range: ::std::os::raw::c_int,
        shakeZ: bool,
    ) -> bool;
}
extern "C" {
    #[doc = " creates the action with a range, shake Z vertices, a grid and duration"]
    #[link_name = "\u{1}?create@CCShaky3D@cocos2d@@SAPEAV12@MAEBVCCSize@2@H_N@Z"]
    pub fn cocos2d_CCShaky3D_create(
        duration: f32,
        gridSize: *const cocos2d_CCSize,
        range: ::std::os::raw::c_int,
        shakeZ: bool,
    ) -> *mut cocos2d_CCShaky3D;
}
impl cocos2d_CCShaky3D {
    #[inline]
    pub unsafe fn initWithDuration(
        &mut self,
        duration: f32,
        gridSize: *const cocos2d_CCSize,
        range: ::std::os::raw::c_int,
        shakeZ: bool,
    ) -> bool {
        cocos2d_CCShaky3D_initWithDuration(self, duration, gridSize, range, shakeZ)
    }
    #[inline]
    pub unsafe fn create(
        duration: f32,
        gridSize: *const cocos2d_CCSize,
        range: ::std::os::raw::c_int,
        shakeZ: bool,
    ) -> *mut cocos2d_CCShaky3D {
        cocos2d_CCShaky3D_create(duration, gridSize, range, shakeZ)
    }
}
extern "C" {
    #[doc = "  @js NA"]
    #[doc = "  @lua NA"]
    #[link_name = "\u{1}?copyWithZone@CCShaky3D@cocos2d@@UEAAPEAVCCObject@2@PEAVCCZone@2@@Z"]
    pub fn cocos2d_CCShaky3D_copyWithZone(
        this: *mut ::std::os::raw::c_void,
        pZone: *mut cocos2d_CCZone,
    ) -> *mut cocos2d_CCObject;
}
extern "C" {
    #[link_name = "\u{1}?update@CCShaky3D@cocos2d@@UEAAXM@Z"]
    pub fn cocos2d_CCShaky3D_update(this: *mut ::std::os::raw::c_void, time: f32);
}
#[doc = " @brief CCLiquid action"]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCLiquid {
    pub _base: cocos2d_CCGrid3DAction,
    pub m_nWaves: ::std::os::raw::c_uint,
    pub m_fAmplitude: f32,
    pub m_fAmplitudeRate: f32,
}
#[test]
fn bindgen_test_layout_cocos2d_CCLiquid() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCLiquid>(),
        104usize,
        concat!("Size of: ", stringify!(cocos2d_CCLiquid))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCLiquid>(),
        8usize,
        concat!("Alignment of ", stringify!(cocos2d_CCLiquid))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cocos2d_CCLiquid>())).m_nWaves as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCLiquid),
            "::",
            stringify!(m_nWaves)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cocos2d_CCLiquid>())).m_fAmplitude as *const _ as usize },
        92usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCLiquid),
            "::",
            stringify!(m_fAmplitude)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cocos2d_CCLiquid>())).m_fAmplitudeRate as *const _ as usize
        },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCLiquid),
            "::",
            stringify!(m_fAmplitudeRate)
        )
    );
}
extern "C" {
    #[doc = " initializes the action with amplitude, a grid and duration"]
    #[link_name = "\u{1}?initWithDuration@CCLiquid@cocos2d@@QEAA_NMAEBVCCSize@2@IM@Z"]
    pub fn cocos2d_CCLiquid_initWithDuration(
        this: *mut cocos2d_CCLiquid,
        duration: f32,
        gridSize: *const cocos2d_CCSize,
        waves: ::std::os::raw::c_uint,
        amplitude: f32,
    ) -> bool;
}
extern "C" {
    #[doc = " creates the action with amplitude, a grid and duration"]
    #[link_name = "\u{1}?create@CCLiquid@cocos2d@@SAPEAV12@MAEBVCCSize@2@IM@Z"]
    pub fn cocos2d_CCLiquid_create(
        duration: f32,
        gridSize: *const cocos2d_CCSize,
        waves: ::std::os::raw::c_uint,
        amplitude: f32,
    ) -> *mut cocos2d_CCLiquid;
}
impl cocos2d_CCLiquid {
    #[inline]
    pub unsafe fn initWithDuration(
        &mut self,
        duration: f32,
        gridSize: *const cocos2d_CCSize,
        waves: ::std::os::raw::c_uint,
        amplitude: f32,
    ) -> bool {
        cocos2d_CCLiquid_initWithDuration(self, duration, gridSize, waves, amplitude)
    }
    #[inline]
    pub unsafe fn create(
        duration: f32,
        gridSize: *const cocos2d_CCSize,
        waves: ::std::os::raw::c_uint,
        amplitude: f32,
    ) -> *mut cocos2d_CCLiquid {
        cocos2d_CCLiquid_create(duration, gridSize, waves, amplitude)
    }
}
extern "C" {
    #[doc = "  @js NA"]
    #[doc = "  @lua NA"]
    #[link_name = "\u{1}?copyWithZone@CCLiquid@cocos2d@@UEAAPEAVCCObject@2@PEAVCCZone@2@@Z"]
    pub fn cocos2d_CCLiquid_copyWithZone(
        this: *mut ::std::os::raw::c_void,
        pZone: *mut cocos2d_CCZone,
    ) -> *mut cocos2d_CCObject;
}
extern "C" {
    #[link_name = "\u{1}?update@CCLiquid@cocos2d@@UEAAXM@Z"]
    pub fn cocos2d_CCLiquid_update(this: *mut ::std::os::raw::c_void, time: f32);
}
#[doc = " @brief CCWaves action"]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCWaves {
    pub _base: cocos2d_CCGrid3DAction,
    pub m_nWaves: ::std::os::raw::c_uint,
    pub m_fAmplitude: f32,
    pub m_fAmplitudeRate: f32,
    pub m_bVertical: bool,
    pub m_bHorizontal: bool,
}
#[test]
fn bindgen_test_layout_cocos2d_CCWaves() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCWaves>(),
        104usize,
        concat!("Size of: ", stringify!(cocos2d_CCWaves))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCWaves>(),
        8usize,
        concat!("Alignment of ", stringify!(cocos2d_CCWaves))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cocos2d_CCWaves>())).m_nWaves as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCWaves),
            "::",
            stringify!(m_nWaves)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cocos2d_CCWaves>())).m_fAmplitude as *const _ as usize },
        92usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCWaves),
            "::",
            stringify!(m_fAmplitude)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cocos2d_CCWaves>())).m_fAmplitudeRate as *const _ as usize
        },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCWaves),
            "::",
            stringify!(m_fAmplitudeRate)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cocos2d_CCWaves>())).m_bVertical as *const _ as usize },
        100usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCWaves),
            "::",
            stringify!(m_bVertical)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cocos2d_CCWaves>())).m_bHorizontal as *const _ as usize },
        101usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCWaves),
            "::",
            stringify!(m_bHorizontal)
        )
    );
}
extern "C" {
    #[doc = " initializes the action with amplitude, horizontal sin, vertical sin, a grid and duration"]
    #[link_name = "\u{1}?initWithDuration@CCWaves@cocos2d@@QEAA_NMAEBVCCSize@2@IM_N1@Z"]
    pub fn cocos2d_CCWaves_initWithDuration(
        this: *mut cocos2d_CCWaves,
        duration: f32,
        gridSize: *const cocos2d_CCSize,
        waves: ::std::os::raw::c_uint,
        amplitude: f32,
        horizontal: bool,
        vertical: bool,
    ) -> bool;
}
extern "C" {
    #[doc = " initializes the action with amplitude, horizontal sin, vertical sin, a grid and duration"]
    #[link_name = "\u{1}?create@CCWaves@cocos2d@@SAPEAV12@MAEBVCCSize@2@IM_N1@Z"]
    pub fn cocos2d_CCWaves_create(
        duration: f32,
        gridSize: *const cocos2d_CCSize,
        waves: ::std::os::raw::c_uint,
        amplitude: f32,
        horizontal: bool,
        vertical: bool,
    ) -> *mut cocos2d_CCWaves;
}
impl cocos2d_CCWaves {
    #[inline]
    pub unsafe fn initWithDuration(
        &mut self,
        duration: f32,
        gridSize: *const cocos2d_CCSize,
        waves: ::std::os::raw::c_uint,
        amplitude: f32,
        horizontal: bool,
        vertical: bool,
    ) -> bool {
        cocos2d_CCWaves_initWithDuration(
            self, duration, gridSize, waves, amplitude, horizontal, vertical,
        )
    }
    #[inline]
    pub unsafe fn create(
        duration: f32,
        gridSize: *const cocos2d_CCSize,
        waves: ::std::os::raw::c_uint,
        amplitude: f32,
        horizontal: bool,
        vertical: bool,
    ) -> *mut cocos2d_CCWaves {
        cocos2d_CCWaves_create(duration, gridSize, waves, amplitude, horizontal, vertical)
    }
}
extern "C" {
    #[doc = "  @js NA"]
    #[doc = "  @lua NA"]
    #[link_name = "\u{1}?copyWithZone@CCWaves@cocos2d@@UEAAPEAVCCObject@2@PEAVCCZone@2@@Z"]
    pub fn cocos2d_CCWaves_copyWithZone(
        this: *mut ::std::os::raw::c_void,
        pZone: *mut cocos2d_CCZone,
    ) -> *mut cocos2d_CCObject;
}
extern "C" {
    #[link_name = "\u{1}?update@CCWaves@cocos2d@@UEAAXM@Z"]
    pub fn cocos2d_CCWaves_update(this: *mut ::std::os::raw::c_void, time: f32);
}
#[doc = " @brief CCTwirl action"]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCTwirl {
    pub _base: cocos2d_CCGrid3DAction,
    pub m_position: cocos2d_CCPoint,
    pub m_nTwirls: ::std::os::raw::c_uint,
    pub m_fAmplitude: f32,
    pub m_fAmplitudeRate: f32,
}
#[test]
fn bindgen_test_layout_cocos2d_CCTwirl() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCTwirl>(),
        112usize,
        concat!("Size of: ", stringify!(cocos2d_CCTwirl))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCTwirl>(),
        8usize,
        concat!("Alignment of ", stringify!(cocos2d_CCTwirl))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cocos2d_CCTwirl>())).m_position as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCTwirl),
            "::",
            stringify!(m_position)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cocos2d_CCTwirl>())).m_nTwirls as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCTwirl),
            "::",
            stringify!(m_nTwirls)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cocos2d_CCTwirl>())).m_fAmplitude as *const _ as usize },
        100usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCTwirl),
            "::",
            stringify!(m_fAmplitude)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cocos2d_CCTwirl>())).m_fAmplitudeRate as *const _ as usize
        },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCTwirl),
            "::",
            stringify!(m_fAmplitudeRate)
        )
    );
}
extern "C" {
    #[doc = " set twirl center"]
    #[link_name = "\u{1}?setPosition@CCTwirl@cocos2d@@QEAAXAEBVCCPoint@2@@Z"]
    pub fn cocos2d_CCTwirl_setPosition(
        this: *mut cocos2d_CCTwirl,
        position: *const cocos2d_CCPoint,
    );
}
extern "C" {
    #[doc = " initializes the action with center position, number of twirls, amplitude, a grid size and duration"]
    #[link_name = "\u{1}?initWithDuration@CCTwirl@cocos2d@@QEAA_NMAEBVCCSize@2@VCCPoint@2@IM@Z"]
    pub fn cocos2d_CCTwirl_initWithDuration(
        this: *mut cocos2d_CCTwirl,
        duration: f32,
        gridSize: *const cocos2d_CCSize,
        position: cocos2d_CCPoint,
        twirls: ::std::os::raw::c_uint,
        amplitude: f32,
    ) -> bool;
}
extern "C" {
    #[doc = " creates the action with center position, number of twirls, amplitude, a grid size and duration"]
    #[link_name = "\u{1}?create@CCTwirl@cocos2d@@SAPEAV12@MAEBVCCSize@2@VCCPoint@2@IM@Z"]
    pub fn cocos2d_CCTwirl_create(
        duration: f32,
        gridSize: *const cocos2d_CCSize,
        position: cocos2d_CCPoint,
        twirls: ::std::os::raw::c_uint,
        amplitude: f32,
    ) -> *mut cocos2d_CCTwirl;
}
impl cocos2d_CCTwirl {
    #[inline]
    pub unsafe fn setPosition(&mut self, position: *const cocos2d_CCPoint) {
        cocos2d_CCTwirl_setPosition(self, position)
    }
    #[inline]
    pub unsafe fn initWithDuration(
        &mut self,
        duration: f32,
        gridSize: *const cocos2d_CCSize,
        position: cocos2d_CCPoint,
        twirls: ::std::os::raw::c_uint,
        amplitude: f32,
    ) -> bool {
        cocos2d_CCTwirl_initWithDuration(self, duration, gridSize, position, twirls, amplitude)
    }
    #[inline]
    pub unsafe fn create(
        duration: f32,
        gridSize: *const cocos2d_CCSize,
        position: cocos2d_CCPoint,
        twirls: ::std::os::raw::c_uint,
        amplitude: f32,
    ) -> *mut cocos2d_CCTwirl {
        cocos2d_CCTwirl_create(duration, gridSize, position, twirls, amplitude)
    }
}
extern "C" {
    #[doc = "  @js NA"]
    #[doc = "  @lua NA"]
    #[link_name = "\u{1}?copyWithZone@CCTwirl@cocos2d@@UEAAPEAVCCObject@2@PEAVCCZone@2@@Z"]
    pub fn cocos2d_CCTwirl_copyWithZone(
        this: *mut ::std::os::raw::c_void,
        pZone: *mut cocos2d_CCZone,
    ) -> *mut cocos2d_CCObject;
}
extern "C" {
    #[link_name = "\u{1}?update@CCTwirl@cocos2d@@UEAAXM@Z"]
    pub fn cocos2d_CCTwirl_update(this: *mut ::std::os::raw::c_void, time: f32);
}
#[doc = "@brief This action simulates a page turn from the bottom right hand corner of the screen."]
#[doc = "It's not much use by itself but is used by the PageTurnTransition."]
#[doc = ""]
#[doc = "Based on an original paper by L Hong et al."]
#[doc = "http://www.parc.com/publication/1638/turning-pages-of-3d-electronic-books.html"]
#[doc = ""]
#[doc = "@since v0.8.2"]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCPageTurn3D {
    pub _base: cocos2d_CCGrid3DAction,
}
#[test]
fn bindgen_test_layout_cocos2d_CCPageTurn3D() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCPageTurn3D>(),
        88usize,
        concat!("Size of: ", stringify!(cocos2d_CCPageTurn3D))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCPageTurn3D>(),
        8usize,
        concat!("Alignment of ", stringify!(cocos2d_CCPageTurn3D))
    );
}
extern "C" {
    #[doc = " create the action"]
    #[link_name = "\u{1}?create@CCPageTurn3D@cocos2d@@SAPEAV12@MAEBVCCSize@2@@Z"]
    pub fn cocos2d_CCPageTurn3D_create(
        duration: f32,
        gridSize: *const cocos2d_CCSize,
    ) -> *mut cocos2d_CCPageTurn3D;
}
impl cocos2d_CCPageTurn3D {
    #[inline]
    pub unsafe fn create(
        duration: f32,
        gridSize: *const cocos2d_CCSize,
    ) -> *mut cocos2d_CCPageTurn3D {
        cocos2d_CCPageTurn3D_create(duration, gridSize)
    }
}
extern "C" {
    #[link_name = "\u{1}?update@CCPageTurn3D@cocos2d@@UEAAXM@Z"]
    pub fn cocos2d_CCPageTurn3D_update(this: *mut ::std::os::raw::c_void, time: f32);
}
#[doc = "@brief Progress to percentage"]
#[doc = "@since v0.99.1"]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCProgressTo {
    pub _base: cocos2d_CCActionInterval,
    pub m_fTo: f32,
    pub m_fFrom: f32,
}
#[test]
fn bindgen_test_layout_cocos2d_CCProgressTo() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCProgressTo>(),
        88usize,
        concat!("Size of: ", stringify!(cocos2d_CCProgressTo))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCProgressTo>(),
        8usize,
        concat!("Alignment of ", stringify!(cocos2d_CCProgressTo))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cocos2d_CCProgressTo>())).m_fTo as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCProgressTo),
            "::",
            stringify!(m_fTo)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cocos2d_CCProgressTo>())).m_fFrom as *const _ as usize },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCProgressTo),
            "::",
            stringify!(m_fFrom)
        )
    );
}
extern "C" {
    #[doc = " Initializes with a duration and a percent"]
    #[link_name = "\u{1}?initWithDuration@CCProgressTo@cocos2d@@QEAA_NMM@Z"]
    pub fn cocos2d_CCProgressTo_initWithDuration(
        this: *mut cocos2d_CCProgressTo,
        duration: f32,
        fPercent: f32,
    ) -> bool;
}
extern "C" {
    #[doc = " Creates and initializes with a duration and a percent"]
    #[link_name = "\u{1}?create@CCProgressTo@cocos2d@@SAPEAV12@MM@Z"]
    pub fn cocos2d_CCProgressTo_create(duration: f32, fPercent: f32) -> *mut cocos2d_CCProgressTo;
}
impl cocos2d_CCProgressTo {
    #[inline]
    pub unsafe fn initWithDuration(&mut self, duration: f32, fPercent: f32) -> bool {
        cocos2d_CCProgressTo_initWithDuration(self, duration, fPercent)
    }
    #[inline]
    pub unsafe fn create(duration: f32, fPercent: f32) -> *mut cocos2d_CCProgressTo {
        cocos2d_CCProgressTo_create(duration, fPercent)
    }
}
extern "C" {
    #[doc = "  @js NA"]
    #[doc = "  @lua NA"]
    #[link_name = "\u{1}?copyWithZone@CCProgressTo@cocos2d@@UEAAPEAVCCObject@2@PEAVCCZone@2@@Z"]
    pub fn cocos2d_CCProgressTo_copyWithZone(
        this: *mut ::std::os::raw::c_void,
        pZone: *mut cocos2d_CCZone,
    ) -> *mut cocos2d_CCObject;
}
extern "C" {
    #[link_name = "\u{1}?startWithTarget@CCProgressTo@cocos2d@@UEAAXPEAVCCNode@2@@Z"]
    pub fn cocos2d_CCProgressTo_startWithTarget(
        this: *mut ::std::os::raw::c_void,
        pTarget: *mut cocos2d_CCNode,
    );
}
extern "C" {
    #[link_name = "\u{1}?update@CCProgressTo@cocos2d@@UEAAXM@Z"]
    pub fn cocos2d_CCProgressTo_update(this: *mut ::std::os::raw::c_void, time: f32);
}
#[doc = "@brief Progress from a percentage to another percentage"]
#[doc = "@since v0.99.1"]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCProgressFromTo {
    pub _base: cocos2d_CCActionInterval,
    pub m_fTo: f32,
    pub m_fFrom: f32,
}
#[test]
fn bindgen_test_layout_cocos2d_CCProgressFromTo() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCProgressFromTo>(),
        88usize,
        concat!("Size of: ", stringify!(cocos2d_CCProgressFromTo))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCProgressFromTo>(),
        8usize,
        concat!("Alignment of ", stringify!(cocos2d_CCProgressFromTo))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cocos2d_CCProgressFromTo>())).m_fTo as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCProgressFromTo),
            "::",
            stringify!(m_fTo)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cocos2d_CCProgressFromTo>())).m_fFrom as *const _ as usize
        },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCProgressFromTo),
            "::",
            stringify!(m_fFrom)
        )
    );
}
extern "C" {
    #[doc = " Initializes the action with a duration, a \"from\" percentage and a \"to\" percentage"]
    #[link_name = "\u{1}?initWithDuration@CCProgressFromTo@cocos2d@@QEAA_NMMM@Z"]
    pub fn cocos2d_CCProgressFromTo_initWithDuration(
        this: *mut cocos2d_CCProgressFromTo,
        duration: f32,
        fFromPercentage: f32,
        fToPercentage: f32,
    ) -> bool;
}
extern "C" {
    #[doc = " Creates and initializes the action with a duration, a \"from\" percentage and a \"to\" percentage"]
    #[link_name = "\u{1}?create@CCProgressFromTo@cocos2d@@SAPEAV12@MMM@Z"]
    pub fn cocos2d_CCProgressFromTo_create(
        duration: f32,
        fFromPercentage: f32,
        fToPercentage: f32,
    ) -> *mut cocos2d_CCProgressFromTo;
}
impl cocos2d_CCProgressFromTo {
    #[inline]
    pub unsafe fn initWithDuration(
        &mut self,
        duration: f32,
        fFromPercentage: f32,
        fToPercentage: f32,
    ) -> bool {
        cocos2d_CCProgressFromTo_initWithDuration(self, duration, fFromPercentage, fToPercentage)
    }
    #[inline]
    pub unsafe fn create(
        duration: f32,
        fFromPercentage: f32,
        fToPercentage: f32,
    ) -> *mut cocos2d_CCProgressFromTo {
        cocos2d_CCProgressFromTo_create(duration, fFromPercentage, fToPercentage)
    }
}
extern "C" {
    #[doc = "  @js NA"]
    #[doc = "  @lua NA"]
    #[link_name = "\u{1}?copyWithZone@CCProgressFromTo@cocos2d@@UEAAPEAVCCObject@2@PEAVCCZone@2@@Z"]
    pub fn cocos2d_CCProgressFromTo_copyWithZone(
        this: *mut ::std::os::raw::c_void,
        pZone: *mut cocos2d_CCZone,
    ) -> *mut cocos2d_CCObject;
}
extern "C" {
    #[link_name = "\u{1}?reverse@CCProgressFromTo@cocos2d@@UEAAPEAVCCActionInterval@2@XZ"]
    pub fn cocos2d_CCProgressFromTo_reverse(
        this: *mut ::std::os::raw::c_void,
    ) -> *mut cocos2d_CCActionInterval;
}
extern "C" {
    #[link_name = "\u{1}?startWithTarget@CCProgressFromTo@cocos2d@@UEAAXPEAVCCNode@2@@Z"]
    pub fn cocos2d_CCProgressFromTo_startWithTarget(
        this: *mut ::std::os::raw::c_void,
        pTarget: *mut cocos2d_CCNode,
    );
}
extern "C" {
    #[link_name = "\u{1}?update@CCProgressFromTo@cocos2d@@UEAAXM@Z"]
    pub fn cocos2d_CCProgressFromTo_update(this: *mut ::std::os::raw::c_void, time: f32);
}
#[doc = " @brief CCShakyTiles3D action"]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCShakyTiles3D {
    pub _base: cocos2d_CCTiledGrid3DAction,
    pub m_nRandrange: ::std::os::raw::c_int,
    pub m_bShakeZ: bool,
}
#[test]
fn bindgen_test_layout_cocos2d_CCShakyTiles3D() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCShakyTiles3D>(),
        96usize,
        concat!("Size of: ", stringify!(cocos2d_CCShakyTiles3D))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCShakyTiles3D>(),
        8usize,
        concat!("Alignment of ", stringify!(cocos2d_CCShakyTiles3D))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cocos2d_CCShakyTiles3D>())).m_nRandrange as *const _ as usize
        },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCShakyTiles3D),
            "::",
            stringify!(m_nRandrange)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cocos2d_CCShakyTiles3D>())).m_bShakeZ as *const _ as usize
        },
        92usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCShakyTiles3D),
            "::",
            stringify!(m_bShakeZ)
        )
    );
}
extern "C" {
    #[doc = " creates the action with a range, whether or not to shake Z vertices, a grid size, and duration"]
    #[link_name = "\u{1}?create@CCShakyTiles3D@cocos2d@@SAPEAV12@MAEBVCCSize@2@H_N@Z"]
    pub fn cocos2d_CCShakyTiles3D_create(
        duration: f32,
        gridSize: *const cocos2d_CCSize,
        nRange: ::std::os::raw::c_int,
        bShakeZ: bool,
    ) -> *mut cocos2d_CCShakyTiles3D;
}
impl cocos2d_CCShakyTiles3D {
    #[inline]
    pub unsafe fn create(
        duration: f32,
        gridSize: *const cocos2d_CCSize,
        nRange: ::std::os::raw::c_int,
        bShakeZ: bool,
    ) -> *mut cocos2d_CCShakyTiles3D {
        cocos2d_CCShakyTiles3D_create(duration, gridSize, nRange, bShakeZ)
    }
}
extern "C" {
    #[doc = " initializes the action with a range, whether or not to shake Z vertices, a grid size, and duration"]
    #[link_name = "\u{1}?initWithDuration@CCShakyTiles3D@cocos2d@@UEAA_NMAEBVCCSize@2@H_N@Z"]
    pub fn cocos2d_CCShakyTiles3D_initWithDuration(
        this: *mut ::std::os::raw::c_void,
        duration: f32,
        gridSize: *const cocos2d_CCSize,
        nRange: ::std::os::raw::c_int,
        bShakeZ: bool,
    ) -> bool;
}
extern "C" {
    #[doc = "  @js NA"]
    #[doc = "  @lua NA"]
    #[link_name = "\u{1}?copyWithZone@CCShakyTiles3D@cocos2d@@UEAAPEAVCCObject@2@PEAVCCZone@2@@Z"]
    pub fn cocos2d_CCShakyTiles3D_copyWithZone(
        this: *mut ::std::os::raw::c_void,
        pZone: *mut cocos2d_CCZone,
    ) -> *mut cocos2d_CCObject;
}
extern "C" {
    #[link_name = "\u{1}?update@CCShakyTiles3D@cocos2d@@UEAAXM@Z"]
    pub fn cocos2d_CCShakyTiles3D_update(this: *mut ::std::os::raw::c_void, time: f32);
}
#[doc = " @brief CCShatteredTiles3D action"]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCShatteredTiles3D {
    pub _base: cocos2d_CCTiledGrid3DAction,
    pub m_nRandrange: ::std::os::raw::c_int,
    pub m_bOnce: bool,
    pub m_bShatterZ: bool,
}
#[test]
fn bindgen_test_layout_cocos2d_CCShatteredTiles3D() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCShatteredTiles3D>(),
        96usize,
        concat!("Size of: ", stringify!(cocos2d_CCShatteredTiles3D))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCShatteredTiles3D>(),
        8usize,
        concat!("Alignment of ", stringify!(cocos2d_CCShatteredTiles3D))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cocos2d_CCShatteredTiles3D>())).m_nRandrange as *const _ as usize
        },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCShatteredTiles3D),
            "::",
            stringify!(m_nRandrange)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cocos2d_CCShatteredTiles3D>())).m_bOnce as *const _ as usize
        },
        92usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCShatteredTiles3D),
            "::",
            stringify!(m_bOnce)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cocos2d_CCShatteredTiles3D>())).m_bShatterZ as *const _ as usize
        },
        93usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCShatteredTiles3D),
            "::",
            stringify!(m_bShatterZ)
        )
    );
}
extern "C" {
    #[doc = " creates the action with a range, whether of not to shatter Z vertices, a grid size and duration"]
    #[link_name = "\u{1}?create@CCShatteredTiles3D@cocos2d@@SAPEAV12@MAEBVCCSize@2@H_N@Z"]
    pub fn cocos2d_CCShatteredTiles3D_create(
        duration: f32,
        gridSize: *const cocos2d_CCSize,
        nRange: ::std::os::raw::c_int,
        bShatterZ: bool,
    ) -> *mut cocos2d_CCShatteredTiles3D;
}
impl cocos2d_CCShatteredTiles3D {
    #[inline]
    pub unsafe fn create(
        duration: f32,
        gridSize: *const cocos2d_CCSize,
        nRange: ::std::os::raw::c_int,
        bShatterZ: bool,
    ) -> *mut cocos2d_CCShatteredTiles3D {
        cocos2d_CCShatteredTiles3D_create(duration, gridSize, nRange, bShatterZ)
    }
}
extern "C" {
    #[doc = " initializes the action with a range, whether or not to shatter Z vertices, a grid size and duration"]
    #[link_name = "\u{1}?initWithDuration@CCShatteredTiles3D@cocos2d@@UEAA_NMAEBVCCSize@2@H_N@Z"]
    pub fn cocos2d_CCShatteredTiles3D_initWithDuration(
        this: *mut ::std::os::raw::c_void,
        duration: f32,
        gridSize: *const cocos2d_CCSize,
        nRange: ::std::os::raw::c_int,
        bShatterZ: bool,
    ) -> bool;
}
extern "C" {
    #[doc = "  @js NA"]
    #[doc = "  @lua NA"]
    #[link_name = "\u{1}?copyWithZone@CCShatteredTiles3D@cocos2d@@UEAAPEAVCCObject@2@PEAVCCZone@2@@Z"]
    pub fn cocos2d_CCShatteredTiles3D_copyWithZone(
        this: *mut ::std::os::raw::c_void,
        pZone: *mut cocos2d_CCZone,
    ) -> *mut cocos2d_CCObject;
}
extern "C" {
    #[link_name = "\u{1}?update@CCShatteredTiles3D@cocos2d@@UEAAXM@Z"]
    pub fn cocos2d_CCShatteredTiles3D_update(this: *mut ::std::os::raw::c_void, time: f32);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cocos2d_Tile {
    _unused: [u8; 0],
}
#[doc = " @brief CCShuffleTiles action"]
#[doc = "Shuffle the tiles in random order"]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCShuffleTiles {
    pub _base: cocos2d_CCTiledGrid3DAction,
    pub m_nSeed: ::std::os::raw::c_uint,
    pub m_nTilesCount: ::std::os::raw::c_uint,
    pub m_pTilesOrder: *mut ::std::os::raw::c_uint,
    pub m_pTiles: *mut cocos2d_Tile,
}
#[test]
fn bindgen_test_layout_cocos2d_CCShuffleTiles() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCShuffleTiles>(),
        112usize,
        concat!("Size of: ", stringify!(cocos2d_CCShuffleTiles))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCShuffleTiles>(),
        8usize,
        concat!("Alignment of ", stringify!(cocos2d_CCShuffleTiles))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cocos2d_CCShuffleTiles>())).m_nSeed as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCShuffleTiles),
            "::",
            stringify!(m_nSeed)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cocos2d_CCShuffleTiles>())).m_nTilesCount as *const _ as usize
        },
        92usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCShuffleTiles),
            "::",
            stringify!(m_nTilesCount)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cocos2d_CCShuffleTiles>())).m_pTilesOrder as *const _ as usize
        },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCShuffleTiles),
            "::",
            stringify!(m_pTilesOrder)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cocos2d_CCShuffleTiles>())).m_pTiles as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCShuffleTiles),
            "::",
            stringify!(m_pTiles)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}?shuffle@CCShuffleTiles@cocos2d@@QEAAXPEAII@Z"]
    pub fn cocos2d_CCShuffleTiles_shuffle(
        this: *mut cocos2d_CCShuffleTiles,
        pArray: *mut ::std::os::raw::c_uint,
        nLen: ::std::os::raw::c_uint,
    );
}
extern "C" {
    #[link_name = "\u{1}?getDelta@CCShuffleTiles@cocos2d@@QEAA?AVCCSize@2@AEBV32@@Z"]
    pub fn cocos2d_CCShuffleTiles_getDelta(
        this: *mut cocos2d_CCShuffleTiles,
        pos: *const cocos2d_CCSize,
    ) -> cocos2d_CCSize;
}
extern "C" {
    #[link_name = "\u{1}?placeTile@CCShuffleTiles@cocos2d@@QEAAXAEBVCCPoint@2@PEAUTile@2@@Z"]
    pub fn cocos2d_CCShuffleTiles_placeTile(
        this: *mut cocos2d_CCShuffleTiles,
        pos: *const cocos2d_CCPoint,
        t: *mut cocos2d_Tile,
    );
}
extern "C" {
    #[doc = " creates the action with a random seed, the grid size and the duration"]
    #[link_name = "\u{1}?create@CCShuffleTiles@cocos2d@@SAPEAV12@MAEBVCCSize@2@I@Z"]
    pub fn cocos2d_CCShuffleTiles_create(
        duration: f32,
        gridSize: *const cocos2d_CCSize,
        seed: ::std::os::raw::c_uint,
    ) -> *mut cocos2d_CCShuffleTiles;
}
impl cocos2d_CCShuffleTiles {
    #[inline]
    pub unsafe fn shuffle(
        &mut self,
        pArray: *mut ::std::os::raw::c_uint,
        nLen: ::std::os::raw::c_uint,
    ) {
        cocos2d_CCShuffleTiles_shuffle(self, pArray, nLen)
    }
    #[inline]
    pub unsafe fn getDelta(&mut self, pos: *const cocos2d_CCSize) -> cocos2d_CCSize {
        cocos2d_CCShuffleTiles_getDelta(self, pos)
    }
    #[inline]
    pub unsafe fn placeTile(&mut self, pos: *const cocos2d_CCPoint, t: *mut cocos2d_Tile) {
        cocos2d_CCShuffleTiles_placeTile(self, pos, t)
    }
    #[inline]
    pub unsafe fn create(
        duration: f32,
        gridSize: *const cocos2d_CCSize,
        seed: ::std::os::raw::c_uint,
    ) -> *mut cocos2d_CCShuffleTiles {
        cocos2d_CCShuffleTiles_create(duration, gridSize, seed)
    }
}
extern "C" {
    #[doc = "  @js NA"]
    #[doc = "  @lua NA"]
    #[link_name = "\u{1}??_DCCShuffleTiles@cocos2d@@QEAAXXZ"]
    pub fn cocos2d_CCShuffleTiles_CCShuffleTiles_destructor(this: *mut cocos2d_CCShuffleTiles);
}
extern "C" {
    #[doc = " initializes the action with a random seed, the grid size and the duration"]
    #[link_name = "\u{1}?initWithDuration@CCShuffleTiles@cocos2d@@UEAA_NMAEBVCCSize@2@I@Z"]
    pub fn cocos2d_CCShuffleTiles_initWithDuration(
        this: *mut ::std::os::raw::c_void,
        duration: f32,
        gridSize: *const cocos2d_CCSize,
        seed: ::std::os::raw::c_uint,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}?startWithTarget@CCShuffleTiles@cocos2d@@UEAAXPEAVCCNode@2@@Z"]
    pub fn cocos2d_CCShuffleTiles_startWithTarget(
        this: *mut ::std::os::raw::c_void,
        pTarget: *mut cocos2d_CCNode,
    );
}
extern "C" {
    #[link_name = "\u{1}?update@CCShuffleTiles@cocos2d@@UEAAXM@Z"]
    pub fn cocos2d_CCShuffleTiles_update(this: *mut ::std::os::raw::c_void, time: f32);
}
extern "C" {
    #[doc = "  @js NA"]
    #[doc = "  @lua NA"]
    #[link_name = "\u{1}?copyWithZone@CCShuffleTiles@cocos2d@@UEAAPEAVCCObject@2@PEAVCCZone@2@@Z"]
    pub fn cocos2d_CCShuffleTiles_copyWithZone(
        this: *mut ::std::os::raw::c_void,
        pZone: *mut cocos2d_CCZone,
    ) -> *mut cocos2d_CCObject;
}
#[doc = " @brief CCFadeOutTRTiles action"]
#[doc = "Fades out the tiles in a Top-Right direction"]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCFadeOutTRTiles {
    pub _base: cocos2d_CCTiledGrid3DAction,
}
#[test]
fn bindgen_test_layout_cocos2d_CCFadeOutTRTiles() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCFadeOutTRTiles>(),
        88usize,
        concat!("Size of: ", stringify!(cocos2d_CCFadeOutTRTiles))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCFadeOutTRTiles>(),
        8usize,
        concat!("Alignment of ", stringify!(cocos2d_CCFadeOutTRTiles))
    );
}
extern "C" {
    #[link_name = "\u{1}?turnOnTile@CCFadeOutTRTiles@cocos2d@@QEAAXAEBVCCPoint@2@@Z"]
    pub fn cocos2d_CCFadeOutTRTiles_turnOnTile(
        this: *mut cocos2d_CCFadeOutTRTiles,
        pos: *const cocos2d_CCPoint,
    );
}
extern "C" {
    #[link_name = "\u{1}?turnOffTile@CCFadeOutTRTiles@cocos2d@@QEAAXAEBVCCPoint@2@@Z"]
    pub fn cocos2d_CCFadeOutTRTiles_turnOffTile(
        this: *mut cocos2d_CCFadeOutTRTiles,
        pos: *const cocos2d_CCPoint,
    );
}
extern "C" {
    #[doc = " creates the action with the grid size and the duration"]
    #[link_name = "\u{1}?create@CCFadeOutTRTiles@cocos2d@@SAPEAV12@MAEBVCCSize@2@@Z"]
    pub fn cocos2d_CCFadeOutTRTiles_create(
        duration: f32,
        gridSize: *const cocos2d_CCSize,
    ) -> *mut cocos2d_CCFadeOutTRTiles;
}
impl cocos2d_CCFadeOutTRTiles {
    #[inline]
    pub unsafe fn turnOnTile(&mut self, pos: *const cocos2d_CCPoint) {
        cocos2d_CCFadeOutTRTiles_turnOnTile(self, pos)
    }
    #[inline]
    pub unsafe fn turnOffTile(&mut self, pos: *const cocos2d_CCPoint) {
        cocos2d_CCFadeOutTRTiles_turnOffTile(self, pos)
    }
    #[inline]
    pub unsafe fn create(
        duration: f32,
        gridSize: *const cocos2d_CCSize,
    ) -> *mut cocos2d_CCFadeOutTRTiles {
        cocos2d_CCFadeOutTRTiles_create(duration, gridSize)
    }
}
extern "C" {
    #[link_name = "\u{1}?testFunc@CCFadeOutTRTiles@cocos2d@@UEAAMAEBVCCSize@2@M@Z"]
    pub fn cocos2d_CCFadeOutTRTiles_testFunc(
        this: *mut ::std::os::raw::c_void,
        pos: *const cocos2d_CCSize,
        time: f32,
    ) -> f32;
}
extern "C" {
    #[link_name = "\u{1}?transformTile@CCFadeOutTRTiles@cocos2d@@UEAAXAEBVCCPoint@2@M@Z"]
    pub fn cocos2d_CCFadeOutTRTiles_transformTile(
        this: *mut ::std::os::raw::c_void,
        pos: *const cocos2d_CCPoint,
        distance: f32,
    );
}
extern "C" {
    #[link_name = "\u{1}?update@CCFadeOutTRTiles@cocos2d@@UEAAXM@Z"]
    pub fn cocos2d_CCFadeOutTRTiles_update(this: *mut ::std::os::raw::c_void, time: f32);
}
#[doc = " @brief CCFadeOutBLTiles action."]
#[doc = "Fades out the tiles in a Bottom-Left direction"]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCFadeOutBLTiles {
    pub _base: cocos2d_CCFadeOutTRTiles,
}
#[test]
fn bindgen_test_layout_cocos2d_CCFadeOutBLTiles() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCFadeOutBLTiles>(),
        88usize,
        concat!("Size of: ", stringify!(cocos2d_CCFadeOutBLTiles))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCFadeOutBLTiles>(),
        8usize,
        concat!("Alignment of ", stringify!(cocos2d_CCFadeOutBLTiles))
    );
}
extern "C" {
    #[doc = " creates the action with the grid size and the duration"]
    #[link_name = "\u{1}?create@CCFadeOutBLTiles@cocos2d@@SAPEAV12@MAEBVCCSize@2@@Z"]
    pub fn cocos2d_CCFadeOutBLTiles_create(
        duration: f32,
        gridSize: *const cocos2d_CCSize,
    ) -> *mut cocos2d_CCFadeOutBLTiles;
}
impl cocos2d_CCFadeOutBLTiles {
    #[inline]
    pub unsafe fn create(
        duration: f32,
        gridSize: *const cocos2d_CCSize,
    ) -> *mut cocos2d_CCFadeOutBLTiles {
        cocos2d_CCFadeOutBLTiles_create(duration, gridSize)
    }
}
extern "C" {
    #[link_name = "\u{1}?testFunc@CCFadeOutBLTiles@cocos2d@@UEAAMAEBVCCSize@2@M@Z"]
    pub fn cocos2d_CCFadeOutBLTiles_testFunc(
        this: *mut ::std::os::raw::c_void,
        pos: *const cocos2d_CCSize,
        time: f32,
    ) -> f32;
}
#[doc = " @brief CCFadeOutUpTiles action."]
#[doc = "Fades out the tiles in upwards direction"]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCFadeOutUpTiles {
    pub _base: cocos2d_CCFadeOutTRTiles,
}
#[test]
fn bindgen_test_layout_cocos2d_CCFadeOutUpTiles() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCFadeOutUpTiles>(),
        88usize,
        concat!("Size of: ", stringify!(cocos2d_CCFadeOutUpTiles))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCFadeOutUpTiles>(),
        8usize,
        concat!("Alignment of ", stringify!(cocos2d_CCFadeOutUpTiles))
    );
}
extern "C" {
    #[doc = " creates the action with the grid size and the duration"]
    #[link_name = "\u{1}?create@CCFadeOutUpTiles@cocos2d@@SAPEAV12@MAEBVCCSize@2@@Z"]
    pub fn cocos2d_CCFadeOutUpTiles_create(
        duration: f32,
        gridSize: *const cocos2d_CCSize,
    ) -> *mut cocos2d_CCFadeOutUpTiles;
}
impl cocos2d_CCFadeOutUpTiles {
    #[inline]
    pub unsafe fn create(
        duration: f32,
        gridSize: *const cocos2d_CCSize,
    ) -> *mut cocos2d_CCFadeOutUpTiles {
        cocos2d_CCFadeOutUpTiles_create(duration, gridSize)
    }
}
extern "C" {
    #[link_name = "\u{1}?testFunc@CCFadeOutUpTiles@cocos2d@@UEAAMAEBVCCSize@2@M@Z"]
    pub fn cocos2d_CCFadeOutUpTiles_testFunc(
        this: *mut ::std::os::raw::c_void,
        pos: *const cocos2d_CCSize,
        time: f32,
    ) -> f32;
}
extern "C" {
    #[link_name = "\u{1}?transformTile@CCFadeOutUpTiles@cocos2d@@UEAAXAEBVCCPoint@2@M@Z"]
    pub fn cocos2d_CCFadeOutUpTiles_transformTile(
        this: *mut ::std::os::raw::c_void,
        pos: *const cocos2d_CCPoint,
        distance: f32,
    );
}
#[doc = " @brief CCFadeOutDownTiles action."]
#[doc = "Fades out the tiles in downwards direction"]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCFadeOutDownTiles {
    pub _base: cocos2d_CCFadeOutUpTiles,
}
#[test]
fn bindgen_test_layout_cocos2d_CCFadeOutDownTiles() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCFadeOutDownTiles>(),
        88usize,
        concat!("Size of: ", stringify!(cocos2d_CCFadeOutDownTiles))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCFadeOutDownTiles>(),
        8usize,
        concat!("Alignment of ", stringify!(cocos2d_CCFadeOutDownTiles))
    );
}
extern "C" {
    #[doc = " creates the action with the grid size and the duration"]
    #[link_name = "\u{1}?create@CCFadeOutDownTiles@cocos2d@@SAPEAV12@MAEBVCCSize@2@@Z"]
    pub fn cocos2d_CCFadeOutDownTiles_create(
        duration: f32,
        gridSize: *const cocos2d_CCSize,
    ) -> *mut cocos2d_CCFadeOutDownTiles;
}
impl cocos2d_CCFadeOutDownTiles {
    #[inline]
    pub unsafe fn create(
        duration: f32,
        gridSize: *const cocos2d_CCSize,
    ) -> *mut cocos2d_CCFadeOutDownTiles {
        cocos2d_CCFadeOutDownTiles_create(duration, gridSize)
    }
}
extern "C" {
    #[link_name = "\u{1}?testFunc@CCFadeOutDownTiles@cocos2d@@UEAAMAEBVCCSize@2@M@Z"]
    pub fn cocos2d_CCFadeOutDownTiles_testFunc(
        this: *mut ::std::os::raw::c_void,
        pos: *const cocos2d_CCSize,
        time: f32,
    ) -> f32;
}
#[doc = " @brief CCTurnOffTiles action."]
#[doc = "Turn off the files in random order"]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCTurnOffTiles {
    pub _base: cocos2d_CCTiledGrid3DAction,
    pub m_nSeed: ::std::os::raw::c_uint,
    pub m_nTilesCount: ::std::os::raw::c_uint,
    pub m_pTilesOrder: *mut ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_cocos2d_CCTurnOffTiles() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCTurnOffTiles>(),
        104usize,
        concat!("Size of: ", stringify!(cocos2d_CCTurnOffTiles))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCTurnOffTiles>(),
        8usize,
        concat!("Alignment of ", stringify!(cocos2d_CCTurnOffTiles))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cocos2d_CCTurnOffTiles>())).m_nSeed as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCTurnOffTiles),
            "::",
            stringify!(m_nSeed)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cocos2d_CCTurnOffTiles>())).m_nTilesCount as *const _ as usize
        },
        92usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCTurnOffTiles),
            "::",
            stringify!(m_nTilesCount)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cocos2d_CCTurnOffTiles>())).m_pTilesOrder as *const _ as usize
        },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCTurnOffTiles),
            "::",
            stringify!(m_pTilesOrder)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}?shuffle@CCTurnOffTiles@cocos2d@@QEAAXPEAII@Z"]
    pub fn cocos2d_CCTurnOffTiles_shuffle(
        this: *mut cocos2d_CCTurnOffTiles,
        pArray: *mut ::std::os::raw::c_uint,
        nLen: ::std::os::raw::c_uint,
    );
}
extern "C" {
    #[link_name = "\u{1}?turnOnTile@CCTurnOffTiles@cocos2d@@QEAAXAEBVCCPoint@2@@Z"]
    pub fn cocos2d_CCTurnOffTiles_turnOnTile(
        this: *mut cocos2d_CCTurnOffTiles,
        pos: *const cocos2d_CCPoint,
    );
}
extern "C" {
    #[link_name = "\u{1}?turnOffTile@CCTurnOffTiles@cocos2d@@QEAAXAEBVCCPoint@2@@Z"]
    pub fn cocos2d_CCTurnOffTiles_turnOffTile(
        this: *mut cocos2d_CCTurnOffTiles,
        pos: *const cocos2d_CCPoint,
    );
}
extern "C" {
    #[doc = " creates the action with the grid size and the duration"]
    #[link_name = "\u{1}?create@CCTurnOffTiles@cocos2d@@SAPEAV12@MAEBVCCSize@2@@Z"]
    pub fn cocos2d_CCTurnOffTiles_create(
        duration: f32,
        gridSize: *const cocos2d_CCSize,
    ) -> *mut cocos2d_CCTurnOffTiles;
}
extern "C" {
    #[doc = " creates the action with a random seed, the grid size and the duration"]
    #[link_name = "\u{1}?create@CCTurnOffTiles@cocos2d@@SAPEAV12@MAEBVCCSize@2@I@Z"]
    pub fn cocos2d_CCTurnOffTiles_create1(
        duration: f32,
        gridSize: *const cocos2d_CCSize,
        seed: ::std::os::raw::c_uint,
    ) -> *mut cocos2d_CCTurnOffTiles;
}
impl cocos2d_CCTurnOffTiles {
    #[inline]
    pub unsafe fn shuffle(
        &mut self,
        pArray: *mut ::std::os::raw::c_uint,
        nLen: ::std::os::raw::c_uint,
    ) {
        cocos2d_CCTurnOffTiles_shuffle(self, pArray, nLen)
    }
    #[inline]
    pub unsafe fn turnOnTile(&mut self, pos: *const cocos2d_CCPoint) {
        cocos2d_CCTurnOffTiles_turnOnTile(self, pos)
    }
    #[inline]
    pub unsafe fn turnOffTile(&mut self, pos: *const cocos2d_CCPoint) {
        cocos2d_CCTurnOffTiles_turnOffTile(self, pos)
    }
    #[inline]
    pub unsafe fn create(
        duration: f32,
        gridSize: *const cocos2d_CCSize,
    ) -> *mut cocos2d_CCTurnOffTiles {
        cocos2d_CCTurnOffTiles_create(duration, gridSize)
    }
    #[inline]
    pub unsafe fn create1(
        duration: f32,
        gridSize: *const cocos2d_CCSize,
        seed: ::std::os::raw::c_uint,
    ) -> *mut cocos2d_CCTurnOffTiles {
        cocos2d_CCTurnOffTiles_create1(duration, gridSize, seed)
    }
}
extern "C" {
    #[doc = "  @js NA"]
    #[doc = "  @lua NA"]
    #[link_name = "\u{1}??_DCCTurnOffTiles@cocos2d@@QEAAXXZ"]
    pub fn cocos2d_CCTurnOffTiles_CCTurnOffTiles_destructor(this: *mut cocos2d_CCTurnOffTiles);
}
extern "C" {
    #[doc = " initializes the action with a random seed, the grid size and the duration"]
    #[link_name = "\u{1}?initWithDuration@CCTurnOffTiles@cocos2d@@UEAA_NMAEBVCCSize@2@I@Z"]
    pub fn cocos2d_CCTurnOffTiles_initWithDuration(
        this: *mut ::std::os::raw::c_void,
        duration: f32,
        gridSize: *const cocos2d_CCSize,
        seed: ::std::os::raw::c_uint,
    ) -> bool;
}
extern "C" {
    #[doc = "  @js NA"]
    #[doc = "  @lua NA"]
    #[link_name = "\u{1}?copyWithZone@CCTurnOffTiles@cocos2d@@UEAAPEAVCCObject@2@PEAVCCZone@2@@Z"]
    pub fn cocos2d_CCTurnOffTiles_copyWithZone(
        this: *mut ::std::os::raw::c_void,
        pZone: *mut cocos2d_CCZone,
    ) -> *mut cocos2d_CCObject;
}
extern "C" {
    #[link_name = "\u{1}?startWithTarget@CCTurnOffTiles@cocos2d@@UEAAXPEAVCCNode@2@@Z"]
    pub fn cocos2d_CCTurnOffTiles_startWithTarget(
        this: *mut ::std::os::raw::c_void,
        pTarget: *mut cocos2d_CCNode,
    );
}
extern "C" {
    #[link_name = "\u{1}?update@CCTurnOffTiles@cocos2d@@UEAAXM@Z"]
    pub fn cocos2d_CCTurnOffTiles_update(this: *mut ::std::os::raw::c_void, time: f32);
}
#[doc = " @brief CCWavesTiles3D action."]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCWavesTiles3D {
    pub _base: cocos2d_CCTiledGrid3DAction,
    pub m_nWaves: ::std::os::raw::c_uint,
    pub m_fAmplitude: f32,
    pub m_fAmplitudeRate: f32,
}
#[test]
fn bindgen_test_layout_cocos2d_CCWavesTiles3D() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCWavesTiles3D>(),
        104usize,
        concat!("Size of: ", stringify!(cocos2d_CCWavesTiles3D))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCWavesTiles3D>(),
        8usize,
        concat!("Alignment of ", stringify!(cocos2d_CCWavesTiles3D))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cocos2d_CCWavesTiles3D>())).m_nWaves as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCWavesTiles3D),
            "::",
            stringify!(m_nWaves)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cocos2d_CCWavesTiles3D>())).m_fAmplitude as *const _ as usize
        },
        92usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCWavesTiles3D),
            "::",
            stringify!(m_fAmplitude)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cocos2d_CCWavesTiles3D>())).m_fAmplitudeRate as *const _ as usize
        },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCWavesTiles3D),
            "::",
            stringify!(m_fAmplitudeRate)
        )
    );
}
extern "C" {
    #[doc = " creates the action with a number of waves, the waves amplitude, the grid size and the duration"]
    #[link_name = "\u{1}?create@CCWavesTiles3D@cocos2d@@SAPEAV12@MAEBVCCSize@2@IM@Z"]
    pub fn cocos2d_CCWavesTiles3D_create(
        duration: f32,
        gridSize: *const cocos2d_CCSize,
        waves: ::std::os::raw::c_uint,
        amplitude: f32,
    ) -> *mut cocos2d_CCWavesTiles3D;
}
impl cocos2d_CCWavesTiles3D {
    #[inline]
    pub unsafe fn create(
        duration: f32,
        gridSize: *const cocos2d_CCSize,
        waves: ::std::os::raw::c_uint,
        amplitude: f32,
    ) -> *mut cocos2d_CCWavesTiles3D {
        cocos2d_CCWavesTiles3D_create(duration, gridSize, waves, amplitude)
    }
}
extern "C" {
    #[doc = " initializes the action with a number of waves, the waves amplitude, the grid size and the duration"]
    #[link_name = "\u{1}?initWithDuration@CCWavesTiles3D@cocos2d@@UEAA_NMAEBVCCSize@2@IM@Z"]
    pub fn cocos2d_CCWavesTiles3D_initWithDuration(
        this: *mut ::std::os::raw::c_void,
        duration: f32,
        gridSize: *const cocos2d_CCSize,
        waves: ::std::os::raw::c_uint,
        amplitude: f32,
    ) -> bool;
}
extern "C" {
    #[doc = "  @js NA"]
    #[doc = "  @lua NA"]
    #[link_name = "\u{1}?copyWithZone@CCWavesTiles3D@cocos2d@@UEAAPEAVCCObject@2@PEAVCCZone@2@@Z"]
    pub fn cocos2d_CCWavesTiles3D_copyWithZone(
        this: *mut ::std::os::raw::c_void,
        pZone: *mut cocos2d_CCZone,
    ) -> *mut cocos2d_CCObject;
}
extern "C" {
    #[link_name = "\u{1}?update@CCWavesTiles3D@cocos2d@@UEAAXM@Z"]
    pub fn cocos2d_CCWavesTiles3D_update(this: *mut ::std::os::raw::c_void, time: f32);
}
#[doc = " @brief CCJumpTiles3D action."]
#[doc = "A sin function is executed to move the tiles across the Z axis"]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCJumpTiles3D {
    pub _base: cocos2d_CCTiledGrid3DAction,
    pub m_nJumps: ::std::os::raw::c_uint,
    pub m_fAmplitude: f32,
    pub m_fAmplitudeRate: f32,
}
#[test]
fn bindgen_test_layout_cocos2d_CCJumpTiles3D() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCJumpTiles3D>(),
        104usize,
        concat!("Size of: ", stringify!(cocos2d_CCJumpTiles3D))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCJumpTiles3D>(),
        8usize,
        concat!("Alignment of ", stringify!(cocos2d_CCJumpTiles3D))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cocos2d_CCJumpTiles3D>())).m_nJumps as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCJumpTiles3D),
            "::",
            stringify!(m_nJumps)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cocos2d_CCJumpTiles3D>())).m_fAmplitude as *const _ as usize
        },
        92usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCJumpTiles3D),
            "::",
            stringify!(m_fAmplitude)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cocos2d_CCJumpTiles3D>())).m_fAmplitudeRate as *const _ as usize
        },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCJumpTiles3D),
            "::",
            stringify!(m_fAmplitudeRate)
        )
    );
}
extern "C" {
    #[doc = " initializes the action with the number of jumps, the sin amplitude, the grid size and the duration"]
    #[link_name = "\u{1}?initWithDuration@CCJumpTiles3D@cocos2d@@QEAA_NMAEBVCCSize@2@IM@Z"]
    pub fn cocos2d_CCJumpTiles3D_initWithDuration(
        this: *mut cocos2d_CCJumpTiles3D,
        duration: f32,
        gridSize: *const cocos2d_CCSize,
        numberOfJumps: ::std::os::raw::c_uint,
        amplitude: f32,
    ) -> bool;
}
extern "C" {
    #[doc = " creates the action with the number of jumps, the sin amplitude, the grid size and the duration"]
    #[link_name = "\u{1}?create@CCJumpTiles3D@cocos2d@@SAPEAV12@MAEBVCCSize@2@IM@Z"]
    pub fn cocos2d_CCJumpTiles3D_create(
        duration: f32,
        gridSize: *const cocos2d_CCSize,
        numberOfJumps: ::std::os::raw::c_uint,
        amplitude: f32,
    ) -> *mut cocos2d_CCJumpTiles3D;
}
impl cocos2d_CCJumpTiles3D {
    #[inline]
    pub unsafe fn initWithDuration(
        &mut self,
        duration: f32,
        gridSize: *const cocos2d_CCSize,
        numberOfJumps: ::std::os::raw::c_uint,
        amplitude: f32,
    ) -> bool {
        cocos2d_CCJumpTiles3D_initWithDuration(self, duration, gridSize, numberOfJumps, amplitude)
    }
    #[inline]
    pub unsafe fn create(
        duration: f32,
        gridSize: *const cocos2d_CCSize,
        numberOfJumps: ::std::os::raw::c_uint,
        amplitude: f32,
    ) -> *mut cocos2d_CCJumpTiles3D {
        cocos2d_CCJumpTiles3D_create(duration, gridSize, numberOfJumps, amplitude)
    }
}
extern "C" {
    #[doc = "  @js NA"]
    #[doc = "  @lua NA"]
    #[link_name = "\u{1}?copyWithZone@CCJumpTiles3D@cocos2d@@UEAAPEAVCCObject@2@PEAVCCZone@2@@Z"]
    pub fn cocos2d_CCJumpTiles3D_copyWithZone(
        this: *mut ::std::os::raw::c_void,
        pZone: *mut cocos2d_CCZone,
    ) -> *mut cocos2d_CCObject;
}
extern "C" {
    #[link_name = "\u{1}?update@CCJumpTiles3D@cocos2d@@UEAAXM@Z"]
    pub fn cocos2d_CCJumpTiles3D_update(this: *mut ::std::os::raw::c_void, time: f32);
}
#[doc = " @brief CCSplitRows action"]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCSplitRows {
    pub _base: cocos2d_CCTiledGrid3DAction,
    pub m_nRows: ::std::os::raw::c_uint,
    pub m_winSize: cocos2d_CCSize,
}
#[test]
fn bindgen_test_layout_cocos2d_CCSplitRows() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCSplitRows>(),
        104usize,
        concat!("Size of: ", stringify!(cocos2d_CCSplitRows))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCSplitRows>(),
        8usize,
        concat!("Alignment of ", stringify!(cocos2d_CCSplitRows))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cocos2d_CCSplitRows>())).m_nRows as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCSplitRows),
            "::",
            stringify!(m_nRows)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cocos2d_CCSplitRows>())).m_winSize as *const _ as usize },
        92usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCSplitRows),
            "::",
            stringify!(m_winSize)
        )
    );
}
extern "C" {
    #[doc = " creates the action with the number of rows to split and the duration"]
    #[link_name = "\u{1}?create@CCSplitRows@cocos2d@@SAPEAV12@MI@Z"]
    pub fn cocos2d_CCSplitRows_create(
        duration: f32,
        nRows: ::std::os::raw::c_uint,
    ) -> *mut cocos2d_CCSplitRows;
}
impl cocos2d_CCSplitRows {
    #[inline]
    pub unsafe fn create(duration: f32, nRows: ::std::os::raw::c_uint) -> *mut cocos2d_CCSplitRows {
        cocos2d_CCSplitRows_create(duration, nRows)
    }
}
extern "C" {
    #[doc = " initializes the action with the number of rows to split and the duration"]
    #[link_name = "\u{1}?initWithDuration@CCSplitRows@cocos2d@@UEAA_NMI@Z"]
    pub fn cocos2d_CCSplitRows_initWithDuration(
        this: *mut ::std::os::raw::c_void,
        duration: f32,
        nRows: ::std::os::raw::c_uint,
    ) -> bool;
}
extern "C" {
    #[doc = "  @js NA"]
    #[doc = "  @lua NA"]
    #[link_name = "\u{1}?copyWithZone@CCSplitRows@cocos2d@@UEAAPEAVCCObject@2@PEAVCCZone@2@@Z"]
    pub fn cocos2d_CCSplitRows_copyWithZone(
        this: *mut ::std::os::raw::c_void,
        pZone: *mut cocos2d_CCZone,
    ) -> *mut cocos2d_CCObject;
}
extern "C" {
    #[link_name = "\u{1}?update@CCSplitRows@cocos2d@@UEAAXM@Z"]
    pub fn cocos2d_CCSplitRows_update(this: *mut ::std::os::raw::c_void, time: f32);
}
extern "C" {
    #[link_name = "\u{1}?startWithTarget@CCSplitRows@cocos2d@@UEAAXPEAVCCNode@2@@Z"]
    pub fn cocos2d_CCSplitRows_startWithTarget(
        this: *mut ::std::os::raw::c_void,
        pTarget: *mut cocos2d_CCNode,
    );
}
#[doc = " @brief CCSplitCols action"]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCSplitCols {
    pub _base: cocos2d_CCTiledGrid3DAction,
    pub m_nCols: ::std::os::raw::c_uint,
    pub m_winSize: cocos2d_CCSize,
}
#[test]
fn bindgen_test_layout_cocos2d_CCSplitCols() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCSplitCols>(),
        104usize,
        concat!("Size of: ", stringify!(cocos2d_CCSplitCols))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCSplitCols>(),
        8usize,
        concat!("Alignment of ", stringify!(cocos2d_CCSplitCols))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cocos2d_CCSplitCols>())).m_nCols as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCSplitCols),
            "::",
            stringify!(m_nCols)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cocos2d_CCSplitCols>())).m_winSize as *const _ as usize },
        92usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCSplitCols),
            "::",
            stringify!(m_winSize)
        )
    );
}
extern "C" {
    #[doc = " creates the action with the number of columns to split and the duration"]
    #[link_name = "\u{1}?create@CCSplitCols@cocos2d@@SAPEAV12@MI@Z"]
    pub fn cocos2d_CCSplitCols_create(
        duration: f32,
        nCols: ::std::os::raw::c_uint,
    ) -> *mut cocos2d_CCSplitCols;
}
impl cocos2d_CCSplitCols {
    #[inline]
    pub unsafe fn create(duration: f32, nCols: ::std::os::raw::c_uint) -> *mut cocos2d_CCSplitCols {
        cocos2d_CCSplitCols_create(duration, nCols)
    }
}
extern "C" {
    #[doc = " initializes the action with the number of columns to split and the duration"]
    #[link_name = "\u{1}?initWithDuration@CCSplitCols@cocos2d@@UEAA_NMI@Z"]
    pub fn cocos2d_CCSplitCols_initWithDuration(
        this: *mut ::std::os::raw::c_void,
        duration: f32,
        nCols: ::std::os::raw::c_uint,
    ) -> bool;
}
extern "C" {
    #[doc = "  @js NA"]
    #[doc = "  @lua NA"]
    #[link_name = "\u{1}?copyWithZone@CCSplitCols@cocos2d@@UEAAPEAVCCObject@2@PEAVCCZone@2@@Z"]
    pub fn cocos2d_CCSplitCols_copyWithZone(
        this: *mut ::std::os::raw::c_void,
        pZone: *mut cocos2d_CCZone,
    ) -> *mut cocos2d_CCObject;
}
extern "C" {
    #[link_name = "\u{1}?update@CCSplitCols@cocos2d@@UEAAXM@Z"]
    pub fn cocos2d_CCSplitCols_update(this: *mut ::std::os::raw::c_void, time: f32);
}
extern "C" {
    #[link_name = "\u{1}?startWithTarget@CCSplitCols@cocos2d@@UEAAXPEAVCCNode@2@@Z"]
    pub fn cocos2d_CCSplitCols_startWithTarget(
        this: *mut ::std::os::raw::c_void,
        pTarget: *mut cocos2d_CCNode,
    );
}
#[repr(C)]
pub struct cocos2d_CCActionTweenDelegate__bindgen_vtable(::std::os::raw::c_void);
#[doc = " @addtogroup actions"]
#[doc = " @{"]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCActionTweenDelegate {
    pub vtable_: *const cocos2d_CCActionTweenDelegate__bindgen_vtable,
}
#[test]
fn bindgen_test_layout_cocos2d_CCActionTweenDelegate() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCActionTweenDelegate>(),
        8usize,
        concat!("Size of: ", stringify!(cocos2d_CCActionTweenDelegate))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCActionTweenDelegate>(),
        8usize,
        concat!("Alignment of ", stringify!(cocos2d_CCActionTweenDelegate))
    );
}
#[doc = " CCActionTween"]
#[doc = ""]
#[doc = "CCActionTween is an action that lets you update any property of an object."]
#[doc = "For example, if you want to modify the \"width\" property of a target from 200 to 300 in 2 seconds, then:"]
#[doc = ""]
#[doc = "id modifyWidth = [CCActionTween actionWithDuration:2 key:@\"width\" from:200 to:300];"]
#[doc = "[target runAction:modifyWidth];"]
#[doc = ""]
#[doc = ""]
#[doc = "Another example: CCScaleTo action could be rewritten using CCPropertyAction:"]
#[doc = ""]
#[doc = "id scaleA = [CCScaleTo actionWithDuration:2 scale:3];"]
#[doc = "id scaleB = [CCActionTween actionWithDuration:2 key:@\"scale\" from:1 to:3];"]
#[doc = ""]
#[doc = ""]
#[doc = "@since v0.99.2"]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCActionTween {
    pub _base: cocos2d_CCActionInterval,
    pub m_strKey: std_string,
    pub m_fFrom: f32,
    pub m_fTo: f32,
    pub m_fDelta: f32,
}
#[test]
fn bindgen_test_layout_cocos2d_CCActionTween() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCActionTween>(),
        128usize,
        concat!("Size of: ", stringify!(cocos2d_CCActionTween))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCActionTween>(),
        8usize,
        concat!("Alignment of ", stringify!(cocos2d_CCActionTween))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cocos2d_CCActionTween>())).m_strKey as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCActionTween),
            "::",
            stringify!(m_strKey)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cocos2d_CCActionTween>())).m_fFrom as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCActionTween),
            "::",
            stringify!(m_fFrom)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cocos2d_CCActionTween>())).m_fTo as *const _ as usize },
        116usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCActionTween),
            "::",
            stringify!(m_fTo)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cocos2d_CCActionTween>())).m_fDelta as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCActionTween),
            "::",
            stringify!(m_fDelta)
        )
    );
}
extern "C" {
    #[doc = " creates an initializes the action with the property name (key), and the from and to parameters."]
    #[link_name = "\u{1}?create@CCActionTween@cocos2d@@SAPEAV12@MPEBDMM@Z"]
    pub fn cocos2d_CCActionTween_create(
        aDuration: f32,
        key: *const ::std::os::raw::c_char,
        from: f32,
        to: f32,
    ) -> *mut cocos2d_CCActionTween;
}
extern "C" {
    #[doc = " initializes the action with the property name (key), and the from and to parameters."]
    #[link_name = "\u{1}?initWithDuration@CCActionTween@cocos2d@@QEAA_NMPEBDMM@Z"]
    pub fn cocos2d_CCActionTween_initWithDuration(
        this: *mut cocos2d_CCActionTween,
        aDuration: f32,
        key: *const ::std::os::raw::c_char,
        from: f32,
        to: f32,
    ) -> bool;
}
impl cocos2d_CCActionTween {
    #[inline]
    pub unsafe fn create(
        aDuration: f32,
        key: *const ::std::os::raw::c_char,
        from: f32,
        to: f32,
    ) -> *mut cocos2d_CCActionTween {
        cocos2d_CCActionTween_create(aDuration, key, from, to)
    }
    #[inline]
    pub unsafe fn initWithDuration(
        &mut self,
        aDuration: f32,
        key: *const ::std::os::raw::c_char,
        from: f32,
        to: f32,
    ) -> bool {
        cocos2d_CCActionTween_initWithDuration(self, aDuration, key, from, to)
    }
}
extern "C" {
    #[link_name = "\u{1}?startWithTarget@CCActionTween@cocos2d@@UEAAXPEAVCCNode@2@@Z"]
    pub fn cocos2d_CCActionTween_startWithTarget(
        this: *mut ::std::os::raw::c_void,
        pTarget: *mut cocos2d_CCNode,
    );
}
extern "C" {
    #[link_name = "\u{1}?update@CCActionTween@cocos2d@@UEAAXM@Z"]
    pub fn cocos2d_CCActionTween_update(this: *mut ::std::os::raw::c_void, dt: f32);
}
extern "C" {
    #[link_name = "\u{1}?reverse@CCActionTween@cocos2d@@UEAAPEAVCCActionInterval@2@XZ"]
    pub fn cocos2d_CCActionTween_reverse(
        this: *mut ::std::os::raw::c_void,
    ) -> *mut cocos2d_CCActionInterval;
}
#[doc = " An Array that contain control points."]
#[doc = " Used by CCCardinalSplineTo and (By) and CCCatmullRomTo (and By) actions."]
#[doc = " @ingroup Actions"]
#[doc = " @js NA"]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCPointArray {
    pub _base: cocos2d_CCObject,
    #[doc = " Array that contains the control points"]
    pub m_pControlPoints: *mut u8,
}
#[test]
fn bindgen_test_layout_cocos2d_CCPointArray() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCPointArray>(),
        48usize,
        concat!("Size of: ", stringify!(cocos2d_CCPointArray))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCPointArray>(),
        8usize,
        concat!("Alignment of ", stringify!(cocos2d_CCPointArray))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cocos2d_CCPointArray>())).m_pControlPoints as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCPointArray),
            "::",
            stringify!(m_pControlPoints)
        )
    );
}
extern "C" {
    #[doc = " creates and initializes a Points array with capacity"]
    #[doc = " @lua NA"]
    #[link_name = "\u{1}?create@CCPointArray@cocos2d@@SAPEAV12@I@Z"]
    pub fn cocos2d_CCPointArray_create(
        capacity: ::std::os::raw::c_uint,
    ) -> *mut cocos2d_CCPointArray;
}
extern "C" {
    #[doc = " initializes a Catmull Rom config with a capacity hint"]
    #[link_name = "\u{1}?initWithCapacity@CCPointArray@cocos2d@@QEAA_NI@Z"]
    pub fn cocos2d_CCPointArray_initWithCapacity(
        this: *mut cocos2d_CCPointArray,
        capacity: ::std::os::raw::c_uint,
    ) -> bool;
}
extern "C" {
    #[doc = " appends a control point"]
    #[link_name = "\u{1}?addControlPoint@CCPointArray@cocos2d@@QEAAXVCCPoint@2@@Z"]
    pub fn cocos2d_CCPointArray_addControlPoint(
        this: *mut cocos2d_CCPointArray,
        controlPoint: cocos2d_CCPoint,
    );
}
extern "C" {
    #[doc = " inserts a controlPoint at index"]
    #[link_name = "\u{1}?insertControlPoint@CCPointArray@cocos2d@@QEAAXAEAVCCPoint@2@I@Z"]
    pub fn cocos2d_CCPointArray_insertControlPoint(
        this: *mut cocos2d_CCPointArray,
        controlPoint: *mut cocos2d_CCPoint,
        index: ::std::os::raw::c_uint,
    );
}
extern "C" {
    #[doc = " replaces an existing controlPoint at index"]
    #[link_name = "\u{1}?replaceControlPoint@CCPointArray@cocos2d@@QEAAXAEAVCCPoint@2@I@Z"]
    pub fn cocos2d_CCPointArray_replaceControlPoint(
        this: *mut cocos2d_CCPointArray,
        controlPoint: *mut cocos2d_CCPoint,
        index: ::std::os::raw::c_uint,
    );
}
extern "C" {
    #[doc = " get the value of a controlPoint at a given index"]
    #[link_name = "\u{1}?getControlPointAtIndex@CCPointArray@cocos2d@@QEAA?AVCCPoint@2@I@Z"]
    pub fn cocos2d_CCPointArray_getControlPointAtIndex(
        this: *mut cocos2d_CCPointArray,
        index: ::std::os::raw::c_uint,
    ) -> cocos2d_CCPoint;
}
extern "C" {
    #[doc = " deletes a control point at a given index"]
    #[link_name = "\u{1}?removeControlPointAtIndex@CCPointArray@cocos2d@@QEAAXI@Z"]
    pub fn cocos2d_CCPointArray_removeControlPointAtIndex(
        this: *mut cocos2d_CCPointArray,
        index: ::std::os::raw::c_uint,
    );
}
extern "C" {
    #[doc = " returns the number of objects of the control point array"]
    #[link_name = "\u{1}?count@CCPointArray@cocos2d@@QEAAIXZ"]
    pub fn cocos2d_CCPointArray_count(this: *mut cocos2d_CCPointArray) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " returns a new copy of the array reversed. User is responsible for releasing this copy"]
    #[link_name = "\u{1}?reverse@CCPointArray@cocos2d@@QEAAPEAV12@XZ"]
    pub fn cocos2d_CCPointArray_reverse(
        this: *mut cocos2d_CCPointArray,
    ) -> *mut cocos2d_CCPointArray;
}
extern "C" {
    #[doc = " reverse the current control point array inline, without generating a new one"]
    #[link_name = "\u{1}?reverseInline@CCPointArray@cocos2d@@QEAAXXZ"]
    pub fn cocos2d_CCPointArray_reverseInline(this: *mut cocos2d_CCPointArray);
}
extern "C" {
    #[link_name = "\u{1}?getControlPoints@CCPointArray@cocos2d@@QEAAPEBV?$vector@PEAVCCPoint@cocos2d@@V?$allocator@PEAVCCPoint@cocos2d@@@std@@@std@@XZ"]
    pub fn cocos2d_CCPointArray_getControlPoints(this: *mut cocos2d_CCPointArray) -> *const u8;
}
extern "C" {
    #[link_name = "\u{1}?setControlPoints@CCPointArray@cocos2d@@QEAAXPEAV?$vector@PEAVCCPoint@cocos2d@@V?$allocator@PEAVCCPoint@cocos2d@@@std@@@std@@@Z"]
    pub fn cocos2d_CCPointArray_setControlPoints(
        this: *mut cocos2d_CCPointArray,
        controlPoints: *mut u8,
    );
}
extern "C" {
    #[doc = " @lua NA"]
    #[link_name = "\u{1}??0CCPointArray@cocos2d@@QEAA@XZ"]
    pub fn cocos2d_CCPointArray_CCPointArray(this: *mut cocos2d_CCPointArray);
}
impl cocos2d_CCPointArray {
    #[inline]
    pub unsafe fn create(capacity: ::std::os::raw::c_uint) -> *mut cocos2d_CCPointArray {
        cocos2d_CCPointArray_create(capacity)
    }
    #[inline]
    pub unsafe fn initWithCapacity(&mut self, capacity: ::std::os::raw::c_uint) -> bool {
        cocos2d_CCPointArray_initWithCapacity(self, capacity)
    }
    #[inline]
    pub unsafe fn addControlPoint(&mut self, controlPoint: cocos2d_CCPoint) {
        cocos2d_CCPointArray_addControlPoint(self, controlPoint)
    }
    #[inline]
    pub unsafe fn insertControlPoint(
        &mut self,
        controlPoint: *mut cocos2d_CCPoint,
        index: ::std::os::raw::c_uint,
    ) {
        cocos2d_CCPointArray_insertControlPoint(self, controlPoint, index)
    }
    #[inline]
    pub unsafe fn replaceControlPoint(
        &mut self,
        controlPoint: *mut cocos2d_CCPoint,
        index: ::std::os::raw::c_uint,
    ) {
        cocos2d_CCPointArray_replaceControlPoint(self, controlPoint, index)
    }
    #[inline]
    pub unsafe fn getControlPointAtIndex(
        &mut self,
        index: ::std::os::raw::c_uint,
    ) -> cocos2d_CCPoint {
        cocos2d_CCPointArray_getControlPointAtIndex(self, index)
    }
    #[inline]
    pub unsafe fn removeControlPointAtIndex(&mut self, index: ::std::os::raw::c_uint) {
        cocos2d_CCPointArray_removeControlPointAtIndex(self, index)
    }
    #[inline]
    pub unsafe fn count(&mut self) -> ::std::os::raw::c_uint {
        cocos2d_CCPointArray_count(self)
    }
    #[inline]
    pub unsafe fn reverse(&mut self) -> *mut cocos2d_CCPointArray {
        cocos2d_CCPointArray_reverse(self)
    }
    #[inline]
    pub unsafe fn reverseInline(&mut self) {
        cocos2d_CCPointArray_reverseInline(self)
    }
    #[inline]
    pub unsafe fn getControlPoints(&mut self) -> *const u8 {
        cocos2d_CCPointArray_getControlPoints(self)
    }
    #[inline]
    pub unsafe fn setControlPoints(&mut self, controlPoints: *mut u8) {
        cocos2d_CCPointArray_setControlPoints(self, controlPoints)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cocos2d_CCPointArray_CCPointArray(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
}
extern "C" {
    #[doc = " @lua NA"]
    #[link_name = "\u{1}??_DCCPointArray@cocos2d@@QEAAXXZ"]
    pub fn cocos2d_CCPointArray_CCPointArray_destructor(this: *mut cocos2d_CCPointArray);
}
extern "C" {
    #[doc = "  @js NA"]
    #[doc = "  @lua NA"]
    #[link_name = "\u{1}?copyWithZone@CCPointArray@cocos2d@@UEAAPEAVCCObject@2@PEAVCCZone@2@@Z"]
    pub fn cocos2d_CCPointArray_copyWithZone(
        this: *mut ::std::os::raw::c_void,
        zone: *mut cocos2d_CCZone,
    ) -> *mut cocos2d_CCObject;
}
#[doc = " Cardinal Spline path."]
#[doc = "http://en.wikipedia.org/wiki/Cubic_Hermite_spline#Cardinal_spline"]
#[doc = "@ingroup Actions"]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCCardinalSplineTo {
    pub _base: cocos2d_CCActionInterval,
    #[doc = " Array of control points"]
    pub m_pPoints: *mut cocos2d_CCPointArray,
    pub m_fDeltaT: f32,
    pub m_fTension: f32,
    pub m_previousPosition: cocos2d_CCPoint,
    pub m_accumulatedDiff: cocos2d_CCPoint,
}
#[test]
fn bindgen_test_layout_cocos2d_CCCardinalSplineTo() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCCardinalSplineTo>(),
        112usize,
        concat!("Size of: ", stringify!(cocos2d_CCCardinalSplineTo))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCCardinalSplineTo>(),
        8usize,
        concat!("Alignment of ", stringify!(cocos2d_CCCardinalSplineTo))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cocos2d_CCCardinalSplineTo>())).m_pPoints as *const _ as usize
        },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCCardinalSplineTo),
            "::",
            stringify!(m_pPoints)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cocos2d_CCCardinalSplineTo>())).m_fDeltaT as *const _ as usize
        },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCCardinalSplineTo),
            "::",
            stringify!(m_fDeltaT)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cocos2d_CCCardinalSplineTo>())).m_fTension as *const _ as usize
        },
        92usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCCardinalSplineTo),
            "::",
            stringify!(m_fTension)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cocos2d_CCCardinalSplineTo>())).m_previousPosition as *const _
                as usize
        },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCCardinalSplineTo),
            "::",
            stringify!(m_previousPosition)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cocos2d_CCCardinalSplineTo>())).m_accumulatedDiff as *const _
                as usize
        },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCCardinalSplineTo),
            "::",
            stringify!(m_accumulatedDiff)
        )
    );
}
extern "C" {
    #[doc = " creates an action with a Cardinal Spline array of points and tension"]
    #[doc = "  @code"]
    #[doc = "  when thie function bound to js,the input params are changed"]
    #[doc = "  js:var create(var duration,var pointTable,var tension)"]
    #[doc = "  @endcode"]
    #[link_name = "\u{1}?create@CCCardinalSplineTo@cocos2d@@SAPEAV12@MPEAVCCPointArray@2@M@Z"]
    pub fn cocos2d_CCCardinalSplineTo_create(
        duration: f32,
        points: *mut cocos2d_CCPointArray,
        tension: f32,
    ) -> *mut cocos2d_CCCardinalSplineTo;
}
extern "C" {
    #[doc = " initializes the action with a duration and an array of points"]
    #[doc = "  @lua NA"]
    #[link_name = "\u{1}?initWithDuration@CCCardinalSplineTo@cocos2d@@QEAA_NMPEAVCCPointArray@2@M@Z"]
    pub fn cocos2d_CCCardinalSplineTo_initWithDuration(
        this: *mut cocos2d_CCCardinalSplineTo,
        duration: f32,
        points: *mut cocos2d_CCPointArray,
        tension: f32,
    ) -> bool;
}
extern "C" {
    #[doc = "  @js ctor"]
    #[doc = "  @lua NA"]
    #[link_name = "\u{1}??0CCCardinalSplineTo@cocos2d@@QEAA@XZ"]
    pub fn cocos2d_CCCardinalSplineTo_CCCardinalSplineTo(this: *mut cocos2d_CCCardinalSplineTo);
}
impl cocos2d_CCCardinalSplineTo {
    #[inline]
    pub unsafe fn create(
        duration: f32,
        points: *mut cocos2d_CCPointArray,
        tension: f32,
    ) -> *mut cocos2d_CCCardinalSplineTo {
        cocos2d_CCCardinalSplineTo_create(duration, points, tension)
    }
    #[inline]
    pub unsafe fn initWithDuration(
        &mut self,
        duration: f32,
        points: *mut cocos2d_CCPointArray,
        tension: f32,
    ) -> bool {
        cocos2d_CCCardinalSplineTo_initWithDuration(self, duration, points, tension)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cocos2d_CCCardinalSplineTo_CCCardinalSplineTo(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
}
extern "C" {
    #[doc = "  @js NA"]
    #[doc = "  @lua NA"]
    #[link_name = "\u{1}??_DCCCardinalSplineTo@cocos2d@@QEAAXXZ"]
    pub fn cocos2d_CCCardinalSplineTo_CCCardinalSplineTo_destructor(
        this: *mut cocos2d_CCCardinalSplineTo,
    );
}
extern "C" {
    #[doc = "  @js NA"]
    #[doc = "  @lua NA"]
    #[link_name = "\u{1}?copyWithZone@CCCardinalSplineTo@cocos2d@@UEAAPEAV12@PEAVCCZone@2@@Z"]
    pub fn cocos2d_CCCardinalSplineTo_copyWithZone(
        this: *mut ::std::os::raw::c_void,
        pZone: *mut cocos2d_CCZone,
    ) -> *mut cocos2d_CCCardinalSplineTo;
}
extern "C" {
    #[doc = "  @lua NA"]
    #[link_name = "\u{1}?startWithTarget@CCCardinalSplineTo@cocos2d@@UEAAXPEAVCCNode@2@@Z"]
    pub fn cocos2d_CCCardinalSplineTo_startWithTarget(
        this: *mut ::std::os::raw::c_void,
        pTarget: *mut cocos2d_CCNode,
    );
}
extern "C" {
    #[doc = "  @lua NA"]
    #[link_name = "\u{1}?update@CCCardinalSplineTo@cocos2d@@UEAAXM@Z"]
    pub fn cocos2d_CCCardinalSplineTo_update(this: *mut ::std::os::raw::c_void, time: f32);
}
extern "C" {
    #[link_name = "\u{1}?reverse@CCCardinalSplineTo@cocos2d@@UEAAPEAVCCActionInterval@2@XZ"]
    pub fn cocos2d_CCCardinalSplineTo_reverse(
        this: *mut ::std::os::raw::c_void,
    ) -> *mut cocos2d_CCActionInterval;
}
extern "C" {
    #[doc = "  @lua NA"]
    #[link_name = "\u{1}?updatePosition@CCCardinalSplineTo@cocos2d@@UEAAXAEAVCCPoint@2@@Z"]
    pub fn cocos2d_CCCardinalSplineTo_updatePosition(
        this: *mut ::std::os::raw::c_void,
        newPos: *mut cocos2d_CCPoint,
    );
}
#[doc = " Cardinal Spline path."]
#[doc = "http://en.wikipedia.org/wiki/Cubic_Hermite_spline#Cardinal_spline"]
#[doc = "@ingroup Actions"]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCCardinalSplineBy {
    pub _base: cocos2d_CCCardinalSplineTo,
    pub m_startPosition: cocos2d_CCPoint,
}
#[test]
fn bindgen_test_layout_cocos2d_CCCardinalSplineBy() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCCardinalSplineBy>(),
        120usize,
        concat!("Size of: ", stringify!(cocos2d_CCCardinalSplineBy))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCCardinalSplineBy>(),
        8usize,
        concat!("Alignment of ", stringify!(cocos2d_CCCardinalSplineBy))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cocos2d_CCCardinalSplineBy>())).m_startPosition as *const _
                as usize
        },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCCardinalSplineBy),
            "::",
            stringify!(m_startPosition)
        )
    );
}
extern "C" {
    #[doc = " creates an action with a Cardinal Spline array of points and tension"]
    #[doc = "  @code"]
    #[doc = "  when thie function bound to js,the input params are changed"]
    #[doc = "  js:var create(var duration,var pointTable,var tension)"]
    #[doc = "  @endcode"]
    #[link_name = "\u{1}?create@CCCardinalSplineBy@cocos2d@@SAPEAV12@MPEAVCCPointArray@2@M@Z"]
    pub fn cocos2d_CCCardinalSplineBy_create(
        duration: f32,
        points: *mut cocos2d_CCPointArray,
        tension: f32,
    ) -> *mut cocos2d_CCCardinalSplineBy;
}
extern "C" {
    #[doc = "  @js NA"]
    #[doc = "  @lua NA"]
    #[link_name = "\u{1}??0CCCardinalSplineBy@cocos2d@@QEAA@XZ"]
    pub fn cocos2d_CCCardinalSplineBy_CCCardinalSplineBy(this: *mut cocos2d_CCCardinalSplineBy);
}
impl cocos2d_CCCardinalSplineBy {
    #[inline]
    pub unsafe fn create(
        duration: f32,
        points: *mut cocos2d_CCPointArray,
        tension: f32,
    ) -> *mut cocos2d_CCCardinalSplineBy {
        cocos2d_CCCardinalSplineBy_create(duration, points, tension)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cocos2d_CCCardinalSplineBy_CCCardinalSplineBy(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
}
extern "C" {
    #[doc = "  @lua NA"]
    #[link_name = "\u{1}?startWithTarget@CCCardinalSplineBy@cocos2d@@UEAAXPEAVCCNode@2@@Z"]
    pub fn cocos2d_CCCardinalSplineBy_startWithTarget(
        this: *mut ::std::os::raw::c_void,
        pTarget: *mut cocos2d_CCNode,
    );
}
extern "C" {
    #[link_name = "\u{1}?reverse@CCCardinalSplineBy@cocos2d@@UEAAPEAVCCActionInterval@2@XZ"]
    pub fn cocos2d_CCCardinalSplineBy_reverse(
        this: *mut ::std::os::raw::c_void,
    ) -> *mut cocos2d_CCActionInterval;
}
extern "C" {
    #[doc = "  @lua NA"]
    #[link_name = "\u{1}?updatePosition@CCCardinalSplineBy@cocos2d@@UEAAXAEAVCCPoint@2@@Z"]
    pub fn cocos2d_CCCardinalSplineBy_updatePosition(
        this: *mut ::std::os::raw::c_void,
        newPos: *mut cocos2d_CCPoint,
    );
}
#[doc = " An action that moves the target with a CatmullRom curve to a destination point."]
#[doc = "A Catmull Rom is a Cardinal Spline with a tension of 0.5."]
#[doc = "http://en.wikipedia.org/wiki/Cubic_Hermite_spline#Catmull.E2.80.93Rom_spline"]
#[doc = "@ingroup Actions"]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCCatmullRomTo {
    pub _base: cocos2d_CCCardinalSplineTo,
}
#[test]
fn bindgen_test_layout_cocos2d_CCCatmullRomTo() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCCatmullRomTo>(),
        112usize,
        concat!("Size of: ", stringify!(cocos2d_CCCatmullRomTo))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCCatmullRomTo>(),
        8usize,
        concat!("Alignment of ", stringify!(cocos2d_CCCatmullRomTo))
    );
}
extern "C" {
    #[doc = " creates an action with a Cardinal Spline array of points and tension"]
    #[doc = "  @code"]
    #[doc = "  when this function bound to js,the input params are changed"]
    #[doc = "  js:var create(var dt,var pointTable)"]
    #[doc = "  @endcode"]
    #[link_name = "\u{1}?create@CCCatmullRomTo@cocos2d@@SAPEAV12@MPEAVCCPointArray@2@@Z"]
    pub fn cocos2d_CCCatmullRomTo_create(
        dt: f32,
        points: *mut cocos2d_CCPointArray,
    ) -> *mut cocos2d_CCCatmullRomTo;
}
extern "C" {
    #[doc = " initializes the action with a duration and an array of points"]
    #[doc = "  @js NA"]
    #[doc = "  @lua NA"]
    #[link_name = "\u{1}?initWithDuration@CCCatmullRomTo@cocos2d@@QEAA_NMPEAVCCPointArray@2@@Z"]
    pub fn cocos2d_CCCatmullRomTo_initWithDuration(
        this: *mut cocos2d_CCCatmullRomTo,
        dt: f32,
        points: *mut cocos2d_CCPointArray,
    ) -> bool;
}
impl cocos2d_CCCatmullRomTo {
    #[inline]
    pub unsafe fn create(
        dt: f32,
        points: *mut cocos2d_CCPointArray,
    ) -> *mut cocos2d_CCCatmullRomTo {
        cocos2d_CCCatmullRomTo_create(dt, points)
    }
    #[inline]
    pub unsafe fn initWithDuration(&mut self, dt: f32, points: *mut cocos2d_CCPointArray) -> bool {
        cocos2d_CCCatmullRomTo_initWithDuration(self, dt, points)
    }
}
#[doc = " An action that moves the target with a CatmullRom curve by a certain distance."]
#[doc = "A Catmull Rom is a Cardinal Spline with a tension of 0.5."]
#[doc = "http://en.wikipedia.org/wiki/Cubic_Hermite_spline#Catmull.E2.80.93Rom_spline"]
#[doc = "@ingroup Actions"]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCCatmullRomBy {
    pub _base: cocos2d_CCCardinalSplineBy,
}
#[test]
fn bindgen_test_layout_cocos2d_CCCatmullRomBy() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCCatmullRomBy>(),
        120usize,
        concat!("Size of: ", stringify!(cocos2d_CCCatmullRomBy))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCCatmullRomBy>(),
        8usize,
        concat!("Alignment of ", stringify!(cocos2d_CCCatmullRomBy))
    );
}
extern "C" {
    #[doc = " creates an action with a Cardinal Spline array of points and tension"]
    #[doc = "  @code"]
    #[doc = "  when this function bound to js,the input params are changed"]
    #[doc = "  js:var create(var dt,var pointTable)"]
    #[doc = "  @endcode"]
    #[link_name = "\u{1}?create@CCCatmullRomBy@cocos2d@@SAPEAV12@MPEAVCCPointArray@2@@Z"]
    pub fn cocos2d_CCCatmullRomBy_create(
        dt: f32,
        points: *mut cocos2d_CCPointArray,
    ) -> *mut cocos2d_CCCatmullRomBy;
}
extern "C" {
    #[doc = " initializes the action with a duration and an array of points"]
    #[doc = "  @js NA"]
    #[doc = "  @lua NA"]
    #[link_name = "\u{1}?initWithDuration@CCCatmullRomBy@cocos2d@@QEAA_NMPEAVCCPointArray@2@@Z"]
    pub fn cocos2d_CCCatmullRomBy_initWithDuration(
        this: *mut cocos2d_CCCatmullRomBy,
        dt: f32,
        points: *mut cocos2d_CCPointArray,
    ) -> bool;
}
impl cocos2d_CCCatmullRomBy {
    #[inline]
    pub unsafe fn create(
        dt: f32,
        points: *mut cocos2d_CCPointArray,
    ) -> *mut cocos2d_CCCatmullRomBy {
        cocos2d_CCCatmullRomBy_create(dt, points)
    }
    #[inline]
    pub unsafe fn initWithDuration(&mut self, dt: f32, points: *mut cocos2d_CCPointArray) -> bool {
        cocos2d_CCCatmullRomBy_initWithDuration(self, dt, points)
    }
}
extern "C" {
    #[doc = " Returns the Cardinal Spline position for a given set of control points, tension and time"]
    #[link_name = "\u{1}?ccCardinalSplineAt@cocos2d@@YA?AVCCPoint@1@AEAV21@000MM@Z"]
    pub fn cocos2d_ccCardinalSplineAt(
        p0: *mut cocos2d_CCPoint,
        p1: *mut cocos2d_CCPoint,
        p2: *mut cocos2d_CCPoint,
        p3: *mut cocos2d_CCPoint,
        tension: f32,
        t: f32,
    ) -> cocos2d_CCPoint;
}
#[doc = " @brief CCAtlasNode is a subclass of CCNode that implements the CCRGBAProtocol and CCTextureProtocol protocol"]
#[doc = ""]
#[doc = "It knows how to render a TextureAtlas object."]
#[doc = "If you are going to render a TextureAtlas consider subclassing CCAtlasNode (or a subclass of CCAtlasNode)"]
#[doc = ""]
#[doc = "All features from CCNode are valid, plus the following features:"]
#[doc = "- opacity and RGB colors"]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCAtlasNode {
    pub _base: cocos2d_CCNodeRGBA,
    pub _base_1: cocos2d_CCTextureProtocol,
    #[doc = "! chars per row"]
    pub m_uItemsPerRow: ::std::os::raw::c_uint,
    #[doc = "! chars per column"]
    pub m_uItemsPerColumn: ::std::os::raw::c_uint,
    #[doc = "! width of each char"]
    pub m_uItemWidth: ::std::os::raw::c_uint,
    #[doc = "! height of each char"]
    pub m_uItemHeight: ::std::os::raw::c_uint,
    pub m_tColorUnmodified: cocos2d_ccColor3B,
    pub m_pTextureAtlas: *mut cocos2d_CCTextureAtlas,
    pub m_bIsOpacityModifyRGB: bool,
    pub m_tBlendFunc: cocos2d_ccBlendFunc,
    pub m_uQuadsToDraw: ::std::os::raw::c_uint,
    pub m_nUniformColor: GLint,
    pub m_bIgnoreContentScaleFactor: bool,
}
#[test]
fn bindgen_test_layout_cocos2d_CCAtlasNode() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCAtlasNode>(),
        384usize,
        concat!("Size of: ", stringify!(cocos2d_CCAtlasNode))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCAtlasNode>(),
        8usize,
        concat!("Alignment of ", stringify!(cocos2d_CCAtlasNode))
    );
}
extern "C" {
    #[doc = " creates a CCAtlasNode  with an Atlas file the width and height of each item and the quantity of items to render"]
    #[link_name = "\u{1}?create@CCAtlasNode@cocos2d@@SAPEAV12@PEBDIII@Z"]
    pub fn cocos2d_CCAtlasNode_create(
        tile: *const ::std::os::raw::c_char,
        tileWidth: ::std::os::raw::c_uint,
        tileHeight: ::std::os::raw::c_uint,
        itemsToRender: ::std::os::raw::c_uint,
    ) -> *mut cocos2d_CCAtlasNode;
}
extern "C" {
    #[doc = " initializes an CCAtlasNode  with an Atlas file the width and height of each item and the quantity of items to render"]
    #[link_name = "\u{1}?initWithTileFile@CCAtlasNode@cocos2d@@QEAA_NPEBDIII@Z"]
    pub fn cocos2d_CCAtlasNode_initWithTileFile(
        this: *mut cocos2d_CCAtlasNode,
        tile: *const ::std::os::raw::c_char,
        tileWidth: ::std::os::raw::c_uint,
        tileHeight: ::std::os::raw::c_uint,
        itemsToRender: ::std::os::raw::c_uint,
    ) -> bool;
}
extern "C" {
    #[doc = " initializes an CCAtlasNode  with a texture the width and height of each item measured in points and the quantity of items to render"]
    #[link_name = "\u{1}?initWithTexture@CCAtlasNode@cocos2d@@QEAA_NPEAVCCTexture2D@2@III@Z"]
    pub fn cocos2d_CCAtlasNode_initWithTexture(
        this: *mut cocos2d_CCAtlasNode,
        texture: *mut cocos2d_CCTexture2D,
        tileWidth: ::std::os::raw::c_uint,
        tileHeight: ::std::os::raw::c_uint,
        itemsToRender: ::std::os::raw::c_uint,
    ) -> bool;
}
extern "C" {
    #[doc = "  @js ctor"]
    #[link_name = "\u{1}??0CCAtlasNode@cocos2d@@QEAA@XZ"]
    pub fn cocos2d_CCAtlasNode_CCAtlasNode(this: *mut cocos2d_CCAtlasNode);
}
impl cocos2d_CCAtlasNode {
    #[inline]
    pub unsafe fn create(
        tile: *const ::std::os::raw::c_char,
        tileWidth: ::std::os::raw::c_uint,
        tileHeight: ::std::os::raw::c_uint,
        itemsToRender: ::std::os::raw::c_uint,
    ) -> *mut cocos2d_CCAtlasNode {
        cocos2d_CCAtlasNode_create(tile, tileWidth, tileHeight, itemsToRender)
    }
    #[inline]
    pub unsafe fn initWithTileFile(
        &mut self,
        tile: *const ::std::os::raw::c_char,
        tileWidth: ::std::os::raw::c_uint,
        tileHeight: ::std::os::raw::c_uint,
        itemsToRender: ::std::os::raw::c_uint,
    ) -> bool {
        cocos2d_CCAtlasNode_initWithTileFile(self, tile, tileWidth, tileHeight, itemsToRender)
    }
    #[inline]
    pub unsafe fn initWithTexture(
        &mut self,
        texture: *mut cocos2d_CCTexture2D,
        tileWidth: ::std::os::raw::c_uint,
        tileHeight: ::std::os::raw::c_uint,
        itemsToRender: ::std::os::raw::c_uint,
    ) -> bool {
        cocos2d_CCAtlasNode_initWithTexture(self, texture, tileWidth, tileHeight, itemsToRender)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cocos2d_CCAtlasNode_CCAtlasNode(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
}
extern "C" {
    #[link_name = "\u{1}?getTextureAtlas@CCAtlasNode@cocos2d@@UEAAPEAVCCTextureAtlas@2@XZ"]
    pub fn cocos2d_CCAtlasNode_getTextureAtlas(
        this: *mut ::std::os::raw::c_void,
    ) -> *mut cocos2d_CCTextureAtlas;
}
extern "C" {
    #[link_name = "\u{1}?setTextureAtlas@CCAtlasNode@cocos2d@@UEAAXPEAVCCTextureAtlas@2@@Z"]
    pub fn cocos2d_CCAtlasNode_setTextureAtlas(
        this: *mut ::std::os::raw::c_void,
        var: *mut cocos2d_CCTextureAtlas,
    );
}
extern "C" {
    #[link_name = "\u{1}?getBlendFunc@CCAtlasNode@cocos2d@@UEAA?AU_ccBlendFunc@2@XZ"]
    pub fn cocos2d_CCAtlasNode_getBlendFunc(
        this: *mut ::std::os::raw::c_void,
    ) -> cocos2d_ccBlendFunc;
}
extern "C" {
    #[link_name = "\u{1}?setBlendFunc@CCAtlasNode@cocos2d@@UEAAXU_ccBlendFunc@2@@Z"]
    pub fn cocos2d_CCAtlasNode_setBlendFunc(
        this: *mut ::std::os::raw::c_void,
        var: cocos2d_ccBlendFunc,
    );
}
extern "C" {
    #[link_name = "\u{1}?getQuadsToDraw@CCAtlasNode@cocos2d@@UEAAIXZ"]
    pub fn cocos2d_CCAtlasNode_getQuadsToDraw(
        this: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[link_name = "\u{1}?setQuadsToDraw@CCAtlasNode@cocos2d@@UEAAXI@Z"]
    pub fn cocos2d_CCAtlasNode_setQuadsToDraw(
        this: *mut ::std::os::raw::c_void,
        var: ::std::os::raw::c_uint,
    );
}
extern "C" {
    #[doc = "  @js NA"]
    #[doc = "  @lua NA"]
    #[link_name = "\u{1}??_DCCAtlasNode@cocos2d@@QEAAXXZ"]
    pub fn cocos2d_CCAtlasNode_CCAtlasNode_destructor(this: *mut cocos2d_CCAtlasNode);
}
extern "C" {
    #[doc = " updates the Atlas (indexed vertex array)."]
    #[doc = " Shall be overridden in subclasses"]
    #[link_name = "\u{1}?updateAtlasValues@CCAtlasNode@cocos2d@@UEAAXXZ"]
    pub fn cocos2d_CCAtlasNode_updateAtlasValues(this: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[link_name = "\u{1}?draw@CCAtlasNode@cocos2d@@UEAAXXZ"]
    pub fn cocos2d_CCAtlasNode_draw(this: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[doc = " returns the used texture"]
    #[link_name = "\u{1}?getTexture@CCAtlasNode@cocos2d@@UEAAPEAVCCTexture2D@2@XZ"]
    pub fn cocos2d_CCAtlasNode_getTexture(
        this: *mut ::std::os::raw::c_void,
    ) -> *mut cocos2d_CCTexture2D;
}
extern "C" {
    #[doc = " sets a new texture. it will be retained"]
    #[link_name = "\u{1}?setTexture@CCAtlasNode@cocos2d@@UEAAXPEAVCCTexture2D@2@@Z"]
    pub fn cocos2d_CCAtlasNode_setTexture(
        this: *mut ::std::os::raw::c_void,
        texture: *mut cocos2d_CCTexture2D,
    );
}
extern "C" {
    #[link_name = "\u{1}?isOpacityModifyRGB@CCAtlasNode@cocos2d@@UEAA_NXZ"]
    pub fn cocos2d_CCAtlasNode_isOpacityModifyRGB(this: *mut ::std::os::raw::c_void) -> bool;
}
extern "C" {
    #[link_name = "\u{1}?setOpacityModifyRGB@CCAtlasNode@cocos2d@@UEAAX_N@Z"]
    pub fn cocos2d_CCAtlasNode_setOpacityModifyRGB(
        this: *mut ::std::os::raw::c_void,
        isOpacityModifyRGB: bool,
    );
}
extern "C" {
    #[link_name = "\u{1}?getColor@CCAtlasNode@cocos2d@@UEAAAEBU_ccColor3B@2@XZ"]
    pub fn cocos2d_CCAtlasNode_getColor(
        this: *mut ::std::os::raw::c_void,
    ) -> *const cocos2d_ccColor3B;
}
extern "C" {
    #[link_name = "\u{1}?setColor@CCAtlasNode@cocos2d@@UEAAXAEBU_ccColor3B@2@@Z"]
    pub fn cocos2d_CCAtlasNode_setColor(
        this: *mut ::std::os::raw::c_void,
        color: *const cocos2d_ccColor3B,
    );
}
extern "C" {
    #[link_name = "\u{1}?setOpacity@CCAtlasNode@cocos2d@@UEAAXE@Z"]
    pub fn cocos2d_CCAtlasNode_setOpacity(this: *mut ::std::os::raw::c_void, opacity: GLubyte);
}
#[doc = " @addtogroup base_nodes"]
#[doc = " @{"]
#[doc = " @js NA"]
#[doc = " @lua NA"]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCAutoreleasePool {
    pub _base: cocos2d_CCObject,
    pub m_pManagedObjectArray: *mut cocos2d_CCArray,
}
#[test]
fn bindgen_test_layout_cocos2d_CCAutoreleasePool() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCAutoreleasePool>(),
        48usize,
        concat!("Size of: ", stringify!(cocos2d_CCAutoreleasePool))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCAutoreleasePool>(),
        8usize,
        concat!("Alignment of ", stringify!(cocos2d_CCAutoreleasePool))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cocos2d_CCAutoreleasePool>())).m_pManagedObjectArray as *const _
                as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCAutoreleasePool),
            "::",
            stringify!(m_pManagedObjectArray)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}?addObject@CCAutoreleasePool@cocos2d@@QEAAXPEAVCCObject@2@@Z"]
    pub fn cocos2d_CCAutoreleasePool_addObject(
        this: *mut cocos2d_CCAutoreleasePool,
        pObject: *mut cocos2d_CCObject,
    );
}
extern "C" {
    #[link_name = "\u{1}?removeObject@CCAutoreleasePool@cocos2d@@QEAAXPEAVCCObject@2@@Z"]
    pub fn cocos2d_CCAutoreleasePool_removeObject(
        this: *mut cocos2d_CCAutoreleasePool,
        pObject: *mut cocos2d_CCObject,
    );
}
extern "C" {
    #[link_name = "\u{1}?clear@CCAutoreleasePool@cocos2d@@QEAAXXZ"]
    pub fn cocos2d_CCAutoreleasePool_clear(this: *mut cocos2d_CCAutoreleasePool);
}
extern "C" {
    #[link_name = "\u{1}??0CCAutoreleasePool@cocos2d@@QEAA@XZ"]
    pub fn cocos2d_CCAutoreleasePool_CCAutoreleasePool(this: *mut cocos2d_CCAutoreleasePool);
}
impl cocos2d_CCAutoreleasePool {
    #[inline]
    pub unsafe fn addObject(&mut self, pObject: *mut cocos2d_CCObject) {
        cocos2d_CCAutoreleasePool_addObject(self, pObject)
    }
    #[inline]
    pub unsafe fn removeObject(&mut self, pObject: *mut cocos2d_CCObject) {
        cocos2d_CCAutoreleasePool_removeObject(self, pObject)
    }
    #[inline]
    pub unsafe fn clear(&mut self) {
        cocos2d_CCAutoreleasePool_clear(self)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cocos2d_CCAutoreleasePool_CCAutoreleasePool(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
}
extern "C" {
    #[link_name = "\u{1}??_DCCAutoreleasePool@cocos2d@@QEAAXXZ"]
    pub fn cocos2d_CCAutoreleasePool_CCAutoreleasePool_destructor(
        this: *mut cocos2d_CCAutoreleasePool,
    );
}
#[doc = " @js NA"]
#[doc = " @lua NA"]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCPoolManager {
    pub m_pReleasePoolStack: *mut cocos2d_CCArray,
    pub m_pCurReleasePool: *mut cocos2d_CCAutoreleasePool,
}
#[test]
fn bindgen_test_layout_cocos2d_CCPoolManager() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCPoolManager>(),
        16usize,
        concat!("Size of: ", stringify!(cocos2d_CCPoolManager))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCPoolManager>(),
        8usize,
        concat!("Alignment of ", stringify!(cocos2d_CCPoolManager))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cocos2d_CCPoolManager>())).m_pReleasePoolStack as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCPoolManager),
            "::",
            stringify!(m_pReleasePoolStack)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cocos2d_CCPoolManager>())).m_pCurReleasePool as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCPoolManager),
            "::",
            stringify!(m_pCurReleasePool)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}?finalize@CCPoolManager@cocos2d@@QEAAXXZ"]
    pub fn cocos2d_CCPoolManager_finalize(this: *mut cocos2d_CCPoolManager);
}
extern "C" {
    #[link_name = "\u{1}?push@CCPoolManager@cocos2d@@QEAAXXZ"]
    pub fn cocos2d_CCPoolManager_push(this: *mut cocos2d_CCPoolManager);
}
extern "C" {
    #[link_name = "\u{1}?pop@CCPoolManager@cocos2d@@QEAAXXZ"]
    pub fn cocos2d_CCPoolManager_pop(this: *mut cocos2d_CCPoolManager);
}
extern "C" {
    #[link_name = "\u{1}?removeObject@CCPoolManager@cocos2d@@QEAAXPEAVCCObject@2@@Z"]
    pub fn cocos2d_CCPoolManager_removeObject(
        this: *mut cocos2d_CCPoolManager,
        pObject: *mut cocos2d_CCObject,
    );
}
extern "C" {
    #[link_name = "\u{1}?addObject@CCPoolManager@cocos2d@@QEAAXPEAVCCObject@2@@Z"]
    pub fn cocos2d_CCPoolManager_addObject(
        this: *mut cocos2d_CCPoolManager,
        pObject: *mut cocos2d_CCObject,
    );
}
extern "C" {
    #[link_name = "\u{1}?sharedPoolManager@CCPoolManager@cocos2d@@SAPEAV12@XZ"]
    pub fn cocos2d_CCPoolManager_sharedPoolManager() -> *mut cocos2d_CCPoolManager;
}
extern "C" {
    #[link_name = "\u{1}?purgePoolManager@CCPoolManager@cocos2d@@SAXXZ"]
    pub fn cocos2d_CCPoolManager_purgePoolManager();
}
extern "C" {
    #[link_name = "\u{1}??0CCPoolManager@cocos2d@@QEAA@XZ"]
    pub fn cocos2d_CCPoolManager_CCPoolManager(this: *mut cocos2d_CCPoolManager);
}
extern "C" {
    #[link_name = "\u{1}??_DCCPoolManager@cocos2d@@QEAAXXZ"]
    pub fn cocos2d_CCPoolManager_CCPoolManager_destructor(this: *mut cocos2d_CCPoolManager);
}
impl cocos2d_CCPoolManager {
    #[inline]
    pub unsafe fn finalize(&mut self) {
        cocos2d_CCPoolManager_finalize(self)
    }
    #[inline]
    pub unsafe fn push(&mut self) {
        cocos2d_CCPoolManager_push(self)
    }
    #[inline]
    pub unsafe fn pop(&mut self) {
        cocos2d_CCPoolManager_pop(self)
    }
    #[inline]
    pub unsafe fn removeObject(&mut self, pObject: *mut cocos2d_CCObject) {
        cocos2d_CCPoolManager_removeObject(self, pObject)
    }
    #[inline]
    pub unsafe fn addObject(&mut self, pObject: *mut cocos2d_CCObject) {
        cocos2d_CCPoolManager_addObject(self, pObject)
    }
    #[inline]
    pub unsafe fn sharedPoolManager() -> *mut cocos2d_CCPoolManager {
        cocos2d_CCPoolManager_sharedPoolManager()
    }
    #[inline]
    pub unsafe fn purgePoolManager() {
        cocos2d_CCPoolManager_purgePoolManager()
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cocos2d_CCPoolManager_CCPoolManager(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn destruct(&mut self) {
        cocos2d_CCPoolManager_CCPoolManager_destructor(self)
    }
}
#[doc = " @addtogroup data_structures"]
#[doc = " @{"]
#[doc = " @js NA"]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCInteger {
    pub _base: cocos2d_CCObject,
    pub m_nValue: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_cocos2d_CCInteger() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCInteger>(),
        48usize,
        concat!("Size of: ", stringify!(cocos2d_CCInteger))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCInteger>(),
        8usize,
        concat!("Alignment of ", stringify!(cocos2d_CCInteger))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cocos2d_CCInteger>())).m_nValue as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCInteger),
            "::",
            stringify!(m_nValue)
        )
    );
}
#[doc = " @addtogroup data_structures"]
#[doc = " @{"]
#[doc = " @js NA"]
#[doc = " @lua NA"]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCFloat {
    pub _base: cocos2d_CCObject,
    pub m_fValue: f32,
}
#[test]
fn bindgen_test_layout_cocos2d_CCFloat() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCFloat>(),
        48usize,
        concat!("Size of: ", stringify!(cocos2d_CCFloat))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCFloat>(),
        8usize,
        concat!("Alignment of ", stringify!(cocos2d_CCFloat))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cocos2d_CCFloat>())).m_fValue as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCFloat),
            "::",
            stringify!(m_fValue)
        )
    );
}
#[doc = " @addtogroup data_structures"]
#[doc = " @{"]
#[doc = " @js NA"]
#[doc = " @lua NA"]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCDouble {
    pub _base: cocos2d_CCObject,
    pub m_dValue: f64,
}
#[test]
fn bindgen_test_layout_cocos2d_CCDouble() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCDouble>(),
        48usize,
        concat!("Size of: ", stringify!(cocos2d_CCDouble))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCDouble>(),
        8usize,
        concat!("Alignment of ", stringify!(cocos2d_CCDouble))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cocos2d_CCDouble>())).m_dValue as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCDouble),
            "::",
            stringify!(m_dValue)
        )
    );
}
#[doc = " @addtogroup data_structures"]
#[doc = " @{"]
#[doc = " @js NA"]
#[doc = " @lua NA"]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCBool {
    pub _base: cocos2d_CCObject,
    pub m_bValue: bool,
}
#[test]
fn bindgen_test_layout_cocos2d_CCBool() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCBool>(),
        48usize,
        concat!("Size of: ", stringify!(cocos2d_CCBool))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCBool>(),
        8usize,
        concat!("Alignment of ", stringify!(cocos2d_CCBool))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cocos2d_CCBool>())).m_bValue as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCBool),
            "::",
            stringify!(m_bValue)
        )
    );
}
extern "C" {
    #[doc = "@brief Returns a Core Graphics rectangle structure corresponding to the data in a given string."]
    #[doc = "@param pszContent   A string object whose contents are of the form \"{{x,y},{w, h}}\","]
    #[doc = "where x is the x coordinate, y is the y coordinate, w is the width, and h is the height."]
    #[doc = "These components can represent integer or float values."]
    #[doc = "An example of a valid string is \"{{3,2},{4,5}}\"."]
    #[doc = "The string is not localized, so items are always separated with a comma."]
    #[doc = "@return A Core Graphics structure that represents a rectangle."]
    #[doc = "If the string is not well-formed, the function returns CCRectZero."]
    #[link_name = "\u{1}?CCRectFromString@cocos2d@@YA?AVCCRect@1@PEBD@Z"]
    pub fn cocos2d_CCRectFromString(pszContent: *const ::std::os::raw::c_char) -> cocos2d_CCRect;
}
extern "C" {
    #[doc = "@brief Returns a Core Graphics point structure corresponding to the data in a given string."]
    #[doc = "@param pszContent   A string object whose contents are of the form \"{x,y}\","]
    #[doc = "where x is the x coordinate and y is the y coordinate."]
    #[doc = "The x and y values can represent integer or float values."]
    #[doc = "An example of a valid string is \"{3.0,2.5}\"."]
    #[doc = "The string is not localized, so items are always separated with a comma."]
    #[doc = "@return A Core Graphics structure that represents a point."]
    #[doc = "If the string is not well-formed, the function returns CCPointZero."]
    #[link_name = "\u{1}?CCPointFromString@cocos2d@@YA?AVCCPoint@1@PEBD@Z"]
    pub fn cocos2d_CCPointFromString(pszContent: *const ::std::os::raw::c_char) -> cocos2d_CCPoint;
}
extern "C" {
    #[doc = "@brief Returns a Core Graphics size structure corresponding to the data in a given string."]
    #[doc = "@param pszContent   A string object whose contents are of the form \"{w, h}\","]
    #[doc = "where w is the width and h is the height."]
    #[doc = "The w and h values can be integer or float values."]
    #[doc = "An example of a valid string is \"{3.0,2.5}\"."]
    #[doc = "The string is not localized, so items are always separated with a comma."]
    #[doc = "@return A Core Graphics structure that represents a size."]
    #[doc = "If the string is not well-formed, the function returns CCSizeZero."]
    #[link_name = "\u{1}?CCSizeFromString@cocos2d@@YA?AVCCSize@1@PEBD@Z"]
    pub fn cocos2d_CCSizeFromString(pszContent: *const ::std::os::raw::c_char) -> cocos2d_CCSize;
}
#[doc = " @js NA"]
#[doc = " @lua NA"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cocos2d_CCZone {
    pub m_pCopyObject: *mut cocos2d_CCObject,
}
#[test]
fn bindgen_test_layout_cocos2d_CCZone() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCZone>(),
        8usize,
        concat!("Size of: ", stringify!(cocos2d_CCZone))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCZone>(),
        8usize,
        concat!("Alignment of ", stringify!(cocos2d_CCZone))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cocos2d_CCZone>())).m_pCopyObject as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCZone),
            "::",
            stringify!(m_pCopyObject)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}??0CCZone@cocos2d@@QEAA@PEAVCCObject@1@@Z"]
    pub fn cocos2d_CCZone_CCZone(this: *mut cocos2d_CCZone, pObject: *mut cocos2d_CCObject);
}
impl cocos2d_CCZone {
    #[inline]
    pub unsafe fn new(pObject: *mut cocos2d_CCObject) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cocos2d_CCZone_CCZone(__bindgen_tmp.as_mut_ptr(), pObject);
        __bindgen_tmp.assume_init()
    }
}
extern "C" {
    #[doc = " Initializes the drawing primitives"]
    #[link_name = "\u{1}?ccDrawInit@cocos2d@@YAXXZ"]
    pub fn cocos2d_ccDrawInit();
}
extern "C" {
    #[doc = " Frees allocated resources by the drawing primitives"]
    #[link_name = "\u{1}?ccDrawFree@cocos2d@@YAXXZ"]
    pub fn cocos2d_ccDrawFree();
}
extern "C" {
    #[doc = " draws a point given x and y coordinate measured in points"]
    #[link_name = "\u{1}?ccDrawPoint@cocos2d@@YAXAEBVCCPoint@1@@Z"]
    pub fn cocos2d_ccDrawPoint(point: *const cocos2d_CCPoint);
}
extern "C" {
    #[doc = " draws an array of points."]
    #[doc = "@since v0.7.2"]
    #[link_name = "\u{1}?ccDrawPoints@cocos2d@@YAXPEBVCCPoint@1@I@Z"]
    pub fn cocos2d_ccDrawPoints(
        points: *const cocos2d_CCPoint,
        numberOfPoints: ::std::os::raw::c_uint,
    );
}
extern "C" {
    #[doc = " draws a line given the origin and destination point measured in points"]
    #[link_name = "\u{1}?ccDrawLine@cocos2d@@YAXAEBVCCPoint@1@0@Z"]
    pub fn cocos2d_ccDrawLine(origin: *const cocos2d_CCPoint, destination: *const cocos2d_CCPoint);
}
extern "C" {
    #[doc = " draws a rectangle given the origin and destination point measured in points."]
    #[link_name = "\u{1}?ccDrawRect@cocos2d@@YAXVCCPoint@1@0@Z"]
    pub fn cocos2d_ccDrawRect(origin: cocos2d_CCPoint, destination: cocos2d_CCPoint);
}
extern "C" {
    #[doc = " draws a solid rectangle given the origin and destination point measured in points."]
    #[doc = "@since 1.1"]
    #[link_name = "\u{1}?ccDrawSolidRect@cocos2d@@YAXVCCPoint@1@0U_ccColor4F@1@@Z"]
    pub fn cocos2d_ccDrawSolidRect(
        origin: cocos2d_CCPoint,
        destination: cocos2d_CCPoint,
        color: cocos2d_ccColor4F,
    );
}
extern "C" {
    #[doc = " draws a polygon given a pointer to CCPoint coordinates and the number of vertices measured in points."]
    #[doc = "The polygon can be closed or open"]
    #[link_name = "\u{1}?ccDrawPoly@cocos2d@@YAXPEBVCCPoint@1@I_N@Z"]
    pub fn cocos2d_ccDrawPoly(
        vertices: *const cocos2d_CCPoint,
        numOfVertices: ::std::os::raw::c_uint,
        closePolygon: bool,
    );
}
extern "C" {
    #[doc = " draws a solid polygon given a pointer to CGPoint coordinates, the number of vertices measured in points, and a color."]
    #[link_name = "\u{1}?ccDrawSolidPoly@cocos2d@@YAXPEBVCCPoint@1@IU_ccColor4F@1@@Z"]
    pub fn cocos2d_ccDrawSolidPoly(
        poli: *const cocos2d_CCPoint,
        numberOfPoints: ::std::os::raw::c_uint,
        color: cocos2d_ccColor4F,
    );
}
extern "C" {
    #[doc = " draws a circle given the center, radius and number of segments."]
    #[link_name = "\u{1}?ccDrawCircle@cocos2d@@YAXAEBVCCPoint@1@MMI_NMM@Z"]
    pub fn cocos2d_ccDrawCircle(
        center: *const cocos2d_CCPoint,
        radius: f32,
        angle: f32,
        segments: ::std::os::raw::c_uint,
        drawLineToCenter: bool,
        scaleX: f32,
        scaleY: f32,
    );
}
extern "C" {
    #[link_name = "\u{1}?ccDrawCircle@cocos2d@@YAXAEBVCCPoint@1@MMI_N@Z"]
    pub fn cocos2d_ccDrawCircle1(
        center: *const cocos2d_CCPoint,
        radius: f32,
        angle: f32,
        segments: ::std::os::raw::c_uint,
        drawLineToCenter: bool,
    );
}
extern "C" {
    #[doc = " draws a quad bezier path"]
    #[doc = "@warning This function could be pretty slow. Use it only for debugging purposes."]
    #[doc = "@since v0.8"]
    #[link_name = "\u{1}?ccDrawQuadBezier@cocos2d@@YAXAEBVCCPoint@1@00I@Z"]
    pub fn cocos2d_ccDrawQuadBezier(
        origin: *const cocos2d_CCPoint,
        control: *const cocos2d_CCPoint,
        destination: *const cocos2d_CCPoint,
        segments: ::std::os::raw::c_uint,
    );
}
extern "C" {
    #[doc = " draws a cubic bezier path"]
    #[doc = "@warning This function could be pretty slow. Use it only for debugging purposes."]
    #[doc = "@since v0.8"]
    #[link_name = "\u{1}?ccDrawCubicBezier@cocos2d@@YAXAEBVCCPoint@1@000I@Z"]
    pub fn cocos2d_ccDrawCubicBezier(
        origin: *const cocos2d_CCPoint,
        control1: *const cocos2d_CCPoint,
        control2: *const cocos2d_CCPoint,
        destination: *const cocos2d_CCPoint,
        segments: ::std::os::raw::c_uint,
    );
}
extern "C" {
    #[doc = " draws a Catmull Rom path."]
    #[doc = "@warning This function could be pretty slow. Use it only for debugging purposes."]
    #[doc = "@since v2.0"]
    #[link_name = "\u{1}?ccDrawCatmullRom@cocos2d@@YAXPEAVCCPointArray@1@I@Z"]
    pub fn cocos2d_ccDrawCatmullRom(
        arrayOfControlPoints: *mut cocos2d_CCPointArray,
        segments: ::std::os::raw::c_uint,
    );
}
extern "C" {
    #[doc = " draws a Cardinal Spline path."]
    #[doc = "@warning This function could be pretty slow. Use it only for debugging purposes."]
    #[doc = "@since v2.0"]
    #[link_name = "\u{1}?ccDrawCardinalSpline@cocos2d@@YAXPEAVCCPointArray@1@MI@Z"]
    pub fn cocos2d_ccDrawCardinalSpline(
        config: *mut cocos2d_CCPointArray,
        tension: f32,
        segments: ::std::os::raw::c_uint,
    );
}
extern "C" {
    #[doc = " set the drawing color with 4 unsigned bytes"]
    #[doc = "@since v2.0"]
    #[link_name = "\u{1}?ccDrawColor4B@cocos2d@@YAXEEEE@Z"]
    pub fn cocos2d_ccDrawColor4B(r: GLubyte, g: GLubyte, b: GLubyte, a: GLubyte);
}
extern "C" {
    #[doc = " set the drawing color with 4 floats"]
    #[doc = "@since v2.0"]
    #[link_name = "\u{1}?ccDrawColor4F@cocos2d@@YAXMMMM@Z"]
    pub fn cocos2d_ccDrawColor4F(r: GLfloat, g: GLfloat, b: GLfloat, a: GLfloat);
}
extern "C" {
    #[doc = " set the point size in points. Default 1."]
    #[doc = "@since v2.0"]
    #[link_name = "\u{1}?ccPointSize@cocos2d@@YAXM@Z"]
    pub fn cocos2d_ccPointSize(pointSize: GLfloat);
}
#[doc = " CCDrawNode"]
#[doc = "Node that draws dots, segments and polygons."]
#[doc = "Faster than the \"drawing primitives\" since they it draws everything in one single batch."]
#[doc = ""]
#[doc = "@since v2.1"]
#[doc = "@lua NA"]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCDrawNode {
    pub _base: cocos2d_CCNode,
    pub m_uVao: GLuint,
    pub m_uVbo: GLuint,
    pub m_uBufferCapacity: ::std::os::raw::c_uint,
    pub m_nBufferCount: GLsizei,
    pub m_pBuffer: *mut cocos2d_ccV2F_C4B_T2F,
    pub m_sBlendFunc: cocos2d_ccBlendFunc,
    pub m_bDirty: bool,
}
#[test]
fn bindgen_test_layout_cocos2d_CCDrawNode() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCDrawNode>(),
        336usize,
        concat!("Size of: ", stringify!(cocos2d_CCDrawNode))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCDrawNode>(),
        8usize,
        concat!("Alignment of ", stringify!(cocos2d_CCDrawNode))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cocos2d_CCDrawNode>())).m_uVao as *const _ as usize },
        296usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCDrawNode),
            "::",
            stringify!(m_uVao)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cocos2d_CCDrawNode>())).m_uVbo as *const _ as usize },
        300usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCDrawNode),
            "::",
            stringify!(m_uVbo)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cocos2d_CCDrawNode>())).m_uBufferCapacity as *const _ as usize
        },
        304usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCDrawNode),
            "::",
            stringify!(m_uBufferCapacity)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cocos2d_CCDrawNode>())).m_nBufferCount as *const _ as usize
        },
        308usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCDrawNode),
            "::",
            stringify!(m_nBufferCount)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cocos2d_CCDrawNode>())).m_pBuffer as *const _ as usize },
        312usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCDrawNode),
            "::",
            stringify!(m_pBuffer)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cocos2d_CCDrawNode>())).m_sBlendFunc as *const _ as usize },
        320usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCDrawNode),
            "::",
            stringify!(m_sBlendFunc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cocos2d_CCDrawNode>())).m_bDirty as *const _ as usize },
        328usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCDrawNode),
            "::",
            stringify!(m_bDirty)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}?create@CCDrawNode@cocos2d@@SAPEAV12@XZ"]
    pub fn cocos2d_CCDrawNode_create() -> *mut cocos2d_CCDrawNode;
}
extern "C" {
    #[doc = " draw a dot at a position, with a given radius and color"]
    #[link_name = "\u{1}?drawDot@CCDrawNode@cocos2d@@QEAAXAEBVCCPoint@2@MAEBU_ccColor4F@2@@Z"]
    pub fn cocos2d_CCDrawNode_drawDot(
        this: *mut cocos2d_CCDrawNode,
        pos: *const cocos2d_CCPoint,
        radius: f32,
        color: *const cocos2d_ccColor4F,
    );
}
extern "C" {
    #[doc = " draw a segment with a radius and color"]
    #[link_name = "\u{1}?drawSegment@CCDrawNode@cocos2d@@QEAAXAEBVCCPoint@2@0MAEBU_ccColor4F@2@@Z"]
    pub fn cocos2d_CCDrawNode_drawSegment(
        this: *mut cocos2d_CCDrawNode,
        from: *const cocos2d_CCPoint,
        to: *const cocos2d_CCPoint,
        radius: f32,
        color: *const cocos2d_ccColor4F,
    );
}
extern "C" {
    #[doc = " draw a polygon with a fill color and line color"]
    #[doc = " @code"]
    #[doc = " when this funciton bound to js,the input params are changed"]
    #[doc = " js:var drawPolygon(var verts, var fillColor,var borderWidth,var borderColor)"]
    #[doc = " @endcode"]
    #[link_name = "\u{1}?drawPolygon@CCDrawNode@cocos2d@@QEAAXPEAVCCPoint@2@IAEBU_ccColor4F@2@M1@Z"]
    pub fn cocos2d_CCDrawNode_drawPolygon(
        this: *mut cocos2d_CCDrawNode,
        verts: *mut cocos2d_CCPoint,
        count: ::std::os::raw::c_uint,
        fillColor: *const cocos2d_ccColor4F,
        borderWidth: f32,
        borderColor: *const cocos2d_ccColor4F,
    );
}
extern "C" {
    #[doc = " Clear the geometry in the node's buffer."]
    #[link_name = "\u{1}?clear@CCDrawNode@cocos2d@@QEAAXXZ"]
    pub fn cocos2d_CCDrawNode_clear(this: *mut cocos2d_CCDrawNode);
}
extern "C" {
    #[doc = " @js NA"]
    #[link_name = "\u{1}?getBlendFunc@CCDrawNode@cocos2d@@QEBA?AU_ccBlendFunc@2@XZ"]
    pub fn cocos2d_CCDrawNode_getBlendFunc(this: *const cocos2d_CCDrawNode) -> cocos2d_ccBlendFunc;
}
extern "C" {
    #[doc = " @code"]
    #[doc = " when this function bound to js ,the input param is change"]
    #[doc = " js:var setBlendFunc(var src,var dst)"]
    #[doc = " @endcode"]
    #[link_name = "\u{1}?setBlendFunc@CCDrawNode@cocos2d@@QEAAXAEBU_ccBlendFunc@2@@Z"]
    pub fn cocos2d_CCDrawNode_setBlendFunc(
        this: *mut cocos2d_CCDrawNode,
        blendFunc: *const cocos2d_ccBlendFunc,
    );
}
extern "C" {
    #[doc = " listen the event that coming to foreground on Android"]
    #[doc = " @js NA"]
    #[link_name = "\u{1}?listenBackToForeground@CCDrawNode@cocos2d@@QEAAXPEAVCCObject@2@@Z"]
    pub fn cocos2d_CCDrawNode_listenBackToForeground(
        this: *mut cocos2d_CCDrawNode,
        obj: *mut cocos2d_CCObject,
    );
}
extern "C" {
    #[link_name = "\u{1}??0CCDrawNode@cocos2d@@QEAA@XZ"]
    pub fn cocos2d_CCDrawNode_CCDrawNode(this: *mut cocos2d_CCDrawNode);
}
impl cocos2d_CCDrawNode {
    #[inline]
    pub unsafe fn create() -> *mut cocos2d_CCDrawNode {
        cocos2d_CCDrawNode_create()
    }
    #[inline]
    pub unsafe fn drawDot(
        &mut self,
        pos: *const cocos2d_CCPoint,
        radius: f32,
        color: *const cocos2d_ccColor4F,
    ) {
        cocos2d_CCDrawNode_drawDot(self, pos, radius, color)
    }
    #[inline]
    pub unsafe fn drawSegment(
        &mut self,
        from: *const cocos2d_CCPoint,
        to: *const cocos2d_CCPoint,
        radius: f32,
        color: *const cocos2d_ccColor4F,
    ) {
        cocos2d_CCDrawNode_drawSegment(self, from, to, radius, color)
    }
    #[inline]
    pub unsafe fn drawPolygon(
        &mut self,
        verts: *mut cocos2d_CCPoint,
        count: ::std::os::raw::c_uint,
        fillColor: *const cocos2d_ccColor4F,
        borderWidth: f32,
        borderColor: *const cocos2d_ccColor4F,
    ) {
        cocos2d_CCDrawNode_drawPolygon(self, verts, count, fillColor, borderWidth, borderColor)
    }
    #[inline]
    pub unsafe fn clear(&mut self) {
        cocos2d_CCDrawNode_clear(self)
    }
    #[inline]
    pub unsafe fn getBlendFunc(&self) -> cocos2d_ccBlendFunc {
        cocos2d_CCDrawNode_getBlendFunc(self)
    }
    #[inline]
    pub unsafe fn setBlendFunc(&mut self, blendFunc: *const cocos2d_ccBlendFunc) {
        cocos2d_CCDrawNode_setBlendFunc(self, blendFunc)
    }
    #[inline]
    pub unsafe fn listenBackToForeground(&mut self, obj: *mut cocos2d_CCObject) {
        cocos2d_CCDrawNode_listenBackToForeground(self, obj)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cocos2d_CCDrawNode_CCDrawNode(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
}
extern "C" {
    #[link_name = "\u{1}??_DCCDrawNode@cocos2d@@QEAAXXZ"]
    pub fn cocos2d_CCDrawNode_CCDrawNode_destructor(this: *mut cocos2d_CCDrawNode);
}
extern "C" {
    #[link_name = "\u{1}?init@CCDrawNode@cocos2d@@UEAA_NXZ"]
    pub fn cocos2d_CCDrawNode_init(this: *mut ::std::os::raw::c_void) -> bool;
}
extern "C" {
    #[link_name = "\u{1}?draw@CCDrawNode@cocos2d@@UEAAXXZ"]
    pub fn cocos2d_CCDrawNode_draw(this: *mut ::std::os::raw::c_void);
}
pub const cocos2d__ccConfigurationType_ConfigurationError: cocos2d__ccConfigurationType = 0;
pub const cocos2d__ccConfigurationType_ConfigurationString: cocos2d__ccConfigurationType = 1;
pub const cocos2d__ccConfigurationType_ConfigurationInt: cocos2d__ccConfigurationType = 2;
pub const cocos2d__ccConfigurationType_ConfigurationDouble: cocos2d__ccConfigurationType = 3;
pub const cocos2d__ccConfigurationType_ConfigurationBoolean: cocos2d__ccConfigurationType = 4;
pub type cocos2d__ccConfigurationType = ::std::os::raw::c_int;
pub use self::cocos2d__ccConfigurationType as cocos2d_ccConfigurationType;
#[doc = " @addtogroup global"]
#[doc = " @{"]
#[doc = "@brief CCConfiguration contains some openGL variables"]
#[doc = "@since v0.99.0"]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCConfiguration {
    pub _base: cocos2d_CCObject,
    pub m_nMaxTextureSize: GLint,
    pub m_nMaxModelviewStackDepth: GLint,
    pub m_bSupportsPVRTC: bool,
    pub m_bSupportsNPOT: bool,
    pub m_bSupportsBGRA8888: bool,
    pub m_bSupportsDiscardFramebuffer: bool,
    pub m_bSupportsShareableVAO: bool,
    pub m_nMaxSamplesAllowed: GLint,
    pub m_nMaxTextureUnits: GLint,
    pub m_pGlExtensions: *mut ::std::os::raw::c_char,
    pub m_pValueDict: *mut cocos2d_CCDictionary,
}
extern "C" {
    #[link_name = "\u{1}?s_gSharedConfiguration@CCConfiguration@cocos2d@@0PEAV12@EA"]
    pub static mut cocos2d_CCConfiguration_s_gSharedConfiguration: *mut cocos2d_CCConfiguration;
}
extern "C" {
    #[link_name = "\u{1}?s_sConfigfile@CCConfiguration@cocos2d@@0V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A"]
    pub static mut cocos2d_CCConfiguration_s_sConfigfile: std_string;
}
#[test]
fn bindgen_test_layout_cocos2d_CCConfiguration() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCConfiguration>(),
        80usize,
        concat!("Size of: ", stringify!(cocos2d_CCConfiguration))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCConfiguration>(),
        8usize,
        concat!("Alignment of ", stringify!(cocos2d_CCConfiguration))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cocos2d_CCConfiguration>())).m_nMaxTextureSize as *const _
                as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCConfiguration),
            "::",
            stringify!(m_nMaxTextureSize)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cocos2d_CCConfiguration>())).m_nMaxModelviewStackDepth
                as *const _ as usize
        },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCConfiguration),
            "::",
            stringify!(m_nMaxModelviewStackDepth)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cocos2d_CCConfiguration>())).m_bSupportsPVRTC as *const _
                as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCConfiguration),
            "::",
            stringify!(m_bSupportsPVRTC)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cocos2d_CCConfiguration>())).m_bSupportsNPOT as *const _ as usize
        },
        49usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCConfiguration),
            "::",
            stringify!(m_bSupportsNPOT)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cocos2d_CCConfiguration>())).m_bSupportsBGRA8888 as *const _
                as usize
        },
        50usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCConfiguration),
            "::",
            stringify!(m_bSupportsBGRA8888)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cocos2d_CCConfiguration>())).m_bSupportsDiscardFramebuffer
                as *const _ as usize
        },
        51usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCConfiguration),
            "::",
            stringify!(m_bSupportsDiscardFramebuffer)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cocos2d_CCConfiguration>())).m_bSupportsShareableVAO as *const _
                as usize
        },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCConfiguration),
            "::",
            stringify!(m_bSupportsShareableVAO)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cocos2d_CCConfiguration>())).m_nMaxSamplesAllowed as *const _
                as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCConfiguration),
            "::",
            stringify!(m_nMaxSamplesAllowed)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cocos2d_CCConfiguration>())).m_nMaxTextureUnits as *const _
                as usize
        },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCConfiguration),
            "::",
            stringify!(m_nMaxTextureUnits)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cocos2d_CCConfiguration>())).m_pGlExtensions as *const _ as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCConfiguration),
            "::",
            stringify!(m_pGlExtensions)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cocos2d_CCConfiguration>())).m_pValueDict as *const _ as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCConfiguration),
            "::",
            stringify!(m_pValueDict)
        )
    );
}
extern "C" {
    #[doc = " returns a shared instance of CCConfiguration"]
    #[link_name = "\u{1}?sharedConfiguration@CCConfiguration@cocos2d@@SAPEAV12@XZ"]
    pub fn cocos2d_CCConfiguration_sharedConfiguration() -> *mut cocos2d_CCConfiguration;
}
extern "C" {
    #[doc = " purge the shared instance of CCConfiguration"]
    #[link_name = "\u{1}?purgeConfiguration@CCConfiguration@cocos2d@@SAXXZ"]
    pub fn cocos2d_CCConfiguration_purgeConfiguration();
}
extern "C" {
    #[doc = " OpenGL Max texture size."]
    #[link_name = "\u{1}?getMaxTextureSize@CCConfiguration@cocos2d@@QEBAHXZ"]
    pub fn cocos2d_CCConfiguration_getMaxTextureSize(
        this: *const cocos2d_CCConfiguration,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " OpenGL Max Modelview Stack Depth."]
    #[link_name = "\u{1}?getMaxModelviewStackDepth@CCConfiguration@cocos2d@@QEBAHXZ"]
    pub fn cocos2d_CCConfiguration_getMaxModelviewStackDepth(
        this: *const cocos2d_CCConfiguration,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " returns the maximum texture units"]
    #[doc = "@since v2.0.0"]
    #[link_name = "\u{1}?getMaxTextureUnits@CCConfiguration@cocos2d@@QEBAHXZ"]
    pub fn cocos2d_CCConfiguration_getMaxTextureUnits(
        this: *const cocos2d_CCConfiguration,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Whether or not the GPU supports NPOT (Non Power Of Two) textures."]
    #[doc = "OpenGL ES 2.0 already supports NPOT (iOS)."]
    #[doc = ""]
    #[doc = "@since v0.99.2"]
    #[link_name = "\u{1}?supportsNPOT@CCConfiguration@cocos2d@@QEBA_NXZ"]
    pub fn cocos2d_CCConfiguration_supportsNPOT(this: *const cocos2d_CCConfiguration) -> bool;
}
extern "C" {
    #[doc = " Whether or not PVR Texture Compressed is supported"]
    #[link_name = "\u{1}?supportsPVRTC@CCConfiguration@cocos2d@@QEBA_NXZ"]
    pub fn cocos2d_CCConfiguration_supportsPVRTC(this: *const cocos2d_CCConfiguration) -> bool;
}
extern "C" {
    #[doc = " Whether or not BGRA8888 textures are supported."]
    #[doc = "@since v0.99.2"]
    #[link_name = "\u{1}?supportsBGRA8888@CCConfiguration@cocos2d@@QEBA_NXZ"]
    pub fn cocos2d_CCConfiguration_supportsBGRA8888(this: *const cocos2d_CCConfiguration) -> bool;
}
extern "C" {
    #[doc = " Whether or not glDiscardFramebufferEXT is supported"]
    #[doc = "@since v0.99.2"]
    #[link_name = "\u{1}?supportsDiscardFramebuffer@CCConfiguration@cocos2d@@QEBA_NXZ"]
    pub fn cocos2d_CCConfiguration_supportsDiscardFramebuffer(
        this: *const cocos2d_CCConfiguration,
    ) -> bool;
}
extern "C" {
    #[doc = " Whether or not shareable VAOs are supported."]
    #[doc = "@since v2.0.0"]
    #[link_name = "\u{1}?supportsShareableVAO@CCConfiguration@cocos2d@@QEBA_NXZ"]
    pub fn cocos2d_CCConfiguration_supportsShareableVAO(
        this: *const cocos2d_CCConfiguration,
    ) -> bool;
}
extern "C" {
    #[doc = " returns whether or not an OpenGL is supported"]
    #[link_name = "\u{1}?checkForGLExtension@CCConfiguration@cocos2d@@QEBA_NAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z"]
    pub fn cocos2d_CCConfiguration_checkForGLExtension(
        this: *const cocos2d_CCConfiguration,
        searchName: *const std_string,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}?init@CCConfiguration@cocos2d@@QEAA_NXZ"]
    pub fn cocos2d_CCConfiguration_init(this: *mut cocos2d_CCConfiguration) -> bool;
}
extern "C" {
    #[doc = " returns the value of a given key as a string."]
    #[doc = "If the key is not found, it will return the default value"]
    #[link_name = "\u{1}?getCString@CCConfiguration@cocos2d@@QEBAPEBDPEBD0@Z"]
    pub fn cocos2d_CCConfiguration_getCString(
        this: *const cocos2d_CCConfiguration,
        key: *const ::std::os::raw::c_char,
        default_value: *const ::std::os::raw::c_char,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " returns the value of a given key as a boolean."]
    #[doc = "If the key is not found, it will return the default value"]
    #[link_name = "\u{1}?getBool@CCConfiguration@cocos2d@@QEBA_NPEBD_N@Z"]
    pub fn cocos2d_CCConfiguration_getBool(
        this: *const cocos2d_CCConfiguration,
        key: *const ::std::os::raw::c_char,
        default_value: bool,
    ) -> bool;
}
extern "C" {
    #[doc = " returns the value of a given key as a double."]
    #[doc = "If the key is not found, it will return the default value"]
    #[link_name = "\u{1}?getNumber@CCConfiguration@cocos2d@@QEBANPEBDN@Z"]
    pub fn cocos2d_CCConfiguration_getNumber(
        this: *const cocos2d_CCConfiguration,
        key: *const ::std::os::raw::c_char,
        default_value: f64,
    ) -> f64;
}
extern "C" {
    #[doc = " returns the value of a given key as a double"]
    #[link_name = "\u{1}?getObject@CCConfiguration@cocos2d@@QEBAPEAVCCObject@2@PEBD@Z"]
    pub fn cocos2d_CCConfiguration_getObject(
        this: *const cocos2d_CCConfiguration,
        key: *const ::std::os::raw::c_char,
    ) -> *mut cocos2d_CCObject;
}
extern "C" {
    #[doc = " sets a new key/value pair  in the configuration dictionary"]
    #[link_name = "\u{1}?setObject@CCConfiguration@cocos2d@@QEAAXPEBDPEAVCCObject@2@@Z"]
    pub fn cocos2d_CCConfiguration_setObject(
        this: *mut cocos2d_CCConfiguration,
        key: *const ::std::os::raw::c_char,
        value: *mut cocos2d_CCObject,
    );
}
extern "C" {
    #[doc = " dumps the current configuration on the console"]
    #[link_name = "\u{1}?dumpInfo@CCConfiguration@cocos2d@@QEBAXXZ"]
    pub fn cocos2d_CCConfiguration_dumpInfo(this: *const cocos2d_CCConfiguration);
}
extern "C" {
    #[doc = " gathers OpenGL / GPU information"]
    #[link_name = "\u{1}?gatherGPUInfo@CCConfiguration@cocos2d@@QEAAXXZ"]
    pub fn cocos2d_CCConfiguration_gatherGPUInfo(this: *mut cocos2d_CCConfiguration);
}
extern "C" {
    #[doc = " Loads a config file. If the keys are already present, then they are going to be replaced. Otherwise the new keys are added."]
    #[link_name = "\u{1}?loadConfigFile@CCConfiguration@cocos2d@@QEAAXPEBD@Z"]
    pub fn cocos2d_CCConfiguration_loadConfigFile(
        this: *mut cocos2d_CCConfiguration,
        filename: *const ::std::os::raw::c_char,
    );
}
impl cocos2d_CCConfiguration {
    #[inline]
    pub unsafe fn sharedConfiguration() -> *mut cocos2d_CCConfiguration {
        cocos2d_CCConfiguration_sharedConfiguration()
    }
    #[inline]
    pub unsafe fn purgeConfiguration() {
        cocos2d_CCConfiguration_purgeConfiguration()
    }
    #[inline]
    pub unsafe fn getMaxTextureSize(&self) -> ::std::os::raw::c_int {
        cocos2d_CCConfiguration_getMaxTextureSize(self)
    }
    #[inline]
    pub unsafe fn getMaxModelviewStackDepth(&self) -> ::std::os::raw::c_int {
        cocos2d_CCConfiguration_getMaxModelviewStackDepth(self)
    }
    #[inline]
    pub unsafe fn getMaxTextureUnits(&self) -> ::std::os::raw::c_int {
        cocos2d_CCConfiguration_getMaxTextureUnits(self)
    }
    #[inline]
    pub unsafe fn supportsNPOT(&self) -> bool {
        cocos2d_CCConfiguration_supportsNPOT(self)
    }
    #[inline]
    pub unsafe fn supportsPVRTC(&self) -> bool {
        cocos2d_CCConfiguration_supportsPVRTC(self)
    }
    #[inline]
    pub unsafe fn supportsBGRA8888(&self) -> bool {
        cocos2d_CCConfiguration_supportsBGRA8888(self)
    }
    #[inline]
    pub unsafe fn supportsDiscardFramebuffer(&self) -> bool {
        cocos2d_CCConfiguration_supportsDiscardFramebuffer(self)
    }
    #[inline]
    pub unsafe fn supportsShareableVAO(&self) -> bool {
        cocos2d_CCConfiguration_supportsShareableVAO(self)
    }
    #[inline]
    pub unsafe fn checkForGLExtension(&self, searchName: *const std_string) -> bool {
        cocos2d_CCConfiguration_checkForGLExtension(self, searchName)
    }
    #[inline]
    pub unsafe fn init(&mut self) -> bool {
        cocos2d_CCConfiguration_init(self)
    }
    #[inline]
    pub unsafe fn getCString(
        &self,
        key: *const ::std::os::raw::c_char,
        default_value: *const ::std::os::raw::c_char,
    ) -> *const ::std::os::raw::c_char {
        cocos2d_CCConfiguration_getCString(self, key, default_value)
    }
    #[inline]
    pub unsafe fn getBool(&self, key: *const ::std::os::raw::c_char, default_value: bool) -> bool {
        cocos2d_CCConfiguration_getBool(self, key, default_value)
    }
    #[inline]
    pub unsafe fn getNumber(&self, key: *const ::std::os::raw::c_char, default_value: f64) -> f64 {
        cocos2d_CCConfiguration_getNumber(self, key, default_value)
    }
    #[inline]
    pub unsafe fn getObject(&self, key: *const ::std::os::raw::c_char) -> *mut cocos2d_CCObject {
        cocos2d_CCConfiguration_getObject(self, key)
    }
    #[inline]
    pub unsafe fn setObject(
        &mut self,
        key: *const ::std::os::raw::c_char,
        value: *mut cocos2d_CCObject,
    ) {
        cocos2d_CCConfiguration_setObject(self, key, value)
    }
    #[inline]
    pub unsafe fn dumpInfo(&self) {
        cocos2d_CCConfiguration_dumpInfo(self)
    }
    #[inline]
    pub unsafe fn gatherGPUInfo(&mut self) {
        cocos2d_CCConfiguration_gatherGPUInfo(self)
    }
    #[inline]
    pub unsafe fn loadConfigFile(&mut self, filename: *const ::std::os::raw::c_char) {
        cocos2d_CCConfiguration_loadConfigFile(self, filename)
    }
}
extern "C" {
    #[doc = "  @js NA"]
    #[doc = "  @lua NA"]
    #[link_name = "\u{1}??_DCCConfiguration@cocos2d@@QEAAXXZ"]
    pub fn cocos2d_CCConfiguration_CCConfiguration_destructor(this: *mut cocos2d_CCConfiguration);
}
#[doc = " FBO class that grabs the the contents of the screen"]
#[doc = " @js NA"]
#[doc = " @lua NA"]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCGrabber {
    pub _base: cocos2d_CCObject,
    pub m_FBO: GLuint,
    pub m_oldFBO: GLint,
    pub m_oldClearColor: [GLfloat; 4usize],
}
#[test]
fn bindgen_test_layout_cocos2d_CCGrabber() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCGrabber>(),
        64usize,
        concat!("Size of: ", stringify!(cocos2d_CCGrabber))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCGrabber>(),
        8usize,
        concat!("Alignment of ", stringify!(cocos2d_CCGrabber))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cocos2d_CCGrabber>())).m_FBO as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCGrabber),
            "::",
            stringify!(m_FBO)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cocos2d_CCGrabber>())).m_oldFBO as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCGrabber),
            "::",
            stringify!(m_oldFBO)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cocos2d_CCGrabber>())).m_oldClearColor as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCGrabber),
            "::",
            stringify!(m_oldClearColor)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}?grab@CCGrabber@cocos2d@@QEAAXPEAVCCTexture2D@2@@Z"]
    pub fn cocos2d_CCGrabber_grab(this: *mut cocos2d_CCGrabber, pTexture: *mut cocos2d_CCTexture2D);
}
extern "C" {
    #[link_name = "\u{1}?beforeRender@CCGrabber@cocos2d@@QEAAXPEAVCCTexture2D@2@@Z"]
    pub fn cocos2d_CCGrabber_beforeRender(
        this: *mut cocos2d_CCGrabber,
        pTexture: *mut cocos2d_CCTexture2D,
    );
}
extern "C" {
    #[link_name = "\u{1}?afterRender@CCGrabber@cocos2d@@QEAAXPEAVCCTexture2D@2@@Z"]
    pub fn cocos2d_CCGrabber_afterRender(
        this: *mut cocos2d_CCGrabber,
        pTexture: *mut cocos2d_CCTexture2D,
    );
}
extern "C" {
    #[link_name = "\u{1}??0CCGrabber@cocos2d@@QEAA@XZ"]
    pub fn cocos2d_CCGrabber_CCGrabber(this: *mut cocos2d_CCGrabber);
}
impl cocos2d_CCGrabber {
    #[inline]
    pub unsafe fn grab(&mut self, pTexture: *mut cocos2d_CCTexture2D) {
        cocos2d_CCGrabber_grab(self, pTexture)
    }
    #[inline]
    pub unsafe fn beforeRender(&mut self, pTexture: *mut cocos2d_CCTexture2D) {
        cocos2d_CCGrabber_beforeRender(self, pTexture)
    }
    #[inline]
    pub unsafe fn afterRender(&mut self, pTexture: *mut cocos2d_CCTexture2D) {
        cocos2d_CCGrabber_afterRender(self, pTexture)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cocos2d_CCGrabber_CCGrabber(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
}
extern "C" {
    #[link_name = "\u{1}??_DCCGrabber@cocos2d@@QEAAXXZ"]
    pub fn cocos2d_CCGrabber_CCGrabber_destructor(this: *mut cocos2d_CCGrabber);
}
#[doc = "A CCCamera is used in every CCNode."]
#[doc = "Useful to look at the object from different views."]
#[doc = "The OpenGL gluLookAt() function is used to locate the"]
#[doc = "camera."]
#[doc = ""]
#[doc = "If the object is transformed by any of the scale, rotation or"]
#[doc = "position attributes, then they will override the camera."]
#[doc = ""]
#[doc = "IMPORTANT: Either your use the camera or the rotation/scale/position properties. You can't use both."]
#[doc = "World coordinates won't work if you use the camera."]
#[doc = ""]
#[doc = "Limitations:"]
#[doc = ""]
#[doc = "- Some nodes, like CCParallaxNode, CCParticle uses world node coordinates, and they won't work properly if you move them (or any of their ancestors)"]
#[doc = "using the camera."]
#[doc = ""]
#[doc = "- It doesn't work on batched nodes like CCSprite objects when they are parented to a CCSpriteBatchNode object."]
#[doc = ""]
#[doc = "- It is recommended to use it ONLY if you are going to create 3D effects. For 2D effects, use the action CCFollow or position/scale/rotate."]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCCamera {
    pub _base: cocos2d_CCObject,
    pub m_fEyeX: f32,
    pub m_fEyeY: f32,
    pub m_fEyeZ: f32,
    pub m_fCenterX: f32,
    pub m_fCenterY: f32,
    pub m_fCenterZ: f32,
    pub m_fUpX: f32,
    pub m_fUpY: f32,
    pub m_fUpZ: f32,
    pub m_bDirty: bool,
    pub m_lookupMatrix: kmMat4,
}
#[test]
fn bindgen_test_layout_cocos2d_CCCamera() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCCamera>(),
        144usize,
        concat!("Size of: ", stringify!(cocos2d_CCCamera))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCCamera>(),
        8usize,
        concat!("Alignment of ", stringify!(cocos2d_CCCamera))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cocos2d_CCCamera>())).m_fEyeX as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCCamera),
            "::",
            stringify!(m_fEyeX)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cocos2d_CCCamera>())).m_fEyeY as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCCamera),
            "::",
            stringify!(m_fEyeY)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cocos2d_CCCamera>())).m_fEyeZ as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCCamera),
            "::",
            stringify!(m_fEyeZ)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cocos2d_CCCamera>())).m_fCenterX as *const _ as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCCamera),
            "::",
            stringify!(m_fCenterX)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cocos2d_CCCamera>())).m_fCenterY as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCCamera),
            "::",
            stringify!(m_fCenterY)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cocos2d_CCCamera>())).m_fCenterZ as *const _ as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCCamera),
            "::",
            stringify!(m_fCenterZ)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cocos2d_CCCamera>())).m_fUpX as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCCamera),
            "::",
            stringify!(m_fUpX)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cocos2d_CCCamera>())).m_fUpY as *const _ as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCCamera),
            "::",
            stringify!(m_fUpY)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cocos2d_CCCamera>())).m_fUpZ as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCCamera),
            "::",
            stringify!(m_fUpZ)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cocos2d_CCCamera>())).m_bDirty as *const _ as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCCamera),
            "::",
            stringify!(m_bDirty)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cocos2d_CCCamera>())).m_lookupMatrix as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCCamera),
            "::",
            stringify!(m_lookupMatrix)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}?init@CCCamera@cocos2d@@QEAAXXZ"]
    pub fn cocos2d_CCCamera_init(this: *mut cocos2d_CCCamera);
}
extern "C" {
    #[doc = "  @js NA"]
    #[link_name = "\u{1}?description@CCCamera@cocos2d@@QEAAPEBDXZ"]
    pub fn cocos2d_CCCamera_description(
        this: *mut cocos2d_CCCamera,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " sets the camera in the default position"]
    #[link_name = "\u{1}?restore@CCCamera@cocos2d@@QEAAXXZ"]
    pub fn cocos2d_CCCamera_restore(this: *mut cocos2d_CCCamera);
}
extern "C" {
    #[doc = " Sets the camera using gluLookAt using its eye, center and up_vector"]
    #[link_name = "\u{1}?locate@CCCamera@cocos2d@@QEAAXXZ"]
    pub fn cocos2d_CCCamera_locate(this: *mut cocos2d_CCCamera);
}
extern "C" {
    #[doc = " sets the eye values in points"]
    #[doc = "  @js setEye"]
    #[link_name = "\u{1}?setEyeXYZ@CCCamera@cocos2d@@QEAAXMMM@Z"]
    pub fn cocos2d_CCCamera_setEyeXYZ(
        this: *mut cocos2d_CCCamera,
        fEyeX: f32,
        fEyeY: f32,
        fEyeZ: f32,
    );
}
extern "C" {
    #[doc = " sets the center values in points"]
    #[doc = "  @js setCenter"]
    #[link_name = "\u{1}?setCenterXYZ@CCCamera@cocos2d@@QEAAXMMM@Z"]
    pub fn cocos2d_CCCamera_setCenterXYZ(
        this: *mut cocos2d_CCCamera,
        fCenterX: f32,
        fCenterY: f32,
        fCenterZ: f32,
    );
}
extern "C" {
    #[doc = " sets the up values"]
    #[doc = "  @js setUp"]
    #[link_name = "\u{1}?setUpXYZ@CCCamera@cocos2d@@QEAAXMMM@Z"]
    pub fn cocos2d_CCCamera_setUpXYZ(this: *mut cocos2d_CCCamera, fUpX: f32, fUpY: f32, fUpZ: f32);
}
extern "C" {
    #[doc = " get the eye vector values in points"]
    #[doc = "  @js NA"]
    #[link_name = "\u{1}?getEyeXYZ@CCCamera@cocos2d@@QEAAXPEAM00@Z"]
    pub fn cocos2d_CCCamera_getEyeXYZ(
        this: *mut cocos2d_CCCamera,
        pEyeX: *mut f32,
        pEyeY: *mut f32,
        pEyeZ: *mut f32,
    );
}
extern "C" {
    #[doc = " get the center vector values int points"]
    #[doc = "  @js NA"]
    #[link_name = "\u{1}?getCenterXYZ@CCCamera@cocos2d@@QEAAXPEAM00@Z"]
    pub fn cocos2d_CCCamera_getCenterXYZ(
        this: *mut cocos2d_CCCamera,
        pCenterX: *mut f32,
        pCenterY: *mut f32,
        pCenterZ: *mut f32,
    );
}
extern "C" {
    #[doc = " get the up vector values"]
    #[doc = "  @js NA"]
    #[link_name = "\u{1}?getUpXYZ@CCCamera@cocos2d@@QEAAXPEAM00@Z"]
    pub fn cocos2d_CCCamera_getUpXYZ(
        this: *mut cocos2d_CCCamera,
        pUpX: *mut f32,
        pUpY: *mut f32,
        pUpZ: *mut f32,
    );
}
extern "C" {
    #[doc = " returns the Z eye"]
    #[link_name = "\u{1}?getZEye@CCCamera@cocos2d@@SAMXZ"]
    pub fn cocos2d_CCCamera_getZEye() -> f32;
}
extern "C" {
    #[doc = "  @js ctor"]
    #[link_name = "\u{1}??0CCCamera@cocos2d@@QEAA@XZ"]
    pub fn cocos2d_CCCamera_CCCamera(this: *mut cocos2d_CCCamera);
}
impl cocos2d_CCCamera {
    #[inline]
    pub unsafe fn init(&mut self) {
        cocos2d_CCCamera_init(self)
    }
    #[inline]
    pub unsafe fn description(&mut self) -> *const ::std::os::raw::c_char {
        cocos2d_CCCamera_description(self)
    }
    #[inline]
    pub unsafe fn restore(&mut self) {
        cocos2d_CCCamera_restore(self)
    }
    #[inline]
    pub unsafe fn locate(&mut self) {
        cocos2d_CCCamera_locate(self)
    }
    #[inline]
    pub unsafe fn setEyeXYZ(&mut self, fEyeX: f32, fEyeY: f32, fEyeZ: f32) {
        cocos2d_CCCamera_setEyeXYZ(self, fEyeX, fEyeY, fEyeZ)
    }
    #[inline]
    pub unsafe fn setCenterXYZ(&mut self, fCenterX: f32, fCenterY: f32, fCenterZ: f32) {
        cocos2d_CCCamera_setCenterXYZ(self, fCenterX, fCenterY, fCenterZ)
    }
    #[inline]
    pub unsafe fn setUpXYZ(&mut self, fUpX: f32, fUpY: f32, fUpZ: f32) {
        cocos2d_CCCamera_setUpXYZ(self, fUpX, fUpY, fUpZ)
    }
    #[inline]
    pub unsafe fn getEyeXYZ(&mut self, pEyeX: *mut f32, pEyeY: *mut f32, pEyeZ: *mut f32) {
        cocos2d_CCCamera_getEyeXYZ(self, pEyeX, pEyeY, pEyeZ)
    }
    #[inline]
    pub unsafe fn getCenterXYZ(
        &mut self,
        pCenterX: *mut f32,
        pCenterY: *mut f32,
        pCenterZ: *mut f32,
    ) {
        cocos2d_CCCamera_getCenterXYZ(self, pCenterX, pCenterY, pCenterZ)
    }
    #[inline]
    pub unsafe fn getUpXYZ(&mut self, pUpX: *mut f32, pUpY: *mut f32, pUpZ: *mut f32) {
        cocos2d_CCCamera_getUpXYZ(self, pUpX, pUpY, pUpZ)
    }
    #[inline]
    pub unsafe fn getZEye() -> f32 {
        cocos2d_CCCamera_getZEye()
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cocos2d_CCCamera_CCCamera(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
}
extern "C" {
    #[doc = "  @js NA"]
    #[doc = "  @lua NA"]
    #[link_name = "\u{1}??_DCCCamera@cocos2d@@QEAAXXZ"]
    pub fn cocos2d_CCCamera_CCCamera_destructor(this: *mut cocos2d_CCCamera);
}
#[doc = " @brief CCLabelAtlas is a subclass of CCAtlasNode."]
#[doc = ""]
#[doc = "It can be as a replacement of CCLabel since it is MUCH faster."]
#[doc = ""]
#[doc = "CCLabelAtlas versus CCLabel:"]
#[doc = "- CCLabelAtlas is MUCH faster than CCLabel"]
#[doc = "- CCLabelAtlas \"characters\" have a fixed height and width"]
#[doc = "- CCLabelAtlas \"characters\" can be anything you want since they are taken from an image file"]
#[doc = ""]
#[doc = "A more flexible class is CCLabelBMFont. It supports variable width characters and it also has a nice editor."]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCLabelAtlas {
    pub _base: cocos2d_CCAtlasNode,
    pub _base_1: cocos2d_CCLabelProtocol,
    pub m_sString: std_string,
    pub m_uMapStartChar: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_cocos2d_CCLabelAtlas() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCLabelAtlas>(),
        432usize,
        concat!("Size of: ", stringify!(cocos2d_CCLabelAtlas))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCLabelAtlas>(),
        8usize,
        concat!("Alignment of ", stringify!(cocos2d_CCLabelAtlas))
    );
}
extern "C" {
    #[doc = " creates the CCLabelAtlas with a string, a char map file(the atlas), the width and height of each element and the starting char of the atlas"]
    #[link_name = "\u{1}?create@CCLabelAtlas@cocos2d@@SAPEAV12@PEBD0III@Z"]
    pub fn cocos2d_CCLabelAtlas_create(
        string: *const ::std::os::raw::c_char,
        charMapFile: *const ::std::os::raw::c_char,
        itemWidth: ::std::os::raw::c_uint,
        itemHeight: ::std::os::raw::c_uint,
        startCharMap: ::std::os::raw::c_uint,
    ) -> *mut cocos2d_CCLabelAtlas;
}
extern "C" {
    #[doc = " creates the CCLabelAtlas with a string and a configuration file"]
    #[doc = "@since v2.0"]
    #[doc = "@js _create"]
    #[link_name = "\u{1}?create@CCLabelAtlas@cocos2d@@SAPEAV12@PEBD0@Z"]
    pub fn cocos2d_CCLabelAtlas_create1(
        string: *const ::std::os::raw::c_char,
        fntFile: *const ::std::os::raw::c_char,
    ) -> *mut cocos2d_CCLabelAtlas;
}
extern "C" {
    #[doc = " initializes the CCLabelAtlas with a string, a char map file(the atlas), the width and height of each element and the starting char of the atlas"]
    #[link_name = "\u{1}?initWithString@CCLabelAtlas@cocos2d@@QEAA_NPEBD0III@Z"]
    pub fn cocos2d_CCLabelAtlas_initWithString(
        this: *mut cocos2d_CCLabelAtlas,
        string: *const ::std::os::raw::c_char,
        charMapFile: *const ::std::os::raw::c_char,
        itemWidth: ::std::os::raw::c_uint,
        itemHeight: ::std::os::raw::c_uint,
        startCharMap: ::std::os::raw::c_uint,
    ) -> bool;
}
extern "C" {
    #[doc = " initializes the CCLabelAtlas with a string and a configuration file"]
    #[doc = "@since v2.0"]
    #[link_name = "\u{1}?initWithString@CCLabelAtlas@cocos2d@@QEAA_NPEBD0@Z"]
    pub fn cocos2d_CCLabelAtlas_initWithString1(
        this: *mut cocos2d_CCLabelAtlas,
        string: *const ::std::os::raw::c_char,
        fntFile: *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    #[doc = " initializes the CCLabelAtlas with a string, a texture, the width and height in points of each element and the starting char of the atlas"]
    #[link_name = "\u{1}?initWithString@CCLabelAtlas@cocos2d@@QEAA_NPEBDPEAVCCTexture2D@2@III@Z"]
    pub fn cocos2d_CCLabelAtlas_initWithString2(
        this: *mut cocos2d_CCLabelAtlas,
        string: *const ::std::os::raw::c_char,
        texture: *mut cocos2d_CCTexture2D,
        itemWidth: ::std::os::raw::c_uint,
        itemHeight: ::std::os::raw::c_uint,
        startCharMap: ::std::os::raw::c_uint,
    ) -> bool;
}
impl cocos2d_CCLabelAtlas {
    #[inline]
    pub unsafe fn create(
        string: *const ::std::os::raw::c_char,
        charMapFile: *const ::std::os::raw::c_char,
        itemWidth: ::std::os::raw::c_uint,
        itemHeight: ::std::os::raw::c_uint,
        startCharMap: ::std::os::raw::c_uint,
    ) -> *mut cocos2d_CCLabelAtlas {
        cocos2d_CCLabelAtlas_create(string, charMapFile, itemWidth, itemHeight, startCharMap)
    }
    #[inline]
    pub unsafe fn create1(
        string: *const ::std::os::raw::c_char,
        fntFile: *const ::std::os::raw::c_char,
    ) -> *mut cocos2d_CCLabelAtlas {
        cocos2d_CCLabelAtlas_create1(string, fntFile)
    }
    #[inline]
    pub unsafe fn initWithString(
        &mut self,
        string: *const ::std::os::raw::c_char,
        charMapFile: *const ::std::os::raw::c_char,
        itemWidth: ::std::os::raw::c_uint,
        itemHeight: ::std::os::raw::c_uint,
        startCharMap: ::std::os::raw::c_uint,
    ) -> bool {
        cocos2d_CCLabelAtlas_initWithString(
            self,
            string,
            charMapFile,
            itemWidth,
            itemHeight,
            startCharMap,
        )
    }
    #[inline]
    pub unsafe fn initWithString1(
        &mut self,
        string: *const ::std::os::raw::c_char,
        fntFile: *const ::std::os::raw::c_char,
    ) -> bool {
        cocos2d_CCLabelAtlas_initWithString1(self, string, fntFile)
    }
    #[inline]
    pub unsafe fn initWithString2(
        &mut self,
        string: *const ::std::os::raw::c_char,
        texture: *mut cocos2d_CCTexture2D,
        itemWidth: ::std::os::raw::c_uint,
        itemHeight: ::std::os::raw::c_uint,
        startCharMap: ::std::os::raw::c_uint,
    ) -> bool {
        cocos2d_CCLabelAtlas_initWithString2(
            self,
            string,
            texture,
            itemWidth,
            itemHeight,
            startCharMap,
        )
    }
}
extern "C" {
    #[link_name = "\u{1}?updateAtlasValues@CCLabelAtlas@cocos2d@@UEAAXXZ"]
    pub fn cocos2d_CCLabelAtlas_updateAtlasValues(this: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[link_name = "\u{1}?setString@CCLabelAtlas@cocos2d@@UEAAXPEBD@Z"]
    pub fn cocos2d_CCLabelAtlas_setString(
        this: *mut ::std::os::raw::c_void,
        label: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    #[link_name = "\u{1}?getString@CCLabelAtlas@cocos2d@@UEAAPEBDXZ"]
    pub fn cocos2d_CCLabelAtlas_getString(
        this: *mut ::std::os::raw::c_void,
    ) -> *const ::std::os::raw::c_char;
}
#[doc = " sets a 2D projection (orthogonal projection)"]
pub const cocos2d_ccDirectorProjection_kCCDirectorProjection2D: cocos2d_ccDirectorProjection = 0;
#[doc = " sets a 3D projection with a fovy=60, znear=0.5f and zfar=1500."]
pub const cocos2d_ccDirectorProjection_kCCDirectorProjection3D: cocos2d_ccDirectorProjection = 1;
#[doc = " it calls \"updateProjection\" on the projection delegate."]
pub const cocos2d_ccDirectorProjection_kCCDirectorProjectionCustom: cocos2d_ccDirectorProjection =
    2;
#[doc = " Default projection is 3D projection"]
pub const cocos2d_ccDirectorProjection_kCCDirectorProjectionDefault: cocos2d_ccDirectorProjection =
    1;
#[doc = " @typedef ccDirectorProjection"]
#[doc = "Possible OpenGL projections used by director"]
pub type cocos2d_ccDirectorProjection = ::std::os::raw::c_int;
pub const cocos2d_TextureQuality_kTextureQualityLow: cocos2d_TextureQuality = 1;
pub const cocos2d_TextureQuality_kTextureQualityMedium: cocos2d_TextureQuality = 2;
pub const cocos2d_TextureQuality_kTextureQualityHigh: cocos2d_TextureQuality = 3;
pub type cocos2d_TextureQuality = ::std::os::raw::c_int;
pub const cocos2d_PopTransition_kPopTransitionFade: cocos2d_PopTransition = 0;
pub const cocos2d_PopTransition_kPopTransitionMoveInT: cocos2d_PopTransition = 1;
pub type cocos2d_PopTransition = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cocos2d_CCSceneDelegate {
    _unused: [u8; 0],
}
#[doc = "@brief Class that creates and handle the main Window and manages how"]
#[doc = "and when to execute the Scenes."]
#[doc = ""]
#[doc = "The CCDirector is also responsible for:"]
#[doc = "- initializing the OpenGL context"]
#[doc = "- setting the OpenGL pixel format (default on is RGB565)"]
#[doc = "- setting the OpenGL buffer depth (default one is 0-bit)"]
#[doc = "- setting the projection (default one is 3D)"]
#[doc = "- setting the orientation (default one is Portrait)"]
#[doc = ""]
#[doc = "Since the CCDirector is a singleton, the standard way to use it is by calling:"]
#[doc = "_ CCDirector::sharedDirector()->methodName();"]
#[doc = ""]
#[doc = "The CCDirector also sets the default OpenGL context:"]
#[doc = "- GL_TEXTURE_2D is enabled"]
#[doc = "- GL_VERTEX_ARRAY is enabled"]
#[doc = "- GL_COLOR_ARRAY is enabled"]
#[doc = "- GL_TEXTURE_COORD_ARRAY is enabled"]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCDirector {
    pub _base: cocos2d_CCObject,
    pub _base_1: cocos2d_TypeInfo,
    pub m_fScreenScaleFactor: f32,
    pub m_fScreenScaleFactorMax: f32,
    pub m_fScreenScaleFactorW: f32,
    pub m_fScreenScaleFactorH: f32,
    pub m_fScreenTop: f32,
    pub m_fScreenBottom: f32,
    pub m_fScreenLeft: f32,
    pub m_fScreenRight: f32,
    pub m_pSceneReference: *mut cocos2d_CCScene,
    pub m_pScheduler: *mut cocos2d_CCScheduler,
    pub m_pActionManager: *mut cocos2d_CCActionManager,
    pub m_pTouchDispatcher: *mut cocos2d_CCTouchDispatcher,
    pub m_pKeypadDispatcher: *mut cocos2d_CCKeypadDispatcher,
    pub m_pKeyboardDispatcher: *mut cocos2d_CCKeyboardDispatcher,
    pub m_pMouseDispatcher: *mut cocos2d_CCMouseDispatcher,
    pub m_pAccelerometer: *mut cocos2d_CCAccelerometer,
    pub m_fDeltaTime: f32,
    pub m_fActualDeltaTime: f32,
    pub m_bIsTransitioning: bool,
    pub m_bSmoothFix: bool,
    pub m_bSmoothFixCheck: bool,
    pub m_bForceSmoothFix: bool,
    pub m_nSmoothFixCounter: ::std::os::raw::c_int,
    pub m_bPurgeDirecotorInNextLoop: bool,
    pub m_pobOpenGLView: *mut cocos2d_CCEGLView,
    pub pad464: [::std::os::raw::c_char; 4usize],
    pub m_dAnimationInterval: f64,
    pub m_dOldAnimationInterval: f64,
    pub m_bLandscape: bool,
    pub m_bDisplayStats: bool,
    pub m_fAccumDt: f32,
    pub m_fFrameRate: f32,
    pub m_pFPSLabel: *mut cocos2d_CCLabelAtlas,
    pub m_pSPFLabel: *mut cocos2d_CCLabelAtlas,
    pub m_pDrawsLabel: *mut cocos2d_CCLabelAtlas,
    #[doc = " Whether or not the Director is paused"]
    pub m_bPaused: bool,
    pub m_uTotalFrames: ::std::os::raw::c_uint,
    pub m_uFrames: ::std::os::raw::c_uint,
    pub m_fSecondsPerFrame: f32,
    pub m_pRunningScene: *mut cocos2d_CCScene,
    pub m_pNextScene: *mut cocos2d_CCScene,
    pub m_bSendCleanupToScene: bool,
    pub m_pobScenesStack: *mut cocos2d_CCArray,
    pub m_pLastUpdate: *mut cocos2d_cc_timeval,
    pub m_bNextDeltaTimeZero: bool,
    pub m_eProjection: cocos2d_ccDirectorProjection,
    pub m_obWinSizeInPoints: cocos2d_CCSize,
    pub m_fContentScaleFactor: f32,
    pub m_pszFPS: *mut ::std::os::raw::c_char,
    pub m_pNotificationNode: *mut cocos2d_CCNode,
    pub m_pProjectionDelegate: *mut cocos2d_CCDirectorDelegate,
    pub m_pAppDelegate: *mut cocos2d_CCSceneDelegate,
    pub m_obScaleFactor: cocos2d_CCSize,
    pub m_obResolutionInPixels: cocos2d_CCSize,
    pub m_eTextureQuality: cocos2d_TextureQuality,
    pub m_bDontCallWillSwitch: bool,
}
#[test]
fn bindgen_test_layout_cocos2d_CCDirector() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCDirector>(),
        376usize,
        concat!("Size of: ", stringify!(cocos2d_CCDirector))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCDirector>(),
        8usize,
        concat!("Alignment of ", stringify!(cocos2d_CCDirector))
    );
}
extern "C" {
    #[link_name = "\u{1}?setOpenGLView@CCDirector@cocos2d@@QEAAXPEAVCCEGLView@2@@Z"]
    pub fn cocos2d_CCDirector_setOpenGLView(
        this: *mut cocos2d_CCDirector,
        pobOpenGLView: *mut cocos2d_CCEGLView,
    );
}
extern "C" {
    #[link_name = "\u{1}?setNextDeltaTimeZero@CCDirector@cocos2d@@QEAAX_N@Z"]
    pub fn cocos2d_CCDirector_setNextDeltaTimeZero(
        this: *mut cocos2d_CCDirector,
        bNextDeltaTimeZero: bool,
    );
}
extern "C" {
    #[link_name = "\u{1}?setProjection@CCDirector@cocos2d@@QEAAXW4ccDirectorProjection@2@@Z"]
    pub fn cocos2d_CCDirector_setProjection(
        this: *mut cocos2d_CCDirector,
        kProjection: cocos2d_ccDirectorProjection,
    );
}
extern "C" {
    #[doc = " reshape projection matrix when canvas has been change\""]
    #[link_name = "\u{1}?reshapeProjection@CCDirector@cocos2d@@QEAAXAEBVCCSize@2@@Z"]
    pub fn cocos2d_CCDirector_reshapeProjection(
        this: *mut cocos2d_CCDirector,
        newWindowSize: *const cocos2d_CCSize,
    );
}
extern "C" {
    #[doc = " Sets the glViewport"]
    #[link_name = "\u{1}?setViewport@CCDirector@cocos2d@@QEAAXXZ"]
    pub fn cocos2d_CCDirector_setViewport(this: *mut cocos2d_CCDirector);
}
extern "C" {
    #[doc = " This object will be visited after the main scene is visited."]
    #[doc = "This object MUST implement the \"visit\" selector."]
    #[doc = "Useful to hook a notification object, like CCNotifications (http://github.com/manucorporat/CCNotifications)"]
    #[doc = "@since v0.99.5"]
    #[link_name = "\u{1}?getNotificationNode@CCDirector@cocos2d@@QEAAPEAVCCNode@2@XZ"]
    pub fn cocos2d_CCDirector_getNotificationNode(
        this: *mut cocos2d_CCDirector,
    ) -> *mut cocos2d_CCNode;
}
extern "C" {
    #[link_name = "\u{1}?setNotificationNode@CCDirector@cocos2d@@QEAAXPEAVCCNode@2@@Z"]
    pub fn cocos2d_CCDirector_setNotificationNode(
        this: *mut cocos2d_CCDirector,
        node: *mut cocos2d_CCNode,
    );
}
extern "C" {
    #[doc = " CCDirector delegate. It shall implemente the CCDirectorDelegate protocol"]
    #[doc = "@since v0.99.5"]
    #[link_name = "\u{1}?getDelegate@CCDirector@cocos2d@@QEBAPEAVCCDirectorDelegate@2@XZ"]
    pub fn cocos2d_CCDirector_getDelegate(
        this: *const cocos2d_CCDirector,
    ) -> *mut cocos2d_CCDirectorDelegate;
}
extern "C" {
    #[link_name = "\u{1}?setDelegate@CCDirector@cocos2d@@QEAAXPEAVCCDirectorDelegate@2@@Z"]
    pub fn cocos2d_CCDirector_setDelegate(
        this: *mut cocos2d_CCDirector,
        pDelegate: *mut cocos2d_CCDirectorDelegate,
    );
}
extern "C" {
    #[doc = " returns the size of the OpenGL view in points."]
    #[link_name = "\u{1}?getWinSize@CCDirector@cocos2d@@QEAA?AVCCSize@2@XZ"]
    pub fn cocos2d_CCDirector_getWinSize(this: *mut cocos2d_CCDirector) -> cocos2d_CCSize;
}
extern "C" {
    #[doc = " returns the size of the OpenGL view in pixels."]
    #[link_name = "\u{1}?getWinSizeInPixels@CCDirector@cocos2d@@QEAA?AVCCSize@2@XZ"]
    pub fn cocos2d_CCDirector_getWinSizeInPixels(this: *mut cocos2d_CCDirector) -> cocos2d_CCSize;
}
extern "C" {
    #[doc = " returns visible size of the OpenGL view in points."]
    #[doc = "  the value is equal to getWinSize if don't invoke"]
    #[doc = "  CCEGLView::setDesignResolutionSize()"]
    #[link_name = "\u{1}?getVisibleSize@CCDirector@cocos2d@@QEAA?AVCCSize@2@XZ"]
    pub fn cocos2d_CCDirector_getVisibleSize(this: *mut cocos2d_CCDirector) -> cocos2d_CCSize;
}
extern "C" {
    #[doc = " returns visible origin of the OpenGL view in points."]
    #[link_name = "\u{1}?getVisibleOrigin@CCDirector@cocos2d@@QEAA?AVCCPoint@2@XZ"]
    pub fn cocos2d_CCDirector_getVisibleOrigin(this: *mut cocos2d_CCDirector) -> cocos2d_CCPoint;
}
extern "C" {
    #[doc = " converts a UIKit coordinate to an OpenGL coordinate"]
    #[doc = "Useful to convert (multi) touch coordinates to the current layout (portrait or landscape)"]
    #[link_name = "\u{1}?convertToGL@CCDirector@cocos2d@@QEAA?AVCCPoint@2@AEBV32@@Z"]
    pub fn cocos2d_CCDirector_convertToGL(
        this: *mut cocos2d_CCDirector,
        obPoint: *const cocos2d_CCPoint,
    ) -> cocos2d_CCPoint;
}
extern "C" {
    #[doc = " converts an OpenGL coordinate to a UIKit coordinate"]
    #[doc = "Useful to convert node points to window points for calls such as glScissor"]
    #[link_name = "\u{1}?convertToUI@CCDirector@cocos2d@@QEAA?AVCCPoint@2@AEBV32@@Z"]
    pub fn cocos2d_CCDirector_convertToUI(
        this: *mut cocos2d_CCDirector,
        obPoint: *const cocos2d_CCPoint,
    ) -> cocos2d_CCPoint;
}
extern "C" {
    #[doc = " XXX: missing description"]
    #[link_name = "\u{1}?getZEye@CCDirector@cocos2d@@QEAAMXZ"]
    pub fn cocos2d_CCDirector_getZEye(this: *mut cocos2d_CCDirector) -> f32;
}
extern "C" {
    #[doc = " Enters the Director's main loop with the given Scene."]
    #[doc = " Call it to run only your FIRST scene."]
    #[doc = " Don't call it if there is already a running scene."]
    #[doc = ""]
    #[doc = " It will call pushScene: and then it will call startAnimation"]
    #[link_name = "\u{1}?runWithScene@CCDirector@cocos2d@@QEAAXPEAVCCScene@2@@Z"]
    pub fn cocos2d_CCDirector_runWithScene(
        this: *mut cocos2d_CCDirector,
        pScene: *mut cocos2d_CCScene,
    );
}
extern "C" {
    #[link_name = "\u{1}?pushScene@CCDirector@cocos2d@@QEAA_NPEAVCCScene@2@@Z"]
    pub fn cocos2d_CCDirector_pushScene(
        this: *mut cocos2d_CCDirector,
        pScene: *mut cocos2d_CCScene,
    ) -> bool;
}
extern "C" {
    #[doc = " Pops out a scene from the queue."]
    #[doc = " This scene will replace the running one."]
    #[doc = " The running scene will be deleted. If there are no more scenes in the stack the execution is terminated."]
    #[doc = " ONLY call it if there is a running scene."]
    #[link_name = "\u{1}?popScene@CCDirector@cocos2d@@QEAAXXZ"]
    pub fn cocos2d_CCDirector_popScene(this: *mut cocos2d_CCDirector);
}
extern "C" {
    #[doc = " Pops out all scenes from the queue until the root scene in the queue."]
    #[doc = " This scene will replace the running one."]
    #[doc = " Internally it will call `popToSceneStackLevel(1)`"]
    #[link_name = "\u{1}?popToRootScene@CCDirector@cocos2d@@QEAAXXZ"]
    pub fn cocos2d_CCDirector_popToRootScene(this: *mut cocos2d_CCDirector);
}
extern "C" {
    #[doc = " Pops out all scenes from the queue until it reaches `level`."]
    #[doc = "If level is 0, it will end the director."]
    #[doc = "If level is 1, it will pop all scenes until it reaches to root scene."]
    #[doc = "If level is <= than the current stack level, it won't do anything."]
    #[link_name = "\u{1}?popToSceneStackLevel@CCDirector@cocos2d@@QEAAXH@Z"]
    pub fn cocos2d_CCDirector_popToSceneStackLevel(
        this: *mut cocos2d_CCDirector,
        level: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}?replaceScene@CCDirector@cocos2d@@QEAA_NPEAVCCScene@2@@Z"]
    pub fn cocos2d_CCDirector_replaceScene(
        this: *mut cocos2d_CCDirector,
        pScene: *mut cocos2d_CCScene,
    ) -> bool;
}
extern "C" {
    #[doc = " Ends the execution, releases the running scene."]
    #[doc = "It doesn't remove the OpenGL view from its parent. You have to do it manually."]
    #[link_name = "\u{1}?end@CCDirector@cocos2d@@QEAAXXZ"]
    pub fn cocos2d_CCDirector_end(this: *mut cocos2d_CCDirector);
}
extern "C" {
    #[doc = " Pauses the running scene."]
    #[doc = "The running scene will be _drawed_ but all scheduled timers will be paused"]
    #[doc = "While paused, the draw rate will be 4 FPS to reduce CPU consumption"]
    #[link_name = "\u{1}?pause@CCDirector@cocos2d@@QEAAXXZ"]
    pub fn cocos2d_CCDirector_pause(this: *mut cocos2d_CCDirector);
}
extern "C" {
    #[doc = " Resumes the paused scene"]
    #[doc = "The scheduled timers will be activated again."]
    #[doc = "The \"delta time\" will be 0 (as if the game wasn't paused)"]
    #[link_name = "\u{1}?resume@CCDirector@cocos2d@@QEAAXXZ"]
    pub fn cocos2d_CCDirector_resume(this: *mut cocos2d_CCDirector);
}
extern "C" {
    #[doc = " Draw the scene."]
    #[doc = "This method is called every frame. Don't call it manually."]
    #[link_name = "\u{1}?drawScene@CCDirector@cocos2d@@QEAAXXZ"]
    pub fn cocos2d_CCDirector_drawScene(this: *mut cocos2d_CCDirector);
}
extern "C" {
    #[doc = " Removes cached all cocos2d cached data."]
    #[doc = "It will purge the CCTextureCache, CCSpriteFrameCache, CCLabelBMFont cache"]
    #[doc = "@since v0.99.3"]
    #[link_name = "\u{1}?purgeCachedData@CCDirector@cocos2d@@QEAAXXZ"]
    pub fn cocos2d_CCDirector_purgeCachedData(this: *mut cocos2d_CCDirector);
}
extern "C" {
    #[doc = " sets the default values based on the CCConfiguration info"]
    #[link_name = "\u{1}?setDefaultValues@CCDirector@cocos2d@@QEAAXXZ"]
    pub fn cocos2d_CCDirector_setDefaultValues(this: *mut cocos2d_CCDirector);
}
extern "C" {
    #[doc = " sets the OpenGL default values"]
    #[link_name = "\u{1}?setGLDefaultValues@CCDirector@cocos2d@@QEAAXXZ"]
    pub fn cocos2d_CCDirector_setGLDefaultValues(this: *mut cocos2d_CCDirector);
}
extern "C" {
    #[doc = " enables/disables OpenGL alpha blending"]
    #[link_name = "\u{1}?setAlphaBlending@CCDirector@cocos2d@@QEAAX_N@Z"]
    pub fn cocos2d_CCDirector_setAlphaBlending(this: *mut cocos2d_CCDirector, bOn: bool);
}
extern "C" {
    #[doc = " enables/disables OpenGL depth test"]
    #[link_name = "\u{1}?setDepthTest@CCDirector@cocos2d@@QEAAX_N@Z"]
    pub fn cocos2d_CCDirector_setDepthTest(this: *mut cocos2d_CCDirector, bOn: bool);
}
extern "C" {
    #[doc = " The size in pixels of the surface. It could be different than the screen size."]
    #[doc = "High-res devices might have a higher surface size than the screen size."]
    #[doc = "Only available when compiled using SDK >= 4.0."]
    #[doc = "@since v0.99.4"]
    #[link_name = "\u{1}?setContentScaleFactor@CCDirector@cocos2d@@QEAAXM@Z"]
    pub fn cocos2d_CCDirector_setContentScaleFactor(
        this: *mut cocos2d_CCDirector,
        scaleFactor: f32,
    );
}
extern "C" {
    #[link_name = "\u{1}?getContentScaleFactor@CCDirector@cocos2d@@QEAAMXZ"]
    pub fn cocos2d_CCDirector_getContentScaleFactor(this: *mut cocos2d_CCDirector) -> f32;
}
extern "C" {
    #[link_name = "\u{1}?checkSceneReference@CCDirector@cocos2d@@QEAAXXZ"]
    pub fn cocos2d_CCDirector_checkSceneReference(this: *mut cocos2d_CCDirector);
}
extern "C" {
    #[link_name = "\u{1}?getNextScene@CCDirector@cocos2d@@QEAAPEAVCCScene@2@XZ"]
    pub fn cocos2d_CCDirector_getNextScene(this: *mut cocos2d_CCDirector) -> *mut cocos2d_CCScene;
}
extern "C" {
    #[link_name = "\u{1}?levelForSceneInStack@CCDirector@cocos2d@@QEAAHPEAVCCScene@2@@Z"]
    pub fn cocos2d_CCDirector_levelForSceneInStack(
        this: *mut cocos2d_CCDirector,
        arg1: *mut cocos2d_CCScene,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}?popSceneWithTransition@CCDirector@cocos2d@@QEAA_NMW4PopTransition@2@@Z"]
    pub fn cocos2d_CCDirector_popSceneWithTransition(
        this: *mut cocos2d_CCDirector,
        arg1: f32,
        arg2: cocos2d_PopTransition,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}?popToSceneInStack@CCDirector@cocos2d@@QEAAXPEAVCCScene@2@@Z"]
    pub fn cocos2d_CCDirector_popToSceneInStack(
        this: *mut cocos2d_CCDirector,
        arg1: *mut cocos2d_CCScene,
    );
}
extern "C" {
    #[link_name = "\u{1}?sceneCount@CCDirector@cocos2d@@QEAAHXZ"]
    pub fn cocos2d_CCDirector_sceneCount(this: *mut cocos2d_CCDirector) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}?willSwitchToScene@CCDirector@cocos2d@@QEAAXPEAVCCScene@2@@Z"]
    pub fn cocos2d_CCDirector_willSwitchToScene(
        this: *mut cocos2d_CCDirector,
        arg1: *mut cocos2d_CCScene,
    );
}
extern "C" {
    #[link_name = "\u{1}?removeStatsLabel@CCDirector@cocos2d@@QEAAXXZ"]
    pub fn cocos2d_CCDirector_removeStatsLabel(this: *mut cocos2d_CCDirector);
}
extern "C" {
    #[link_name = "\u{1}?resetSmoothFixCounter@CCDirector@cocos2d@@QEAAXXZ"]
    pub fn cocos2d_CCDirector_resetSmoothFixCounter(this: *mut cocos2d_CCDirector);
}
extern "C" {
    #[link_name = "\u{1}?setDeltaTime@CCDirector@cocos2d@@QEAAXM@Z"]
    pub fn cocos2d_CCDirector_setDeltaTime(this: *mut cocos2d_CCDirector, arg1: f32);
}
extern "C" {
    #[link_name = "\u{1}?setupScreenScale@CCDirector@cocos2d@@QEAAXVCCSize@2@0W4TextureQuality@2@@Z"]
    pub fn cocos2d_CCDirector_setupScreenScale(
        this: *mut cocos2d_CCDirector,
        arg1: cocos2d_CCSize,
        arg2: cocos2d_CCSize,
        arg3: cocos2d_TextureQuality,
    );
}
extern "C" {
    #[link_name = "\u{1}?updateContentScale@CCDirector@cocos2d@@QEAAXW4TextureQuality@2@@Z"]
    pub fn cocos2d_CCDirector_updateContentScale(
        this: *mut cocos2d_CCDirector,
        arg1: cocos2d_TextureQuality,
    );
}
extern "C" {
    #[link_name = "\u{1}?updateScreenScale@CCDirector@cocos2d@@QEAAXVCCSize@2@@Z"]
    pub fn cocos2d_CCDirector_updateScreenScale(
        this: *mut cocos2d_CCDirector,
        arg1: cocos2d_CCSize,
    );
}
extern "C" {
    #[link_name = "\u{1}?getLoadedTextureQuality@CCDirector@cocos2d@@QEBA?AW4TextureQuality@2@XZ"]
    pub fn cocos2d_CCDirector_getLoadedTextureQuality(
        this: *const cocos2d_CCDirector,
    ) -> cocos2d_TextureQuality;
}
extern "C" {
    #[doc = " returns a shared instance of the director"]
    #[doc = "  @js getInstance"]
    #[link_name = "\u{1}?sharedDirector@CCDirector@cocos2d@@SAPEAV12@XZ"]
    pub fn cocos2d_CCDirector_sharedDirector() -> *mut cocos2d_CCDirector;
}
extern "C" {
    #[link_name = "\u{1}?purgeDirector@CCDirector@cocos2d@@IEAAXXZ"]
    pub fn cocos2d_CCDirector_purgeDirector(this: *mut cocos2d_CCDirector);
}
extern "C" {
    #[link_name = "\u{1}?setNextScene@CCDirector@cocos2d@@QEAAXXZ"]
    pub fn cocos2d_CCDirector_setNextScene(this: *mut cocos2d_CCDirector);
}
extern "C" {
    #[link_name = "\u{1}?showStats@CCDirector@cocos2d@@QEAAXXZ"]
    pub fn cocos2d_CCDirector_showStats(this: *mut cocos2d_CCDirector);
}
extern "C" {
    #[link_name = "\u{1}?createStatsLabel@CCDirector@cocos2d@@QEAAXXZ"]
    pub fn cocos2d_CCDirector_createStatsLabel(this: *mut cocos2d_CCDirector);
}
extern "C" {
    #[link_name = "\u{1}?calculateMPF@CCDirector@cocos2d@@QEAAXXZ"]
    pub fn cocos2d_CCDirector_calculateMPF(this: *mut cocos2d_CCDirector);
}
extern "C" {
    #[link_name = "\u{1}?getFPSImageData@CCDirector@cocos2d@@QEAAXPEAPEAEPEAI@Z"]
    pub fn cocos2d_CCDirector_getFPSImageData(
        this: *mut cocos2d_CCDirector,
        datapointer: *mut *mut ::std::os::raw::c_uchar,
        length: *mut ::std::os::raw::c_uint,
    );
}
extern "C" {
    #[doc = " calculates delta time since last time it was called"]
    #[link_name = "\u{1}?calculateDeltaTime@CCDirector@cocos2d@@QEAAXXZ"]
    pub fn cocos2d_CCDirector_calculateDeltaTime(this: *mut cocos2d_CCDirector);
}
extern "C" {
    #[doc = "  @js ctor"]
    #[link_name = "\u{1}??0CCDirector@cocos2d@@QEAA@XZ"]
    pub fn cocos2d_CCDirector_CCDirector(this: *mut cocos2d_CCDirector);
}
extern "C" {
    #[link_name = "\u{1}??0CCDirector@cocos2d@@QEAA@AEBV01@@Z"]
    pub fn cocos2d_CCDirector_CCDirector1(
        this: *mut cocos2d_CCDirector,
        arg1: *const cocos2d_CCDirector,
    );
}
impl cocos2d_CCDirector {
    #[inline]
    pub unsafe fn setOpenGLView(&mut self, pobOpenGLView: *mut cocos2d_CCEGLView) {
        cocos2d_CCDirector_setOpenGLView(self, pobOpenGLView)
    }
    #[inline]
    pub unsafe fn setNextDeltaTimeZero(&mut self, bNextDeltaTimeZero: bool) {
        cocos2d_CCDirector_setNextDeltaTimeZero(self, bNextDeltaTimeZero)
    }
    #[inline]
    pub unsafe fn setProjection(&mut self, kProjection: cocos2d_ccDirectorProjection) {
        cocos2d_CCDirector_setProjection(self, kProjection)
    }
    #[inline]
    pub unsafe fn reshapeProjection(&mut self, newWindowSize: *const cocos2d_CCSize) {
        cocos2d_CCDirector_reshapeProjection(self, newWindowSize)
    }
    #[inline]
    pub unsafe fn setViewport(&mut self) {
        cocos2d_CCDirector_setViewport(self)
    }
    #[inline]
    pub unsafe fn getNotificationNode(&mut self) -> *mut cocos2d_CCNode {
        cocos2d_CCDirector_getNotificationNode(self)
    }
    #[inline]
    pub unsafe fn setNotificationNode(&mut self, node: *mut cocos2d_CCNode) {
        cocos2d_CCDirector_setNotificationNode(self, node)
    }
    #[inline]
    pub unsafe fn getDelegate(&self) -> *mut cocos2d_CCDirectorDelegate {
        cocos2d_CCDirector_getDelegate(self)
    }
    #[inline]
    pub unsafe fn setDelegate(&mut self, pDelegate: *mut cocos2d_CCDirectorDelegate) {
        cocos2d_CCDirector_setDelegate(self, pDelegate)
    }
    #[inline]
    pub unsafe fn getWinSize(&mut self) -> cocos2d_CCSize {
        cocos2d_CCDirector_getWinSize(self)
    }
    #[inline]
    pub unsafe fn getWinSizeInPixels(&mut self) -> cocos2d_CCSize {
        cocos2d_CCDirector_getWinSizeInPixels(self)
    }
    #[inline]
    pub unsafe fn getVisibleSize(&mut self) -> cocos2d_CCSize {
        cocos2d_CCDirector_getVisibleSize(self)
    }
    #[inline]
    pub unsafe fn getVisibleOrigin(&mut self) -> cocos2d_CCPoint {
        cocos2d_CCDirector_getVisibleOrigin(self)
    }
    #[inline]
    pub unsafe fn convertToGL(&mut self, obPoint: *const cocos2d_CCPoint) -> cocos2d_CCPoint {
        cocos2d_CCDirector_convertToGL(self, obPoint)
    }
    #[inline]
    pub unsafe fn convertToUI(&mut self, obPoint: *const cocos2d_CCPoint) -> cocos2d_CCPoint {
        cocos2d_CCDirector_convertToUI(self, obPoint)
    }
    #[inline]
    pub unsafe fn getZEye(&mut self) -> f32 {
        cocos2d_CCDirector_getZEye(self)
    }
    #[inline]
    pub unsafe fn runWithScene(&mut self, pScene: *mut cocos2d_CCScene) {
        cocos2d_CCDirector_runWithScene(self, pScene)
    }
    #[inline]
    pub unsafe fn pushScene(&mut self, pScene: *mut cocos2d_CCScene) -> bool {
        cocos2d_CCDirector_pushScene(self, pScene)
    }
    #[inline]
    pub unsafe fn popScene(&mut self) {
        cocos2d_CCDirector_popScene(self)
    }
    #[inline]
    pub unsafe fn popToRootScene(&mut self) {
        cocos2d_CCDirector_popToRootScene(self)
    }
    #[inline]
    pub unsafe fn popToSceneStackLevel(&mut self, level: ::std::os::raw::c_int) {
        cocos2d_CCDirector_popToSceneStackLevel(self, level)
    }
    #[inline]
    pub unsafe fn replaceScene(&mut self, pScene: *mut cocos2d_CCScene) -> bool {
        cocos2d_CCDirector_replaceScene(self, pScene)
    }
    #[inline]
    pub unsafe fn end(&mut self) {
        cocos2d_CCDirector_end(self)
    }
    #[inline]
    pub unsafe fn pause(&mut self) {
        cocos2d_CCDirector_pause(self)
    }
    #[inline]
    pub unsafe fn resume(&mut self) {
        cocos2d_CCDirector_resume(self)
    }
    #[inline]
    pub unsafe fn drawScene(&mut self) {
        cocos2d_CCDirector_drawScene(self)
    }
    #[inline]
    pub unsafe fn purgeCachedData(&mut self) {
        cocos2d_CCDirector_purgeCachedData(self)
    }
    #[inline]
    pub unsafe fn setDefaultValues(&mut self) {
        cocos2d_CCDirector_setDefaultValues(self)
    }
    #[inline]
    pub unsafe fn setGLDefaultValues(&mut self) {
        cocos2d_CCDirector_setGLDefaultValues(self)
    }
    #[inline]
    pub unsafe fn setAlphaBlending(&mut self, bOn: bool) {
        cocos2d_CCDirector_setAlphaBlending(self, bOn)
    }
    #[inline]
    pub unsafe fn setDepthTest(&mut self, bOn: bool) {
        cocos2d_CCDirector_setDepthTest(self, bOn)
    }
    #[inline]
    pub unsafe fn setContentScaleFactor(&mut self, scaleFactor: f32) {
        cocos2d_CCDirector_setContentScaleFactor(self, scaleFactor)
    }
    #[inline]
    pub unsafe fn getContentScaleFactor(&mut self) -> f32 {
        cocos2d_CCDirector_getContentScaleFactor(self)
    }
    #[inline]
    pub unsafe fn checkSceneReference(&mut self) {
        cocos2d_CCDirector_checkSceneReference(self)
    }
    #[inline]
    pub unsafe fn getNextScene(&mut self) -> *mut cocos2d_CCScene {
        cocos2d_CCDirector_getNextScene(self)
    }
    #[inline]
    pub unsafe fn levelForSceneInStack(
        &mut self,
        arg1: *mut cocos2d_CCScene,
    ) -> ::std::os::raw::c_int {
        cocos2d_CCDirector_levelForSceneInStack(self, arg1)
    }
    #[inline]
    pub unsafe fn popSceneWithTransition(
        &mut self,
        arg1: f32,
        arg2: cocos2d_PopTransition,
    ) -> bool {
        cocos2d_CCDirector_popSceneWithTransition(self, arg1, arg2)
    }
    #[inline]
    pub unsafe fn popToSceneInStack(&mut self, arg1: *mut cocos2d_CCScene) {
        cocos2d_CCDirector_popToSceneInStack(self, arg1)
    }
    #[inline]
    pub unsafe fn sceneCount(&mut self) -> ::std::os::raw::c_int {
        cocos2d_CCDirector_sceneCount(self)
    }
    #[inline]
    pub unsafe fn willSwitchToScene(&mut self, arg1: *mut cocos2d_CCScene) {
        cocos2d_CCDirector_willSwitchToScene(self, arg1)
    }
    #[inline]
    pub unsafe fn removeStatsLabel(&mut self) {
        cocos2d_CCDirector_removeStatsLabel(self)
    }
    #[inline]
    pub unsafe fn resetSmoothFixCounter(&mut self) {
        cocos2d_CCDirector_resetSmoothFixCounter(self)
    }
    #[inline]
    pub unsafe fn setDeltaTime(&mut self, arg1: f32) {
        cocos2d_CCDirector_setDeltaTime(self, arg1)
    }
    #[inline]
    pub unsafe fn setupScreenScale(
        &mut self,
        arg1: cocos2d_CCSize,
        arg2: cocos2d_CCSize,
        arg3: cocos2d_TextureQuality,
    ) {
        cocos2d_CCDirector_setupScreenScale(self, arg1, arg2, arg3)
    }
    #[inline]
    pub unsafe fn updateContentScale(&mut self, arg1: cocos2d_TextureQuality) {
        cocos2d_CCDirector_updateContentScale(self, arg1)
    }
    #[inline]
    pub unsafe fn updateScreenScale(&mut self, arg1: cocos2d_CCSize) {
        cocos2d_CCDirector_updateScreenScale(self, arg1)
    }
    #[inline]
    pub unsafe fn getLoadedTextureQuality(&self) -> cocos2d_TextureQuality {
        cocos2d_CCDirector_getLoadedTextureQuality(self)
    }
    #[inline]
    pub unsafe fn sharedDirector() -> *mut cocos2d_CCDirector {
        cocos2d_CCDirector_sharedDirector()
    }
    #[inline]
    pub unsafe fn purgeDirector(&mut self) {
        cocos2d_CCDirector_purgeDirector(self)
    }
    #[inline]
    pub unsafe fn setNextScene(&mut self) {
        cocos2d_CCDirector_setNextScene(self)
    }
    #[inline]
    pub unsafe fn showStats(&mut self) {
        cocos2d_CCDirector_showStats(self)
    }
    #[inline]
    pub unsafe fn createStatsLabel(&mut self) {
        cocos2d_CCDirector_createStatsLabel(self)
    }
    #[inline]
    pub unsafe fn calculateMPF(&mut self) {
        cocos2d_CCDirector_calculateMPF(self)
    }
    #[inline]
    pub unsafe fn getFPSImageData(
        &mut self,
        datapointer: *mut *mut ::std::os::raw::c_uchar,
        length: *mut ::std::os::raw::c_uint,
    ) {
        cocos2d_CCDirector_getFPSImageData(self, datapointer, length)
    }
    #[inline]
    pub unsafe fn calculateDeltaTime(&mut self) {
        cocos2d_CCDirector_calculateDeltaTime(self)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cocos2d_CCDirector_CCDirector(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new1(arg1: *const cocos2d_CCDirector) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cocos2d_CCDirector_CCDirector1(__bindgen_tmp.as_mut_ptr(), arg1);
        __bindgen_tmp.assume_init()
    }
}
extern "C" {
    #[doc = "  @js NA"]
    #[doc = "  @lua NA"]
    #[link_name = "\u{1}??_DCCDirector@cocos2d@@QEAAXXZ"]
    pub fn cocos2d_CCDirector_CCDirector_destructor(this: *mut cocos2d_CCDirector);
}
extern "C" {
    #[link_name = "\u{1}?init@CCDirector@cocos2d@@UEAA_NXZ"]
    pub fn cocos2d_CCDirector_init(this: *mut ::std::os::raw::c_void) -> bool;
}
extern "C" {
    #[link_name = "\u{1}?getScheduler@CCDirector@cocos2d@@UEAAPEAVCCScheduler@2@XZ"]
    pub fn cocos2d_CCDirector_getScheduler(
        this: *mut ::std::os::raw::c_void,
    ) -> *mut cocos2d_CCScheduler;
}
extern "C" {
    #[link_name = "\u{1}?setScheduler@CCDirector@cocos2d@@UEAAXPEAVCCScheduler@2@@Z"]
    pub fn cocos2d_CCDirector_setScheduler(
        this: *mut ::std::os::raw::c_void,
        var: *mut cocos2d_CCScheduler,
    );
}
extern "C" {
    #[link_name = "\u{1}?getActionManager@CCDirector@cocos2d@@UEAAPEAVCCActionManager@2@XZ"]
    pub fn cocos2d_CCDirector_getActionManager(
        this: *mut ::std::os::raw::c_void,
    ) -> *mut cocos2d_CCActionManager;
}
extern "C" {
    #[link_name = "\u{1}?setActionManager@CCDirector@cocos2d@@UEAAXPEAVCCActionManager@2@@Z"]
    pub fn cocos2d_CCDirector_setActionManager(
        this: *mut ::std::os::raw::c_void,
        var: *mut cocos2d_CCActionManager,
    );
}
extern "C" {
    #[link_name = "\u{1}?getTouchDispatcher@CCDirector@cocos2d@@UEAAPEAVCCTouchDispatcher@2@XZ"]
    pub fn cocos2d_CCDirector_getTouchDispatcher(
        this: *mut ::std::os::raw::c_void,
    ) -> *mut cocos2d_CCTouchDispatcher;
}
extern "C" {
    #[link_name = "\u{1}?setTouchDispatcher@CCDirector@cocos2d@@UEAAXPEAVCCTouchDispatcher@2@@Z"]
    pub fn cocos2d_CCDirector_setTouchDispatcher(
        this: *mut ::std::os::raw::c_void,
        var: *mut cocos2d_CCTouchDispatcher,
    );
}
extern "C" {
    #[link_name = "\u{1}?getKeypadDispatcher@CCDirector@cocos2d@@UEAAPEAVCCKeypadDispatcher@2@XZ"]
    pub fn cocos2d_CCDirector_getKeypadDispatcher(
        this: *mut ::std::os::raw::c_void,
    ) -> *mut cocos2d_CCKeypadDispatcher;
}
extern "C" {
    #[link_name = "\u{1}?setKeypadDispatcher@CCDirector@cocos2d@@UEAAXPEAVCCKeypadDispatcher@2@@Z"]
    pub fn cocos2d_CCDirector_setKeypadDispatcher(
        this: *mut ::std::os::raw::c_void,
        var: *mut cocos2d_CCKeypadDispatcher,
    );
}
extern "C" {
    #[link_name = "\u{1}?getKeyboardDispatcher@CCDirector@cocos2d@@UEAAPEAVCCKeyboardDispatcher@2@XZ"]
    pub fn cocos2d_CCDirector_getKeyboardDispatcher(
        this: *mut ::std::os::raw::c_void,
    ) -> *mut cocos2d_CCKeyboardDispatcher;
}
extern "C" {
    #[link_name = "\u{1}?setKeyboardDispatcher@CCDirector@cocos2d@@UEAAXPEAVCCKeyboardDispatcher@2@@Z"]
    pub fn cocos2d_CCDirector_setKeyboardDispatcher(
        this: *mut ::std::os::raw::c_void,
        var: *mut cocos2d_CCKeyboardDispatcher,
    );
}
extern "C" {
    #[link_name = "\u{1}?getMouseDispatcher@CCDirector@cocos2d@@UEAAPEAVCCMouseDispatcher@2@XZ"]
    pub fn cocos2d_CCDirector_getMouseDispatcher(
        this: *mut ::std::os::raw::c_void,
    ) -> *mut cocos2d_CCMouseDispatcher;
}
extern "C" {
    #[link_name = "\u{1}?setMouseDispatcher@CCDirector@cocos2d@@UEAAXPEAVCCMouseDispatcher@2@@Z"]
    pub fn cocos2d_CCDirector_setMouseDispatcher(
        this: *mut ::std::os::raw::c_void,
        var: *mut cocos2d_CCMouseDispatcher,
    );
}
extern "C" {
    #[link_name = "\u{1}?getAccelerometer@CCDirector@cocos2d@@UEAAPEAVCCAccelerometer@2@XZ"]
    pub fn cocos2d_CCDirector_getAccelerometer(
        this: *mut ::std::os::raw::c_void,
    ) -> *mut cocos2d_CCAccelerometer;
}
extern "C" {
    #[link_name = "\u{1}?setAccelerometer@CCDirector@cocos2d@@UEAAXPEAVCCAccelerometer@2@@Z"]
    pub fn cocos2d_CCDirector_setAccelerometer(
        this: *mut ::std::os::raw::c_void,
        var: *mut cocos2d_CCAccelerometer,
    );
}
extern "C" {
    #[link_name = "\u{1}?getDeltaTime@CCDirector@cocos2d@@UEAAMXZ"]
    pub fn cocos2d_CCDirector_getDeltaTime(this: *mut ::std::os::raw::c_void) -> f32;
}
extern "C" {
    #[link_name = "\u{1}?getSceneDelegate@CCDirector@cocos2d@@UEAAPEAVCCSceneDelegate@2@XZ"]
    pub fn cocos2d_CCDirector_getSceneDelegate(
        this: *mut ::std::os::raw::c_void,
    ) -> *mut cocos2d_CCSceneDelegate;
}
extern "C" {
    #[link_name = "\u{1}?setSceneDelegate@CCDirector@cocos2d@@UEAAXPEAVCCSceneDelegate@2@@Z"]
    pub fn cocos2d_CCDirector_setSceneDelegate(
        this: *mut ::std::os::raw::c_void,
        var: *mut cocos2d_CCSceneDelegate,
    );
}
#[doc = "@brief DisplayLinkDirector is a Director that synchronizes timers with the refresh rate of the display."]
#[doc = ""]
#[doc = "Features and Limitations:"]
#[doc = "- Scheduled timers & drawing are synchronizes with the refresh rate of the display"]
#[doc = "- Only supports animation intervals of 1/60 1/30 & 1/15"]
#[doc = ""]
#[doc = "@since v0.8.2"]
#[doc = "@js NA"]
#[doc = "@lua NA"]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCDisplayLinkDirector {
    pub _base: cocos2d_CCDirector,
    pub m_bInvalid: bool,
}
#[test]
fn bindgen_test_layout_cocos2d_CCDisplayLinkDirector() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCDisplayLinkDirector>(),
        384usize,
        concat!("Size of: ", stringify!(cocos2d_CCDisplayLinkDirector))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCDisplayLinkDirector>(),
        8usize,
        concat!("Alignment of ", stringify!(cocos2d_CCDisplayLinkDirector))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cocos2d_CCDisplayLinkDirector>())).m_bInvalid as *const _
                as usize
        },
        376usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCDisplayLinkDirector),
            "::",
            stringify!(m_bInvalid)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}?mainLoop@CCDisplayLinkDirector@cocos2d@@UEAAXXZ"]
    pub fn cocos2d_CCDisplayLinkDirector_mainLoop(this: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[link_name = "\u{1}?setAnimationInterval@CCDisplayLinkDirector@cocos2d@@UEAAXN@Z"]
    pub fn cocos2d_CCDisplayLinkDirector_setAnimationInterval(
        this: *mut ::std::os::raw::c_void,
        dValue: f64,
    );
}
extern "C" {
    #[link_name = "\u{1}?startAnimation@CCDisplayLinkDirector@cocos2d@@UEAAXXZ"]
    pub fn cocos2d_CCDisplayLinkDirector_startAnimation(this: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[link_name = "\u{1}?stopAnimation@CCDisplayLinkDirector@cocos2d@@UEAAXXZ"]
    pub fn cocos2d_CCDisplayLinkDirector_stopAnimation(this: *mut ::std::os::raw::c_void);
}
#[doc = " Base class for other"]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCGridBase {
    pub _base: cocos2d_CCObject,
    pub m_bActive: bool,
    pub m_nReuseGrid: ::std::os::raw::c_int,
    pub m_sGridSize: cocos2d_CCSize,
    pub m_pTexture: *mut cocos2d_CCTexture2D,
    pub m_obStep: cocos2d_CCPoint,
    pub m_pGrabber: *mut cocos2d_CCGrabber,
    pub m_bIsTextureFlipped: bool,
    pub m_pShaderProgram: *mut cocos2d_CCGLProgram,
    pub m_directorProjection: cocos2d_ccDirectorProjection,
}
#[test]
fn bindgen_test_layout_cocos2d_CCGridBase() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCGridBase>(),
        104usize,
        concat!("Size of: ", stringify!(cocos2d_CCGridBase))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCGridBase>(),
        8usize,
        concat!("Alignment of ", stringify!(cocos2d_CCGridBase))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cocos2d_CCGridBase>())).m_bActive as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCGridBase),
            "::",
            stringify!(m_bActive)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cocos2d_CCGridBase>())).m_nReuseGrid as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCGridBase),
            "::",
            stringify!(m_nReuseGrid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cocos2d_CCGridBase>())).m_sGridSize as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCGridBase),
            "::",
            stringify!(m_sGridSize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cocos2d_CCGridBase>())).m_pTexture as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCGridBase),
            "::",
            stringify!(m_pTexture)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cocos2d_CCGridBase>())).m_obStep as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCGridBase),
            "::",
            stringify!(m_obStep)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cocos2d_CCGridBase>())).m_pGrabber as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCGridBase),
            "::",
            stringify!(m_pGrabber)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cocos2d_CCGridBase>())).m_bIsTextureFlipped as *const _ as usize
        },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCGridBase),
            "::",
            stringify!(m_bIsTextureFlipped)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cocos2d_CCGridBase>())).m_pShaderProgram as *const _ as usize
        },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCGridBase),
            "::",
            stringify!(m_pShaderProgram)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cocos2d_CCGridBase>())).m_directorProjection as *const _ as usize
        },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCGridBase),
            "::",
            stringify!(m_directorProjection)
        )
    );
}
extern "C" {
    #[doc = "  @lua NA"]
    #[link_name = "\u{1}?setActive@CCGridBase@cocos2d@@QEAAX_N@Z"]
    pub fn cocos2d_CCGridBase_setActive(this: *mut cocos2d_CCGridBase, bActive: bool);
}
extern "C" {
    #[doc = "  @lua NA"]
    #[link_name = "\u{1}?setTextureFlipped@CCGridBase@cocos2d@@QEAAX_N@Z"]
    pub fn cocos2d_CCGridBase_setTextureFlipped(this: *mut cocos2d_CCGridBase, bFlipped: bool);
}
extern "C" {
    #[doc = "  @lua NA"]
    #[link_name = "\u{1}?initWithSize@CCGridBase@cocos2d@@QEAA_NAEBVCCSize@2@PEAVCCTexture2D@2@_N@Z"]
    pub fn cocos2d_CCGridBase_initWithSize(
        this: *mut cocos2d_CCGridBase,
        gridSize: *const cocos2d_CCSize,
        pTexture: *mut cocos2d_CCTexture2D,
        bFlipped: bool,
    ) -> bool;
}
extern "C" {
    #[doc = "  @lua NA"]
    #[link_name = "\u{1}?initWithSize@CCGridBase@cocos2d@@QEAA_NAEBVCCSize@2@@Z"]
    pub fn cocos2d_CCGridBase_initWithSize1(
        this: *mut cocos2d_CCGridBase,
        gridSize: *const cocos2d_CCSize,
    ) -> bool;
}
extern "C" {
    #[doc = "  @lua NA"]
    #[link_name = "\u{1}?beforeDraw@CCGridBase@cocos2d@@QEAAXXZ"]
    pub fn cocos2d_CCGridBase_beforeDraw(this: *mut cocos2d_CCGridBase);
}
extern "C" {
    #[doc = "  @lua NA"]
    #[link_name = "\u{1}?afterDraw@CCGridBase@cocos2d@@QEAAXPEAVCCNode@2@@Z"]
    pub fn cocos2d_CCGridBase_afterDraw(
        this: *mut cocos2d_CCGridBase,
        pTarget: *mut cocos2d_CCNode,
    );
}
extern "C" {
    #[doc = " create one Grid"]
    #[doc = " @lua NA"]
    #[link_name = "\u{1}?create@CCGridBase@cocos2d@@SAPEAV12@AEBVCCSize@2@PEAVCCTexture2D@2@_N@Z"]
    pub fn cocos2d_CCGridBase_create(
        gridSize: *const cocos2d_CCSize,
        texture: *mut cocos2d_CCTexture2D,
        flipped: bool,
    ) -> *mut cocos2d_CCGridBase;
}
extern "C" {
    #[doc = " create one Grid"]
    #[doc = " @lua NA"]
    #[link_name = "\u{1}?create@CCGridBase@cocos2d@@SAPEAV12@AEBVCCSize@2@@Z"]
    pub fn cocos2d_CCGridBase_create1(gridSize: *const cocos2d_CCSize) -> *mut cocos2d_CCGridBase;
}
extern "C" {
    #[doc = "  @lua NA"]
    #[link_name = "\u{1}?set2DProjection@CCGridBase@cocos2d@@QEAAXXZ"]
    pub fn cocos2d_CCGridBase_set2DProjection(this: *mut cocos2d_CCGridBase);
}
impl cocos2d_CCGridBase {
    #[inline]
    pub unsafe fn setActive(&mut self, bActive: bool) {
        cocos2d_CCGridBase_setActive(self, bActive)
    }
    #[inline]
    pub unsafe fn setTextureFlipped(&mut self, bFlipped: bool) {
        cocos2d_CCGridBase_setTextureFlipped(self, bFlipped)
    }
    #[inline]
    pub unsafe fn initWithSize(
        &mut self,
        gridSize: *const cocos2d_CCSize,
        pTexture: *mut cocos2d_CCTexture2D,
        bFlipped: bool,
    ) -> bool {
        cocos2d_CCGridBase_initWithSize(self, gridSize, pTexture, bFlipped)
    }
    #[inline]
    pub unsafe fn initWithSize1(&mut self, gridSize: *const cocos2d_CCSize) -> bool {
        cocos2d_CCGridBase_initWithSize1(self, gridSize)
    }
    #[inline]
    pub unsafe fn beforeDraw(&mut self) {
        cocos2d_CCGridBase_beforeDraw(self)
    }
    #[inline]
    pub unsafe fn afterDraw(&mut self, pTarget: *mut cocos2d_CCNode) {
        cocos2d_CCGridBase_afterDraw(self, pTarget)
    }
    #[inline]
    pub unsafe fn create(
        gridSize: *const cocos2d_CCSize,
        texture: *mut cocos2d_CCTexture2D,
        flipped: bool,
    ) -> *mut cocos2d_CCGridBase {
        cocos2d_CCGridBase_create(gridSize, texture, flipped)
    }
    #[inline]
    pub unsafe fn create1(gridSize: *const cocos2d_CCSize) -> *mut cocos2d_CCGridBase {
        cocos2d_CCGridBase_create1(gridSize)
    }
    #[inline]
    pub unsafe fn set2DProjection(&mut self) {
        cocos2d_CCGridBase_set2DProjection(self)
    }
}
extern "C" {
    #[doc = "  @js NA"]
    #[doc = "  @lua NA"]
    #[link_name = "\u{1}??_DCCGridBase@cocos2d@@QEAAXXZ"]
    pub fn cocos2d_CCGridBase_CCGridBase_destructor(this: *mut cocos2d_CCGridBase);
}
extern "C" {
    #[doc = "  @lua NA"]
    #[link_name = "\u{1}?blit@CCGridBase@cocos2d@@UEAAXXZ"]
    pub fn cocos2d_CCGridBase_blit(this: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[doc = "  @lua NA"]
    #[link_name = "\u{1}?reuse@CCGridBase@cocos2d@@UEAAXXZ"]
    pub fn cocos2d_CCGridBase_reuse(this: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[doc = "  @lua NA"]
    #[link_name = "\u{1}?calculateVertexPoints@CCGridBase@cocos2d@@UEAAXXZ"]
    pub fn cocos2d_CCGridBase_calculateVertexPoints(this: *mut ::std::os::raw::c_void);
}
#[doc = "CCGrid3D is a 3D grid implementation. Each vertex has 3 dimensions: x,y,z"]
#[doc = "@js NA"]
#[doc = "@lua NA"]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCGrid3D {
    pub _base: cocos2d_CCGridBase,
    pub m_pTexCoordinates: *mut GLvoid,
    pub m_pVertices: *mut GLvoid,
    pub m_pOriginalVertices: *mut GLvoid,
    pub m_pIndices: *mut GLushort,
}
#[test]
fn bindgen_test_layout_cocos2d_CCGrid3D() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCGrid3D>(),
        136usize,
        concat!("Size of: ", stringify!(cocos2d_CCGrid3D))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCGrid3D>(),
        8usize,
        concat!("Alignment of ", stringify!(cocos2d_CCGrid3D))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cocos2d_CCGrid3D>())).m_pTexCoordinates as *const _ as usize
        },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCGrid3D),
            "::",
            stringify!(m_pTexCoordinates)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cocos2d_CCGrid3D>())).m_pVertices as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCGrid3D),
            "::",
            stringify!(m_pVertices)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cocos2d_CCGrid3D>())).m_pOriginalVertices as *const _ as usize
        },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCGrid3D),
            "::",
            stringify!(m_pOriginalVertices)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cocos2d_CCGrid3D>())).m_pIndices as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCGrid3D),
            "::",
            stringify!(m_pIndices)
        )
    );
}
extern "C" {
    #[doc = " returns the vertex at a given position"]
    #[link_name = "\u{1}?vertex@CCGrid3D@cocos2d@@QEAA?AU_ccVertex3F@2@AEBVCCPoint@2@@Z"]
    pub fn cocos2d_CCGrid3D_vertex(
        this: *mut cocos2d_CCGrid3D,
        pos: *const cocos2d_CCPoint,
    ) -> cocos2d_ccVertex3F;
}
extern "C" {
    #[doc = " returns the original (non-transformed) vertex at a given position"]
    #[link_name = "\u{1}?originalVertex@CCGrid3D@cocos2d@@QEAA?AU_ccVertex3F@2@AEBVCCPoint@2@@Z"]
    pub fn cocos2d_CCGrid3D_originalVertex(
        this: *mut cocos2d_CCGrid3D,
        pos: *const cocos2d_CCPoint,
    ) -> cocos2d_ccVertex3F;
}
extern "C" {
    #[doc = " sets a new vertex at a given position"]
    #[link_name = "\u{1}?setVertex@CCGrid3D@cocos2d@@QEAAXAEBVCCPoint@2@AEBU_ccVertex3F@2@@Z"]
    pub fn cocos2d_CCGrid3D_setVertex(
        this: *mut cocos2d_CCGrid3D,
        pos: *const cocos2d_CCPoint,
        vertex: *const cocos2d_ccVertex3F,
    );
}
extern "C" {
    #[doc = " create one Grid"]
    #[link_name = "\u{1}?create@CCGrid3D@cocos2d@@SAPEAV12@AEBVCCSize@2@PEAVCCTexture2D@2@_N@Z"]
    pub fn cocos2d_CCGrid3D_create(
        gridSize: *const cocos2d_CCSize,
        pTexture: *mut cocos2d_CCTexture2D,
        bFlipped: bool,
    ) -> *mut cocos2d_CCGrid3D;
}
extern "C" {
    #[doc = " create one Grid"]
    #[link_name = "\u{1}?create@CCGrid3D@cocos2d@@SAPEAV12@AEBVCCSize@2@@Z"]
    pub fn cocos2d_CCGrid3D_create1(gridSize: *const cocos2d_CCSize) -> *mut cocos2d_CCGrid3D;
}
extern "C" {
    #[link_name = "\u{1}??0CCGrid3D@cocos2d@@QEAA@XZ"]
    pub fn cocos2d_CCGrid3D_CCGrid3D(this: *mut cocos2d_CCGrid3D);
}
impl cocos2d_CCGrid3D {
    #[inline]
    pub unsafe fn vertex(&mut self, pos: *const cocos2d_CCPoint) -> cocos2d_ccVertex3F {
        cocos2d_CCGrid3D_vertex(self, pos)
    }
    #[inline]
    pub unsafe fn originalVertex(&mut self, pos: *const cocos2d_CCPoint) -> cocos2d_ccVertex3F {
        cocos2d_CCGrid3D_originalVertex(self, pos)
    }
    #[inline]
    pub unsafe fn setVertex(
        &mut self,
        pos: *const cocos2d_CCPoint,
        vertex: *const cocos2d_ccVertex3F,
    ) {
        cocos2d_CCGrid3D_setVertex(self, pos, vertex)
    }
    #[inline]
    pub unsafe fn create(
        gridSize: *const cocos2d_CCSize,
        pTexture: *mut cocos2d_CCTexture2D,
        bFlipped: bool,
    ) -> *mut cocos2d_CCGrid3D {
        cocos2d_CCGrid3D_create(gridSize, pTexture, bFlipped)
    }
    #[inline]
    pub unsafe fn create1(gridSize: *const cocos2d_CCSize) -> *mut cocos2d_CCGrid3D {
        cocos2d_CCGrid3D_create1(gridSize)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cocos2d_CCGrid3D_CCGrid3D(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
}
extern "C" {
    #[link_name = "\u{1}??_DCCGrid3D@cocos2d@@QEAAXXZ"]
    pub fn cocos2d_CCGrid3D_CCGrid3D_destructor(this: *mut cocos2d_CCGrid3D);
}
extern "C" {
    #[link_name = "\u{1}?blit@CCGrid3D@cocos2d@@UEAAXXZ"]
    pub fn cocos2d_CCGrid3D_blit(this: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[link_name = "\u{1}?reuse@CCGrid3D@cocos2d@@UEAAXXZ"]
    pub fn cocos2d_CCGrid3D_reuse(this: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[link_name = "\u{1}?calculateVertexPoints@CCGrid3D@cocos2d@@UEAAXXZ"]
    pub fn cocos2d_CCGrid3D_calculateVertexPoints(this: *mut ::std::os::raw::c_void);
}
#[doc = "CCTiledGrid3D is a 3D grid implementation. It differs from Grid3D in that"]
#[doc = "the tiles can be separated from the grid."]
#[doc = "@js NA"]
#[doc = "@lua NA"]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCTiledGrid3D {
    pub _base: cocos2d_CCGridBase,
    pub m_pTexCoordinates: *mut GLvoid,
    pub m_pVertices: *mut GLvoid,
    pub m_pOriginalVertices: *mut GLvoid,
    pub m_pIndices: *mut GLushort,
}
#[test]
fn bindgen_test_layout_cocos2d_CCTiledGrid3D() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCTiledGrid3D>(),
        136usize,
        concat!("Size of: ", stringify!(cocos2d_CCTiledGrid3D))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCTiledGrid3D>(),
        8usize,
        concat!("Alignment of ", stringify!(cocos2d_CCTiledGrid3D))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cocos2d_CCTiledGrid3D>())).m_pTexCoordinates as *const _ as usize
        },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCTiledGrid3D),
            "::",
            stringify!(m_pTexCoordinates)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cocos2d_CCTiledGrid3D>())).m_pVertices as *const _ as usize
        },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCTiledGrid3D),
            "::",
            stringify!(m_pVertices)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cocos2d_CCTiledGrid3D>())).m_pOriginalVertices as *const _
                as usize
        },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCTiledGrid3D),
            "::",
            stringify!(m_pOriginalVertices)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cocos2d_CCTiledGrid3D>())).m_pIndices as *const _ as usize
        },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCTiledGrid3D),
            "::",
            stringify!(m_pIndices)
        )
    );
}
extern "C" {
    #[doc = " returns the tile at the given position"]
    #[link_name = "\u{1}?tile@CCTiledGrid3D@cocos2d@@QEAA?AU_ccQuad3@2@AEBVCCPoint@2@@Z"]
    pub fn cocos2d_CCTiledGrid3D_tile(
        this: *mut cocos2d_CCTiledGrid3D,
        pos: *const cocos2d_CCPoint,
    ) -> cocos2d_ccQuad3;
}
extern "C" {
    #[doc = " returns the original tile (untransformed) at the given position"]
    #[link_name = "\u{1}?originalTile@CCTiledGrid3D@cocos2d@@QEAA?AU_ccQuad3@2@AEBVCCPoint@2@@Z"]
    pub fn cocos2d_CCTiledGrid3D_originalTile(
        this: *mut cocos2d_CCTiledGrid3D,
        pos: *const cocos2d_CCPoint,
    ) -> cocos2d_ccQuad3;
}
extern "C" {
    #[doc = " sets a new tile"]
    #[link_name = "\u{1}?setTile@CCTiledGrid3D@cocos2d@@QEAAXAEBVCCPoint@2@AEBU_ccQuad3@2@@Z"]
    pub fn cocos2d_CCTiledGrid3D_setTile(
        this: *mut cocos2d_CCTiledGrid3D,
        pos: *const cocos2d_CCPoint,
        coords: *const cocos2d_ccQuad3,
    );
}
extern "C" {
    #[doc = " create one Grid"]
    #[link_name = "\u{1}?create@CCTiledGrid3D@cocos2d@@SAPEAV12@AEBVCCSize@2@PEAVCCTexture2D@2@_N@Z"]
    pub fn cocos2d_CCTiledGrid3D_create(
        gridSize: *const cocos2d_CCSize,
        pTexture: *mut cocos2d_CCTexture2D,
        bFlipped: bool,
    ) -> *mut cocos2d_CCTiledGrid3D;
}
extern "C" {
    #[doc = " create one Grid"]
    #[link_name = "\u{1}?create@CCTiledGrid3D@cocos2d@@SAPEAV12@AEBVCCSize@2@@Z"]
    pub fn cocos2d_CCTiledGrid3D_create1(
        gridSize: *const cocos2d_CCSize,
    ) -> *mut cocos2d_CCTiledGrid3D;
}
extern "C" {
    #[link_name = "\u{1}??0CCTiledGrid3D@cocos2d@@QEAA@XZ"]
    pub fn cocos2d_CCTiledGrid3D_CCTiledGrid3D(this: *mut cocos2d_CCTiledGrid3D);
}
impl cocos2d_CCTiledGrid3D {
    #[inline]
    pub unsafe fn tile(&mut self, pos: *const cocos2d_CCPoint) -> cocos2d_ccQuad3 {
        cocos2d_CCTiledGrid3D_tile(self, pos)
    }
    #[inline]
    pub unsafe fn originalTile(&mut self, pos: *const cocos2d_CCPoint) -> cocos2d_ccQuad3 {
        cocos2d_CCTiledGrid3D_originalTile(self, pos)
    }
    #[inline]
    pub unsafe fn setTile(&mut self, pos: *const cocos2d_CCPoint, coords: *const cocos2d_ccQuad3) {
        cocos2d_CCTiledGrid3D_setTile(self, pos, coords)
    }
    #[inline]
    pub unsafe fn create(
        gridSize: *const cocos2d_CCSize,
        pTexture: *mut cocos2d_CCTexture2D,
        bFlipped: bool,
    ) -> *mut cocos2d_CCTiledGrid3D {
        cocos2d_CCTiledGrid3D_create(gridSize, pTexture, bFlipped)
    }
    #[inline]
    pub unsafe fn create1(gridSize: *const cocos2d_CCSize) -> *mut cocos2d_CCTiledGrid3D {
        cocos2d_CCTiledGrid3D_create1(gridSize)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cocos2d_CCTiledGrid3D_CCTiledGrid3D(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
}
extern "C" {
    #[link_name = "\u{1}??_DCCTiledGrid3D@cocos2d@@QEAAXXZ"]
    pub fn cocos2d_CCTiledGrid3D_CCTiledGrid3D_destructor(this: *mut cocos2d_CCTiledGrid3D);
}
extern "C" {
    #[link_name = "\u{1}?blit@CCTiledGrid3D@cocos2d@@UEAAXXZ"]
    pub fn cocos2d_CCTiledGrid3D_blit(this: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[link_name = "\u{1}?reuse@CCTiledGrid3D@cocos2d@@UEAAXXZ"]
    pub fn cocos2d_CCTiledGrid3D_reuse(this: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[link_name = "\u{1}?calculateVertexPoints@CCTiledGrid3D@cocos2d@@UEAAXXZ"]
    pub fn cocos2d_CCTiledGrid3D_calculateVertexPoints(this: *mut ::std::os::raw::c_void);
}
#[repr(C)]
pub struct cocos2d_CCKeypadDelegate__bindgen_vtable(::std::os::raw::c_void);
#[doc = " @addtogroup input"]
#[doc = " @{"]
#[doc = " @js NA"]
#[doc = " @lua NA"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cocos2d_CCKeypadDelegate {
    pub vtable_: *const cocos2d_CCKeypadDelegate__bindgen_vtable,
}
#[test]
fn bindgen_test_layout_cocos2d_CCKeypadDelegate() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCKeypadDelegate>(),
        8usize,
        concat!("Size of: ", stringify!(cocos2d_CCKeypadDelegate))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCKeypadDelegate>(),
        8usize,
        concat!("Alignment of ", stringify!(cocos2d_CCKeypadDelegate))
    );
}
#[doc = " @brief"]
#[doc = " CCKeypadHandler"]
#[doc = " Object than contains the CCKeypadDelegate."]
#[doc = " @js NA"]
#[doc = " @lua NA"]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCKeypadHandler {
    pub _base: cocos2d_CCObject,
    pub m_pDelegate: *mut cocos2d_CCKeypadDelegate,
}
#[test]
fn bindgen_test_layout_cocos2d_CCKeypadHandler() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCKeypadHandler>(),
        48usize,
        concat!("Size of: ", stringify!(cocos2d_CCKeypadHandler))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCKeypadHandler>(),
        8usize,
        concat!("Alignment of ", stringify!(cocos2d_CCKeypadHandler))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cocos2d_CCKeypadHandler>())).m_pDelegate as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCKeypadHandler),
            "::",
            stringify!(m_pDelegate)
        )
    );
}
extern "C" {
    #[doc = " delegate"]
    #[link_name = "\u{1}?getDelegate@CCKeypadHandler@cocos2d@@QEAAPEAVCCKeypadDelegate@2@XZ"]
    pub fn cocos2d_CCKeypadHandler_getDelegate(
        this: *mut cocos2d_CCKeypadHandler,
    ) -> *mut cocos2d_CCKeypadDelegate;
}
extern "C" {
    #[link_name = "\u{1}?setDelegate@CCKeypadHandler@cocos2d@@QEAAXPEAVCCKeypadDelegate@2@@Z"]
    pub fn cocos2d_CCKeypadHandler_setDelegate(
        this: *mut cocos2d_CCKeypadHandler,
        pDelegate: *mut cocos2d_CCKeypadDelegate,
    );
}
extern "C" {
    #[doc = " allocates a CCKeypadHandler with a delegate"]
    #[link_name = "\u{1}?handlerWithDelegate@CCKeypadHandler@cocos2d@@SAPEAV12@PEAVCCKeypadDelegate@2@@Z"]
    pub fn cocos2d_CCKeypadHandler_handlerWithDelegate(
        pDelegate: *mut cocos2d_CCKeypadDelegate,
    ) -> *mut cocos2d_CCKeypadHandler;
}
impl cocos2d_CCKeypadHandler {
    #[inline]
    pub unsafe fn getDelegate(&mut self) -> *mut cocos2d_CCKeypadDelegate {
        cocos2d_CCKeypadHandler_getDelegate(self)
    }
    #[inline]
    pub unsafe fn setDelegate(&mut self, pDelegate: *mut cocos2d_CCKeypadDelegate) {
        cocos2d_CCKeypadHandler_setDelegate(self, pDelegate)
    }
    #[inline]
    pub unsafe fn handlerWithDelegate(
        pDelegate: *mut cocos2d_CCKeypadDelegate,
    ) -> *mut cocos2d_CCKeypadHandler {
        cocos2d_CCKeypadHandler_handlerWithDelegate(pDelegate)
    }
}
extern "C" {
    #[link_name = "\u{1}??_DCCKeypadHandler@cocos2d@@QEAAXXZ"]
    pub fn cocos2d_CCKeypadHandler_CCKeypadHandler_destructor(this: *mut cocos2d_CCKeypadHandler);
}
extern "C" {
    #[doc = " initializes a CCKeypadHandler with a delegate"]
    #[link_name = "\u{1}?initWithDelegate@CCKeypadHandler@cocos2d@@UEAA_NPEAVCCKeypadDelegate@2@@Z"]
    pub fn cocos2d_CCKeypadHandler_initWithDelegate(
        this: *mut ::std::os::raw::c_void,
        pDelegate: *mut cocos2d_CCKeypadDelegate,
    ) -> bool;
}
pub const cocos2d_ccKeypadMSGType_kTypeBackClicked: cocos2d_ccKeypadMSGType = 1;
pub const cocos2d_ccKeypadMSGType_kTypeMenuClicked: cocos2d_ccKeypadMSGType = 2;
#[doc = " @addtogroup input"]
#[doc = " @{"]
pub type cocos2d_ccKeypadMSGType = ::std::os::raw::c_int;
#[doc = "@class CCKeypadDispatcher"]
#[doc = "@brief Dispatch the keypad message from the phone"]
#[doc = "@js NA"]
#[doc = "@lua NA"]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCKeypadDispatcher {
    pub _base: cocos2d_CCObject,
    pub m_pDelegates: *mut cocos2d_CCArray,
    pub m_bLocked: bool,
    pub m_bToAdd: bool,
    pub m_bToRemove: bool,
    pub m_pHandlersToAdd: *mut cocos2d__ccCArray,
    pub m_pHandlersToRemove: *mut cocos2d__ccCArray,
}
#[test]
fn bindgen_test_layout_cocos2d_CCKeypadDispatcher() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCKeypadDispatcher>(),
        72usize,
        concat!("Size of: ", stringify!(cocos2d_CCKeypadDispatcher))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCKeypadDispatcher>(),
        8usize,
        concat!("Alignment of ", stringify!(cocos2d_CCKeypadDispatcher))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cocos2d_CCKeypadDispatcher>())).m_pDelegates as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCKeypadDispatcher),
            "::",
            stringify!(m_pDelegates)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cocos2d_CCKeypadDispatcher>())).m_bLocked as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCKeypadDispatcher),
            "::",
            stringify!(m_bLocked)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cocos2d_CCKeypadDispatcher>())).m_bToAdd as *const _ as usize
        },
        49usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCKeypadDispatcher),
            "::",
            stringify!(m_bToAdd)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cocos2d_CCKeypadDispatcher>())).m_bToRemove as *const _ as usize
        },
        50usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCKeypadDispatcher),
            "::",
            stringify!(m_bToRemove)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cocos2d_CCKeypadDispatcher>())).m_pHandlersToAdd as *const _
                as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCKeypadDispatcher),
            "::",
            stringify!(m_pHandlersToAdd)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cocos2d_CCKeypadDispatcher>())).m_pHandlersToRemove as *const _
                as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCKeypadDispatcher),
            "::",
            stringify!(m_pHandlersToRemove)
        )
    );
}
extern "C" {
    #[doc = "@brief add delegate to concern keypad msg"]
    #[link_name = "\u{1}?addDelegate@CCKeypadDispatcher@cocos2d@@QEAAXPEAVCCKeypadDelegate@2@@Z"]
    pub fn cocos2d_CCKeypadDispatcher_addDelegate(
        this: *mut cocos2d_CCKeypadDispatcher,
        pDelegate: *mut cocos2d_CCKeypadDelegate,
    );
}
extern "C" {
    #[doc = "@brief remove the delegate from the delegates who concern keypad msg"]
    #[link_name = "\u{1}?removeDelegate@CCKeypadDispatcher@cocos2d@@QEAAXPEAVCCKeypadDelegate@2@@Z"]
    pub fn cocos2d_CCKeypadDispatcher_removeDelegate(
        this: *mut cocos2d_CCKeypadDispatcher,
        pDelegate: *mut cocos2d_CCKeypadDelegate,
    );
}
extern "C" {
    #[doc = "@brief force add the delegate"]
    #[link_name = "\u{1}?forceAddDelegate@CCKeypadDispatcher@cocos2d@@QEAAXPEAVCCKeypadDelegate@2@@Z"]
    pub fn cocos2d_CCKeypadDispatcher_forceAddDelegate(
        this: *mut cocos2d_CCKeypadDispatcher,
        pDelegate: *mut cocos2d_CCKeypadDelegate,
    );
}
extern "C" {
    #[doc = "@brief force remove the delegate"]
    #[link_name = "\u{1}?forceRemoveDelegate@CCKeypadDispatcher@cocos2d@@QEAAXPEAVCCKeypadDelegate@2@@Z"]
    pub fn cocos2d_CCKeypadDispatcher_forceRemoveDelegate(
        this: *mut cocos2d_CCKeypadDispatcher,
        pDelegate: *mut cocos2d_CCKeypadDelegate,
    );
}
extern "C" {
    #[doc = "@brief dispatch the key pad msg"]
    #[link_name = "\u{1}?dispatchKeypadMSG@CCKeypadDispatcher@cocos2d@@QEAA_NW4ccKeypadMSGType@2@@Z"]
    pub fn cocos2d_CCKeypadDispatcher_dispatchKeypadMSG(
        this: *mut cocos2d_CCKeypadDispatcher,
        nMsgType: cocos2d_ccKeypadMSGType,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}??0CCKeypadDispatcher@cocos2d@@QEAA@XZ"]
    pub fn cocos2d_CCKeypadDispatcher_CCKeypadDispatcher(this: *mut cocos2d_CCKeypadDispatcher);
}
impl cocos2d_CCKeypadDispatcher {
    #[inline]
    pub unsafe fn addDelegate(&mut self, pDelegate: *mut cocos2d_CCKeypadDelegate) {
        cocos2d_CCKeypadDispatcher_addDelegate(self, pDelegate)
    }
    #[inline]
    pub unsafe fn removeDelegate(&mut self, pDelegate: *mut cocos2d_CCKeypadDelegate) {
        cocos2d_CCKeypadDispatcher_removeDelegate(self, pDelegate)
    }
    #[inline]
    pub unsafe fn forceAddDelegate(&mut self, pDelegate: *mut cocos2d_CCKeypadDelegate) {
        cocos2d_CCKeypadDispatcher_forceAddDelegate(self, pDelegate)
    }
    #[inline]
    pub unsafe fn forceRemoveDelegate(&mut self, pDelegate: *mut cocos2d_CCKeypadDelegate) {
        cocos2d_CCKeypadDispatcher_forceRemoveDelegate(self, pDelegate)
    }
    #[inline]
    pub unsafe fn dispatchKeypadMSG(&mut self, nMsgType: cocos2d_ccKeypadMSGType) -> bool {
        cocos2d_CCKeypadDispatcher_dispatchKeypadMSG(self, nMsgType)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cocos2d_CCKeypadDispatcher_CCKeypadDispatcher(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
}
extern "C" {
    #[link_name = "\u{1}??_DCCKeypadDispatcher@cocos2d@@QEAAXXZ"]
    pub fn cocos2d_CCKeypadDispatcher_CCKeypadDispatcher_destructor(
        this: *mut cocos2d_CCKeypadDispatcher,
    );
}
#[doc = " @addtogroup base_nodes"]
#[doc = " @{"]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCTextureAtlas {
    pub _base: cocos2d_CCObject,
    pub m_pIndices: *mut GLushort,
    pub m_pBuffersVBO: [GLuint; 2usize],
    pub m_bDirty: bool,
    pub m_uTotalQuads: ::std::os::raw::c_uint,
    pub m_uCapacity: ::std::os::raw::c_uint,
    pub m_pTexture: *mut cocos2d_CCTexture2D,
    pub m_pQuads: *mut cocos2d_ccV3F_C4B_T2F_Quad,
}
#[test]
fn bindgen_test_layout_cocos2d_CCTextureAtlas() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCTextureAtlas>(),
        88usize,
        concat!("Size of: ", stringify!(cocos2d_CCTextureAtlas))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCTextureAtlas>(),
        8usize,
        concat!("Alignment of ", stringify!(cocos2d_CCTextureAtlas))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cocos2d_CCTextureAtlas>())).m_pIndices as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCTextureAtlas),
            "::",
            stringify!(m_pIndices)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cocos2d_CCTextureAtlas>())).m_pBuffersVBO as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCTextureAtlas),
            "::",
            stringify!(m_pBuffersVBO)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cocos2d_CCTextureAtlas>())).m_bDirty as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCTextureAtlas),
            "::",
            stringify!(m_bDirty)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cocos2d_CCTextureAtlas>())).m_uTotalQuads as *const _ as usize
        },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCTextureAtlas),
            "::",
            stringify!(m_uTotalQuads)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cocos2d_CCTextureAtlas>())).m_uCapacity as *const _ as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCTextureAtlas),
            "::",
            stringify!(m_uCapacity)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cocos2d_CCTextureAtlas>())).m_pTexture as *const _ as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCTextureAtlas),
            "::",
            stringify!(m_pTexture)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cocos2d_CCTextureAtlas>())).m_pQuads as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCTextureAtlas),
            "::",
            stringify!(m_pQuads)
        )
    );
}
extern "C" {
    #[doc = "  @js NA"]
    #[doc = "  @lua NA"]
    #[link_name = "\u{1}?description@CCTextureAtlas@cocos2d@@QEAAPEBDXZ"]
    pub fn cocos2d_CCTextureAtlas_description(
        this: *mut cocos2d_CCTextureAtlas,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " creates a TextureAtlas with an filename and with an initial capacity for Quads."]
    #[doc = " The TextureAtlas capacity can be increased in runtime."]
    #[link_name = "\u{1}?create@CCTextureAtlas@cocos2d@@SAPEAV12@PEBDI@Z"]
    pub fn cocos2d_CCTextureAtlas_create(
        file: *const ::std::os::raw::c_char,
        capacity: ::std::os::raw::c_uint,
    ) -> *mut cocos2d_CCTextureAtlas;
}
extern "C" {
    #[doc = " initializes a TextureAtlas with a filename and with a certain capacity for Quads."]
    #[doc = " The TextureAtlas capacity can be increased in runtime."]
    #[doc = ""]
    #[doc = " WARNING: Do not reinitialize the TextureAtlas because it will leak memory (issue #706)"]
    #[link_name = "\u{1}?initWithFile@CCTextureAtlas@cocos2d@@QEAA_NPEBDI@Z"]
    pub fn cocos2d_CCTextureAtlas_initWithFile(
        this: *mut cocos2d_CCTextureAtlas,
        file: *const ::std::os::raw::c_char,
        capacity: ::std::os::raw::c_uint,
    ) -> bool;
}
extern "C" {
    #[doc = " creates a TextureAtlas with a previously initialized Texture2D object, and"]
    #[doc = " with an initial capacity for n Quads."]
    #[doc = " The TextureAtlas capacity can be increased in runtime."]
    #[link_name = "\u{1}?createWithTexture@CCTextureAtlas@cocos2d@@SAPEAV12@PEAVCCTexture2D@2@I@Z"]
    pub fn cocos2d_CCTextureAtlas_createWithTexture(
        texture: *mut cocos2d_CCTexture2D,
        capacity: ::std::os::raw::c_uint,
    ) -> *mut cocos2d_CCTextureAtlas;
}
extern "C" {
    #[doc = " initializes a TextureAtlas with a previously initialized Texture2D object, and"]
    #[doc = " with an initial capacity for Quads."]
    #[doc = " The TextureAtlas capacity can be increased in runtime."]
    #[doc = ""]
    #[doc = " WARNING: Do not reinitialize the TextureAtlas because it will leak memory (issue #706)"]
    #[link_name = "\u{1}?initWithTexture@CCTextureAtlas@cocos2d@@QEAA_NPEAVCCTexture2D@2@I@Z"]
    pub fn cocos2d_CCTextureAtlas_initWithTexture(
        this: *mut cocos2d_CCTextureAtlas,
        texture: *mut cocos2d_CCTexture2D,
        capacity: ::std::os::raw::c_uint,
    ) -> bool;
}
extern "C" {
    #[doc = " updates a Quad (texture, vertex and color) at a certain index"]
    #[doc = " index must be between 0 and the atlas capacity - 1"]
    #[doc = "@since v0.8"]
    #[link_name = "\u{1}?updateQuad@CCTextureAtlas@cocos2d@@QEAAXPEAU_ccV3F_C4B_T2F_Quad@2@I@Z"]
    pub fn cocos2d_CCTextureAtlas_updateQuad(
        this: *mut cocos2d_CCTextureAtlas,
        quad: *mut cocos2d_ccV3F_C4B_T2F_Quad,
        index: ::std::os::raw::c_uint,
    );
}
extern "C" {
    #[doc = " Inserts a Quad (texture, vertex and color) at a certain index"]
    #[doc = "index must be between 0 and the atlas capacity - 1"]
    #[doc = "@since v0.8"]
    #[link_name = "\u{1}?insertQuad@CCTextureAtlas@cocos2d@@QEAAXPEAU_ccV3F_C4B_T2F_Quad@2@I@Z"]
    pub fn cocos2d_CCTextureAtlas_insertQuad(
        this: *mut cocos2d_CCTextureAtlas,
        quad: *mut cocos2d_ccV3F_C4B_T2F_Quad,
        index: ::std::os::raw::c_uint,
    );
}
extern "C" {
    #[doc = " Inserts a c array of quads at a given index"]
    #[doc = "index must be between 0 and the atlas capacity - 1"]
    #[doc = "this method doesn't enlarge the array when amount + index > totalQuads"]
    #[doc = "@since v1.1"]
    #[link_name = "\u{1}?insertQuads@CCTextureAtlas@cocos2d@@QEAAXPEAU_ccV3F_C4B_T2F_Quad@2@II@Z"]
    pub fn cocos2d_CCTextureAtlas_insertQuads(
        this: *mut cocos2d_CCTextureAtlas,
        quads: *mut cocos2d_ccV3F_C4B_T2F_Quad,
        index: ::std::os::raw::c_uint,
        amount: ::std::os::raw::c_uint,
    );
}
extern "C" {
    #[doc = " Removes the quad that is located at a certain index and inserts it at a new index"]
    #[doc = "This operation is faster than removing and inserting in a quad in 2 different steps"]
    #[doc = "@since v0.7.2"]
    #[link_name = "\u{1}?insertQuadFromIndex@CCTextureAtlas@cocos2d@@QEAAXII@Z"]
    pub fn cocos2d_CCTextureAtlas_insertQuadFromIndex(
        this: *mut cocos2d_CCTextureAtlas,
        fromIndex: ::std::os::raw::c_uint,
        newIndex: ::std::os::raw::c_uint,
    );
}
extern "C" {
    #[doc = " removes a quad at a given index number."]
    #[doc = "The capacity remains the same, but the total number of quads to be drawn is reduced in 1"]
    #[doc = "@since v0.7.2"]
    #[link_name = "\u{1}?removeQuadAtIndex@CCTextureAtlas@cocos2d@@QEAAXI@Z"]
    pub fn cocos2d_CCTextureAtlas_removeQuadAtIndex(
        this: *mut cocos2d_CCTextureAtlas,
        index: ::std::os::raw::c_uint,
    );
}
extern "C" {
    #[doc = " removes a amount of quads starting from index"]
    #[doc = "@since 1.1"]
    #[link_name = "\u{1}?removeQuadsAtIndex@CCTextureAtlas@cocos2d@@QEAAXII@Z"]
    pub fn cocos2d_CCTextureAtlas_removeQuadsAtIndex(
        this: *mut cocos2d_CCTextureAtlas,
        index: ::std::os::raw::c_uint,
        amount: ::std::os::raw::c_uint,
    );
}
extern "C" {
    #[doc = " removes all Quads."]
    #[doc = "The TextureAtlas capacity remains untouched. No memory is freed."]
    #[doc = "The total number of quads to be drawn will be 0"]
    #[doc = "@since v0.7.2"]
    #[link_name = "\u{1}?removeAllQuads@CCTextureAtlas@cocos2d@@QEAAXXZ"]
    pub fn cocos2d_CCTextureAtlas_removeAllQuads(this: *mut cocos2d_CCTextureAtlas);
}
extern "C" {
    #[doc = " resize the capacity of the CCTextureAtlas."]
    #[doc = " The new capacity can be lower or higher than the current one"]
    #[doc = " It returns YES if the resize was successful."]
    #[doc = " If it fails to resize the capacity it will return NO with a new capacity of 0."]
    #[link_name = "\u{1}?resizeCapacity@CCTextureAtlas@cocos2d@@QEAA_NI@Z"]
    pub fn cocos2d_CCTextureAtlas_resizeCapacity(
        this: *mut cocos2d_CCTextureAtlas,
        n: ::std::os::raw::c_uint,
    ) -> bool;
}
extern "C" {
    #[doc = "Used internally by CCParticleBatchNode"]
    #[doc = "don't use this unless you know what you're doing"]
    #[doc = "@since 1.1"]
    #[link_name = "\u{1}?increaseTotalQuadsWith@CCTextureAtlas@cocos2d@@QEAAXI@Z"]
    pub fn cocos2d_CCTextureAtlas_increaseTotalQuadsWith(
        this: *mut cocos2d_CCTextureAtlas,
        amount: ::std::os::raw::c_uint,
    );
}
extern "C" {
    #[doc = " Moves an amount of quads from oldIndex at newIndex"]
    #[doc = "@since v1.1"]
    #[link_name = "\u{1}?moveQuadsFromIndex@CCTextureAtlas@cocos2d@@QEAAXIII@Z"]
    pub fn cocos2d_CCTextureAtlas_moveQuadsFromIndex(
        this: *mut cocos2d_CCTextureAtlas,
        oldIndex: ::std::os::raw::c_uint,
        amount: ::std::os::raw::c_uint,
        newIndex: ::std::os::raw::c_uint,
    );
}
extern "C" {
    #[doc = "Moves quads from index till totalQuads to the newIndex"]
    #[doc = "Used internally by CCParticleBatchNode"]
    #[doc = "This method doesn't enlarge the array if newIndex + quads to be moved > capacity"]
    #[doc = "@since 1.1"]
    #[link_name = "\u{1}?moveQuadsFromIndex@CCTextureAtlas@cocos2d@@QEAAXII@Z"]
    pub fn cocos2d_CCTextureAtlas_moveQuadsFromIndex1(
        this: *mut cocos2d_CCTextureAtlas,
        index: ::std::os::raw::c_uint,
        newIndex: ::std::os::raw::c_uint,
    );
}
extern "C" {
    #[doc = "Ensures that after a realloc quads are still empty"]
    #[doc = "Used internally by CCParticleBatchNode"]
    #[doc = "@since 1.1"]
    #[link_name = "\u{1}?fillWithEmptyQuadsFromIndex@CCTextureAtlas@cocos2d@@QEAAXII@Z"]
    pub fn cocos2d_CCTextureAtlas_fillWithEmptyQuadsFromIndex(
        this: *mut cocos2d_CCTextureAtlas,
        index: ::std::os::raw::c_uint,
        amount: ::std::os::raw::c_uint,
    );
}
extern "C" {
    #[doc = " draws n quads"]
    #[doc = " n can't be greater than the capacity of the Atlas"]
    #[link_name = "\u{1}?drawNumberOfQuads@CCTextureAtlas@cocos2d@@QEAAXI@Z"]
    pub fn cocos2d_CCTextureAtlas_drawNumberOfQuads(
        this: *mut cocos2d_CCTextureAtlas,
        n: ::std::os::raw::c_uint,
    );
}
extern "C" {
    #[doc = " draws n quads from an index (offset)."]
    #[doc = "n + start can't be greater than the capacity of the atlas"]
    #[doc = ""]
    #[doc = "@since v1.0"]
    #[link_name = "\u{1}?drawNumberOfQuads@CCTextureAtlas@cocos2d@@QEAAXII@Z"]
    pub fn cocos2d_CCTextureAtlas_drawNumberOfQuads1(
        this: *mut cocos2d_CCTextureAtlas,
        n: ::std::os::raw::c_uint,
        start: ::std::os::raw::c_uint,
    );
}
extern "C" {
    #[doc = " draws all the Atlas's Quads"]
    #[link_name = "\u{1}?drawQuads@CCTextureAtlas@cocos2d@@QEAAXXZ"]
    pub fn cocos2d_CCTextureAtlas_drawQuads(this: *mut cocos2d_CCTextureAtlas);
}
extern "C" {
    #[doc = " listen the event that coming to foreground on Android"]
    #[link_name = "\u{1}?listenBackToForeground@CCTextureAtlas@cocos2d@@QEAAXPEAVCCObject@2@@Z"]
    pub fn cocos2d_CCTextureAtlas_listenBackToForeground(
        this: *mut cocos2d_CCTextureAtlas,
        obj: *mut cocos2d_CCObject,
    );
}
extern "C" {
    #[doc = " @js ctor"]
    #[link_name = "\u{1}??0CCTextureAtlas@cocos2d@@QEAA@XZ"]
    pub fn cocos2d_CCTextureAtlas_CCTextureAtlas(this: *mut cocos2d_CCTextureAtlas);
}
impl cocos2d_CCTextureAtlas {
    #[inline]
    pub unsafe fn description(&mut self) -> *const ::std::os::raw::c_char {
        cocos2d_CCTextureAtlas_description(self)
    }
    #[inline]
    pub unsafe fn create(
        file: *const ::std::os::raw::c_char,
        capacity: ::std::os::raw::c_uint,
    ) -> *mut cocos2d_CCTextureAtlas {
        cocos2d_CCTextureAtlas_create(file, capacity)
    }
    #[inline]
    pub unsafe fn initWithFile(
        &mut self,
        file: *const ::std::os::raw::c_char,
        capacity: ::std::os::raw::c_uint,
    ) -> bool {
        cocos2d_CCTextureAtlas_initWithFile(self, file, capacity)
    }
    #[inline]
    pub unsafe fn createWithTexture(
        texture: *mut cocos2d_CCTexture2D,
        capacity: ::std::os::raw::c_uint,
    ) -> *mut cocos2d_CCTextureAtlas {
        cocos2d_CCTextureAtlas_createWithTexture(texture, capacity)
    }
    #[inline]
    pub unsafe fn initWithTexture(
        &mut self,
        texture: *mut cocos2d_CCTexture2D,
        capacity: ::std::os::raw::c_uint,
    ) -> bool {
        cocos2d_CCTextureAtlas_initWithTexture(self, texture, capacity)
    }
    #[inline]
    pub unsafe fn updateQuad(
        &mut self,
        quad: *mut cocos2d_ccV3F_C4B_T2F_Quad,
        index: ::std::os::raw::c_uint,
    ) {
        cocos2d_CCTextureAtlas_updateQuad(self, quad, index)
    }
    #[inline]
    pub unsafe fn insertQuad(
        &mut self,
        quad: *mut cocos2d_ccV3F_C4B_T2F_Quad,
        index: ::std::os::raw::c_uint,
    ) {
        cocos2d_CCTextureAtlas_insertQuad(self, quad, index)
    }
    #[inline]
    pub unsafe fn insertQuads(
        &mut self,
        quads: *mut cocos2d_ccV3F_C4B_T2F_Quad,
        index: ::std::os::raw::c_uint,
        amount: ::std::os::raw::c_uint,
    ) {
        cocos2d_CCTextureAtlas_insertQuads(self, quads, index, amount)
    }
    #[inline]
    pub unsafe fn insertQuadFromIndex(
        &mut self,
        fromIndex: ::std::os::raw::c_uint,
        newIndex: ::std::os::raw::c_uint,
    ) {
        cocos2d_CCTextureAtlas_insertQuadFromIndex(self, fromIndex, newIndex)
    }
    #[inline]
    pub unsafe fn removeQuadAtIndex(&mut self, index: ::std::os::raw::c_uint) {
        cocos2d_CCTextureAtlas_removeQuadAtIndex(self, index)
    }
    #[inline]
    pub unsafe fn removeQuadsAtIndex(
        &mut self,
        index: ::std::os::raw::c_uint,
        amount: ::std::os::raw::c_uint,
    ) {
        cocos2d_CCTextureAtlas_removeQuadsAtIndex(self, index, amount)
    }
    #[inline]
    pub unsafe fn removeAllQuads(&mut self) {
        cocos2d_CCTextureAtlas_removeAllQuads(self)
    }
    #[inline]
    pub unsafe fn resizeCapacity(&mut self, n: ::std::os::raw::c_uint) -> bool {
        cocos2d_CCTextureAtlas_resizeCapacity(self, n)
    }
    #[inline]
    pub unsafe fn increaseTotalQuadsWith(&mut self, amount: ::std::os::raw::c_uint) {
        cocos2d_CCTextureAtlas_increaseTotalQuadsWith(self, amount)
    }
    #[inline]
    pub unsafe fn moveQuadsFromIndex(
        &mut self,
        oldIndex: ::std::os::raw::c_uint,
        amount: ::std::os::raw::c_uint,
        newIndex: ::std::os::raw::c_uint,
    ) {
        cocos2d_CCTextureAtlas_moveQuadsFromIndex(self, oldIndex, amount, newIndex)
    }
    #[inline]
    pub unsafe fn moveQuadsFromIndex1(
        &mut self,
        index: ::std::os::raw::c_uint,
        newIndex: ::std::os::raw::c_uint,
    ) {
        cocos2d_CCTextureAtlas_moveQuadsFromIndex1(self, index, newIndex)
    }
    #[inline]
    pub unsafe fn fillWithEmptyQuadsFromIndex(
        &mut self,
        index: ::std::os::raw::c_uint,
        amount: ::std::os::raw::c_uint,
    ) {
        cocos2d_CCTextureAtlas_fillWithEmptyQuadsFromIndex(self, index, amount)
    }
    #[inline]
    pub unsafe fn drawNumberOfQuads(&mut self, n: ::std::os::raw::c_uint) {
        cocos2d_CCTextureAtlas_drawNumberOfQuads(self, n)
    }
    #[inline]
    pub unsafe fn drawNumberOfQuads1(
        &mut self,
        n: ::std::os::raw::c_uint,
        start: ::std::os::raw::c_uint,
    ) {
        cocos2d_CCTextureAtlas_drawNumberOfQuads1(self, n, start)
    }
    #[inline]
    pub unsafe fn drawQuads(&mut self) {
        cocos2d_CCTextureAtlas_drawQuads(self)
    }
    #[inline]
    pub unsafe fn listenBackToForeground(&mut self, obj: *mut cocos2d_CCObject) {
        cocos2d_CCTextureAtlas_listenBackToForeground(self, obj)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cocos2d_CCTextureAtlas_CCTextureAtlas(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
}
extern "C" {
    #[link_name = "\u{1}?getTotalQuads@CCTextureAtlas@cocos2d@@UEAAIXZ"]
    pub fn cocos2d_CCTextureAtlas_getTotalQuads(
        this: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[link_name = "\u{1}?getCapacity@CCTextureAtlas@cocos2d@@UEAAIXZ"]
    pub fn cocos2d_CCTextureAtlas_getCapacity(
        this: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[link_name = "\u{1}?getTexture@CCTextureAtlas@cocos2d@@UEAAPEAVCCTexture2D@2@XZ"]
    pub fn cocos2d_CCTextureAtlas_getTexture(
        this: *mut ::std::os::raw::c_void,
    ) -> *mut cocos2d_CCTexture2D;
}
extern "C" {
    #[link_name = "\u{1}?setTexture@CCTextureAtlas@cocos2d@@UEAAXPEAVCCTexture2D@2@@Z"]
    pub fn cocos2d_CCTextureAtlas_setTexture(
        this: *mut ::std::os::raw::c_void,
        var: *mut cocos2d_CCTexture2D,
    );
}
extern "C" {
    #[link_name = "\u{1}?getQuads@CCTextureAtlas@cocos2d@@UEAAPEAU_ccV3F_C4B_T2F_Quad@2@XZ"]
    pub fn cocos2d_CCTextureAtlas_getQuads(
        this: *mut ::std::os::raw::c_void,
    ) -> *mut cocos2d_ccV3F_C4B_T2F_Quad;
}
extern "C" {
    #[link_name = "\u{1}?setQuads@CCTextureAtlas@cocos2d@@UEAAXPEAU_ccV3F_C4B_T2F_Quad@2@@Z"]
    pub fn cocos2d_CCTextureAtlas_setQuads(
        this: *mut ::std::os::raw::c_void,
        var: *mut cocos2d_ccV3F_C4B_T2F_Quad,
    );
}
extern "C" {
    #[doc = "  @js NA"]
    #[doc = "  @lua NA"]
    #[link_name = "\u{1}??_DCCTextureAtlas@cocos2d@@QEAAXXZ"]
    pub fn cocos2d_CCTextureAtlas_CCTextureAtlas_destructor(this: *mut cocos2d_CCTextureAtlas);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cocos2d_transformValues_ {
    _unused: [u8; 0],
}
#[doc = " CCSprite is a 2d image ( http://en.wikipedia.org/wiki/Sprite_(computer_graphics) )"]
#[doc = ""]
#[doc = " CCSprite can be created with an image, or with a sub-rectangle of an image."]
#[doc = ""]
#[doc = " If the parent or any of its ancestors is a CCSpriteBatchNode then the following features/limitations are valid"]
#[doc = "    - Features when the parent is a CCBatchNode:"]
#[doc = "        - MUCH faster rendering, specially if the CCSpriteBatchNode has many children. All the children will be drawn in a single batch."]
#[doc = ""]
#[doc = "    - Limitations"]
#[doc = "        - Camera is not supported yet (eg: CCOrbitCamera action doesn't work)"]
#[doc = "        - GridBase actions are not supported (eg: CCLens, CCRipple, CCTwirl)"]
#[doc = "        - The Alias/Antialias property belongs to CCSpriteBatchNode, so you can't individually set the aliased property."]
#[doc = "        - The Blending function property belongs to CCSpriteBatchNode, so you can't individually set the blending function property."]
#[doc = "        - Parallax scroller is not supported, but can be simulated with a \"proxy\" sprite."]
#[doc = ""]
#[doc = "  If the parent is an standard CCNode, then CCSprite behaves like any other CCNode:"]
#[doc = "    - It supports blending functions"]
#[doc = "    - It supports aliasing / antialiasing"]
#[doc = "    - But the rendering will be slower: 1 draw per children."]
#[doc = ""]
#[doc = " The default anchorPoint in CCSprite is (0.5, 0.5)."]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCSprite {
    pub _base: cocos2d_CCNodeRGBA,
    pub _base_1: cocos2d_CCTextureProtocol,
    pub m_pobTextureAtlas: *mut cocos2d_CCTextureAtlas,
    #[doc = " CCSpriteBatchNode texture atlas (weak reference)"]
    pub m_uAtlasIndex: ::std::os::raw::c_uint,
    #[doc = " Absolute (real) Index on the SpriteSheet"]
    pub m_pobBatchNode: *mut cocos2d_CCSpriteBatchNode,
    #[doc = " Used batch node (weak reference)"]
    pub m_bDirty: bool,
    #[doc = " Whether the sprite needs to be updated"]
    pub m_bRecursiveDirty: bool,
    #[doc = " Whether all of the sprite's children needs to be updated"]
    pub m_bHasChildren: bool,
    #[doc = " Whether the sprite contains children"]
    pub m_bShouldBeHidden: bool,
    #[doc = " should not be drawn because one of the ancestors is not visible"]
    pub m_transformToBatch: cocos2d_CCAffineTransform,
    pub m_sBlendFunc: cocos2d_ccBlendFunc,
    #[doc = " It's required for CCTextureProtocol inheritance"]
    pub m_pobTexture: *mut cocos2d_CCTexture2D,
    #[doc = " CCTexture2D object that is used to render the sprite"]
    pub m_obRect: cocos2d_CCRect,
    #[doc = " Retangle of CCTexture2D"]
    pub m_bRectRotated: bool,
    #[doc = " Whether the texture is rotated"]
    pub m_obOffsetPosition: cocos2d_CCPoint,
    pub m_obUnflippedOffsetPositionFromCenter: cocos2d_CCPoint,
    pub m_sQuad: cocos2d_ccV3F_C4B_T2F_Quad,
    pub m_bOpacityModifyRGB: bool,
    pub m_bFlipX: bool,
    #[doc = " Whether the sprite is flipped horizaontally or not."]
    pub m_bFlipY: bool,
    pub m_bDontDraw: bool,
    pub m_fTlVertexMod: f32,
    pub m_fTrVertexMod: f32,
    pub m_fBlVertexMod: f32,
    pub m_fBrVertexMod: f32,
    pub pad567: [::std::os::raw::c_char; 16usize],
    pub m_bUnknown: bool,
    pub m_nUnknown: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_cocos2d_CCSprite() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCSprite>(),
        576usize,
        concat!("Size of: ", stringify!(cocos2d_CCSprite))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCSprite>(),
        8usize,
        concat!("Alignment of ", stringify!(cocos2d_CCSprite))
    );
}
extern "C" {
    #[doc = " Creates an empty sprite without texture. You can call setTexture method subsequently."]
    #[doc = ""]
    #[doc = " @return An empty sprite object that is marked as autoreleased."]
    #[link_name = "\u{1}?create@CCSprite@cocos2d@@SAPEAV12@XZ"]
    pub fn cocos2d_CCSprite_create() -> *mut cocos2d_CCSprite;
}
extern "C" {
    #[doc = " Creates a sprite with an image filename."]
    #[doc = ""]
    #[doc = " After creation, the rect of sprite will be the size of the image,"]
    #[doc = " and the offset will be (0,0)."]
    #[doc = ""]
    #[doc = " @param   pszFileName The string which indicates a path to image file, e.g., \"scene1/monster.png\"."]
    #[doc = " @return  A valid sprite object that is marked as autoreleased."]
    #[link_name = "\u{1}?create@CCSprite@cocos2d@@SAPEAV12@PEBD@Z"]
    pub fn cocos2d_CCSprite_create1(
        pszFileName: *const ::std::os::raw::c_char,
    ) -> *mut cocos2d_CCSprite;
}
extern "C" {
    #[doc = " Creates a sprite with an image filename and a rect."]
    #[doc = ""]
    #[doc = " @param   pszFileName The string wich indicates a path to image file, e.g., \"scene1/monster.png\""]
    #[doc = " @param   rect        Only the contents inside rect of pszFileName's texture will be applied for this sprite."]
    #[doc = " @return  A valid sprite object that is marked as autoreleased."]
    #[link_name = "\u{1}?create@CCSprite@cocos2d@@SAPEAV12@PEBDAEBVCCRect@2@@Z"]
    pub fn cocos2d_CCSprite_create2(
        pszFileName: *const ::std::os::raw::c_char,
        rect: *const cocos2d_CCRect,
    ) -> *mut cocos2d_CCSprite;
}
extern "C" {
    #[doc = " Creates a sprite with an exsiting texture contained in a CCTexture2D object"]
    #[doc = " After creation, the rect will be the size of the texture, and the offset will be (0,0)."]
    #[doc = ""]
    #[doc = " @param   pTexture    A pointer to a CCTexture2D object."]
    #[doc = " @return  A valid sprite object that is marked as autoreleased."]
    #[link_name = "\u{1}?createWithTexture@CCSprite@cocos2d@@SAPEAV12@PEAVCCTexture2D@2@@Z"]
    pub fn cocos2d_CCSprite_createWithTexture(
        pTexture: *mut cocos2d_CCTexture2D,
    ) -> *mut cocos2d_CCSprite;
}
extern "C" {
    #[doc = " Creates a sprite with a texture and a rect."]
    #[doc = ""]
    #[doc = " After creation, the offset will be (0,0)."]
    #[doc = ""]
    #[doc = " @param   pTexture    A pointer to an existing CCTexture2D object."]
    #[doc = "                      You can use a CCTexture2D object for many sprites."]
    #[doc = " @param   rect        Only the contents inside the rect of this texture will be applied for this sprite."]
    #[doc = " @return  A valid sprite object that is marked as autoreleased."]
    #[link_name = "\u{1}?createWithTexture@CCSprite@cocos2d@@SAPEAV12@PEAVCCTexture2D@2@AEBVCCRect@2@@Z"]
    pub fn cocos2d_CCSprite_createWithTexture1(
        pTexture: *mut cocos2d_CCTexture2D,
        rect: *const cocos2d_CCRect,
    ) -> *mut cocos2d_CCSprite;
}
extern "C" {
    #[doc = " Creates a sprite with an sprite frame."]
    #[doc = ""]
    #[doc = " @param   pSpriteFrame    A sprite frame which involves a texture and a rect"]
    #[doc = " @return  A valid sprite object that is marked as autoreleased."]
    #[link_name = "\u{1}?createWithSpriteFrame@CCSprite@cocos2d@@SAPEAV12@PEAVCCSpriteFrame@2@@Z"]
    pub fn cocos2d_CCSprite_createWithSpriteFrame(
        pSpriteFrame: *mut cocos2d_CCSpriteFrame,
    ) -> *mut cocos2d_CCSprite;
}
extern "C" {
    #[doc = " Creates a sprite with an sprite frame name."]
    #[doc = ""]
    #[doc = " A CCSpriteFrame will be fetched from the CCSpriteFrameCache by pszSpriteFrameName param."]
    #[doc = " If the CCSpriteFrame doesn't exist it will raise an exception."]
    #[doc = ""]
    #[doc = " @param   pszSpriteFrameName A null terminated string which indicates the sprite frame name."]
    #[doc = " @return  A valid sprite object that is marked as autoreleased."]
    #[link_name = "\u{1}?createWithSpriteFrameName@CCSprite@cocos2d@@SAPEAV12@PEBD@Z"]
    pub fn cocos2d_CCSprite_createWithSpriteFrameName(
        pszSpriteFrameName: *const ::std::os::raw::c_char,
    ) -> *mut cocos2d_CCSprite;
}
extern "C" {
    #[doc = " Returns the flag which indicates whether the sprite is flipped horizontally or not."]
    #[doc = ""]
    #[doc = " It only flips the texture of the sprite, and not the texture of the sprite's children."]
    #[doc = " Also, flipping the texture doesn't alter the anchorPoint."]
    #[doc = " If you want to flip the anchorPoint too, and/or to flip the children too use:"]
    #[doc = " sprite->setScaleX(sprite->getScaleX() * -1);"]
    #[doc = ""]
    #[doc = " @return true if the sprite is flipped horizaontally, false otherwise."]
    #[doc = " @js isFlippedX"]
    #[link_name = "\u{1}?isFlipX@CCSprite@cocos2d@@QEAA_NXZ"]
    pub fn cocos2d_CCSprite_isFlipX(this: *mut cocos2d_CCSprite) -> bool;
}
extern "C" {
    #[doc = " Sets whether the sprite should be flipped horizontally or not."]
    #[doc = ""]
    #[doc = " @param bFlipX true if the sprite should be flipped horizaontally, false otherwise."]
    #[link_name = "\u{1}?setFlipX@CCSprite@cocos2d@@QEAAX_N@Z"]
    pub fn cocos2d_CCSprite_setFlipX(this: *mut cocos2d_CCSprite, bFlipX: bool);
}
extern "C" {
    #[doc = " Return the flag which indicates whether the sprite is flipped vertically or not."]
    #[doc = ""]
    #[doc = " It only flips the texture of the sprite, and not the texture of the sprite's children."]
    #[doc = " Also, flipping the texture doesn't alter the anchorPoint."]
    #[doc = " If you want to flip the anchorPoint too, and/or to flip the children too use:"]
    #[doc = " sprite->setScaleY(sprite->getScaleY() * -1);"]
    #[doc = ""]
    #[doc = " @return true if the sprite is flipped vertically, flase otherwise."]
    #[doc = " @js isFlippedY"]
    #[link_name = "\u{1}?isFlipY@CCSprite@cocos2d@@QEAA_NXZ"]
    pub fn cocos2d_CCSprite_isFlipY(this: *mut cocos2d_CCSprite) -> bool;
}
extern "C" {
    #[doc = " Sets whether the sprite should be flipped vertically or not."]
    #[doc = ""]
    #[doc = " @param bFlipY true if the sprite should be flipped vertically, flase otherwise."]
    #[link_name = "\u{1}?setFlipY@CCSprite@cocos2d@@QEAAX_N@Z"]
    pub fn cocos2d_CCSprite_setFlipY(this: *mut cocos2d_CCSprite, bFlipY: bool);
}
extern "C" {
    #[doc = " @} End of Sprite properties getter/setters"]
    #[link_name = "\u{1}?updateColor@CCSprite@cocos2d@@IEAAXXZ"]
    pub fn cocos2d_CCSprite_updateColor(this: *mut cocos2d_CCSprite);
}
extern "C" {
    #[doc = " Default constructor"]
    #[doc = " @js ctor"]
    #[link_name = "\u{1}??0CCSprite@cocos2d@@QEAA@XZ"]
    pub fn cocos2d_CCSprite_CCSprite(this: *mut cocos2d_CCSprite);
}
impl cocos2d_CCSprite {
    #[inline]
    pub unsafe fn create() -> *mut cocos2d_CCSprite {
        cocos2d_CCSprite_create()
    }
    #[inline]
    pub unsafe fn create1(pszFileName: *const ::std::os::raw::c_char) -> *mut cocos2d_CCSprite {
        cocos2d_CCSprite_create1(pszFileName)
    }
    #[inline]
    pub unsafe fn create2(
        pszFileName: *const ::std::os::raw::c_char,
        rect: *const cocos2d_CCRect,
    ) -> *mut cocos2d_CCSprite {
        cocos2d_CCSprite_create2(pszFileName, rect)
    }
    #[inline]
    pub unsafe fn createWithTexture(pTexture: *mut cocos2d_CCTexture2D) -> *mut cocos2d_CCSprite {
        cocos2d_CCSprite_createWithTexture(pTexture)
    }
    #[inline]
    pub unsafe fn createWithTexture1(
        pTexture: *mut cocos2d_CCTexture2D,
        rect: *const cocos2d_CCRect,
    ) -> *mut cocos2d_CCSprite {
        cocos2d_CCSprite_createWithTexture1(pTexture, rect)
    }
    #[inline]
    pub unsafe fn createWithSpriteFrame(
        pSpriteFrame: *mut cocos2d_CCSpriteFrame,
    ) -> *mut cocos2d_CCSprite {
        cocos2d_CCSprite_createWithSpriteFrame(pSpriteFrame)
    }
    #[inline]
    pub unsafe fn createWithSpriteFrameName(
        pszSpriteFrameName: *const ::std::os::raw::c_char,
    ) -> *mut cocos2d_CCSprite {
        cocos2d_CCSprite_createWithSpriteFrameName(pszSpriteFrameName)
    }
    #[inline]
    pub unsafe fn isFlipX(&mut self) -> bool {
        cocos2d_CCSprite_isFlipX(self)
    }
    #[inline]
    pub unsafe fn setFlipX(&mut self, bFlipX: bool) {
        cocos2d_CCSprite_setFlipX(self, bFlipX)
    }
    #[inline]
    pub unsafe fn isFlipY(&mut self) -> bool {
        cocos2d_CCSprite_isFlipY(self)
    }
    #[inline]
    pub unsafe fn setFlipY(&mut self, bFlipY: bool) {
        cocos2d_CCSprite_setFlipY(self, bFlipY)
    }
    #[inline]
    pub unsafe fn updateColor(&mut self) {
        cocos2d_CCSprite_updateColor(self)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cocos2d_CCSprite_CCSprite(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
}
extern "C" {
    #[doc = " Default destructor"]
    #[doc = " @js NA"]
    #[doc = " @lua NA"]
    #[link_name = "\u{1}??_DCCSprite@cocos2d@@QEAAXXZ"]
    pub fn cocos2d_CCSprite_CCSprite_destructor(this: *mut cocos2d_CCSprite);
}
extern "C" {
    #[doc = " Initializes an empty sprite with nothing init."]
    #[link_name = "\u{1}?init@CCSprite@cocos2d@@UEAA_NXZ"]
    pub fn cocos2d_CCSprite_init(this: *mut ::std::os::raw::c_void) -> bool;
}
extern "C" {
    #[doc = " Initializes a sprite with a texture."]
    #[doc = ""]
    #[doc = " After initialization, the rect used will be the size of the texture, and the offset will be (0,0)."]
    #[doc = ""]
    #[doc = " @param   pTexture    A pointer to an existing CCTexture2D object."]
    #[doc = "                      You can use a CCTexture2D object for many sprites."]
    #[doc = " @return  true if the sprite is initialized properly, false otherwise."]
    #[link_name = "\u{1}?initWithTexture@CCSprite@cocos2d@@UEAA_NPEAVCCTexture2D@2@@Z"]
    pub fn cocos2d_CCSprite_initWithTexture(
        this: *mut ::std::os::raw::c_void,
        pTexture: *mut cocos2d_CCTexture2D,
    ) -> bool;
}
extern "C" {
    #[doc = " Initializes a sprite with a texture and a rect."]
    #[doc = ""]
    #[doc = " After initialization, the offset will be (0,0)."]
    #[doc = ""]
    #[doc = " @param   pTexture    A pointer to an exisiting CCTexture2D object."]
    #[doc = "                      You can use a CCTexture2D object for many sprites."]
    #[doc = " @param   rect        Only the contents inside rect of this texture will be applied for this sprite."]
    #[doc = " @return  true if the sprite is initialized properly, false otherwise."]
    #[link_name = "\u{1}?initWithTexture@CCSprite@cocos2d@@UEAA_NPEAVCCTexture2D@2@AEBVCCRect@2@@Z"]
    pub fn cocos2d_CCSprite_initWithTexture1(
        this: *mut ::std::os::raw::c_void,
        pTexture: *mut cocos2d_CCTexture2D,
        rect: *const cocos2d_CCRect,
    ) -> bool;
}
extern "C" {
    #[doc = " Initializes a sprite with a texture and a rect in points, optionally rotated."]
    #[doc = ""]
    #[doc = " After initialization, the offset will be (0,0)."]
    #[doc = " @note    This is the designated initializer."]
    #[doc = ""]
    #[doc = " @param   pTexture    A CCTexture2D object whose texture will be applied to this sprite."]
    #[doc = " @param   rect        A rectangle assigned the contents of texture."]
    #[doc = " @param   rotated     Whether or not the texture rectangle is rotated."]
    #[doc = " @return  true if the sprite is initialized properly, false otherwise."]
    #[link_name = "\u{1}?initWithTexture@CCSprite@cocos2d@@UEAA_NPEAVCCTexture2D@2@AEBVCCRect@2@_N@Z"]
    pub fn cocos2d_CCSprite_initWithTexture2(
        this: *mut ::std::os::raw::c_void,
        pTexture: *mut cocos2d_CCTexture2D,
        rect: *const cocos2d_CCRect,
        rotated: bool,
    ) -> bool;
}
extern "C" {
    #[doc = " Initializes a sprite with an SpriteFrame. The texture and rect in SpriteFrame will be applied on this sprite"]
    #[doc = ""]
    #[doc = " @param   pSpriteFrame  A CCSpriteFrame object. It should includes a valid texture and a rect"]
    #[doc = " @return  true if the sprite is initialized properly, false otherwise."]
    #[link_name = "\u{1}?initWithSpriteFrame@CCSprite@cocos2d@@UEAA_NPEAVCCSpriteFrame@2@@Z"]
    pub fn cocos2d_CCSprite_initWithSpriteFrame(
        this: *mut ::std::os::raw::c_void,
        pSpriteFrame: *mut cocos2d_CCSpriteFrame,
    ) -> bool;
}
extern "C" {
    #[doc = " Initializes a sprite with an sprite frame name."]
    #[doc = ""]
    #[doc = " A CCSpriteFrame will be fetched from the CCSpriteFrameCache by name."]
    #[doc = " If the CCSpriteFrame doesn't exist it will raise an exception."]
    #[doc = ""]
    #[doc = " @param   pszSpriteFrameName  A key string that can fected a volid CCSpriteFrame from CCSpriteFrameCache"]
    #[doc = " @return  true if the sprite is initialized properly, false otherwise."]
    #[link_name = "\u{1}?initWithSpriteFrameName@CCSprite@cocos2d@@UEAA_NPEBD@Z"]
    pub fn cocos2d_CCSprite_initWithSpriteFrameName(
        this: *mut ::std::os::raw::c_void,
        pszSpriteFrameName: *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    #[doc = " Initializes a sprite with an image filename."]
    #[doc = ""]
    #[doc = " This method will find pszFilename from local file system, load its content to CCTexture2D,"]
    #[doc = " then use CCTexture2D to create a sprite."]
    #[doc = " After initialization, the rect used will be the size of the image. The offset will be (0,0)."]
    #[doc = ""]
    #[doc = " @param   pszFilename The path to an image file in local file system"]
    #[doc = " @return  true if the sprite is initialized properly, false otherwise."]
    #[doc = " @js init"]
    #[link_name = "\u{1}?initWithFile@CCSprite@cocos2d@@UEAA_NPEBD@Z"]
    pub fn cocos2d_CCSprite_initWithFile(
        this: *mut ::std::os::raw::c_void,
        pszFilename: *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    #[doc = " Initializes a sprite with an image filename, and a rect."]
    #[doc = ""]
    #[doc = " This method will find pszFilename from local file system, load its content to CCTexture2D,"]
    #[doc = " then use CCTexture2D to create a sprite."]
    #[doc = " After initialization, the offset will be (0,0)."]
    #[doc = ""]
    #[doc = " @param   pszFilename The path to an image file in local file system."]
    #[doc = " @param   rect        The rectangle assigned the content area from texture."]
    #[doc = " @return  true if the sprite is initialized properly, false otherwise."]
    #[doc = " @js init"]
    #[link_name = "\u{1}?initWithFile@CCSprite@cocos2d@@UEAA_NPEBDAEBVCCRect@2@@Z"]
    pub fn cocos2d_CCSprite_initWithFile1(
        this: *mut ::std::os::raw::c_void,
        pszFilename: *const ::std::os::raw::c_char,
        rect: *const cocos2d_CCRect,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}?setChildColor@CCSprite@cocos2d@@UEAAXAEBU_ccColor3B@2@@Z"]
    pub fn cocos2d_CCSprite_setChildColor(
        this: *mut ::std::os::raw::c_void,
        arg1: *const cocos2d_ccColor3B,
    );
}
extern "C" {
    #[link_name = "\u{1}?setChildOpacity@CCSprite@cocos2d@@UEAAXE@Z"]
    pub fn cocos2d_CCSprite_setChildOpacity(this: *mut ::std::os::raw::c_void, arg1: GLubyte);
}
extern "C" {
    #[doc = " @{"]
    #[doc = " @name Functions inherited from CCTextureProtocol"]
    #[link_name = "\u{1}?setTexture@CCSprite@cocos2d@@UEAAXPEAVCCTexture2D@2@@Z"]
    pub fn cocos2d_CCSprite_setTexture(
        this: *mut ::std::os::raw::c_void,
        texture: *mut cocos2d_CCTexture2D,
    );
}
extern "C" {
    #[link_name = "\u{1}?getTexture@CCSprite@cocos2d@@UEAAPEAVCCTexture2D@2@XZ"]
    pub fn cocos2d_CCSprite_getTexture(
        this: *mut ::std::os::raw::c_void,
    ) -> *mut cocos2d_CCTexture2D;
}
extern "C" {
    #[doc = " @{"]
    #[doc = " @name Functions inherited from CCNode"]
    #[link_name = "\u{1}?setScaleX@CCSprite@cocos2d@@UEAAXM@Z"]
    pub fn cocos2d_CCSprite_setScaleX(this: *mut ::std::os::raw::c_void, fScaleX: f32);
}
extern "C" {
    #[link_name = "\u{1}?setScaleY@CCSprite@cocos2d@@UEAAXM@Z"]
    pub fn cocos2d_CCSprite_setScaleY(this: *mut ::std::os::raw::c_void, fScaleY: f32);
}
extern "C" {
    #[doc = " @lua NA"]
    #[link_name = "\u{1}?setPosition@CCSprite@cocos2d@@UEAAXAEBVCCPoint@2@@Z"]
    pub fn cocos2d_CCSprite_setPosition(
        this: *mut ::std::os::raw::c_void,
        pos: *const cocos2d_CCPoint,
    );
}
extern "C" {
    #[link_name = "\u{1}?setRotation@CCSprite@cocos2d@@UEAAXM@Z"]
    pub fn cocos2d_CCSprite_setRotation(this: *mut ::std::os::raw::c_void, fRotation: f32);
}
extern "C" {
    #[link_name = "\u{1}?setRotationX@CCSprite@cocos2d@@UEAAXM@Z"]
    pub fn cocos2d_CCSprite_setRotationX(this: *mut ::std::os::raw::c_void, fRotationX: f32);
}
extern "C" {
    #[link_name = "\u{1}?setRotationY@CCSprite@cocos2d@@UEAAXM@Z"]
    pub fn cocos2d_CCSprite_setRotationY(this: *mut ::std::os::raw::c_void, fRotationY: f32);
}
extern "C" {
    #[link_name = "\u{1}?setSkewX@CCSprite@cocos2d@@UEAAXM@Z"]
    pub fn cocos2d_CCSprite_setSkewX(this: *mut ::std::os::raw::c_void, sx: f32);
}
extern "C" {
    #[link_name = "\u{1}?setSkewY@CCSprite@cocos2d@@UEAAXM@Z"]
    pub fn cocos2d_CCSprite_setSkewY(this: *mut ::std::os::raw::c_void, sy: f32);
}
extern "C" {
    #[link_name = "\u{1}?removeChild@CCSprite@cocos2d@@UEAAXPEAVCCNode@2@_N@Z"]
    pub fn cocos2d_CCSprite_removeChild(
        this: *mut ::std::os::raw::c_void,
        pChild: *mut cocos2d_CCNode,
        bCleanup: bool,
    );
}
extern "C" {
    #[link_name = "\u{1}?removeAllChildrenWithCleanup@CCSprite@cocos2d@@UEAAX_N@Z"]
    pub fn cocos2d_CCSprite_removeAllChildrenWithCleanup(
        this: *mut ::std::os::raw::c_void,
        bCleanup: bool,
    );
}
extern "C" {
    #[link_name = "\u{1}?reorderChild@CCSprite@cocos2d@@UEAAXPEAVCCNode@2@H@Z"]
    pub fn cocos2d_CCSprite_reorderChild(
        this: *mut ::std::os::raw::c_void,
        pChild: *mut cocos2d_CCNode,
        zOrder: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}?addChild@CCSprite@cocos2d@@UEAAXPEAVCCNode@2@@Z"]
    pub fn cocos2d_CCSprite_addChild(
        this: *mut ::std::os::raw::c_void,
        pChild: *mut cocos2d_CCNode,
    );
}
extern "C" {
    #[link_name = "\u{1}?addChild@CCSprite@cocos2d@@UEAAXPEAVCCNode@2@H@Z"]
    pub fn cocos2d_CCSprite_addChild1(
        this: *mut ::std::os::raw::c_void,
        pChild: *mut cocos2d_CCNode,
        zOrder: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}?addChild@CCSprite@cocos2d@@UEAAXPEAVCCNode@2@HH@Z"]
    pub fn cocos2d_CCSprite_addChild2(
        this: *mut ::std::os::raw::c_void,
        pChild: *mut cocos2d_CCNode,
        zOrder: ::std::os::raw::c_int,
        tag: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}?sortAllChildren@CCSprite@cocos2d@@UEAAXXZ"]
    pub fn cocos2d_CCSprite_sortAllChildren(this: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[link_name = "\u{1}?setScale@CCSprite@cocos2d@@UEAAXM@Z"]
    pub fn cocos2d_CCSprite_setScale(this: *mut ::std::os::raw::c_void, fScale: f32);
}
extern "C" {
    #[link_name = "\u{1}?setVertexZ@CCSprite@cocos2d@@UEAAXM@Z"]
    pub fn cocos2d_CCSprite_setVertexZ(this: *mut ::std::os::raw::c_void, fVertexZ: f32);
}
extern "C" {
    #[link_name = "\u{1}?setAnchorPoint@CCSprite@cocos2d@@UEAAXAEBVCCPoint@2@@Z"]
    pub fn cocos2d_CCSprite_setAnchorPoint(
        this: *mut ::std::os::raw::c_void,
        anchor: *const cocos2d_CCPoint,
    );
}
extern "C" {
    #[link_name = "\u{1}?ignoreAnchorPointForPosition@CCSprite@cocos2d@@UEAAX_N@Z"]
    pub fn cocos2d_CCSprite_ignoreAnchorPointForPosition(
        this: *mut ::std::os::raw::c_void,
        value: bool,
    );
}
extern "C" {
    #[link_name = "\u{1}?setVisible@CCSprite@cocos2d@@UEAAX_N@Z"]
    pub fn cocos2d_CCSprite_setVisible(this: *mut ::std::os::raw::c_void, bVisible: bool);
}
extern "C" {
    #[link_name = "\u{1}?draw@CCSprite@cocos2d@@UEAAXXZ"]
    pub fn cocos2d_CCSprite_draw(this: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[doc = " @{"]
    #[doc = " @name Functions inherited from CCNodeRGBA"]
    #[link_name = "\u{1}?setColor@CCSprite@cocos2d@@UEAAXAEBU_ccColor3B@2@@Z"]
    pub fn cocos2d_CCSprite_setColor(
        this: *mut ::std::os::raw::c_void,
        color3: *const cocos2d_ccColor3B,
    );
}
extern "C" {
    #[link_name = "\u{1}?updateDisplayedColor@CCSprite@cocos2d@@UEAAXAEBU_ccColor3B@2@@Z"]
    pub fn cocos2d_CCSprite_updateDisplayedColor(
        this: *mut ::std::os::raw::c_void,
        parentColor: *const cocos2d_ccColor3B,
    );
}
extern "C" {
    #[link_name = "\u{1}?setOpacity@CCSprite@cocos2d@@UEAAXE@Z"]
    pub fn cocos2d_CCSprite_setOpacity(this: *mut ::std::os::raw::c_void, opacity: GLubyte);
}
extern "C" {
    #[link_name = "\u{1}?setOpacityModifyRGB@CCSprite@cocos2d@@UEAAX_N@Z"]
    pub fn cocos2d_CCSprite_setOpacityModifyRGB(this: *mut ::std::os::raw::c_void, modify: bool);
}
extern "C" {
    #[link_name = "\u{1}?isOpacityModifyRGB@CCSprite@cocos2d@@UEAA_NXZ"]
    pub fn cocos2d_CCSprite_isOpacityModifyRGB(this: *mut ::std::os::raw::c_void) -> bool;
}
extern "C" {
    #[link_name = "\u{1}?updateDisplayedOpacity@CCSprite@cocos2d@@UEAAXE@Z"]
    pub fn cocos2d_CCSprite_updateDisplayedOpacity(
        this: *mut ::std::os::raw::c_void,
        parentOpacity: GLubyte,
    );
}
extern "C" {
    #[doc = " Updates the quad according the rotation, position, scale values."]
    #[link_name = "\u{1}?updateTransform@CCSprite@cocos2d@@UEAAXXZ"]
    pub fn cocos2d_CCSprite_updateTransform(this: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[doc = " Returns the batch node object if this sprite is rendered by CCSpriteBatchNode"]
    #[doc = ""]
    #[doc = " @return The CCSpriteBatchNode object if this sprite is rendered by CCSpriteBatchNode,"]
    #[doc = "         NULL if the sprite isn't used batch node."]
    #[link_name = "\u{1}?getBatchNode@CCSprite@cocos2d@@UEAAPEAVCCSpriteBatchNode@2@XZ"]
    pub fn cocos2d_CCSprite_getBatchNode(
        this: *mut ::std::os::raw::c_void,
    ) -> *mut cocos2d_CCSpriteBatchNode;
}
extern "C" {
    #[doc = " Sets the batch node to sprite"]
    #[doc = " @warning This method is not recommended for game developers. Sample code for using batch node"]
    #[doc = " @code"]
    #[doc = " CCSpriteBatchNode *batch = CCSpriteBatchNode::create(\"Images/grossini_dance_atlas.png\", 15);"]
    #[doc = " CCSprite *sprite = CCSprite::createWithTexture(batch->getTexture(), CCRectMake(0, 0, 57, 57));"]
    #[doc = " batch->addChild(sprite);"]
    #[doc = " layer->addChild(batch);"]
    #[doc = " @endcode"]
    #[link_name = "\u{1}?setBatchNode@CCSprite@cocos2d@@UEAAXPEAVCCSpriteBatchNode@2@@Z"]
    pub fn cocos2d_CCSprite_setBatchNode(
        this: *mut ::std::os::raw::c_void,
        pobSpriteBatchNode: *mut cocos2d_CCSpriteBatchNode,
    );
}
extern "C" {
    #[link_name = "\u{1}?refreshTextureRect@CCSprite@cocos2d@@UEAAXXZ"]
    pub fn cocos2d_CCSprite_refreshTextureRect(this: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[doc = " Updates the texture rect of the CCSprite in points."]
    #[doc = " It will call setTextureRect:rotated:untrimmedSize with rotated = NO, and utrimmedSize = rect.size."]
    #[link_name = "\u{1}?setTextureRect@CCSprite@cocos2d@@UEAAXAEBVCCRect@2@@Z"]
    pub fn cocos2d_CCSprite_setTextureRect(
        this: *mut ::std::os::raw::c_void,
        rect: *const cocos2d_CCRect,
    );
}
extern "C" {
    #[doc = " Sets the texture rect, rectRotated and untrimmed size of the CCSprite in points."]
    #[doc = " It will update the texture coordinates and the vertex rectangle."]
    #[link_name = "\u{1}?setTextureRect@CCSprite@cocos2d@@UEAAXAEBVCCRect@2@_NAEBVCCSize@2@@Z"]
    pub fn cocos2d_CCSprite_setTextureRect1(
        this: *mut ::std::os::raw::c_void,
        rect: *const cocos2d_CCRect,
        rotated: bool,
        untrimmedSize: *const cocos2d_CCSize,
    );
}
extern "C" {
    #[doc = " Sets the vertex rect."]
    #[doc = " It will be called internally by setTextureRect."]
    #[doc = " Useful if you want to create 2x images from SD images in Retina Display."]
    #[doc = " Do not call it manually. Use setTextureRect instead."]
    #[link_name = "\u{1}?setVertexRect@CCSprite@cocos2d@@UEAAXAEBVCCRect@2@@Z"]
    pub fn cocos2d_CCSprite_setVertexRect(
        this: *mut ::std::os::raw::c_void,
        rect: *const cocos2d_CCRect,
    );
}
extern "C" {
    #[doc = " Sets a new display frame to the CCSprite."]
    #[link_name = "\u{1}?setDisplayFrame@CCSprite@cocos2d@@UEAAXPEAVCCSpriteFrame@2@@Z"]
    pub fn cocos2d_CCSprite_setDisplayFrame(
        this: *mut ::std::os::raw::c_void,
        pNewFrame: *mut cocos2d_CCSpriteFrame,
    );
}
extern "C" {
    #[doc = " Returns whether or not a CCSpriteFrame is being displayed"]
    #[link_name = "\u{1}?isFrameDisplayed@CCSprite@cocos2d@@UEAA_NPEAVCCSpriteFrame@2@@Z"]
    pub fn cocos2d_CCSprite_isFrameDisplayed(
        this: *mut ::std::os::raw::c_void,
        pFrame: *mut cocos2d_CCSpriteFrame,
    ) -> bool;
}
extern "C" {
    #[doc = " Returns the current displayed frame."]
    #[doc = " @js NA"]
    #[link_name = "\u{1}?displayFrame@CCSprite@cocos2d@@UEAAPEAVCCSpriteFrame@2@XZ"]
    pub fn cocos2d_CCSprite_displayFrame(
        this: *mut ::std::os::raw::c_void,
    ) -> *mut cocos2d_CCSpriteFrame;
}
extern "C" {
    #[doc = " @{"]
    #[doc = " @name Animation methods"]
    #[doc = "**"]
    #[doc = "* Changes the display frame with animation name and index."]
    #[doc = "* The animation name will be get from the CCAnimationCache"]
    #[doc = "*/"]
    #[link_name = "\u{1}?setDisplayFrameWithAnimationName@CCSprite@cocos2d@@UEAAXPEBDH@Z"]
    pub fn cocos2d_CCSprite_setDisplayFrameWithAnimationName(
        this: *mut ::std::os::raw::c_void,
        animationName: *const ::std::os::raw::c_char,
        frameIndex: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}?setTextureCoords@CCSprite@cocos2d@@MEAAXAEBVCCRect@2@@Z"]
    pub fn cocos2d_CCSprite_setTextureCoords(
        this: *mut ::std::os::raw::c_void,
        rect: *const cocos2d_CCRect,
    );
}
extern "C" {
    #[link_name = "\u{1}?updateBlendFunc@CCSprite@cocos2d@@MEAAXXZ"]
    pub fn cocos2d_CCSprite_updateBlendFunc(this: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[link_name = "\u{1}?setReorderChildDirtyRecursively@CCSprite@cocos2d@@MEAAXXZ"]
    pub fn cocos2d_CCSprite_setReorderChildDirtyRecursively(this: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[link_name = "\u{1}?setDirtyRecursively@CCSprite@cocos2d@@MEAAX_N@Z"]
    pub fn cocos2d_CCSprite_setDirtyRecursively(this: *mut ::std::os::raw::c_void, bValue: bool);
}
#[doc = " @brief CCLabelTTF is a subclass of CCTextureNode that knows how to render text labels"]
#[doc = ""]
#[doc = " All features from CCTextureNode are valid in CCLabelTTF"]
#[doc = ""]
#[doc = " CCLabelTTF objects are slow. Consider using CCLabelAtlas or CCLabelBMFont instead."]
#[doc = ""]
#[doc = " Custom ttf file can be put in assets/ or external storage that the Application can access."]
#[doc = " @code"]
#[doc = " CCLabelTTF *label1 = CCLabelTTF::create(\"alignment left\", \"A Damn Mess\", fontSize, blockSize,"]
#[doc = "                                          kCCTextAlignmentLeft, kCCVerticalTextAlignmentCenter);"]
#[doc = " CCLabelTTF *label2 = CCLabelTTF::create(\"alignment right\", \"/mnt/sdcard/Scissor Cuts.ttf\", fontSize, blockSize,"]
#[doc = "                                          kCCTextAlignmentLeft, kCCVerticalTextAlignmentCenter);"]
#[doc = " @endcode"]
#[doc = ""]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCLabelTTF {
    pub _base: cocos2d_CCSprite,
    pub _base_1: cocos2d_CCLabelProtocol,
    #[doc = " Dimensions of the label in Points"]
    pub m_tDimensions: cocos2d_CCSize,
    #[doc = " The alignment of the label"]
    pub m_hAlignment: cocos2d_CCTextAlignment,
    #[doc = " The vertical alignment of the label"]
    pub m_vAlignment: cocos2d_CCVerticalTextAlignment,
    #[doc = " Font name used in the label"]
    pub m_pFontName: *mut std_string,
    #[doc = " Font size of the label"]
    pub m_fFontSize: f32,
    #[doc = " label's string"]
    pub m_string: std_string,
    #[doc = " font shadow"]
    pub m_shadowEnabled: bool,
    pub m_shadowOffset: cocos2d_CCSize,
    pub m_shadowOpacity: f32,
    pub m_shadowBlur: f32,
    #[doc = " font stroke"]
    pub m_strokeEnabled: bool,
    pub m_strokeColor: cocos2d_ccColor3B,
    pub m_strokeSize: f32,
    #[doc = " font tint"]
    pub m_textFillColor: cocos2d_ccColor3B,
}
#[test]
fn bindgen_test_layout_cocos2d_CCLabelTTF() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCLabelTTF>(),
        680usize,
        concat!("Size of: ", stringify!(cocos2d_CCLabelTTF))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCLabelTTF>(),
        8usize,
        concat!("Alignment of ", stringify!(cocos2d_CCLabelTTF))
    );
}
extern "C" {
    #[doc = "  @js NA"]
    #[doc = "  @lua NA"]
    #[link_name = "\u{1}?description@CCLabelTTF@cocos2d@@QEAAPEBDXZ"]
    pub fn cocos2d_CCLabelTTF_description(
        this: *mut cocos2d_CCLabelTTF,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " creates a CCLabelTTF with a font name and font size in points"]
    #[doc = "@since v2.0.1"]
    #[link_name = "\u{1}?create@CCLabelTTF@cocos2d@@SAPEAV12@PEBD0M@Z"]
    pub fn cocos2d_CCLabelTTF_create(
        string: *const ::std::os::raw::c_char,
        fontName: *const ::std::os::raw::c_char,
        fontSize: f32,
    ) -> *mut cocos2d_CCLabelTTF;
}
extern "C" {
    #[doc = " creates a CCLabelTTF from a fontname, horizontal alignment, dimension in points,  and font size in points."]
    #[doc = "@since v2.0.1"]
    #[link_name = "\u{1}?create@CCLabelTTF@cocos2d@@SAPEAV12@PEBD0MAEBVCCSize@2@W4CCTextAlignment@2@@Z"]
    pub fn cocos2d_CCLabelTTF_create1(
        string: *const ::std::os::raw::c_char,
        fontName: *const ::std::os::raw::c_char,
        fontSize: f32,
        dimensions: *const cocos2d_CCSize,
        hAlignment: cocos2d_CCTextAlignment,
    ) -> *mut cocos2d_CCLabelTTF;
}
extern "C" {
    #[doc = " creates a CCLabel from a fontname, alignment, dimension in points and font size in points"]
    #[doc = "@since v2.0.1"]
    #[link_name = "\u{1}?create@CCLabelTTF@cocos2d@@SAPEAV12@PEBD0MAEBVCCSize@2@W4CCTextAlignment@2@W4CCVerticalTextAlignment@2@@Z"]
    pub fn cocos2d_CCLabelTTF_create2(
        string: *const ::std::os::raw::c_char,
        fontName: *const ::std::os::raw::c_char,
        fontSize: f32,
        dimensions: *const cocos2d_CCSize,
        hAlignment: cocos2d_CCTextAlignment,
        vAlignment: cocos2d_CCVerticalTextAlignment,
    ) -> *mut cocos2d_CCLabelTTF;
}
extern "C" {
    #[doc = " Create a lable with string and a font definition"]
    #[link_name = "\u{1}?createWithFontDefinition@CCLabelTTF@cocos2d@@SAPEAV12@PEBDAEAU_ccFontDefinition@2@@Z"]
    pub fn cocos2d_CCLabelTTF_createWithFontDefinition(
        string: *const ::std::os::raw::c_char,
        textDefinition: *mut cocos2d_ccFontDefinition,
    ) -> *mut cocos2d_CCLabelTTF;
}
extern "C" {
    #[doc = " initializes the CCLabelTTF with a font name and font size"]
    #[link_name = "\u{1}?initWithString@CCLabelTTF@cocos2d@@QEAA_NPEBD0M@Z"]
    pub fn cocos2d_CCLabelTTF_initWithString(
        this: *mut cocos2d_CCLabelTTF,
        string: *const ::std::os::raw::c_char,
        fontName: *const ::std::os::raw::c_char,
        fontSize: f32,
    ) -> bool;
}
extern "C" {
    #[doc = " initializes the CCLabelTTF with a font name, alignment, dimension and font size"]
    #[link_name = "\u{1}?initWithString@CCLabelTTF@cocos2d@@QEAA_NPEBD0MAEBVCCSize@2@W4CCTextAlignment@2@@Z"]
    pub fn cocos2d_CCLabelTTF_initWithString1(
        this: *mut cocos2d_CCLabelTTF,
        string: *const ::std::os::raw::c_char,
        fontName: *const ::std::os::raw::c_char,
        fontSize: f32,
        dimensions: *const cocos2d_CCSize,
        hAlignment: cocos2d_CCTextAlignment,
    ) -> bool;
}
extern "C" {
    #[doc = " initializes the CCLabelTTF with a font name, alignment, dimension and font size"]
    #[link_name = "\u{1}?initWithString@CCLabelTTF@cocos2d@@QEAA_NPEBD0MAEBVCCSize@2@W4CCTextAlignment@2@W4CCVerticalTextAlignment@2@@Z"]
    pub fn cocos2d_CCLabelTTF_initWithString2(
        this: *mut cocos2d_CCLabelTTF,
        string: *const ::std::os::raw::c_char,
        fontName: *const ::std::os::raw::c_char,
        fontSize: f32,
        dimensions: *const cocos2d_CCSize,
        hAlignment: cocos2d_CCTextAlignment,
        vAlignment: cocos2d_CCVerticalTextAlignment,
    ) -> bool;
}
extern "C" {
    #[doc = " initializes the CCLabelTTF with a font name, alignment, dimension and font size"]
    #[link_name = "\u{1}?initWithStringAndTextDefinition@CCLabelTTF@cocos2d@@QEAA_NPEBDAEAU_ccFontDefinition@2@@Z"]
    pub fn cocos2d_CCLabelTTF_initWithStringAndTextDefinition(
        this: *mut cocos2d_CCLabelTTF,
        string: *const ::std::os::raw::c_char,
        textDefinition: *mut cocos2d_ccFontDefinition,
    ) -> bool;
}
extern "C" {
    #[doc = " set the text definition used by this label"]
    #[link_name = "\u{1}?setTextDefinition@CCLabelTTF@cocos2d@@QEAAXPEAU_ccFontDefinition@2@@Z"]
    pub fn cocos2d_CCLabelTTF_setTextDefinition(
        this: *mut cocos2d_CCLabelTTF,
        theDefinition: *mut cocos2d_ccFontDefinition,
    );
}
extern "C" {
    #[doc = " get the text definition used by this label"]
    #[link_name = "\u{1}?getTextDefinition@CCLabelTTF@cocos2d@@QEAAPEAU_ccFontDefinition@2@XZ"]
    pub fn cocos2d_CCLabelTTF_getTextDefinition(
        this: *mut cocos2d_CCLabelTTF,
    ) -> *mut cocos2d_ccFontDefinition;
}
extern "C" {
    #[doc = " enable or disable shadow for the label"]
    #[link_name = "\u{1}?enableShadow@CCLabelTTF@cocos2d@@QEAAXAEBVCCSize@2@MM_N@Z"]
    pub fn cocos2d_CCLabelTTF_enableShadow(
        this: *mut cocos2d_CCLabelTTF,
        shadowOffset: *const cocos2d_CCSize,
        shadowOpacity: f32,
        shadowBlur: f32,
        mustUpdateTexture: bool,
    );
}
extern "C" {
    #[doc = " disable shadow rendering"]
    #[link_name = "\u{1}?disableShadow@CCLabelTTF@cocos2d@@QEAAX_N@Z"]
    pub fn cocos2d_CCLabelTTF_disableShadow(this: *mut cocos2d_CCLabelTTF, mustUpdateTexture: bool);
}
extern "C" {
    #[doc = " enable or disable stroke"]
    #[link_name = "\u{1}?enableStroke@CCLabelTTF@cocos2d@@QEAAXAEBU_ccColor3B@2@M_N@Z"]
    pub fn cocos2d_CCLabelTTF_enableStroke(
        this: *mut cocos2d_CCLabelTTF,
        strokeColor: *const cocos2d_ccColor3B,
        strokeSize: f32,
        mustUpdateTexture: bool,
    );
}
extern "C" {
    #[doc = " disable stroke"]
    #[link_name = "\u{1}?disableStroke@CCLabelTTF@cocos2d@@QEAAX_N@Z"]
    pub fn cocos2d_CCLabelTTF_disableStroke(this: *mut cocos2d_CCLabelTTF, mustUpdateTexture: bool);
}
extern "C" {
    #[doc = " set text tinting"]
    #[link_name = "\u{1}?setFontFillColor@CCLabelTTF@cocos2d@@QEAAXAEBU_ccColor3B@2@_N@Z"]
    pub fn cocos2d_CCLabelTTF_setFontFillColor(
        this: *mut cocos2d_CCLabelTTF,
        tintColor: *const cocos2d_ccColor3B,
        mustUpdateTexture: bool,
    );
}
extern "C" {
    #[doc = " Creates an label."]
    #[link_name = "\u{1}?create@CCLabelTTF@cocos2d@@SAPEAV12@XZ"]
    pub fn cocos2d_CCLabelTTF_create3() -> *mut cocos2d_CCLabelTTF;
}
extern "C" {
    #[link_name = "\u{1}?getHorizontalAlignment@CCLabelTTF@cocos2d@@QEAA?AW4CCTextAlignment@2@XZ"]
    pub fn cocos2d_CCLabelTTF_getHorizontalAlignment(
        this: *mut cocos2d_CCLabelTTF,
    ) -> cocos2d_CCTextAlignment;
}
extern "C" {
    #[link_name = "\u{1}?setHorizontalAlignment@CCLabelTTF@cocos2d@@QEAAXW4CCTextAlignment@2@@Z"]
    pub fn cocos2d_CCLabelTTF_setHorizontalAlignment(
        this: *mut cocos2d_CCLabelTTF,
        alignment: cocos2d_CCTextAlignment,
    );
}
extern "C" {
    #[link_name = "\u{1}?getVerticalAlignment@CCLabelTTF@cocos2d@@QEAA?AW4CCVerticalTextAlignment@2@XZ"]
    pub fn cocos2d_CCLabelTTF_getVerticalAlignment(
        this: *mut cocos2d_CCLabelTTF,
    ) -> cocos2d_CCVerticalTextAlignment;
}
extern "C" {
    #[link_name = "\u{1}?setVerticalAlignment@CCLabelTTF@cocos2d@@QEAAXW4CCVerticalTextAlignment@2@@Z"]
    pub fn cocos2d_CCLabelTTF_setVerticalAlignment(
        this: *mut cocos2d_CCLabelTTF,
        verticalAlignment: cocos2d_CCVerticalTextAlignment,
    );
}
extern "C" {
    #[link_name = "\u{1}?getDimensions@CCLabelTTF@cocos2d@@QEAA?AVCCSize@2@XZ"]
    pub fn cocos2d_CCLabelTTF_getDimensions(this: *mut cocos2d_CCLabelTTF) -> cocos2d_CCSize;
}
extern "C" {
    #[link_name = "\u{1}?setDimensions@CCLabelTTF@cocos2d@@QEAAXAEBVCCSize@2@@Z"]
    pub fn cocos2d_CCLabelTTF_setDimensions(
        this: *mut cocos2d_CCLabelTTF,
        dim: *const cocos2d_CCSize,
    );
}
extern "C" {
    #[link_name = "\u{1}?getFontSize@CCLabelTTF@cocos2d@@QEAAMXZ"]
    pub fn cocos2d_CCLabelTTF_getFontSize(this: *mut cocos2d_CCLabelTTF) -> f32;
}
extern "C" {
    #[link_name = "\u{1}?setFontSize@CCLabelTTF@cocos2d@@QEAAXM@Z"]
    pub fn cocos2d_CCLabelTTF_setFontSize(this: *mut cocos2d_CCLabelTTF, fontSize: f32);
}
extern "C" {
    #[link_name = "\u{1}?getFontName@CCLabelTTF@cocos2d@@QEAAPEBDXZ"]
    pub fn cocos2d_CCLabelTTF_getFontName(
        this: *mut cocos2d_CCLabelTTF,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}?setFontName@CCLabelTTF@cocos2d@@QEAAXPEBD@Z"]
    pub fn cocos2d_CCLabelTTF_setFontName(
        this: *mut cocos2d_CCLabelTTF,
        fontName: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    #[doc = " set the text definition for this label"]
    #[link_name = "\u{1}?_updateWithTextDefinition@CCLabelTTF@cocos2d@@IEAAXAEAU_ccFontDefinition@2@_N@Z"]
    pub fn cocos2d_CCLabelTTF__updateWithTextDefinition(
        this: *mut cocos2d_CCLabelTTF,
        textDefinition: *mut cocos2d_ccFontDefinition,
        mustUpdateTexture: bool,
    );
}
extern "C" {
    #[link_name = "\u{1}?_prepareTextDefinition@CCLabelTTF@cocos2d@@IEAA?AU_ccFontDefinition@2@_N@Z"]
    pub fn cocos2d_CCLabelTTF__prepareTextDefinition(
        this: *mut cocos2d_CCLabelTTF,
        adjustForResolution: bool,
    ) -> cocos2d_ccFontDefinition;
}
extern "C" {
    #[doc = "  @js ctor"]
    #[link_name = "\u{1}??0CCLabelTTF@cocos2d@@QEAA@XZ"]
    pub fn cocos2d_CCLabelTTF_CCLabelTTF(this: *mut cocos2d_CCLabelTTF);
}
impl cocos2d_CCLabelTTF {
    #[inline]
    pub unsafe fn description(&mut self) -> *const ::std::os::raw::c_char {
        cocos2d_CCLabelTTF_description(self)
    }
    #[inline]
    pub unsafe fn create(
        string: *const ::std::os::raw::c_char,
        fontName: *const ::std::os::raw::c_char,
        fontSize: f32,
    ) -> *mut cocos2d_CCLabelTTF {
        cocos2d_CCLabelTTF_create(string, fontName, fontSize)
    }
    #[inline]
    pub unsafe fn create1(
        string: *const ::std::os::raw::c_char,
        fontName: *const ::std::os::raw::c_char,
        fontSize: f32,
        dimensions: *const cocos2d_CCSize,
        hAlignment: cocos2d_CCTextAlignment,
    ) -> *mut cocos2d_CCLabelTTF {
        cocos2d_CCLabelTTF_create1(string, fontName, fontSize, dimensions, hAlignment)
    }
    #[inline]
    pub unsafe fn create2(
        string: *const ::std::os::raw::c_char,
        fontName: *const ::std::os::raw::c_char,
        fontSize: f32,
        dimensions: *const cocos2d_CCSize,
        hAlignment: cocos2d_CCTextAlignment,
        vAlignment: cocos2d_CCVerticalTextAlignment,
    ) -> *mut cocos2d_CCLabelTTF {
        cocos2d_CCLabelTTF_create2(
            string, fontName, fontSize, dimensions, hAlignment, vAlignment,
        )
    }
    #[inline]
    pub unsafe fn createWithFontDefinition(
        string: *const ::std::os::raw::c_char,
        textDefinition: *mut cocos2d_ccFontDefinition,
    ) -> *mut cocos2d_CCLabelTTF {
        cocos2d_CCLabelTTF_createWithFontDefinition(string, textDefinition)
    }
    #[inline]
    pub unsafe fn initWithString(
        &mut self,
        string: *const ::std::os::raw::c_char,
        fontName: *const ::std::os::raw::c_char,
        fontSize: f32,
    ) -> bool {
        cocos2d_CCLabelTTF_initWithString(self, string, fontName, fontSize)
    }
    #[inline]
    pub unsafe fn initWithString1(
        &mut self,
        string: *const ::std::os::raw::c_char,
        fontName: *const ::std::os::raw::c_char,
        fontSize: f32,
        dimensions: *const cocos2d_CCSize,
        hAlignment: cocos2d_CCTextAlignment,
    ) -> bool {
        cocos2d_CCLabelTTF_initWithString1(self, string, fontName, fontSize, dimensions, hAlignment)
    }
    #[inline]
    pub unsafe fn initWithString2(
        &mut self,
        string: *const ::std::os::raw::c_char,
        fontName: *const ::std::os::raw::c_char,
        fontSize: f32,
        dimensions: *const cocos2d_CCSize,
        hAlignment: cocos2d_CCTextAlignment,
        vAlignment: cocos2d_CCVerticalTextAlignment,
    ) -> bool {
        cocos2d_CCLabelTTF_initWithString2(
            self, string, fontName, fontSize, dimensions, hAlignment, vAlignment,
        )
    }
    #[inline]
    pub unsafe fn initWithStringAndTextDefinition(
        &mut self,
        string: *const ::std::os::raw::c_char,
        textDefinition: *mut cocos2d_ccFontDefinition,
    ) -> bool {
        cocos2d_CCLabelTTF_initWithStringAndTextDefinition(self, string, textDefinition)
    }
    #[inline]
    pub unsafe fn setTextDefinition(&mut self, theDefinition: *mut cocos2d_ccFontDefinition) {
        cocos2d_CCLabelTTF_setTextDefinition(self, theDefinition)
    }
    #[inline]
    pub unsafe fn getTextDefinition(&mut self) -> *mut cocos2d_ccFontDefinition {
        cocos2d_CCLabelTTF_getTextDefinition(self)
    }
    #[inline]
    pub unsafe fn enableShadow(
        &mut self,
        shadowOffset: *const cocos2d_CCSize,
        shadowOpacity: f32,
        shadowBlur: f32,
        mustUpdateTexture: bool,
    ) {
        cocos2d_CCLabelTTF_enableShadow(
            self,
            shadowOffset,
            shadowOpacity,
            shadowBlur,
            mustUpdateTexture,
        )
    }
    #[inline]
    pub unsafe fn disableShadow(&mut self, mustUpdateTexture: bool) {
        cocos2d_CCLabelTTF_disableShadow(self, mustUpdateTexture)
    }
    #[inline]
    pub unsafe fn enableStroke(
        &mut self,
        strokeColor: *const cocos2d_ccColor3B,
        strokeSize: f32,
        mustUpdateTexture: bool,
    ) {
        cocos2d_CCLabelTTF_enableStroke(self, strokeColor, strokeSize, mustUpdateTexture)
    }
    #[inline]
    pub unsafe fn disableStroke(&mut self, mustUpdateTexture: bool) {
        cocos2d_CCLabelTTF_disableStroke(self, mustUpdateTexture)
    }
    #[inline]
    pub unsafe fn setFontFillColor(
        &mut self,
        tintColor: *const cocos2d_ccColor3B,
        mustUpdateTexture: bool,
    ) {
        cocos2d_CCLabelTTF_setFontFillColor(self, tintColor, mustUpdateTexture)
    }
    #[inline]
    pub unsafe fn create3() -> *mut cocos2d_CCLabelTTF {
        cocos2d_CCLabelTTF_create3()
    }
    #[inline]
    pub unsafe fn getHorizontalAlignment(&mut self) -> cocos2d_CCTextAlignment {
        cocos2d_CCLabelTTF_getHorizontalAlignment(self)
    }
    #[inline]
    pub unsafe fn setHorizontalAlignment(&mut self, alignment: cocos2d_CCTextAlignment) {
        cocos2d_CCLabelTTF_setHorizontalAlignment(self, alignment)
    }
    #[inline]
    pub unsafe fn getVerticalAlignment(&mut self) -> cocos2d_CCVerticalTextAlignment {
        cocos2d_CCLabelTTF_getVerticalAlignment(self)
    }
    #[inline]
    pub unsafe fn setVerticalAlignment(
        &mut self,
        verticalAlignment: cocos2d_CCVerticalTextAlignment,
    ) {
        cocos2d_CCLabelTTF_setVerticalAlignment(self, verticalAlignment)
    }
    #[inline]
    pub unsafe fn getDimensions(&mut self) -> cocos2d_CCSize {
        cocos2d_CCLabelTTF_getDimensions(self)
    }
    #[inline]
    pub unsafe fn setDimensions(&mut self, dim: *const cocos2d_CCSize) {
        cocos2d_CCLabelTTF_setDimensions(self, dim)
    }
    #[inline]
    pub unsafe fn getFontSize(&mut self) -> f32 {
        cocos2d_CCLabelTTF_getFontSize(self)
    }
    #[inline]
    pub unsafe fn setFontSize(&mut self, fontSize: f32) {
        cocos2d_CCLabelTTF_setFontSize(self, fontSize)
    }
    #[inline]
    pub unsafe fn getFontName(&mut self) -> *const ::std::os::raw::c_char {
        cocos2d_CCLabelTTF_getFontName(self)
    }
    #[inline]
    pub unsafe fn setFontName(&mut self, fontName: *const ::std::os::raw::c_char) {
        cocos2d_CCLabelTTF_setFontName(self, fontName)
    }
    #[inline]
    pub unsafe fn _updateWithTextDefinition(
        &mut self,
        textDefinition: *mut cocos2d_ccFontDefinition,
        mustUpdateTexture: bool,
    ) {
        cocos2d_CCLabelTTF__updateWithTextDefinition(self, textDefinition, mustUpdateTexture)
    }
    #[inline]
    pub unsafe fn _prepareTextDefinition(
        &mut self,
        adjustForResolution: bool,
    ) -> cocos2d_ccFontDefinition {
        cocos2d_CCLabelTTF__prepareTextDefinition(self, adjustForResolution)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cocos2d_CCLabelTTF_CCLabelTTF(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
}
extern "C" {
    #[doc = "  @js NA"]
    #[doc = "  @lua NA"]
    #[link_name = "\u{1}??_DCCLabelTTF@cocos2d@@QEAAXXZ"]
    pub fn cocos2d_CCLabelTTF_CCLabelTTF_destructor(this: *mut cocos2d_CCLabelTTF);
}
extern "C" {
    #[doc = " initializes the CCLabelTTF"]
    #[link_name = "\u{1}?init@CCLabelTTF@cocos2d@@UEAA_NXZ"]
    pub fn cocos2d_CCLabelTTF_init(this: *mut ::std::os::raw::c_void) -> bool;
}
extern "C" {
    #[doc = " changes the string to render"]
    #[doc = " @warning Changing the string is as expensive as creating a new CCLabelTTF. To obtain better performance use CCLabelAtlas"]
    #[link_name = "\u{1}?setString@CCLabelTTF@cocos2d@@UEAAXPEBD@Z"]
    pub fn cocos2d_CCLabelTTF_setString(
        this: *mut ::std::os::raw::c_void,
        label: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    #[link_name = "\u{1}?getString@CCLabelTTF@cocos2d@@UEAAPEBDXZ"]
    pub fn cocos2d_CCLabelTTF_getString(
        this: *mut ::std::os::raw::c_void,
    ) -> *const ::std::os::raw::c_char;
}
#[doc = " CCSpriteBatchNode is like a batch node: if it contains children, it will draw them in 1 single OpenGL call"]
#[doc = " (often known as \"batch draw\")."]
#[doc = ""]
#[doc = " A CCSpriteBatchNode can reference one and only one texture (one image file, one texture atlas)."]
#[doc = " Only the CCSprites that are contained in that texture can be added to the CCSpriteBatchNode."]
#[doc = " All CCSprites added to a CCSpriteBatchNode are drawn in one OpenGL ES draw call."]
#[doc = " If the CCSprites are not added to a CCSpriteBatchNode then an OpenGL ES draw call will be needed for each one, which is less efficient."]
#[doc = ""]
#[doc = ""]
#[doc = " Limitations:"]
#[doc = "  - The only object that is accepted as child (or grandchild, grand-grandchild, etc...) is CCSprite or any subclass of CCSprite. eg: particles, labels and layer can't be added to a CCSpriteBatchNode."]
#[doc = "  - Either all its children are Aliased or Antialiased. It can't be a mix. This is because \"alias\" is a property of the texture, and all the sprites share the same texture."]
#[doc = ""]
#[doc = " @since v0.7.1"]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCSpriteBatchNode {
    pub _base: cocos2d_CCNode,
    pub _base_1: cocos2d_CCTextureProtocol,
    pub m_pobTextureAtlas: *mut cocos2d_CCTextureAtlas,
    pub m_blendFunc: cocos2d_ccBlendFunc,
    pub m_pobDescendants: *mut cocos2d_CCArray,
    pub m_bManualSortChildren: bool,
    pub m_bManualSortAllChildrenDirty: bool,
}
#[test]
fn bindgen_test_layout_cocos2d_CCSpriteBatchNode() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCSpriteBatchNode>(),
        336usize,
        concat!("Size of: ", stringify!(cocos2d_CCSpriteBatchNode))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCSpriteBatchNode>(),
        8usize,
        concat!("Alignment of ", stringify!(cocos2d_CCSpriteBatchNode))
    );
}
extern "C" {
    #[doc = " creates a CCSpriteBatchNode with a texture2d and capacity of children."]
    #[doc = "The capacity will be increased in 33% in runtime if it run out of space."]
    #[link_name = "\u{1}?createWithTexture@CCSpriteBatchNode@cocos2d@@SAPEAV12@PEAVCCTexture2D@2@I@Z"]
    pub fn cocos2d_CCSpriteBatchNode_createWithTexture(
        tex: *mut cocos2d_CCTexture2D,
        capacity: ::std::os::raw::c_uint,
    ) -> *mut cocos2d_CCSpriteBatchNode;
}
extern "C" {
    #[doc = " creates a CCSpriteBatchNode with a file image (.png, .jpeg, .pvr, etc) and capacity of children."]
    #[doc = "The capacity will be increased in 33% in runtime if it run out of space."]
    #[doc = "The file will be loaded using the TextureMgr."]
    #[link_name = "\u{1}?create@CCSpriteBatchNode@cocos2d@@SAPEAV12@PEBDI@Z"]
    pub fn cocos2d_CCSpriteBatchNode_create(
        fileImage: *const ::std::os::raw::c_char,
        capacity: ::std::os::raw::c_uint,
    ) -> *mut cocos2d_CCSpriteBatchNode;
}
extern "C" {
    #[doc = " initializes a CCSpriteBatchNode with a texture2d and capacity of children."]
    #[doc = "The capacity will be increased in 33% in runtime if it run out of space."]
    #[link_name = "\u{1}?initWithTexture@CCSpriteBatchNode@cocos2d@@QEAA_NPEAVCCTexture2D@2@I@Z"]
    pub fn cocos2d_CCSpriteBatchNode_initWithTexture(
        this: *mut cocos2d_CCSpriteBatchNode,
        tex: *mut cocos2d_CCTexture2D,
        capacity: ::std::os::raw::c_uint,
    ) -> bool;
}
extern "C" {
    #[doc = " initializes a CCSpriteBatchNode with a file image (.png, .jpeg, .pvr, etc) and a capacity of children."]
    #[doc = "The capacity will be increased in 33% in runtime if it run out of space."]
    #[doc = "The file will be loaded using the TextureMgr."]
    #[link_name = "\u{1}?initWithFile@CCSpriteBatchNode@cocos2d@@QEAA_NPEBDI@Z"]
    pub fn cocos2d_CCSpriteBatchNode_initWithFile(
        this: *mut cocos2d_CCSpriteBatchNode,
        fileImage: *const ::std::os::raw::c_char,
        capacity: ::std::os::raw::c_uint,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}?increaseAtlasCapacity@CCSpriteBatchNode@cocos2d@@QEAAXXZ"]
    pub fn cocos2d_CCSpriteBatchNode_increaseAtlasCapacity(this: *mut cocos2d_CCSpriteBatchNode);
}
extern "C" {
    #[doc = " removes a child given a certain index. It will also cleanup the running actions depending on the cleanup parameter."]
    #[doc = "@warning Removing a child from a CCSpriteBatchNode is very slow"]
    #[link_name = "\u{1}?removeChildAtIndex@CCSpriteBatchNode@cocos2d@@QEAAXI_N@Z"]
    pub fn cocos2d_CCSpriteBatchNode_removeChildAtIndex(
        this: *mut cocos2d_CCSpriteBatchNode,
        index: ::std::os::raw::c_uint,
        doCleanup: bool,
    );
}
extern "C" {
    #[link_name = "\u{1}?insertChild@CCSpriteBatchNode@cocos2d@@QEAAXPEAVCCSprite@2@I@Z"]
    pub fn cocos2d_CCSpriteBatchNode_insertChild(
        this: *mut cocos2d_CCSpriteBatchNode,
        child: *mut cocos2d_CCSprite,
        index: ::std::os::raw::c_uint,
    );
}
extern "C" {
    #[link_name = "\u{1}?appendChild@CCSpriteBatchNode@cocos2d@@QEAAXPEAVCCSprite@2@@Z"]
    pub fn cocos2d_CCSpriteBatchNode_appendChild(
        this: *mut cocos2d_CCSpriteBatchNode,
        sprite: *mut cocos2d_CCSprite,
    );
}
extern "C" {
    #[link_name = "\u{1}?removeSpriteFromAtlas@CCSpriteBatchNode@cocos2d@@QEAAXPEAVCCSprite@2@@Z"]
    pub fn cocos2d_CCSpriteBatchNode_removeSpriteFromAtlas(
        this: *mut cocos2d_CCSpriteBatchNode,
        sprite: *mut cocos2d_CCSprite,
    );
}
extern "C" {
    #[link_name = "\u{1}?rebuildIndexInOrder@CCSpriteBatchNode@cocos2d@@QEAAIPEAVCCSprite@2@I@Z"]
    pub fn cocos2d_CCSpriteBatchNode_rebuildIndexInOrder(
        this: *mut cocos2d_CCSpriteBatchNode,
        parent: *mut cocos2d_CCSprite,
        index: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[link_name = "\u{1}?highestAtlasIndexInChild@CCSpriteBatchNode@cocos2d@@QEAAIPEAVCCSprite@2@@Z"]
    pub fn cocos2d_CCSpriteBatchNode_highestAtlasIndexInChild(
        this: *mut cocos2d_CCSpriteBatchNode,
        sprite: *mut cocos2d_CCSprite,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[link_name = "\u{1}?lowestAtlasIndexInChild@CCSpriteBatchNode@cocos2d@@QEAAIPEAVCCSprite@2@@Z"]
    pub fn cocos2d_CCSpriteBatchNode_lowestAtlasIndexInChild(
        this: *mut cocos2d_CCSpriteBatchNode,
        sprite: *mut cocos2d_CCSprite,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[link_name = "\u{1}?atlasIndexForChild@CCSpriteBatchNode@cocos2d@@QEAAIPEAVCCSprite@2@H@Z"]
    pub fn cocos2d_CCSpriteBatchNode_atlasIndexForChild(
        this: *mut cocos2d_CCSpriteBatchNode,
        sprite: *mut cocos2d_CCSprite,
        z: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[link_name = "\u{1}?reorderBatch@CCSpriteBatchNode@cocos2d@@QEAAX_N@Z"]
    pub fn cocos2d_CCSpriteBatchNode_reorderBatch(
        this: *mut cocos2d_CCSpriteBatchNode,
        reorder: bool,
    );
}
extern "C" {
    #[doc = " Inserts a quad at a certain index into the texture atlas. The CCSprite won't be added into the children array."]
    #[doc = "This method should be called only when you are dealing with very big AtlasSrite and when most of the CCSprite won't be updated."]
    #[doc = "For example: a tile map (CCTMXMap) or a label with lots of characters (CCLabelBMFont)"]
    #[link_name = "\u{1}?insertQuadFromSprite@CCSpriteBatchNode@cocos2d@@IEAAXPEAVCCSprite@2@I@Z"]
    pub fn cocos2d_CCSpriteBatchNode_insertQuadFromSprite(
        this: *mut cocos2d_CCSpriteBatchNode,
        sprite: *mut cocos2d_CCSprite,
        index: ::std::os::raw::c_uint,
    );
}
extern "C" {
    #[doc = " Updates a quad at a certain index into the texture atlas. The CCSprite won't be added into the children array."]
    #[doc = "This method should be called only when you are dealing with very big AtlasSrite and when most of the CCSprite won't be updated."]
    #[doc = "For example: a tile map (CCTMXMap) or a label with lots of characters (CCLabelBMFont)"]
    #[link_name = "\u{1}?updateQuadFromSprite@CCSpriteBatchNode@cocos2d@@IEAAXPEAVCCSprite@2@I@Z"]
    pub fn cocos2d_CCSpriteBatchNode_updateQuadFromSprite(
        this: *mut cocos2d_CCSpriteBatchNode,
        sprite: *mut cocos2d_CCSprite,
        index: ::std::os::raw::c_uint,
    );
}
extern "C" {
    #[link_name = "\u{1}?addSpriteWithoutQuad@CCSpriteBatchNode@cocos2d@@IEAAPEAV12@PEAVCCSprite@2@IH@Z"]
    pub fn cocos2d_CCSpriteBatchNode_addSpriteWithoutQuad(
        this: *mut cocos2d_CCSpriteBatchNode,
        child: *mut cocos2d_CCSprite,
        z: ::std::os::raw::c_uint,
        aTag: ::std::os::raw::c_int,
    ) -> *mut cocos2d_CCSpriteBatchNode;
}
extern "C" {
    #[doc = "  @js ctor"]
    #[link_name = "\u{1}??0CCSpriteBatchNode@cocos2d@@QEAA@XZ"]
    pub fn cocos2d_CCSpriteBatchNode_CCSpriteBatchNode(this: *mut cocos2d_CCSpriteBatchNode);
}
impl cocos2d_CCSpriteBatchNode {
    #[inline]
    pub unsafe fn createWithTexture(
        tex: *mut cocos2d_CCTexture2D,
        capacity: ::std::os::raw::c_uint,
    ) -> *mut cocos2d_CCSpriteBatchNode {
        cocos2d_CCSpriteBatchNode_createWithTexture(tex, capacity)
    }
    #[inline]
    pub unsafe fn create(
        fileImage: *const ::std::os::raw::c_char,
        capacity: ::std::os::raw::c_uint,
    ) -> *mut cocos2d_CCSpriteBatchNode {
        cocos2d_CCSpriteBatchNode_create(fileImage, capacity)
    }
    #[inline]
    pub unsafe fn initWithTexture(
        &mut self,
        tex: *mut cocos2d_CCTexture2D,
        capacity: ::std::os::raw::c_uint,
    ) -> bool {
        cocos2d_CCSpriteBatchNode_initWithTexture(self, tex, capacity)
    }
    #[inline]
    pub unsafe fn initWithFile(
        &mut self,
        fileImage: *const ::std::os::raw::c_char,
        capacity: ::std::os::raw::c_uint,
    ) -> bool {
        cocos2d_CCSpriteBatchNode_initWithFile(self, fileImage, capacity)
    }
    #[inline]
    pub unsafe fn increaseAtlasCapacity(&mut self) {
        cocos2d_CCSpriteBatchNode_increaseAtlasCapacity(self)
    }
    #[inline]
    pub unsafe fn removeChildAtIndex(&mut self, index: ::std::os::raw::c_uint, doCleanup: bool) {
        cocos2d_CCSpriteBatchNode_removeChildAtIndex(self, index, doCleanup)
    }
    #[inline]
    pub unsafe fn insertChild(
        &mut self,
        child: *mut cocos2d_CCSprite,
        index: ::std::os::raw::c_uint,
    ) {
        cocos2d_CCSpriteBatchNode_insertChild(self, child, index)
    }
    #[inline]
    pub unsafe fn appendChild(&mut self, sprite: *mut cocos2d_CCSprite) {
        cocos2d_CCSpriteBatchNode_appendChild(self, sprite)
    }
    #[inline]
    pub unsafe fn removeSpriteFromAtlas(&mut self, sprite: *mut cocos2d_CCSprite) {
        cocos2d_CCSpriteBatchNode_removeSpriteFromAtlas(self, sprite)
    }
    #[inline]
    pub unsafe fn rebuildIndexInOrder(
        &mut self,
        parent: *mut cocos2d_CCSprite,
        index: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_uint {
        cocos2d_CCSpriteBatchNode_rebuildIndexInOrder(self, parent, index)
    }
    #[inline]
    pub unsafe fn highestAtlasIndexInChild(
        &mut self,
        sprite: *mut cocos2d_CCSprite,
    ) -> ::std::os::raw::c_uint {
        cocos2d_CCSpriteBatchNode_highestAtlasIndexInChild(self, sprite)
    }
    #[inline]
    pub unsafe fn lowestAtlasIndexInChild(
        &mut self,
        sprite: *mut cocos2d_CCSprite,
    ) -> ::std::os::raw::c_uint {
        cocos2d_CCSpriteBatchNode_lowestAtlasIndexInChild(self, sprite)
    }
    #[inline]
    pub unsafe fn atlasIndexForChild(
        &mut self,
        sprite: *mut cocos2d_CCSprite,
        z: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_uint {
        cocos2d_CCSpriteBatchNode_atlasIndexForChild(self, sprite, z)
    }
    #[inline]
    pub unsafe fn reorderBatch(&mut self, reorder: bool) {
        cocos2d_CCSpriteBatchNode_reorderBatch(self, reorder)
    }
    #[inline]
    pub unsafe fn insertQuadFromSprite(
        &mut self,
        sprite: *mut cocos2d_CCSprite,
        index: ::std::os::raw::c_uint,
    ) {
        cocos2d_CCSpriteBatchNode_insertQuadFromSprite(self, sprite, index)
    }
    #[inline]
    pub unsafe fn updateQuadFromSprite(
        &mut self,
        sprite: *mut cocos2d_CCSprite,
        index: ::std::os::raw::c_uint,
    ) {
        cocos2d_CCSpriteBatchNode_updateQuadFromSprite(self, sprite, index)
    }
    #[inline]
    pub unsafe fn addSpriteWithoutQuad(
        &mut self,
        child: *mut cocos2d_CCSprite,
        z: ::std::os::raw::c_uint,
        aTag: ::std::os::raw::c_int,
    ) -> *mut cocos2d_CCSpriteBatchNode {
        cocos2d_CCSpriteBatchNode_addSpriteWithoutQuad(self, child, z, aTag)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cocos2d_CCSpriteBatchNode_CCSpriteBatchNode(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
}
extern "C" {
    #[doc = " @js NA"]
    #[doc = " @lua NA"]
    #[link_name = "\u{1}??_DCCSpriteBatchNode@cocos2d@@QEAAXXZ"]
    pub fn cocos2d_CCSpriteBatchNode_CCSpriteBatchNode_destructor(
        this: *mut cocos2d_CCSpriteBatchNode,
    );
}
extern "C" {
    #[link_name = "\u{1}?init@CCSpriteBatchNode@cocos2d@@UEAA_NXZ"]
    pub fn cocos2d_CCSpriteBatchNode_init(this: *mut ::std::os::raw::c_void) -> bool;
}
extern "C" {
    #[link_name = "\u{1}?getTexture@CCSpriteBatchNode@cocos2d@@UEAAPEAVCCTexture2D@2@XZ"]
    pub fn cocos2d_CCSpriteBatchNode_getTexture(
        this: *mut ::std::os::raw::c_void,
    ) -> *mut cocos2d_CCTexture2D;
}
extern "C" {
    #[link_name = "\u{1}?setTexture@CCSpriteBatchNode@cocos2d@@UEAAXPEAVCCTexture2D@2@@Z"]
    pub fn cocos2d_CCSpriteBatchNode_setTexture(
        this: *mut ::std::os::raw::c_void,
        texture: *mut cocos2d_CCTexture2D,
    );
}
extern "C" {
    #[link_name = "\u{1}?setBlendFunc@CCSpriteBatchNode@cocos2d@@UEAAXU_ccBlendFunc@2@@Z"]
    pub fn cocos2d_CCSpriteBatchNode_setBlendFunc(
        this: *mut ::std::os::raw::c_void,
        blendFunc: cocos2d_ccBlendFunc,
    );
}
extern "C" {
    #[doc = " @js NA"]
    #[link_name = "\u{1}?getBlendFunc@CCSpriteBatchNode@cocos2d@@UEAA?AU_ccBlendFunc@2@XZ"]
    pub fn cocos2d_CCSpriteBatchNode_getBlendFunc(
        this: *mut ::std::os::raw::c_void,
    ) -> cocos2d_ccBlendFunc;
}
extern "C" {
    #[link_name = "\u{1}?visit@CCSpriteBatchNode@cocos2d@@UEAAXXZ"]
    pub fn cocos2d_CCSpriteBatchNode_visit(this: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[link_name = "\u{1}?addChild@CCSpriteBatchNode@cocos2d@@UEAAXPEAVCCNode@2@@Z"]
    pub fn cocos2d_CCSpriteBatchNode_addChild(
        this: *mut ::std::os::raw::c_void,
        child: *mut cocos2d_CCNode,
    );
}
extern "C" {
    #[link_name = "\u{1}?addChild@CCSpriteBatchNode@cocos2d@@UEAAXPEAVCCNode@2@H@Z"]
    pub fn cocos2d_CCSpriteBatchNode_addChild1(
        this: *mut ::std::os::raw::c_void,
        child: *mut cocos2d_CCNode,
        zOrder: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}?addChild@CCSpriteBatchNode@cocos2d@@UEAAXPEAVCCNode@2@HH@Z"]
    pub fn cocos2d_CCSpriteBatchNode_addChild2(
        this: *mut ::std::os::raw::c_void,
        child: *mut cocos2d_CCNode,
        zOrder: ::std::os::raw::c_int,
        tag: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}?reorderChild@CCSpriteBatchNode@cocos2d@@UEAAXPEAVCCNode@2@H@Z"]
    pub fn cocos2d_CCSpriteBatchNode_reorderChild(
        this: *mut ::std::os::raw::c_void,
        child: *mut cocos2d_CCNode,
        zOrder: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}?removeChild@CCSpriteBatchNode@cocos2d@@UEAAXPEAVCCNode@2@_N@Z"]
    pub fn cocos2d_CCSpriteBatchNode_removeChild(
        this: *mut ::std::os::raw::c_void,
        child: *mut cocos2d_CCNode,
        cleanup: bool,
    );
}
extern "C" {
    #[link_name = "\u{1}?removeAllChildrenWithCleanup@CCSpriteBatchNode@cocos2d@@UEAAX_N@Z"]
    pub fn cocos2d_CCSpriteBatchNode_removeAllChildrenWithCleanup(
        this: *mut ::std::os::raw::c_void,
        cleanup: bool,
    );
}
extern "C" {
    #[link_name = "\u{1}?sortAllChildren@CCSpriteBatchNode@cocos2d@@UEAAXXZ"]
    pub fn cocos2d_CCSpriteBatchNode_sortAllChildren(this: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[link_name = "\u{1}?draw@CCSpriteBatchNode@cocos2d@@UEAAXXZ"]
    pub fn cocos2d_CCSpriteBatchNode_draw(this: *mut ::std::os::raw::c_void);
}
pub const kCCLabelAutomaticWidth: ::std::os::raw::c_int = -1;
#[doc = " @addtogroup GUI"]
#[doc = " @{"]
#[doc = " @addtogroup label"]
#[doc = " @{"]
pub type cocos2d__bindgen_ty_7 = ::std::os::raw::c_int;
#[doc = "@struct ccBMFontDef"]
#[doc = "BMFont definition"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cocos2d__BMFontDef {
    #[doc = "! ID of the character"]
    pub charID: ::std::os::raw::c_uint,
    #[doc = "! origin and size of the font"]
    pub rect: cocos2d_CCRect,
    #[doc = "! The X amount the image should be offset when drawing the image (in pixels)"]
    pub xOffset: ::std::os::raw::c_short,
    #[doc = "! The Y amount the image should be offset when drawing the image (in pixels)"]
    pub yOffset: ::std::os::raw::c_short,
    #[doc = "! The amount to move the current position after drawing the character (in pixels)"]
    pub xAdvance: ::std::os::raw::c_short,
}
#[test]
fn bindgen_test_layout_cocos2d__BMFontDef() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d__BMFontDef>(),
        28usize,
        concat!("Size of: ", stringify!(cocos2d__BMFontDef))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d__BMFontDef>(),
        4usize,
        concat!("Alignment of ", stringify!(cocos2d__BMFontDef))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cocos2d__BMFontDef>())).charID as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d__BMFontDef),
            "::",
            stringify!(charID)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cocos2d__BMFontDef>())).rect as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d__BMFontDef),
            "::",
            stringify!(rect)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cocos2d__BMFontDef>())).xOffset as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d__BMFontDef),
            "::",
            stringify!(xOffset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cocos2d__BMFontDef>())).yOffset as *const _ as usize },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d__BMFontDef),
            "::",
            stringify!(yOffset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cocos2d__BMFontDef>())).xAdvance as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d__BMFontDef),
            "::",
            stringify!(xAdvance)
        )
    );
}
#[doc = "@struct ccBMFontDef"]
#[doc = "BMFont definition"]
pub type cocos2d_ccBMFontDef = cocos2d__BMFontDef;
#[doc = " @struct ccBMFontPadding"]
#[doc = "BMFont padding"]
#[doc = "@since v0.8.2"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cocos2d__BMFontPadding {
    #[doc = " padding left"]
    pub left: ::std::os::raw::c_int,
    #[doc = " padding top"]
    pub top: ::std::os::raw::c_int,
    #[doc = " padding right"]
    pub right: ::std::os::raw::c_int,
    #[doc = " padding bottom"]
    pub bottom: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_cocos2d__BMFontPadding() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d__BMFontPadding>(),
        16usize,
        concat!("Size of: ", stringify!(cocos2d__BMFontPadding))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d__BMFontPadding>(),
        4usize,
        concat!("Alignment of ", stringify!(cocos2d__BMFontPadding))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cocos2d__BMFontPadding>())).left as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d__BMFontPadding),
            "::",
            stringify!(left)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cocos2d__BMFontPadding>())).top as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d__BMFontPadding),
            "::",
            stringify!(top)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cocos2d__BMFontPadding>())).right as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d__BMFontPadding),
            "::",
            stringify!(right)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cocos2d__BMFontPadding>())).bottom as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d__BMFontPadding),
            "::",
            stringify!(bottom)
        )
    );
}
#[doc = " @struct ccBMFontPadding"]
#[doc = "BMFont padding"]
#[doc = "@since v0.8.2"]
pub type cocos2d_ccBMFontPadding = cocos2d__BMFontPadding;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cocos2d__FontDefHashElement {
    pub key: ::std::os::raw::c_uint,
    pub fontDef: cocos2d_ccBMFontDef,
    pub hh: UT_hash_handle,
}
#[test]
fn bindgen_test_layout_cocos2d__FontDefHashElement() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d__FontDefHashElement>(),
        88usize,
        concat!("Size of: ", stringify!(cocos2d__FontDefHashElement))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d__FontDefHashElement>(),
        8usize,
        concat!("Alignment of ", stringify!(cocos2d__FontDefHashElement))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cocos2d__FontDefHashElement>())).key as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d__FontDefHashElement),
            "::",
            stringify!(key)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cocos2d__FontDefHashElement>())).fontDef as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d__FontDefHashElement),
            "::",
            stringify!(fontDef)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cocos2d__FontDefHashElement>())).hh as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d__FontDefHashElement),
            "::",
            stringify!(hh)
        )
    );
}
pub type cocos2d_tCCFontDefHashElement = cocos2d__FontDefHashElement;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cocos2d__KerningHashElement {
    pub key: ::std::os::raw::c_int,
    pub amount: ::std::os::raw::c_int,
    pub hh: UT_hash_handle,
}
#[test]
fn bindgen_test_layout_cocos2d__KerningHashElement() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d__KerningHashElement>(),
        64usize,
        concat!("Size of: ", stringify!(cocos2d__KerningHashElement))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d__KerningHashElement>(),
        8usize,
        concat!("Alignment of ", stringify!(cocos2d__KerningHashElement))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cocos2d__KerningHashElement>())).key as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d__KerningHashElement),
            "::",
            stringify!(key)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cocos2d__KerningHashElement>())).amount as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d__KerningHashElement),
            "::",
            stringify!(amount)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cocos2d__KerningHashElement>())).hh as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d__KerningHashElement),
            "::",
            stringify!(hh)
        )
    );
}
pub type cocos2d_tCCKerningHashElement = cocos2d__KerningHashElement;
#[doc = " @brief CCBMFontConfiguration has parsed configuration of the the .fnt file"]
#[doc = "@since v0.8"]
#[doc = "@js NA"]
#[doc = "@lua NA"]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCBMFontConfiguration {
    pub _base: cocos2d_CCObject,
    pub m_pFontDefDictionary: *mut cocos2d_tCCFontDefHashElement,
    #[doc = "! FNTConfig: Common Height Should be signed (issue #1343)"]
    pub m_nCommonHeight: ::std::os::raw::c_int,
    #[doc = "! Padding"]
    pub m_tPadding: cocos2d_ccBMFontPadding,
    #[doc = "! atlas name"]
    pub m_sAtlasName: std_string,
    #[doc = "! values for kerning"]
    pub m_pKerningDictionary: *mut cocos2d_tCCKerningHashElement,
    pub m_pCharacterSet: *mut u8,
}
#[test]
fn bindgen_test_layout_cocos2d_CCBMFontConfiguration() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCBMFontConfiguration>(),
        120usize,
        concat!("Size of: ", stringify!(cocos2d_CCBMFontConfiguration))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCBMFontConfiguration>(),
        8usize,
        concat!("Alignment of ", stringify!(cocos2d_CCBMFontConfiguration))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cocos2d_CCBMFontConfiguration>())).m_pFontDefDictionary
                as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCBMFontConfiguration),
            "::",
            stringify!(m_pFontDefDictionary)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cocos2d_CCBMFontConfiguration>())).m_nCommonHeight as *const _
                as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCBMFontConfiguration),
            "::",
            stringify!(m_nCommonHeight)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cocos2d_CCBMFontConfiguration>())).m_tPadding as *const _
                as usize
        },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCBMFontConfiguration),
            "::",
            stringify!(m_tPadding)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cocos2d_CCBMFontConfiguration>())).m_sAtlasName as *const _
                as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCBMFontConfiguration),
            "::",
            stringify!(m_sAtlasName)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cocos2d_CCBMFontConfiguration>())).m_pKerningDictionary
                as *const _ as usize
        },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCBMFontConfiguration),
            "::",
            stringify!(m_pKerningDictionary)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cocos2d_CCBMFontConfiguration>())).m_pCharacterSet as *const _
                as usize
        },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCBMFontConfiguration),
            "::",
            stringify!(m_pCharacterSet)
        )
    );
}
extern "C" {
    #[doc = "  @js NA"]
    #[doc = "  @lua NA"]
    #[link_name = "\u{1}?description@CCBMFontConfiguration@cocos2d@@QEAAPEBDXZ"]
    pub fn cocos2d_CCBMFontConfiguration_description(
        this: *mut cocos2d_CCBMFontConfiguration,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " allocates a CCBMFontConfiguration with a FNT file"]
    #[link_name = "\u{1}?create@CCBMFontConfiguration@cocos2d@@SAPEAV12@PEBD@Z"]
    pub fn cocos2d_CCBMFontConfiguration_create(
        FNTfile: *const ::std::os::raw::c_char,
    ) -> *mut cocos2d_CCBMFontConfiguration;
}
extern "C" {
    #[doc = " initializes a BitmapFontConfiguration with a FNT file"]
    #[link_name = "\u{1}?initWithFNTfile@CCBMFontConfiguration@cocos2d@@QEAA_NPEBD@Z"]
    pub fn cocos2d_CCBMFontConfiguration_initWithFNTfile(
        this: *mut cocos2d_CCBMFontConfiguration,
        FNTfile: *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}?getCharacterSet@CCBMFontConfiguration@cocos2d@@QEBAPEAV?$set@IU?$less@I@std@@V?$allocator@I@2@@std@@XZ"]
    pub fn cocos2d_CCBMFontConfiguration_getCharacterSet(
        this: *const cocos2d_CCBMFontConfiguration,
    ) -> *mut u8;
}
extern "C" {
    #[link_name = "\u{1}??0CCBMFontConfiguration@cocos2d@@QEAA@XZ"]
    pub fn cocos2d_CCBMFontConfiguration_CCBMFontConfiguration(
        this: *mut cocos2d_CCBMFontConfiguration,
    );
}
impl cocos2d_CCBMFontConfiguration {
    #[inline]
    pub unsafe fn description(&mut self) -> *const ::std::os::raw::c_char {
        cocos2d_CCBMFontConfiguration_description(self)
    }
    #[inline]
    pub unsafe fn create(
        FNTfile: *const ::std::os::raw::c_char,
    ) -> *mut cocos2d_CCBMFontConfiguration {
        cocos2d_CCBMFontConfiguration_create(FNTfile)
    }
    #[inline]
    pub unsafe fn initWithFNTfile(&mut self, FNTfile: *const ::std::os::raw::c_char) -> bool {
        cocos2d_CCBMFontConfiguration_initWithFNTfile(self, FNTfile)
    }
    #[inline]
    pub unsafe fn getCharacterSet(&self) -> *mut u8 {
        cocos2d_CCBMFontConfiguration_getCharacterSet(self)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cocos2d_CCBMFontConfiguration_CCBMFontConfiguration(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
}
extern "C" {
    #[doc = "  @js NA"]
    #[doc = "  @lua NA"]
    #[link_name = "\u{1}??_DCCBMFontConfiguration@cocos2d@@QEAAXXZ"]
    pub fn cocos2d_CCBMFontConfiguration_CCBMFontConfiguration_destructor(
        this: *mut cocos2d_CCBMFontConfiguration,
    );
}
#[doc = " @brief CCLabelBMFont is a subclass of CCSpriteBatchNode."]
#[doc = ""]
#[doc = "Features:"]
#[doc = "- Treats each character like a CCSprite. This means that each individual character can be:"]
#[doc = "- rotated"]
#[doc = "- scaled"]
#[doc = "- translated"]
#[doc = "- tinted"]
#[doc = "- change the opacity"]
#[doc = "- It can be used as part of a menu item."]
#[doc = "- anchorPoint can be used to align the \"label\""]
#[doc = "- Supports AngelCode text format"]
#[doc = ""]
#[doc = "Limitations:"]
#[doc = "- All inner characters are using an anchorPoint of (0.5f, 0.5f) and it is not recommend to change it"]
#[doc = "because it might affect the rendering"]
#[doc = ""]
#[doc = "CCLabelBMFont implements the protocol CCLabelProtocol, like CCLabel and CCLabelAtlas."]
#[doc = "CCLabelBMFont has the flexibility of CCLabel, the speed of CCLabelAtlas and all the features of CCSprite."]
#[doc = "If in doubt, use CCLabelBMFont instead of CCLabelAtlas / CCLabel."]
#[doc = ""]
#[doc = "Supported editors:"]
#[doc = "http://glyphdesigner.71squared.com/ (Commercial, Mac OS X)"]
#[doc = "http://www.n4te.com/hiero/hiero.jnlp (Free, Java)"]
#[doc = "http://slick.cokeandcode.com/demos/hiero.jnlp (Free, Java)"]
#[doc = "http://www.angelcode.com/products/bmfont/ (Free, Windows only)"]
#[doc = ""]
#[doc = "@since v0.8"]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCLabelBMFont {
    pub _base: cocos2d_CCSpriteBatchNode,
    pub _base_1: cocos2d_CCLabelProtocol,
    pub _base_2: cocos2d_CCRGBAProtocol,
    pub m_sString: *mut ::std::os::raw::c_ushort,
    pub m_sFntFile: std_string,
    pub m_sInitialString: *mut ::std::os::raw::c_ushort,
    pub m_sInitialStringUTF8: std_string,
    pub m_pAlignment: cocos2d_CCTextAlignment,
    pub m_fWidth: f32,
    pub m_pConfiguration: *mut cocos2d_CCBMFontConfiguration,
    pub m_bLineBreakWithoutSpaces: bool,
    pub m_tImageOffset: cocos2d_CCPoint,
    pub m_pReusedChar: *mut cocos2d_CCSprite,
    pub m_cDisplayedOpacity: GLubyte,
    pub m_cRealOpacity: GLubyte,
    pub m_tDisplayedColor: cocos2d_ccColor3B,
    pub m_tRealColor: cocos2d_ccColor3B,
    pub m_bCascadeColorEnabled: bool,
    pub m_bCascadeOpacityEnabled: bool,
    #[doc = " conforms to CCRGBAProtocol protocol"]
    pub m_bIsOpacityModifyRGB: bool,
    pub m_bIsBatched: bool,
    pub m_pTargetArray: *mut cocos2d_CCArray,
    pub m_pSomeTexture: *mut cocos2d_CCTexture2D,
}
#[test]
fn bindgen_test_layout_cocos2d_CCLabelBMFont() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCLabelBMFont>(),
        504usize,
        concat!("Size of: ", stringify!(cocos2d_CCLabelBMFont))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCLabelBMFont>(),
        8usize,
        concat!("Alignment of ", stringify!(cocos2d_CCLabelBMFont))
    );
}
extern "C" {
    #[doc = " Purges the cached data."]
    #[doc = "Removes from memory the cached configurations and the atlas name dictionary."]
    #[doc = "@since v0.99.3"]
    #[link_name = "\u{1}?purgeCachedData@CCLabelBMFont@cocos2d@@SAXXZ"]
    pub fn cocos2d_CCLabelBMFont_purgeCachedData();
}
extern "C" {
    #[doc = " creates a bitmap font atlas with an initial string and the FNT file"]
    #[link_name = "\u{1}?create@CCLabelBMFont@cocos2d@@SAPEAV12@PEBD0MW4CCTextAlignment@2@VCCPoint@2@@Z"]
    pub fn cocos2d_CCLabelBMFont_create(
        str_: *const ::std::os::raw::c_char,
        fntFile: *const ::std::os::raw::c_char,
        width: f32,
        alignment: cocos2d_CCTextAlignment,
        imageOffset: cocos2d_CCPoint,
    ) -> *mut cocos2d_CCLabelBMFont;
}
extern "C" {
    #[link_name = "\u{1}?create@CCLabelBMFont@cocos2d@@SAPEAV12@PEBD0MW4CCTextAlignment@2@@Z"]
    pub fn cocos2d_CCLabelBMFont_create1(
        str_: *const ::std::os::raw::c_char,
        fntFile: *const ::std::os::raw::c_char,
        width: f32,
        alignment: cocos2d_CCTextAlignment,
    ) -> *mut cocos2d_CCLabelBMFont;
}
extern "C" {
    #[link_name = "\u{1}?create@CCLabelBMFont@cocos2d@@SAPEAV12@PEBD0M@Z"]
    pub fn cocos2d_CCLabelBMFont_create2(
        str_: *const ::std::os::raw::c_char,
        fntFile: *const ::std::os::raw::c_char,
        width: f32,
    ) -> *mut cocos2d_CCLabelBMFont;
}
extern "C" {
    #[link_name = "\u{1}?create@CCLabelBMFont@cocos2d@@SAPEAV12@PEBD0@Z"]
    pub fn cocos2d_CCLabelBMFont_create3(
        str_: *const ::std::os::raw::c_char,
        fntFile: *const ::std::os::raw::c_char,
    ) -> *mut cocos2d_CCLabelBMFont;
}
extern "C" {
    #[doc = " Creates an label."]
    #[link_name = "\u{1}?create@CCLabelBMFont@cocos2d@@SAPEAV12@XZ"]
    pub fn cocos2d_CCLabelBMFont_create4() -> *mut cocos2d_CCLabelBMFont;
}
extern "C" {
    #[doc = " init a bitmap font atlas with an initial string and the FNT file"]
    #[link_name = "\u{1}?initWithString@CCLabelBMFont@cocos2d@@QEAA_NPEBD0MW4CCTextAlignment@2@VCCPoint@2@@Z"]
    pub fn cocos2d_CCLabelBMFont_initWithString(
        this: *mut cocos2d_CCLabelBMFont,
        str_: *const ::std::os::raw::c_char,
        fntFile: *const ::std::os::raw::c_char,
        width: f32,
        alignment: cocos2d_CCTextAlignment,
        imageOffset: cocos2d_CCPoint,
    ) -> bool;
}
extern "C" {
    #[doc = " updates the font chars based on the string to render"]
    #[link_name = "\u{1}?createFontChars@CCLabelBMFont@cocos2d@@QEAAXXZ"]
    pub fn cocos2d_CCLabelBMFont_createFontChars(this: *mut cocos2d_CCLabelBMFont);
}
extern "C" {
    #[link_name = "\u{1}?setFntFile@CCLabelBMFont@cocos2d@@QEAAXPEBD@Z"]
    pub fn cocos2d_CCLabelBMFont_setFntFile(
        this: *mut cocos2d_CCLabelBMFont,
        fntFile: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    #[link_name = "\u{1}?getFntFile@CCLabelBMFont@cocos2d@@QEAAPEBDXZ"]
    pub fn cocos2d_CCLabelBMFont_getFntFile(
        this: *mut cocos2d_CCLabelBMFont,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}?getConfiguration@CCLabelBMFont@cocos2d@@QEBAPEAVCCBMFontConfiguration@2@XZ"]
    pub fn cocos2d_CCLabelBMFont_getConfiguration(
        this: *const cocos2d_CCLabelBMFont,
    ) -> *mut cocos2d_CCBMFontConfiguration;
}
extern "C" {
    #[link_name = "\u{1}?createBatched@CCLabelBMFont@cocos2d@@SAPEAV12@PEBD0PEAVCCArray@2@@Z"]
    pub fn cocos2d_CCLabelBMFont_createBatched(
        str_: *const ::std::os::raw::c_char,
        fntFile: *const ::std::os::raw::c_char,
        arg1: *mut cocos2d_CCArray,
    ) -> *mut cocos2d_CCLabelBMFont;
}
extern "C" {
    #[link_name = "\u{1}?limitLabelWidth@CCLabelBMFont@cocos2d@@QEAAXMMM@Z"]
    pub fn cocos2d_CCLabelBMFont_limitLabelWidth(
        this: *mut cocos2d_CCLabelBMFont,
        width: f32,
        defaultScale: f32,
        minScale: f32,
    );
}
extern "C" {
    #[doc = "  @js ctor"]
    #[link_name = "\u{1}??0CCLabelBMFont@cocos2d@@QEAA@XZ"]
    pub fn cocos2d_CCLabelBMFont_CCLabelBMFont(this: *mut cocos2d_CCLabelBMFont);
}
impl cocos2d_CCLabelBMFont {
    #[inline]
    pub unsafe fn purgeCachedData() {
        cocos2d_CCLabelBMFont_purgeCachedData()
    }
    #[inline]
    pub unsafe fn create(
        str_: *const ::std::os::raw::c_char,
        fntFile: *const ::std::os::raw::c_char,
        width: f32,
        alignment: cocos2d_CCTextAlignment,
        imageOffset: cocos2d_CCPoint,
    ) -> *mut cocos2d_CCLabelBMFont {
        cocos2d_CCLabelBMFont_create(str_, fntFile, width, alignment, imageOffset)
    }
    #[inline]
    pub unsafe fn create1(
        str_: *const ::std::os::raw::c_char,
        fntFile: *const ::std::os::raw::c_char,
        width: f32,
        alignment: cocos2d_CCTextAlignment,
    ) -> *mut cocos2d_CCLabelBMFont {
        cocos2d_CCLabelBMFont_create1(str_, fntFile, width, alignment)
    }
    #[inline]
    pub unsafe fn create2(
        str_: *const ::std::os::raw::c_char,
        fntFile: *const ::std::os::raw::c_char,
        width: f32,
    ) -> *mut cocos2d_CCLabelBMFont {
        cocos2d_CCLabelBMFont_create2(str_, fntFile, width)
    }
    #[inline]
    pub unsafe fn create3(
        str_: *const ::std::os::raw::c_char,
        fntFile: *const ::std::os::raw::c_char,
    ) -> *mut cocos2d_CCLabelBMFont {
        cocos2d_CCLabelBMFont_create3(str_, fntFile)
    }
    #[inline]
    pub unsafe fn create4() -> *mut cocos2d_CCLabelBMFont {
        cocos2d_CCLabelBMFont_create4()
    }
    #[inline]
    pub unsafe fn initWithString(
        &mut self,
        str_: *const ::std::os::raw::c_char,
        fntFile: *const ::std::os::raw::c_char,
        width: f32,
        alignment: cocos2d_CCTextAlignment,
        imageOffset: cocos2d_CCPoint,
    ) -> bool {
        cocos2d_CCLabelBMFont_initWithString(self, str_, fntFile, width, alignment, imageOffset)
    }
    #[inline]
    pub unsafe fn createFontChars(&mut self) {
        cocos2d_CCLabelBMFont_createFontChars(self)
    }
    #[inline]
    pub unsafe fn setFntFile(&mut self, fntFile: *const ::std::os::raw::c_char) {
        cocos2d_CCLabelBMFont_setFntFile(self, fntFile)
    }
    #[inline]
    pub unsafe fn getFntFile(&mut self) -> *const ::std::os::raw::c_char {
        cocos2d_CCLabelBMFont_getFntFile(self)
    }
    #[inline]
    pub unsafe fn getConfiguration(&self) -> *mut cocos2d_CCBMFontConfiguration {
        cocos2d_CCLabelBMFont_getConfiguration(self)
    }
    #[inline]
    pub unsafe fn createBatched(
        str_: *const ::std::os::raw::c_char,
        fntFile: *const ::std::os::raw::c_char,
        arg1: *mut cocos2d_CCArray,
    ) -> *mut cocos2d_CCLabelBMFont {
        cocos2d_CCLabelBMFont_createBatched(str_, fntFile, arg1)
    }
    #[inline]
    pub unsafe fn limitLabelWidth(&mut self, width: f32, defaultScale: f32, minScale: f32) {
        cocos2d_CCLabelBMFont_limitLabelWidth(self, width, defaultScale, minScale)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cocos2d_CCLabelBMFont_CCLabelBMFont(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
}
extern "C" {
    #[doc = "  @js NA"]
    #[doc = "  @lua NA"]
    #[link_name = "\u{1}??_DCCLabelBMFont@cocos2d@@QEAAXXZ"]
    pub fn cocos2d_CCLabelBMFont_CCLabelBMFont_destructor(this: *mut cocos2d_CCLabelBMFont);
}
extern "C" {
    #[link_name = "\u{1}?init@CCLabelBMFont@cocos2d@@UEAA_NXZ"]
    pub fn cocos2d_CCLabelBMFont_init(this: *mut ::std::os::raw::c_void) -> bool;
}
extern "C" {
    #[link_name = "\u{1}?setString@CCLabelBMFont@cocos2d@@UEAAXPEBD@Z"]
    pub fn cocos2d_CCLabelBMFont_setString(
        this: *mut ::std::os::raw::c_void,
        newString: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    #[link_name = "\u{1}?setString@CCLabelBMFont@cocos2d@@UEAAXPEBD_N@Z"]
    pub fn cocos2d_CCLabelBMFont_setString1(
        this: *mut ::std::os::raw::c_void,
        newString: *const ::std::os::raw::c_char,
        needUpdateLabel: bool,
    );
}
extern "C" {
    #[link_name = "\u{1}?getString@CCLabelBMFont@cocos2d@@UEAAPEBDXZ"]
    pub fn cocos2d_CCLabelBMFont_getString(
        this: *mut ::std::os::raw::c_void,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}?setCString@CCLabelBMFont@cocos2d@@UEAAXPEBD@Z"]
    pub fn cocos2d_CCLabelBMFont_setCString(
        this: *mut ::std::os::raw::c_void,
        label: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    #[link_name = "\u{1}?setAnchorPoint@CCLabelBMFont@cocos2d@@UEAAXAEBVCCPoint@2@@Z"]
    pub fn cocos2d_CCLabelBMFont_setAnchorPoint(
        this: *mut ::std::os::raw::c_void,
        var: *const cocos2d_CCPoint,
    );
}
extern "C" {
    #[link_name = "\u{1}?updateLabel@CCLabelBMFont@cocos2d@@UEAAXXZ"]
    pub fn cocos2d_CCLabelBMFont_updateLabel(this: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[link_name = "\u{1}?setAlignment@CCLabelBMFont@cocos2d@@UEAAXW4CCTextAlignment@2@@Z"]
    pub fn cocos2d_CCLabelBMFont_setAlignment(
        this: *mut ::std::os::raw::c_void,
        alignment: cocos2d_CCTextAlignment,
    );
}
extern "C" {
    #[link_name = "\u{1}?setWidth@CCLabelBMFont@cocos2d@@UEAAXM@Z"]
    pub fn cocos2d_CCLabelBMFont_setWidth(this: *mut ::std::os::raw::c_void, width: f32);
}
extern "C" {
    #[link_name = "\u{1}?setLineBreakWithoutSpace@CCLabelBMFont@cocos2d@@UEAAX_N@Z"]
    pub fn cocos2d_CCLabelBMFont_setLineBreakWithoutSpace(
        this: *mut ::std::os::raw::c_void,
        breakWithoutSpace: bool,
    );
}
extern "C" {
    #[link_name = "\u{1}?setScale@CCLabelBMFont@cocos2d@@UEAAXM@Z"]
    pub fn cocos2d_CCLabelBMFont_setScale(this: *mut ::std::os::raw::c_void, scale: f32);
}
extern "C" {
    #[link_name = "\u{1}?setScaleX@CCLabelBMFont@cocos2d@@UEAAXM@Z"]
    pub fn cocos2d_CCLabelBMFont_setScaleX(this: *mut ::std::os::raw::c_void, scaleX: f32);
}
extern "C" {
    #[link_name = "\u{1}?setScaleY@CCLabelBMFont@cocos2d@@UEAAXM@Z"]
    pub fn cocos2d_CCLabelBMFont_setScaleY(this: *mut ::std::os::raw::c_void, scaleY: f32);
}
extern "C" {
    #[link_name = "\u{1}?isOpacityModifyRGB@CCLabelBMFont@cocos2d@@UEAA_NXZ"]
    pub fn cocos2d_CCLabelBMFont_isOpacityModifyRGB(this: *mut ::std::os::raw::c_void) -> bool;
}
extern "C" {
    #[link_name = "\u{1}?setOpacityModifyRGB@CCLabelBMFont@cocos2d@@UEAAX_N@Z"]
    pub fn cocos2d_CCLabelBMFont_setOpacityModifyRGB(
        this: *mut ::std::os::raw::c_void,
        isOpacityModifyRGB: bool,
    );
}
extern "C" {
    #[link_name = "\u{1}?getOpacity@CCLabelBMFont@cocos2d@@UEAAEXZ"]
    pub fn cocos2d_CCLabelBMFont_getOpacity(this: *mut ::std::os::raw::c_void) -> GLubyte;
}
extern "C" {
    #[link_name = "\u{1}?getDisplayedOpacity@CCLabelBMFont@cocos2d@@UEAAEXZ"]
    pub fn cocos2d_CCLabelBMFont_getDisplayedOpacity(this: *mut ::std::os::raw::c_void) -> GLubyte;
}
extern "C" {
    #[link_name = "\u{1}?setOpacity@CCLabelBMFont@cocos2d@@UEAAXE@Z"]
    pub fn cocos2d_CCLabelBMFont_setOpacity(this: *mut ::std::os::raw::c_void, opacity: GLubyte);
}
extern "C" {
    #[link_name = "\u{1}?updateDisplayedOpacity@CCLabelBMFont@cocos2d@@UEAAXE@Z"]
    pub fn cocos2d_CCLabelBMFont_updateDisplayedOpacity(
        this: *mut ::std::os::raw::c_void,
        parentOpacity: GLubyte,
    );
}
extern "C" {
    #[link_name = "\u{1}?isCascadeOpacityEnabled@CCLabelBMFont@cocos2d@@UEAA_NXZ"]
    pub fn cocos2d_CCLabelBMFont_isCascadeOpacityEnabled(this: *mut ::std::os::raw::c_void)
        -> bool;
}
extern "C" {
    #[link_name = "\u{1}?setCascadeOpacityEnabled@CCLabelBMFont@cocos2d@@UEAAX_N@Z"]
    pub fn cocos2d_CCLabelBMFont_setCascadeOpacityEnabled(
        this: *mut ::std::os::raw::c_void,
        cascadeOpacityEnabled: bool,
    );
}
extern "C" {
    #[link_name = "\u{1}?getColor@CCLabelBMFont@cocos2d@@UEAAAEBU_ccColor3B@2@XZ"]
    pub fn cocos2d_CCLabelBMFont_getColor(
        this: *mut ::std::os::raw::c_void,
    ) -> *const cocos2d_ccColor3B;
}
extern "C" {
    #[link_name = "\u{1}?getDisplayedColor@CCLabelBMFont@cocos2d@@UEAAAEBU_ccColor3B@2@XZ"]
    pub fn cocos2d_CCLabelBMFont_getDisplayedColor(
        this: *mut ::std::os::raw::c_void,
    ) -> *const cocos2d_ccColor3B;
}
extern "C" {
    #[link_name = "\u{1}?setColor@CCLabelBMFont@cocos2d@@UEAAXAEBU_ccColor3B@2@@Z"]
    pub fn cocos2d_CCLabelBMFont_setColor(
        this: *mut ::std::os::raw::c_void,
        color: *const cocos2d_ccColor3B,
    );
}
extern "C" {
    #[link_name = "\u{1}?updateDisplayedColor@CCLabelBMFont@cocos2d@@UEAAXAEBU_ccColor3B@2@@Z"]
    pub fn cocos2d_CCLabelBMFont_updateDisplayedColor(
        this: *mut ::std::os::raw::c_void,
        parentColor: *const cocos2d_ccColor3B,
    );
}
extern "C" {
    #[link_name = "\u{1}?isCascadeColorEnabled@CCLabelBMFont@cocos2d@@UEAA_NXZ"]
    pub fn cocos2d_CCLabelBMFont_isCascadeColorEnabled(this: *mut ::std::os::raw::c_void) -> bool;
}
extern "C" {
    #[link_name = "\u{1}?setCascadeColorEnabled@CCLabelBMFont@cocos2d@@UEAAX_N@Z"]
    pub fn cocos2d_CCLabelBMFont_setCascadeColorEnabled(
        this: *mut ::std::os::raw::c_void,
        cascadeColorEnabled: bool,
    );
}
extern "C" {
    #[link_name = "\u{1}?setString@CCLabelBMFont@cocos2d@@MEAAXPEAG_N@Z"]
    pub fn cocos2d_CCLabelBMFont_setString2(
        this: *mut ::std::os::raw::c_void,
        newString: *mut ::std::os::raw::c_ushort,
        needUpdateLabel: bool,
    );
}
extern "C" {
    #[doc = " Free function that parses a FNT file a place it on the cache"]
    #[link_name = "\u{1}?FNTConfigLoadFile@cocos2d@@YAPEAVCCBMFontConfiguration@1@PEBD@Z"]
    pub fn cocos2d_FNTConfigLoadFile(
        file: *const ::std::os::raw::c_char,
    ) -> *mut cocos2d_CCBMFontConfiguration;
}
extern "C" {
    #[doc = " Purges the FNT config cache"]
    #[link_name = "\u{1}?FNTConfigRemoveCache@cocos2d@@YAXXZ"]
    pub fn cocos2d_FNTConfigRemoveCache();
}
#[repr(C)]
pub struct cocos2d_CCTouchDelegate__bindgen_vtable(::std::os::raw::c_void);
#[doc = " @addtogroup input"]
#[doc = " @{"]
#[doc = " @js NA"]
#[doc = " @lua NA"]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCTouchDelegate {
    pub vtable_: *const cocos2d_CCTouchDelegate__bindgen_vtable,
}
#[test]
fn bindgen_test_layout_cocos2d_CCTouchDelegate() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCTouchDelegate>(),
        8usize,
        concat!("Size of: ", stringify!(cocos2d_CCTouchDelegate))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCTouchDelegate>(),
        8usize,
        concat!("Alignment of ", stringify!(cocos2d_CCTouchDelegate))
    );
}
#[doc = "@brief"]
#[doc = "Using this type of delegate results in two benefits:"]
#[doc = "- 1. You don't need to deal with CCSets, the dispatcher does the job of splitting"]
#[doc = "them. You get exactly one UITouch per call."]
#[doc = "- 2. You can *claim* a UITouch by returning YES in ccTouchBegan. Updates of claimed"]
#[doc = "touches are sent only to the delegate(s) that claimed them. So if you get a move/"]
#[doc = "ended/canceled update you're sure it's your touch. This frees you from doing a"]
#[doc = "lot of checks when doing multi-touch."]
#[doc = ""]
#[doc = "(The name TargetedTouchDelegate relates to updates \"targeting\" their specific"]
#[doc = "handler, without bothering the other handlers.)"]
#[doc = "@since v0.8"]
#[doc = "@js NA"]
#[doc = "@lua NA"]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCTargetedTouchDelegate {
    pub _base: cocos2d_CCTouchDelegate,
}
#[test]
fn bindgen_test_layout_cocos2d_CCTargetedTouchDelegate() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCTargetedTouchDelegate>(),
        8usize,
        concat!("Size of: ", stringify!(cocos2d_CCTargetedTouchDelegate))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCTargetedTouchDelegate>(),
        8usize,
        concat!("Alignment of ", stringify!(cocos2d_CCTargetedTouchDelegate))
    );
}
#[doc = " @brief"]
#[doc = "This type of delegate is the same one used by CocoaTouch. You will receive all the events (Began,Moved,Ended,Canceled)."]
#[doc = "@since v0.8"]
#[doc = "@js NA"]
#[doc = "@lua NA"]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCStandardTouchDelegate {
    pub _base: cocos2d_CCTouchDelegate,
}
#[test]
fn bindgen_test_layout_cocos2d_CCStandardTouchDelegate() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCStandardTouchDelegate>(),
        8usize,
        concat!("Size of: ", stringify!(cocos2d_CCStandardTouchDelegate))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCStandardTouchDelegate>(),
        8usize,
        concat!("Alignment of ", stringify!(cocos2d_CCStandardTouchDelegate))
    );
}
pub const cocos2d_enumKeyCodes_KEY_None: cocos2d_enumKeyCodes = 0;
pub const cocos2d_enumKeyCodes_KEY_Backspace: cocos2d_enumKeyCodes = 8;
pub const cocos2d_enumKeyCodes_KEY_Tab: cocos2d_enumKeyCodes = 9;
pub const cocos2d_enumKeyCodes_KEY_Clear: cocos2d_enumKeyCodes = 12;
pub const cocos2d_enumKeyCodes_KEY_Enter: cocos2d_enumKeyCodes = 13;
pub const cocos2d_enumKeyCodes_KEY_Shift: cocos2d_enumKeyCodes = 16;
pub const cocos2d_enumKeyCodes_KEY_Control: cocos2d_enumKeyCodes = 17;
pub const cocos2d_enumKeyCodes_KEY_Alt: cocos2d_enumKeyCodes = 18;
pub const cocos2d_enumKeyCodes_KEY_Pause: cocos2d_enumKeyCodes = 19;
pub const cocos2d_enumKeyCodes_KEY_CapsLock: cocos2d_enumKeyCodes = 20;
pub const cocos2d_enumKeyCodes_KEY_Escape: cocos2d_enumKeyCodes = 27;
pub const cocos2d_enumKeyCodes_KEY_Space: cocos2d_enumKeyCodes = 32;
pub const cocos2d_enumKeyCodes_KEY_PageUp: cocos2d_enumKeyCodes = 33;
pub const cocos2d_enumKeyCodes_KEY_PageDown: cocos2d_enumKeyCodes = 34;
pub const cocos2d_enumKeyCodes_KEY_End: cocos2d_enumKeyCodes = 35;
pub const cocos2d_enumKeyCodes_KEY_Home: cocos2d_enumKeyCodes = 36;
pub const cocos2d_enumKeyCodes_KEY_Left: cocos2d_enumKeyCodes = 37;
pub const cocos2d_enumKeyCodes_KEY_Up: cocos2d_enumKeyCodes = 38;
pub const cocos2d_enumKeyCodes_KEY_Right: cocos2d_enumKeyCodes = 39;
pub const cocos2d_enumKeyCodes_KEY_Down: cocos2d_enumKeyCodes = 40;
pub const cocos2d_enumKeyCodes_KEY_Select: cocos2d_enumKeyCodes = 41;
pub const cocos2d_enumKeyCodes_KEY_Print: cocos2d_enumKeyCodes = 42;
pub const cocos2d_enumKeyCodes_KEY_Execute: cocos2d_enumKeyCodes = 43;
pub const cocos2d_enumKeyCodes_KEY_PrintScreen: cocos2d_enumKeyCodes = 44;
pub const cocos2d_enumKeyCodes_KEY_Insert: cocos2d_enumKeyCodes = 45;
pub const cocos2d_enumKeyCodes_KEY_Delete: cocos2d_enumKeyCodes = 46;
pub const cocos2d_enumKeyCodes_KEY_Help: cocos2d_enumKeyCodes = 47;
pub const cocos2d_enumKeyCodes_KEY_Zero: cocos2d_enumKeyCodes = 48;
pub const cocos2d_enumKeyCodes_KEY_One: cocos2d_enumKeyCodes = 49;
pub const cocos2d_enumKeyCodes_KEY_Two: cocos2d_enumKeyCodes = 50;
pub const cocos2d_enumKeyCodes_KEY_Three: cocos2d_enumKeyCodes = 51;
pub const cocos2d_enumKeyCodes_KEY_Four: cocos2d_enumKeyCodes = 52;
pub const cocos2d_enumKeyCodes_KEY_Five: cocos2d_enumKeyCodes = 53;
pub const cocos2d_enumKeyCodes_KEY_Six: cocos2d_enumKeyCodes = 54;
pub const cocos2d_enumKeyCodes_KEY_Seven: cocos2d_enumKeyCodes = 55;
pub const cocos2d_enumKeyCodes_KEY_Eight: cocos2d_enumKeyCodes = 56;
pub const cocos2d_enumKeyCodes_KEY_Nine: cocos2d_enumKeyCodes = 57;
pub const cocos2d_enumKeyCodes_KEY_A: cocos2d_enumKeyCodes = 65;
pub const cocos2d_enumKeyCodes_KEY_B: cocos2d_enumKeyCodes = 66;
pub const cocos2d_enumKeyCodes_KEY_C: cocos2d_enumKeyCodes = 67;
pub const cocos2d_enumKeyCodes_KEY_D: cocos2d_enumKeyCodes = 68;
pub const cocos2d_enumKeyCodes_KEY_E: cocos2d_enumKeyCodes = 69;
pub const cocos2d_enumKeyCodes_KEY_F: cocos2d_enumKeyCodes = 70;
pub const cocos2d_enumKeyCodes_KEY_G: cocos2d_enumKeyCodes = 71;
pub const cocos2d_enumKeyCodes_KEY_H: cocos2d_enumKeyCodes = 72;
pub const cocos2d_enumKeyCodes_KEY_I: cocos2d_enumKeyCodes = 73;
pub const cocos2d_enumKeyCodes_KEY_J: cocos2d_enumKeyCodes = 74;
pub const cocos2d_enumKeyCodes_KEY_K: cocos2d_enumKeyCodes = 75;
pub const cocos2d_enumKeyCodes_KEY_L: cocos2d_enumKeyCodes = 76;
pub const cocos2d_enumKeyCodes_KEY_M: cocos2d_enumKeyCodes = 77;
pub const cocos2d_enumKeyCodes_KEY_N: cocos2d_enumKeyCodes = 78;
pub const cocos2d_enumKeyCodes_KEY_O: cocos2d_enumKeyCodes = 79;
pub const cocos2d_enumKeyCodes_KEY_P: cocos2d_enumKeyCodes = 80;
pub const cocos2d_enumKeyCodes_KEY_Q: cocos2d_enumKeyCodes = 81;
pub const cocos2d_enumKeyCodes_KEY_R: cocos2d_enumKeyCodes = 82;
pub const cocos2d_enumKeyCodes_KEY_S: cocos2d_enumKeyCodes = 83;
pub const cocos2d_enumKeyCodes_KEY_T: cocos2d_enumKeyCodes = 84;
pub const cocos2d_enumKeyCodes_KEY_U: cocos2d_enumKeyCodes = 85;
pub const cocos2d_enumKeyCodes_KEY_V: cocos2d_enumKeyCodes = 86;
pub const cocos2d_enumKeyCodes_KEY_W: cocos2d_enumKeyCodes = 87;
pub const cocos2d_enumKeyCodes_KEY_X: cocos2d_enumKeyCodes = 88;
pub const cocos2d_enumKeyCodes_KEY_Y: cocos2d_enumKeyCodes = 89;
pub const cocos2d_enumKeyCodes_KEY_Z: cocos2d_enumKeyCodes = 90;
pub const cocos2d_enumKeyCodes_KEY_LeftWindowsKey: cocos2d_enumKeyCodes = 91;
pub const cocos2d_enumKeyCodes_KEY_RightWindowsKey: cocos2d_enumKeyCodes = 92;
pub const cocos2d_enumKeyCodes_KEY_ApplicationsKey: cocos2d_enumKeyCodes = 93;
pub const cocos2d_enumKeyCodes_KEY_Sleep: cocos2d_enumKeyCodes = 95;
pub const cocos2d_enumKeyCodes_KEY_NumPad0: cocos2d_enumKeyCodes = 96;
pub const cocos2d_enumKeyCodes_KEY_NumPad1: cocos2d_enumKeyCodes = 97;
pub const cocos2d_enumKeyCodes_KEY_NumPad2: cocos2d_enumKeyCodes = 98;
pub const cocos2d_enumKeyCodes_KEY_NumPad3: cocos2d_enumKeyCodes = 99;
pub const cocos2d_enumKeyCodes_KEY_NumPad4: cocos2d_enumKeyCodes = 100;
pub const cocos2d_enumKeyCodes_KEY_NumPad5: cocos2d_enumKeyCodes = 101;
pub const cocos2d_enumKeyCodes_KEY_NumPad6: cocos2d_enumKeyCodes = 102;
pub const cocos2d_enumKeyCodes_KEY_NumPad7: cocos2d_enumKeyCodes = 103;
pub const cocos2d_enumKeyCodes_KEY_NumPad8: cocos2d_enumKeyCodes = 104;
pub const cocos2d_enumKeyCodes_KEY_NumPad9: cocos2d_enumKeyCodes = 105;
pub const cocos2d_enumKeyCodes_KEY_Multiply: cocos2d_enumKeyCodes = 106;
pub const cocos2d_enumKeyCodes_KEY_Add: cocos2d_enumKeyCodes = 107;
pub const cocos2d_enumKeyCodes_KEY_Seperator: cocos2d_enumKeyCodes = 108;
pub const cocos2d_enumKeyCodes_KEY_Subtract: cocos2d_enumKeyCodes = 109;
pub const cocos2d_enumKeyCodes_KEY_Decimal: cocos2d_enumKeyCodes = 110;
pub const cocos2d_enumKeyCodes_KEY_Divide: cocos2d_enumKeyCodes = 111;
pub const cocos2d_enumKeyCodes_KEY_F1: cocos2d_enumKeyCodes = 112;
pub const cocos2d_enumKeyCodes_KEY_F2: cocos2d_enumKeyCodes = 113;
pub const cocos2d_enumKeyCodes_KEY_F3: cocos2d_enumKeyCodes = 114;
pub const cocos2d_enumKeyCodes_KEY_F4: cocos2d_enumKeyCodes = 115;
pub const cocos2d_enumKeyCodes_KEY_F5: cocos2d_enumKeyCodes = 116;
pub const cocos2d_enumKeyCodes_KEY_F6: cocos2d_enumKeyCodes = 117;
pub const cocos2d_enumKeyCodes_KEY_F7: cocos2d_enumKeyCodes = 118;
pub const cocos2d_enumKeyCodes_KEY_F8: cocos2d_enumKeyCodes = 119;
pub const cocos2d_enumKeyCodes_KEY_F9: cocos2d_enumKeyCodes = 120;
pub const cocos2d_enumKeyCodes_KEY_F10: cocos2d_enumKeyCodes = 121;
pub const cocos2d_enumKeyCodes_KEY_F11: cocos2d_enumKeyCodes = 122;
pub const cocos2d_enumKeyCodes_KEY_F12: cocos2d_enumKeyCodes = 123;
pub const cocos2d_enumKeyCodes_KEY_F13: cocos2d_enumKeyCodes = 124;
pub const cocos2d_enumKeyCodes_KEY_F14: cocos2d_enumKeyCodes = 125;
pub const cocos2d_enumKeyCodes_KEY_F15: cocos2d_enumKeyCodes = 126;
pub const cocos2d_enumKeyCodes_KEY_F16: cocos2d_enumKeyCodes = 127;
pub const cocos2d_enumKeyCodes_KEY_F17: cocos2d_enumKeyCodes = 128;
pub const cocos2d_enumKeyCodes_KEY_F18: cocos2d_enumKeyCodes = 129;
pub const cocos2d_enumKeyCodes_KEY_F19: cocos2d_enumKeyCodes = 130;
pub const cocos2d_enumKeyCodes_KEY_F20: cocos2d_enumKeyCodes = 131;
pub const cocos2d_enumKeyCodes_KEY_F21: cocos2d_enumKeyCodes = 132;
pub const cocos2d_enumKeyCodes_KEY_F22: cocos2d_enumKeyCodes = 133;
pub const cocos2d_enumKeyCodes_KEY_F23: cocos2d_enumKeyCodes = 134;
pub const cocos2d_enumKeyCodes_KEY_F24: cocos2d_enumKeyCodes = 135;
pub const cocos2d_enumKeyCodes_KEY_Numlock: cocos2d_enumKeyCodes = 144;
pub const cocos2d_enumKeyCodes_KEY_ScrollLock: cocos2d_enumKeyCodes = 145;
pub const cocos2d_enumKeyCodes_KEY_LeftShift: cocos2d_enumKeyCodes = 160;
pub const cocos2d_enumKeyCodes_KEY_RightShift: cocos2d_enumKeyCodes = 161;
pub const cocos2d_enumKeyCodes_KEY_LeftControl: cocos2d_enumKeyCodes = 162;
pub const cocos2d_enumKeyCodes_KEY_RightContol: cocos2d_enumKeyCodes = 163;
pub const cocos2d_enumKeyCodes_KEY_LeftMenu: cocos2d_enumKeyCodes = 164;
pub const cocos2d_enumKeyCodes_KEY_RightMenu: cocos2d_enumKeyCodes = 165;
pub const cocos2d_enumKeyCodes_KEY_BrowserBack: cocos2d_enumKeyCodes = 166;
pub const cocos2d_enumKeyCodes_KEY_BrowserForward: cocos2d_enumKeyCodes = 167;
pub const cocos2d_enumKeyCodes_KEY_BrowserRefresh: cocos2d_enumKeyCodes = 168;
pub const cocos2d_enumKeyCodes_KEY_BrowserStop: cocos2d_enumKeyCodes = 169;
pub const cocos2d_enumKeyCodes_KEY_BrowserSearch: cocos2d_enumKeyCodes = 170;
pub const cocos2d_enumKeyCodes_KEY_BrowserFavorites: cocos2d_enumKeyCodes = 171;
pub const cocos2d_enumKeyCodes_KEY_BrowserHome: cocos2d_enumKeyCodes = 172;
pub const cocos2d_enumKeyCodes_KEY_VolumeMute: cocos2d_enumKeyCodes = 173;
pub const cocos2d_enumKeyCodes_KEY_VolumeDown: cocos2d_enumKeyCodes = 174;
pub const cocos2d_enumKeyCodes_KEY_VolumeUp: cocos2d_enumKeyCodes = 175;
pub const cocos2d_enumKeyCodes_KEY_NextTrack: cocos2d_enumKeyCodes = 176;
pub const cocos2d_enumKeyCodes_KEY_PreviousTrack: cocos2d_enumKeyCodes = 177;
pub const cocos2d_enumKeyCodes_KEY_StopMedia: cocos2d_enumKeyCodes = 178;
pub const cocos2d_enumKeyCodes_KEY_PlayPause: cocos2d_enumKeyCodes = 179;
pub const cocos2d_enumKeyCodes_KEY_LaunchMail: cocos2d_enumKeyCodes = 180;
pub const cocos2d_enumKeyCodes_KEY_SelectMedia: cocos2d_enumKeyCodes = 181;
pub const cocos2d_enumKeyCodes_KEY_LaunchApp1: cocos2d_enumKeyCodes = 182;
pub const cocos2d_enumKeyCodes_KEY_LaunchApp2: cocos2d_enumKeyCodes = 183;
pub const cocos2d_enumKeyCodes_KEY_OEM1: cocos2d_enumKeyCodes = 186;
pub const cocos2d_enumKeyCodes_KEY_OEMPlus: cocos2d_enumKeyCodes = 184;
pub const cocos2d_enumKeyCodes_KEY_OEMComma: cocos2d_enumKeyCodes = 188;
pub const cocos2d_enumKeyCodes_KEY_OEMMinus: cocos2d_enumKeyCodes = 189;
pub const cocos2d_enumKeyCodes_KEY_OEMPeriod: cocos2d_enumKeyCodes = 190;
pub const cocos2d_enumKeyCodes_KEY_OEM2: cocos2d_enumKeyCodes = 191;
pub const cocos2d_enumKeyCodes_KEY_OEM3: cocos2d_enumKeyCodes = 192;
pub const cocos2d_enumKeyCodes_KEY_OEM4: cocos2d_enumKeyCodes = 219;
pub const cocos2d_enumKeyCodes_KEY_OEM5: cocos2d_enumKeyCodes = 220;
pub const cocos2d_enumKeyCodes_KEY_OEM6: cocos2d_enumKeyCodes = 221;
pub const cocos2d_enumKeyCodes_KEY_OEM7: cocos2d_enumKeyCodes = 222;
pub const cocos2d_enumKeyCodes_KEY_OEM8: cocos2d_enumKeyCodes = 223;
pub const cocos2d_enumKeyCodes_KEY_OEM102: cocos2d_enumKeyCodes = 226;
pub const cocos2d_enumKeyCodes_KEY_Process: cocos2d_enumKeyCodes = 229;
pub const cocos2d_enumKeyCodes_KEY_Packet: cocos2d_enumKeyCodes = 231;
pub const cocos2d_enumKeyCodes_KEY_Attn: cocos2d_enumKeyCodes = 246;
pub const cocos2d_enumKeyCodes_KEY_CrSel: cocos2d_enumKeyCodes = 247;
pub const cocos2d_enumKeyCodes_KEY_ExSel: cocos2d_enumKeyCodes = 248;
pub const cocos2d_enumKeyCodes_KEY_EraseEOF: cocos2d_enumKeyCodes = 249;
pub const cocos2d_enumKeyCodes_KEY_Play: cocos2d_enumKeyCodes = 250;
pub const cocos2d_enumKeyCodes_KEY_Zoom: cocos2d_enumKeyCodes = 251;
pub const cocos2d_enumKeyCodes_KEY_PA1: cocos2d_enumKeyCodes = 253;
pub const cocos2d_enumKeyCodes_KEY_OEMClear: cocos2d_enumKeyCodes = 254;
pub const cocos2d_enumKeyCodes_KEY_ArrowUp: cocos2d_enumKeyCodes = 283;
pub const cocos2d_enumKeyCodes_KEY_ArrowDown: cocos2d_enumKeyCodes = 284;
pub const cocos2d_enumKeyCodes_KEY_ArrowLeft: cocos2d_enumKeyCodes = 285;
pub const cocos2d_enumKeyCodes_KEY_ArrowRight: cocos2d_enumKeyCodes = 286;
pub type cocos2d_enumKeyCodes = ::std::os::raw::c_int;
#[repr(C)]
pub struct cocos2d_CCKeyboardDelegate__bindgen_vtable(::std::os::raw::c_void);
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cocos2d_CCKeyboardDelegate {
    pub vtable_: *const cocos2d_CCKeyboardDelegate__bindgen_vtable,
}
#[test]
fn bindgen_test_layout_cocos2d_CCKeyboardDelegate() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCKeyboardDelegate>(),
        8usize,
        concat!("Size of: ", stringify!(cocos2d_CCKeyboardDelegate))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCKeyboardDelegate>(),
        8usize,
        concat!("Alignment of ", stringify!(cocos2d_CCKeyboardDelegate))
    );
}
extern "C" {
    #[link_name = "\u{1}??0CCKeyboardDelegate@cocos2d@@QEAA@AEBV01@@Z"]
    pub fn cocos2d_CCKeyboardDelegate_CCKeyboardDelegate(
        this: *mut cocos2d_CCKeyboardDelegate,
        arg1: *const cocos2d_CCKeyboardDelegate,
    );
}
extern "C" {
    #[link_name = "\u{1}??0CCKeyboardDelegate@cocos2d@@QEAA@XZ"]
    pub fn cocos2d_CCKeyboardDelegate_CCKeyboardDelegate1(this: *mut cocos2d_CCKeyboardDelegate);
}
impl cocos2d_CCKeyboardDelegate {
    #[inline]
    pub unsafe fn new(arg1: *const cocos2d_CCKeyboardDelegate) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cocos2d_CCKeyboardDelegate_CCKeyboardDelegate(__bindgen_tmp.as_mut_ptr(), arg1);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new1() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cocos2d_CCKeyboardDelegate_CCKeyboardDelegate1(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
}
extern "C" {
    #[link_name = "\u{1}?keyDown@CCKeyboardDelegate@cocos2d@@UEAAXW4enumKeyCodes@2@@Z"]
    pub fn cocos2d_CCKeyboardDelegate_keyDown(
        this: *mut ::std::os::raw::c_void,
        key: cocos2d_enumKeyCodes,
    );
}
extern "C" {
    #[link_name = "\u{1}?keyUp@CCKeyboardDelegate@cocos2d@@UEAAXW4enumKeyCodes@2@@Z"]
    pub fn cocos2d_CCKeyboardDelegate_keyUp(
        this: *mut ::std::os::raw::c_void,
        key: cocos2d_enumKeyCodes,
    );
}
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCKeyboardHandler {
    pub _base: cocos2d_CCObject,
    pub m_pDelegate: *mut cocos2d_CCKeyboardDelegate,
}
#[test]
fn bindgen_test_layout_cocos2d_CCKeyboardHandler() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCKeyboardHandler>(),
        48usize,
        concat!("Size of: ", stringify!(cocos2d_CCKeyboardHandler))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCKeyboardHandler>(),
        8usize,
        concat!("Alignment of ", stringify!(cocos2d_CCKeyboardHandler))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cocos2d_CCKeyboardHandler>())).m_pDelegate as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCKeyboardHandler),
            "::",
            stringify!(m_pDelegate)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}?getDelegate@CCKeyboardHandler@cocos2d@@QEAAPEAVCCKeyboardDelegate@2@XZ"]
    pub fn cocos2d_CCKeyboardHandler_getDelegate(
        this: *mut cocos2d_CCKeyboardHandler,
    ) -> *mut cocos2d_CCKeyboardDelegate;
}
extern "C" {
    #[link_name = "\u{1}?handlerWithDelegate@CCKeyboardHandler@cocos2d@@SAPEAV12@PEAVCCKeyboardDelegate@2@@Z"]
    pub fn cocos2d_CCKeyboardHandler_handlerWithDelegate(
        pDelegate: *mut cocos2d_CCKeyboardDelegate,
    ) -> *mut cocos2d_CCKeyboardHandler;
}
extern "C" {
    #[link_name = "\u{1}?setDelegate@CCKeyboardHandler@cocos2d@@QEAAXPEAVCCKeyboardDelegate@2@@Z"]
    pub fn cocos2d_CCKeyboardHandler_setDelegate(
        this: *mut cocos2d_CCKeyboardHandler,
        pDelegate: *mut cocos2d_CCKeyboardDelegate,
    );
}
extern "C" {
    #[link_name = "\u{1}??0CCKeyboardHandler@cocos2d@@QEAA@AEBV01@@Z"]
    pub fn cocos2d_CCKeyboardHandler_CCKeyboardHandler(
        this: *mut cocos2d_CCKeyboardHandler,
        arg1: *const cocos2d_CCKeyboardHandler,
    );
}
extern "C" {
    #[link_name = "\u{1}??0CCKeyboardHandler@cocos2d@@QEAA@XZ"]
    pub fn cocos2d_CCKeyboardHandler_CCKeyboardHandler1(this: *mut cocos2d_CCKeyboardHandler);
}
impl cocos2d_CCKeyboardHandler {
    #[inline]
    pub unsafe fn getDelegate(&mut self) -> *mut cocos2d_CCKeyboardDelegate {
        cocos2d_CCKeyboardHandler_getDelegate(self)
    }
    #[inline]
    pub unsafe fn handlerWithDelegate(
        pDelegate: *mut cocos2d_CCKeyboardDelegate,
    ) -> *mut cocos2d_CCKeyboardHandler {
        cocos2d_CCKeyboardHandler_handlerWithDelegate(pDelegate)
    }
    #[inline]
    pub unsafe fn setDelegate(&mut self, pDelegate: *mut cocos2d_CCKeyboardDelegate) {
        cocos2d_CCKeyboardHandler_setDelegate(self, pDelegate)
    }
    #[inline]
    pub unsafe fn new(arg1: *const cocos2d_CCKeyboardHandler) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cocos2d_CCKeyboardHandler_CCKeyboardHandler(__bindgen_tmp.as_mut_ptr(), arg1);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new1() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cocos2d_CCKeyboardHandler_CCKeyboardHandler1(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
}
extern "C" {
    #[link_name = "\u{1}??_DCCKeyboardHandler@cocos2d@@QEAAXXZ"]
    pub fn cocos2d_CCKeyboardHandler_CCKeyboardHandler_destructor(
        this: *mut cocos2d_CCKeyboardHandler,
    );
}
extern "C" {
    #[link_name = "\u{1}?initWithDelegate@CCKeyboardHandler@cocos2d@@UEAA_NPEAVCCKeyboardDelegate@2@@Z"]
    pub fn cocos2d_CCKeyboardHandler_initWithDelegate(
        this: *mut ::std::os::raw::c_void,
        pDelegate: *mut cocos2d_CCKeyboardDelegate,
    ) -> bool;
}
#[repr(C)]
pub struct cocos2d_CCMouseDelegate__bindgen_vtable(::std::os::raw::c_void);
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cocos2d_CCMouseDelegate {
    pub vtable_: *const cocos2d_CCMouseDelegate__bindgen_vtable,
}
#[test]
fn bindgen_test_layout_cocos2d_CCMouseDelegate() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCMouseDelegate>(),
        8usize,
        concat!("Size of: ", stringify!(cocos2d_CCMouseDelegate))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCMouseDelegate>(),
        8usize,
        concat!("Alignment of ", stringify!(cocos2d_CCMouseDelegate))
    );
}
extern "C" {
    #[link_name = "\u{1}??0CCMouseDelegate@cocos2d@@QEAA@AEBV01@@Z"]
    pub fn cocos2d_CCMouseDelegate_CCMouseDelegate(
        this: *mut cocos2d_CCMouseDelegate,
        arg1: *const cocos2d_CCMouseDelegate,
    );
}
extern "C" {
    #[link_name = "\u{1}??0CCMouseDelegate@cocos2d@@QEAA@XZ"]
    pub fn cocos2d_CCMouseDelegate_CCMouseDelegate1(this: *mut cocos2d_CCMouseDelegate);
}
impl cocos2d_CCMouseDelegate {
    #[inline]
    pub unsafe fn new(arg1: *const cocos2d_CCMouseDelegate) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cocos2d_CCMouseDelegate_CCMouseDelegate(__bindgen_tmp.as_mut_ptr(), arg1);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new1() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cocos2d_CCMouseDelegate_CCMouseDelegate1(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
}
extern "C" {
    #[link_name = "\u{1}?rightKeyDown@CCMouseDelegate@cocos2d@@UEAAXXZ"]
    pub fn cocos2d_CCMouseDelegate_rightKeyDown(this: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[link_name = "\u{1}?rightKeyUp@CCMouseDelegate@cocos2d@@UEAAXXZ"]
    pub fn cocos2d_CCMouseDelegate_rightKeyUp(this: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[link_name = "\u{1}?scrollWheel@CCMouseDelegate@cocos2d@@UEAAXMM@Z"]
    pub fn cocos2d_CCMouseDelegate_scrollWheel(this: *mut ::std::os::raw::c_void, x: f32, y: f32);
}
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCMouseHandler {
    pub _base: cocos2d_CCObject,
    pub m_pDelegate: *mut cocos2d_CCMouseDelegate,
}
#[test]
fn bindgen_test_layout_cocos2d_CCMouseHandler() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCMouseHandler>(),
        48usize,
        concat!("Size of: ", stringify!(cocos2d_CCMouseHandler))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCMouseHandler>(),
        8usize,
        concat!("Alignment of ", stringify!(cocos2d_CCMouseHandler))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cocos2d_CCMouseHandler>())).m_pDelegate as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCMouseHandler),
            "::",
            stringify!(m_pDelegate)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}?getDelegate@CCMouseHandler@cocos2d@@QEAAPEAVCCMouseDelegate@2@XZ"]
    pub fn cocos2d_CCMouseHandler_getDelegate(
        this: *mut cocos2d_CCMouseHandler,
    ) -> *mut cocos2d_CCMouseDelegate;
}
extern "C" {
    #[link_name = "\u{1}?handlerWithDelegate@CCMouseHandler@cocos2d@@SAPEAV12@PEAVCCMouseDelegate@2@@Z"]
    pub fn cocos2d_CCMouseHandler_handlerWithDelegate(
        pDelegate: *mut cocos2d_CCMouseDelegate,
    ) -> *mut cocos2d_CCMouseHandler;
}
extern "C" {
    #[link_name = "\u{1}?setDelegate@CCMouseHandler@cocos2d@@QEAAXPEAVCCMouseDelegate@2@@Z"]
    pub fn cocos2d_CCMouseHandler_setDelegate(
        this: *mut cocos2d_CCMouseHandler,
        pDelegate: *mut cocos2d_CCMouseDelegate,
    );
}
extern "C" {
    #[link_name = "\u{1}??0CCMouseHandler@cocos2d@@QEAA@AEBV01@@Z"]
    pub fn cocos2d_CCMouseHandler_CCMouseHandler(
        this: *mut cocos2d_CCMouseHandler,
        arg1: *const cocos2d_CCMouseHandler,
    );
}
extern "C" {
    #[link_name = "\u{1}??0CCMouseHandler@cocos2d@@QEAA@XZ"]
    pub fn cocos2d_CCMouseHandler_CCMouseHandler1(this: *mut cocos2d_CCMouseHandler);
}
impl cocos2d_CCMouseHandler {
    #[inline]
    pub unsafe fn getDelegate(&mut self) -> *mut cocos2d_CCMouseDelegate {
        cocos2d_CCMouseHandler_getDelegate(self)
    }
    #[inline]
    pub unsafe fn handlerWithDelegate(
        pDelegate: *mut cocos2d_CCMouseDelegate,
    ) -> *mut cocos2d_CCMouseHandler {
        cocos2d_CCMouseHandler_handlerWithDelegate(pDelegate)
    }
    #[inline]
    pub unsafe fn setDelegate(&mut self, pDelegate: *mut cocos2d_CCMouseDelegate) {
        cocos2d_CCMouseHandler_setDelegate(self, pDelegate)
    }
    #[inline]
    pub unsafe fn new(arg1: *const cocos2d_CCMouseHandler) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cocos2d_CCMouseHandler_CCMouseHandler(__bindgen_tmp.as_mut_ptr(), arg1);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new1() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cocos2d_CCMouseHandler_CCMouseHandler1(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
}
extern "C" {
    #[link_name = "\u{1}??_DCCMouseHandler@cocos2d@@QEAAXXZ"]
    pub fn cocos2d_CCMouseHandler_CCMouseHandler_destructor(this: *mut cocos2d_CCMouseHandler);
}
extern "C" {
    #[link_name = "\u{1}?initWithDelegate@CCMouseHandler@cocos2d@@UEAA_NPEAVCCMouseDelegate@2@@Z"]
    pub fn cocos2d_CCMouseHandler_initWithDelegate(
        this: *mut ::std::os::raw::c_void,
        pDelegate: *mut cocos2d_CCMouseDelegate,
    ) -> bool;
}
pub const cocos2d_ccTouchesMode_kCCTouchesAllAtOnce: cocos2d_ccTouchesMode = 0;
pub const cocos2d_ccTouchesMode_kCCTouchesOneByOne: cocos2d_ccTouchesMode = 1;
pub type cocos2d_ccTouchesMode = ::std::os::raw::c_int;
#[doc = " @brief CCLayer is a subclass of CCNode that implements the TouchEventsDelegate protocol."]
#[doc = ""]
#[doc = "All features from CCNode are valid, plus the following new features:"]
#[doc = "- It can receive iPhone Touches"]
#[doc = "- It can receive Accelerometer input"]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCLayer {
    pub _base: cocos2d_CCNode,
    pub _base_1: cocos2d_CCTouchDelegate,
    pub _base_2: cocos2d_CCAccelerometerDelegate,
    pub _base_3: cocos2d_CCKeypadDelegate,
    pub _base_4: cocos2d_CCKeyboardDelegate,
    pub _base_5: cocos2d_CCMouseDelegate,
    pub m_bTouchEnabled: bool,
    pub m_bAccelerometerEnabled: bool,
    pub m_bKeypadEnabled: bool,
    pub m_bKeyboardEnabled: bool,
    pub m_bMouseEnabled: bool,
    pub m_pScriptTouchHandlerEntry: *mut cocos2d_CCTouchScriptHandlerEntry,
    pub m_pScriptKeypadHandlerEntry: *mut cocos2d_CCScriptHandlerEntry,
    pub m_pScriptAccelerateHandlerEntry: *mut cocos2d_CCScriptHandlerEntry,
    pub m_nTouchPriority: ::std::os::raw::c_int,
    pub m_eTouchMode: cocos2d_ccTouchesMode,
}
#[test]
fn bindgen_test_layout_cocos2d_CCLayer() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCLayer>(),
        376usize,
        concat!("Size of: ", stringify!(cocos2d_CCLayer))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCLayer>(),
        8usize,
        concat!("Alignment of ", stringify!(cocos2d_CCLayer))
    );
}
extern "C" {
    #[doc = " create one layer"]
    #[link_name = "\u{1}?create@CCLayer@cocos2d@@SAPEAV12@XZ"]
    pub fn cocos2d_CCLayer_create() -> *mut cocos2d_CCLayer;
}
extern "C" {
    #[link_name = "\u{1}?registerScriptAccelerateHandler@CCLayer@cocos2d@@QEAAXH@Z"]
    pub fn cocos2d_CCLayer_registerScriptAccelerateHandler(
        this: *mut cocos2d_CCLayer,
        nHandler: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}?unregisterScriptAccelerateHandler@CCLayer@cocos2d@@QEAAXXZ"]
    pub fn cocos2d_CCLayer_unregisterScriptAccelerateHandler(this: *mut cocos2d_CCLayer);
}
extern "C" {
    #[doc = " Register keypad events handler"]
    #[link_name = "\u{1}?registerScriptKeypadHandler@CCLayer@cocos2d@@QEAAXH@Z"]
    pub fn cocos2d_CCLayer_registerScriptKeypadHandler(
        this: *mut cocos2d_CCLayer,
        nHandler: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " Unregister keypad events handler"]
    #[link_name = "\u{1}?unregisterScriptKeypadHandler@CCLayer@cocos2d@@QEAAXXZ"]
    pub fn cocos2d_CCLayer_unregisterScriptKeypadHandler(this: *mut cocos2d_CCLayer);
}
extern "C" {
    #[doc = "  @js ctor"]
    #[link_name = "\u{1}??0CCLayer@cocos2d@@QEAA@XZ"]
    pub fn cocos2d_CCLayer_CCLayer(this: *mut cocos2d_CCLayer);
}
impl cocos2d_CCLayer {
    #[inline]
    pub unsafe fn create() -> *mut cocos2d_CCLayer {
        cocos2d_CCLayer_create()
    }
    #[inline]
    pub unsafe fn registerScriptAccelerateHandler(&mut self, nHandler: ::std::os::raw::c_int) {
        cocos2d_CCLayer_registerScriptAccelerateHandler(self, nHandler)
    }
    #[inline]
    pub unsafe fn unregisterScriptAccelerateHandler(&mut self) {
        cocos2d_CCLayer_unregisterScriptAccelerateHandler(self)
    }
    #[inline]
    pub unsafe fn registerScriptKeypadHandler(&mut self, nHandler: ::std::os::raw::c_int) {
        cocos2d_CCLayer_registerScriptKeypadHandler(self, nHandler)
    }
    #[inline]
    pub unsafe fn unregisterScriptKeypadHandler(&mut self) {
        cocos2d_CCLayer_unregisterScriptKeypadHandler(self)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cocos2d_CCLayer_CCLayer(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
}
extern "C" {
    #[doc = "  @js NA"]
    #[doc = "  @lua NA"]
    #[link_name = "\u{1}??_DCCLayer@cocos2d@@QEAAXXZ"]
    pub fn cocos2d_CCLayer_CCLayer_destructor(this: *mut cocos2d_CCLayer);
}
extern "C" {
    #[link_name = "\u{1}?init@CCLayer@cocos2d@@UEAA_NXZ"]
    pub fn cocos2d_CCLayer_init(this: *mut ::std::os::raw::c_void) -> bool;
}
extern "C" {
    #[doc = "  @js NA"]
    #[doc = "  @lua NA"]
    #[link_name = "\u{1}?onEnter@CCLayer@cocos2d@@UEAAXXZ"]
    pub fn cocos2d_CCLayer_onEnter(this: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[doc = "  @js NA"]
    #[doc = "  @lua NA"]
    #[link_name = "\u{1}?onExit@CCLayer@cocos2d@@UEAAXXZ"]
    pub fn cocos2d_CCLayer_onExit(this: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[doc = "  @js NA"]
    #[doc = "  @lua NA"]
    #[link_name = "\u{1}?onEnterTransitionDidFinish@CCLayer@cocos2d@@UEAAXXZ"]
    pub fn cocos2d_CCLayer_onEnterTransitionDidFinish(this: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[link_name = "\u{1}?ccTouchBegan@CCLayer@cocos2d@@UEAA_NPEAVCCTouch@2@PEAVCCEvent@2@@Z"]
    pub fn cocos2d_CCLayer_ccTouchBegan(
        this: *mut ::std::os::raw::c_void,
        pTouch: *mut cocos2d_CCTouch,
        pEvent: *mut cocos2d_CCEvent,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}?ccTouchMoved@CCLayer@cocos2d@@UEAAXPEAVCCTouch@2@PEAVCCEvent@2@@Z"]
    pub fn cocos2d_CCLayer_ccTouchMoved(
        this: *mut ::std::os::raw::c_void,
        pTouch: *mut cocos2d_CCTouch,
        pEvent: *mut cocos2d_CCEvent,
    );
}
extern "C" {
    #[link_name = "\u{1}?ccTouchEnded@CCLayer@cocos2d@@UEAAXPEAVCCTouch@2@PEAVCCEvent@2@@Z"]
    pub fn cocos2d_CCLayer_ccTouchEnded(
        this: *mut ::std::os::raw::c_void,
        pTouch: *mut cocos2d_CCTouch,
        pEvent: *mut cocos2d_CCEvent,
    );
}
extern "C" {
    #[link_name = "\u{1}?ccTouchCancelled@CCLayer@cocos2d@@UEAAXPEAVCCTouch@2@PEAVCCEvent@2@@Z"]
    pub fn cocos2d_CCLayer_ccTouchCancelled(
        this: *mut ::std::os::raw::c_void,
        pTouch: *mut cocos2d_CCTouch,
        pEvent: *mut cocos2d_CCEvent,
    );
}
extern "C" {
    #[link_name = "\u{1}?ccTouchesBegan@CCLayer@cocos2d@@UEAAXPEAVCCSet@2@PEAVCCEvent@2@@Z"]
    pub fn cocos2d_CCLayer_ccTouchesBegan(
        this: *mut ::std::os::raw::c_void,
        pTouches: *mut cocos2d_CCSet,
        pEvent: *mut cocos2d_CCEvent,
    );
}
extern "C" {
    #[link_name = "\u{1}?ccTouchesMoved@CCLayer@cocos2d@@UEAAXPEAVCCSet@2@PEAVCCEvent@2@@Z"]
    pub fn cocos2d_CCLayer_ccTouchesMoved(
        this: *mut ::std::os::raw::c_void,
        pTouches: *mut cocos2d_CCSet,
        pEvent: *mut cocos2d_CCEvent,
    );
}
extern "C" {
    #[link_name = "\u{1}?ccTouchesEnded@CCLayer@cocos2d@@UEAAXPEAVCCSet@2@PEAVCCEvent@2@@Z"]
    pub fn cocos2d_CCLayer_ccTouchesEnded(
        this: *mut ::std::os::raw::c_void,
        pTouches: *mut cocos2d_CCSet,
        pEvent: *mut cocos2d_CCEvent,
    );
}
extern "C" {
    #[link_name = "\u{1}?ccTouchesCancelled@CCLayer@cocos2d@@UEAAXPEAVCCSet@2@PEAVCCEvent@2@@Z"]
    pub fn cocos2d_CCLayer_ccTouchesCancelled(
        this: *mut ::std::os::raw::c_void,
        pTouches: *mut cocos2d_CCSet,
        pEvent: *mut cocos2d_CCEvent,
    );
}
extern "C" {
    #[doc = " @js NA"]
    #[doc = " @lua NA"]
    #[link_name = "\u{1}?didAccelerate@CCLayer@cocos2d@@UEAAXPEAVCCAcceleration@2@@Z"]
    pub fn cocos2d_CCLayer_didAccelerate(
        this: *mut ::std::os::raw::c_void,
        pAccelerationValue: *mut cocos2d_CCAcceleration,
    );
}
extern "C" {
    #[doc = " If isTouchEnabled, this method is called onEnter. Override it to change the"]
    #[doc = "way CCLayer receives touch events."]
    #[doc = "( Default: CCTouchDispatcher::sharedDispatcher()->addStandardDelegate(this,0); )"]
    #[doc = "Example:"]
    #[doc = "void CCLayer::registerWithTouchDispatcher()"]
    #[doc = "{"]
    #[doc = "CCTouchDispatcher::sharedDispatcher()->addTargetedDelegate(this,INT_MIN+1,true);"]
    #[doc = "}"]
    #[doc = "@since v0.8.0"]
    #[link_name = "\u{1}?registerWithTouchDispatcher@CCLayer@cocos2d@@UEAAXXZ"]
    pub fn cocos2d_CCLayer_registerWithTouchDispatcher(this: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[doc = " Register script touch events handler"]
    #[link_name = "\u{1}?registerScriptTouchHandler@CCLayer@cocos2d@@UEAAXH_NH0@Z"]
    pub fn cocos2d_CCLayer_registerScriptTouchHandler(
        this: *mut ::std::os::raw::c_void,
        nHandler: ::std::os::raw::c_int,
        bIsMultiTouches: bool,
        nPriority: ::std::os::raw::c_int,
        bSwallowsTouches: bool,
    );
}
extern "C" {
    #[doc = " Unregister script touch events handler"]
    #[link_name = "\u{1}?unregisterScriptTouchHandler@CCLayer@cocos2d@@UEAAXXZ"]
    pub fn cocos2d_CCLayer_unregisterScriptTouchHandler(this: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[doc = " whether or not it will receive Touch events."]
    #[doc = "You can enable / disable touch events with this property."]
    #[doc = "Only the touches of this node will be affected. This \"method\" is not propagated to it's children."]
    #[doc = "@since v0.8.1"]
    #[link_name = "\u{1}?isTouchEnabled@CCLayer@cocos2d@@UEAA_NXZ"]
    pub fn cocos2d_CCLayer_isTouchEnabled(this: *mut ::std::os::raw::c_void) -> bool;
}
extern "C" {
    #[link_name = "\u{1}?setTouchEnabled@CCLayer@cocos2d@@UEAAX_N@Z"]
    pub fn cocos2d_CCLayer_setTouchEnabled(this: *mut ::std::os::raw::c_void, value: bool);
}
extern "C" {
    #[link_name = "\u{1}?setTouchMode@CCLayer@cocos2d@@UEAAXW4ccTouchesMode@2@@Z"]
    pub fn cocos2d_CCLayer_setTouchMode(
        this: *mut ::std::os::raw::c_void,
        mode: cocos2d_ccTouchesMode,
    );
}
extern "C" {
    #[link_name = "\u{1}?getTouchMode@CCLayer@cocos2d@@UEAAHXZ"]
    pub fn cocos2d_CCLayer_getTouchMode(this: *mut ::std::os::raw::c_void)
        -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " priority of the touch events. Default is 0"]
    #[link_name = "\u{1}?setTouchPriority@CCLayer@cocos2d@@UEAAXH@Z"]
    pub fn cocos2d_CCLayer_setTouchPriority(
        this: *mut ::std::os::raw::c_void,
        priority: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}?getTouchPriority@CCLayer@cocos2d@@UEAAHXZ"]
    pub fn cocos2d_CCLayer_getTouchPriority(
        this: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " whether or not it will receive Accelerometer events"]
    #[doc = "You can enable / disable accelerometer events with this property."]
    #[doc = "@since v0.8.1"]
    #[link_name = "\u{1}?isAccelerometerEnabled@CCLayer@cocos2d@@UEAA_NXZ"]
    pub fn cocos2d_CCLayer_isAccelerometerEnabled(this: *mut ::std::os::raw::c_void) -> bool;
}
extern "C" {
    #[link_name = "\u{1}?setAccelerometerEnabled@CCLayer@cocos2d@@UEAAX_N@Z"]
    pub fn cocos2d_CCLayer_setAccelerometerEnabled(this: *mut ::std::os::raw::c_void, value: bool);
}
extern "C" {
    #[link_name = "\u{1}?setAccelerometerInterval@CCLayer@cocos2d@@UEAAXN@Z"]
    pub fn cocos2d_CCLayer_setAccelerometerInterval(
        this: *mut ::std::os::raw::c_void,
        interval: f64,
    );
}
extern "C" {
    #[doc = " whether or not it will receive keypad events"]
    #[doc = "You can enable / disable accelerometer events with this property."]
    #[doc = "it's new in cocos2d-x"]
    #[link_name = "\u{1}?isKeypadEnabled@CCLayer@cocos2d@@UEAA_NXZ"]
    pub fn cocos2d_CCLayer_isKeypadEnabled(this: *mut ::std::os::raw::c_void) -> bool;
}
extern "C" {
    #[link_name = "\u{1}?setKeypadEnabled@CCLayer@cocos2d@@UEAAX_N@Z"]
    pub fn cocos2d_CCLayer_setKeypadEnabled(this: *mut ::std::os::raw::c_void, value: bool);
}
extern "C" {
    #[link_name = "\u{1}?isKeyboardEnabled@CCLayer@cocos2d@@UEAA_NXZ"]
    pub fn cocos2d_CCLayer_isKeyboardEnabled(this: *mut ::std::os::raw::c_void) -> bool;
}
extern "C" {
    #[link_name = "\u{1}?setKeyboardEnabled@CCLayer@cocos2d@@UEAAX_N@Z"]
    pub fn cocos2d_CCLayer_setKeyboardEnabled(this: *mut ::std::os::raw::c_void, value: bool);
}
extern "C" {
    #[link_name = "\u{1}?isMouseEnabled@CCLayer@cocos2d@@UEAA_NXZ"]
    pub fn cocos2d_CCLayer_isMouseEnabled(this: *mut ::std::os::raw::c_void) -> bool;
}
extern "C" {
    #[link_name = "\u{1}?setMouseEnabled@CCLayer@cocos2d@@UEAAX_N@Z"]
    pub fn cocos2d_CCLayer_setMouseEnabled(this: *mut ::std::os::raw::c_void, value: bool);
}
extern "C" {
    #[link_name = "\u{1}?keyBackClicked@CCLayer@cocos2d@@UEAAXXZ"]
    pub fn cocos2d_CCLayer_keyBackClicked(this: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[link_name = "\u{1}?keyMenuClicked@CCLayer@cocos2d@@UEAAXXZ"]
    pub fn cocos2d_CCLayer_keyMenuClicked(this: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[link_name = "\u{1}?keyDown@CCLayer@cocos2d@@UEAAXW4enumKeyCodes@2@@Z"]
    pub fn cocos2d_CCLayer_keyDown(this: *mut ::std::os::raw::c_void, arg1: cocos2d_enumKeyCodes);
}
#[doc = " CCLayerRGBA is a subclass of CCLayer that implements the CCRGBAProtocol protocol using a solid color as the background."]
#[doc = ""]
#[doc = "All features from CCLayer are valid, plus the following new features that propagate into children that conform to the CCRGBAProtocol:"]
#[doc = "- opacity"]
#[doc = "- RGB colors"]
#[doc = "@since 2.1"]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCLayerRGBA {
    pub _base: cocos2d_CCLayer,
    pub _base_1: cocos2d_CCRGBAProtocol,
    pub _displayedOpacity: GLubyte,
    pub _realOpacity: GLubyte,
    pub _displayedColor: cocos2d_ccColor3B,
    pub _realColor: cocos2d_ccColor3B,
    pub _cascadeOpacityEnabled: bool,
    pub _cascadeColorEnabled: bool,
}
#[test]
fn bindgen_test_layout_cocos2d_CCLayerRGBA() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCLayerRGBA>(),
        400usize,
        concat!("Size of: ", stringify!(cocos2d_CCLayerRGBA))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCLayerRGBA>(),
        8usize,
        concat!("Alignment of ", stringify!(cocos2d_CCLayerRGBA))
    );
}
extern "C" {
    #[doc = "  @js ctor"]
    #[link_name = "\u{1}??0CCLayerRGBA@cocos2d@@QEAA@XZ"]
    pub fn cocos2d_CCLayerRGBA_CCLayerRGBA(this: *mut cocos2d_CCLayerRGBA);
}
impl cocos2d_CCLayerRGBA {
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cocos2d_CCLayerRGBA_CCLayerRGBA(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
}
extern "C" {
    #[doc = "  @js NA"]
    #[doc = "  @lua NA"]
    #[link_name = "\u{1}??_DCCLayerRGBA@cocos2d@@QEAAXXZ"]
    pub fn cocos2d_CCLayerRGBA_CCLayerRGBA_destructor(this: *mut cocos2d_CCLayerRGBA);
}
extern "C" {
    #[link_name = "\u{1}?init@CCLayerRGBA@cocos2d@@UEAA_NXZ"]
    pub fn cocos2d_CCLayerRGBA_init(this: *mut ::std::os::raw::c_void) -> bool;
}
extern "C" {
    #[link_name = "\u{1}?getOpacity@CCLayerRGBA@cocos2d@@UEAAEXZ"]
    pub fn cocos2d_CCLayerRGBA_getOpacity(this: *mut ::std::os::raw::c_void) -> GLubyte;
}
extern "C" {
    #[link_name = "\u{1}?getDisplayedOpacity@CCLayerRGBA@cocos2d@@UEAAEXZ"]
    pub fn cocos2d_CCLayerRGBA_getDisplayedOpacity(this: *mut ::std::os::raw::c_void) -> GLubyte;
}
extern "C" {
    #[link_name = "\u{1}?setOpacity@CCLayerRGBA@cocos2d@@UEAAXE@Z"]
    pub fn cocos2d_CCLayerRGBA_setOpacity(this: *mut ::std::os::raw::c_void, opacity: GLubyte);
}
extern "C" {
    #[link_name = "\u{1}?updateDisplayedOpacity@CCLayerRGBA@cocos2d@@UEAAXE@Z"]
    pub fn cocos2d_CCLayerRGBA_updateDisplayedOpacity(
        this: *mut ::std::os::raw::c_void,
        parentOpacity: GLubyte,
    );
}
extern "C" {
    #[link_name = "\u{1}?isCascadeOpacityEnabled@CCLayerRGBA@cocos2d@@UEAA_NXZ"]
    pub fn cocos2d_CCLayerRGBA_isCascadeOpacityEnabled(this: *mut ::std::os::raw::c_void) -> bool;
}
extern "C" {
    #[link_name = "\u{1}?setCascadeOpacityEnabled@CCLayerRGBA@cocos2d@@UEAAX_N@Z"]
    pub fn cocos2d_CCLayerRGBA_setCascadeOpacityEnabled(
        this: *mut ::std::os::raw::c_void,
        cascadeOpacityEnabled: bool,
    );
}
extern "C" {
    #[link_name = "\u{1}?getColor@CCLayerRGBA@cocos2d@@UEAAAEBU_ccColor3B@2@XZ"]
    pub fn cocos2d_CCLayerRGBA_getColor(
        this: *mut ::std::os::raw::c_void,
    ) -> *const cocos2d_ccColor3B;
}
extern "C" {
    #[link_name = "\u{1}?getDisplayedColor@CCLayerRGBA@cocos2d@@UEAAAEBU_ccColor3B@2@XZ"]
    pub fn cocos2d_CCLayerRGBA_getDisplayedColor(
        this: *mut ::std::os::raw::c_void,
    ) -> *const cocos2d_ccColor3B;
}
extern "C" {
    #[link_name = "\u{1}?setColor@CCLayerRGBA@cocos2d@@UEAAXAEBU_ccColor3B@2@@Z"]
    pub fn cocos2d_CCLayerRGBA_setColor(
        this: *mut ::std::os::raw::c_void,
        color: *const cocos2d_ccColor3B,
    );
}
extern "C" {
    #[link_name = "\u{1}?updateDisplayedColor@CCLayerRGBA@cocos2d@@UEAAXAEBU_ccColor3B@2@@Z"]
    pub fn cocos2d_CCLayerRGBA_updateDisplayedColor(
        this: *mut ::std::os::raw::c_void,
        parentColor: *const cocos2d_ccColor3B,
    );
}
extern "C" {
    #[link_name = "\u{1}?isCascadeColorEnabled@CCLayerRGBA@cocos2d@@UEAA_NXZ"]
    pub fn cocos2d_CCLayerRGBA_isCascadeColorEnabled(this: *mut ::std::os::raw::c_void) -> bool;
}
extern "C" {
    #[link_name = "\u{1}?setCascadeColorEnabled@CCLayerRGBA@cocos2d@@UEAAX_N@Z"]
    pub fn cocos2d_CCLayerRGBA_setCascadeColorEnabled(
        this: *mut ::std::os::raw::c_void,
        cascadeColorEnabled: bool,
    );
}
#[doc = " @brief CCLayerColor is a subclass of CCLayer that implements the CCRGBAProtocol protocol."]
#[doc = ""]
#[doc = "All features from CCLayer are valid, plus the following new features:"]
#[doc = "- opacity"]
#[doc = "- RGB colors"]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCLayerColor {
    pub _base: cocos2d_CCLayerRGBA,
    pub _base_1: cocos2d_CCBlendProtocol,
    pub m_pSquareVertices: [cocos2d_ccVertex2F; 4usize],
    pub m_pSquareColors: [cocos2d_ccColor4F; 4usize],
    pub m_tBlendFunc: cocos2d_ccBlendFunc,
}
#[test]
fn bindgen_test_layout_cocos2d_CCLayerColor() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCLayerColor>(),
        512usize,
        concat!("Size of: ", stringify!(cocos2d_CCLayerColor))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCLayerColor>(),
        8usize,
        concat!("Alignment of ", stringify!(cocos2d_CCLayerColor))
    );
}
extern "C" {
    #[link_name = "\u{1}?create@CCLayerColor@cocos2d@@SAPEAV12@XZ"]
    pub fn cocos2d_CCLayerColor_create() -> *mut cocos2d_CCLayerColor;
}
extern "C" {
    #[doc = " creates a CCLayer with color, width and height in Points"]
    #[link_name = "\u{1}?create@CCLayerColor@cocos2d@@SAPEAV12@AEBU_ccColor4B@2@MM@Z"]
    pub fn cocos2d_CCLayerColor_create1(
        color: *const cocos2d_ccColor4B,
        width: GLfloat,
        height: GLfloat,
    ) -> *mut cocos2d_CCLayerColor;
}
extern "C" {
    #[doc = " creates a CCLayer with color. Width and height are the window size."]
    #[link_name = "\u{1}?create@CCLayerColor@cocos2d@@SAPEAV12@AEBU_ccColor4B@2@@Z"]
    pub fn cocos2d_CCLayerColor_create2(
        color: *const cocos2d_ccColor4B,
    ) -> *mut cocos2d_CCLayerColor;
}
extern "C" {
    #[doc = " change width in Points"]
    #[link_name = "\u{1}?changeWidth@CCLayerColor@cocos2d@@QEAAXM@Z"]
    pub fn cocos2d_CCLayerColor_changeWidth(this: *mut cocos2d_CCLayerColor, w: GLfloat);
}
extern "C" {
    #[doc = " change height in Points"]
    #[link_name = "\u{1}?changeHeight@CCLayerColor@cocos2d@@QEAAXM@Z"]
    pub fn cocos2d_CCLayerColor_changeHeight(this: *mut cocos2d_CCLayerColor, h: GLfloat);
}
extern "C" {
    #[doc = " change width and height in Points"]
    #[doc = "@since v0.8"]
    #[link_name = "\u{1}?changeWidthAndHeight@CCLayerColor@cocos2d@@QEAAXMM@Z"]
    pub fn cocos2d_CCLayerColor_changeWidthAndHeight(
        this: *mut cocos2d_CCLayerColor,
        w: GLfloat,
        h: GLfloat,
    );
}
extern "C" {
    #[doc = "  @js ctor"]
    #[link_name = "\u{1}??0CCLayerColor@cocos2d@@QEAA@XZ"]
    pub fn cocos2d_CCLayerColor_CCLayerColor(this: *mut cocos2d_CCLayerColor);
}
impl cocos2d_CCLayerColor {
    #[inline]
    pub unsafe fn create() -> *mut cocos2d_CCLayerColor {
        cocos2d_CCLayerColor_create()
    }
    #[inline]
    pub unsafe fn create1(
        color: *const cocos2d_ccColor4B,
        width: GLfloat,
        height: GLfloat,
    ) -> *mut cocos2d_CCLayerColor {
        cocos2d_CCLayerColor_create1(color, width, height)
    }
    #[inline]
    pub unsafe fn create2(color: *const cocos2d_ccColor4B) -> *mut cocos2d_CCLayerColor {
        cocos2d_CCLayerColor_create2(color)
    }
    #[inline]
    pub unsafe fn changeWidth(&mut self, w: GLfloat) {
        cocos2d_CCLayerColor_changeWidth(self, w)
    }
    #[inline]
    pub unsafe fn changeHeight(&mut self, h: GLfloat) {
        cocos2d_CCLayerColor_changeHeight(self, h)
    }
    #[inline]
    pub unsafe fn changeWidthAndHeight(&mut self, w: GLfloat, h: GLfloat) {
        cocos2d_CCLayerColor_changeWidthAndHeight(self, w, h)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cocos2d_CCLayerColor_CCLayerColor(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
}
extern "C" {
    #[doc = "  @js NA"]
    #[doc = "  @lua NA"]
    #[link_name = "\u{1}??_DCCLayerColor@cocos2d@@QEAAXXZ"]
    pub fn cocos2d_CCLayerColor_CCLayerColor_destructor(this: *mut cocos2d_CCLayerColor);
}
extern "C" {
    #[link_name = "\u{1}?draw@CCLayerColor@cocos2d@@UEAAXXZ"]
    pub fn cocos2d_CCLayerColor_draw(this: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[link_name = "\u{1}?setContentSize@CCLayerColor@cocos2d@@UEAAXAEBVCCSize@2@@Z"]
    pub fn cocos2d_CCLayerColor_setContentSize(
        this: *mut ::std::os::raw::c_void,
        var: *const cocos2d_CCSize,
    );
}
extern "C" {
    #[link_name = "\u{1}?init@CCLayerColor@cocos2d@@UEAA_NXZ"]
    pub fn cocos2d_CCLayerColor_init(this: *mut ::std::os::raw::c_void) -> bool;
}
extern "C" {
    #[doc = " initializes a CCLayer with color, width and height in Points"]
    #[link_name = "\u{1}?initWithColor@CCLayerColor@cocos2d@@UEAA_NAEBU_ccColor4B@2@MM@Z"]
    pub fn cocos2d_CCLayerColor_initWithColor(
        this: *mut ::std::os::raw::c_void,
        color: *const cocos2d_ccColor4B,
        width: GLfloat,
        height: GLfloat,
    ) -> bool;
}
extern "C" {
    #[doc = " initializes a CCLayer with color. Width and height are the window size."]
    #[link_name = "\u{1}?initWithColor@CCLayerColor@cocos2d@@UEAA_NAEBU_ccColor4B@2@@Z"]
    pub fn cocos2d_CCLayerColor_initWithColor1(
        this: *mut ::std::os::raw::c_void,
        color: *const cocos2d_ccColor4B,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}?getBlendFunc@CCLayerColor@cocos2d@@UEAA?AU_ccBlendFunc@2@XZ"]
    pub fn cocos2d_CCLayerColor_getBlendFunc(
        this: *mut ::std::os::raw::c_void,
    ) -> cocos2d_ccBlendFunc;
}
extern "C" {
    #[link_name = "\u{1}?setBlendFunc@CCLayerColor@cocos2d@@UEAAXU_ccBlendFunc@2@@Z"]
    pub fn cocos2d_CCLayerColor_setBlendFunc(
        this: *mut ::std::os::raw::c_void,
        var: cocos2d_ccBlendFunc,
    );
}
extern "C" {
    #[doc = " BlendFunction. Conforms to CCBlendProtocol protocol"]
    #[link_name = "\u{1}?setColor@CCLayerColor@cocos2d@@UEAAXAEBU_ccColor3B@2@@Z"]
    pub fn cocos2d_CCLayerColor_setColor(
        this: *mut ::std::os::raw::c_void,
        color: *const cocos2d_ccColor3B,
    );
}
extern "C" {
    #[link_name = "\u{1}?setOpacity@CCLayerColor@cocos2d@@UEAAXE@Z"]
    pub fn cocos2d_CCLayerColor_setOpacity(this: *mut ::std::os::raw::c_void, opacity: GLubyte);
}
extern "C" {
    #[link_name = "\u{1}?updateColor@CCLayerColor@cocos2d@@MEAAXXZ"]
    pub fn cocos2d_CCLayerColor_updateColor(this: *mut ::std::os::raw::c_void);
}
#[doc = " @brief CCLayerGradient is a subclass of CCLayerColor that draws gradients across the background."]
#[doc = ""]
#[doc = "All features from CCLayerColor are valid, plus the following new features:"]
#[doc = "- direction"]
#[doc = "- final color"]
#[doc = "- interpolation mode"]
#[doc = ""]
#[doc = "Color is interpolated between the startColor and endColor along the given"]
#[doc = "vector (starting at the origin, ending at the terminus).  If no vector is"]
#[doc = "supplied, it defaults to (0, -1) -- a fade from top to bottom."]
#[doc = ""]
#[doc = "If 'compressedInterpolation' is disabled, you will not see either the start or end color for"]
#[doc = "non-cardinal vectors; a smooth gradient implying both end points will be still"]
#[doc = "be drawn, however."]
#[doc = ""]
#[doc = "If ' compressedInterpolation' is enabled (default mode) you will see both the start and end colors of the gradient."]
#[doc = ""]
#[doc = "@since v0.99.5"]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCLayerGradient {
    pub _base: cocos2d_CCLayerColor,
    pub m_startColor: cocos2d_ccColor3B,
    pub m_endColor: cocos2d_ccColor3B,
    pub m_cStartOpacity: GLubyte,
    pub m_cEndOpacity: GLubyte,
    pub m_AlongVector: cocos2d_CCPoint,
    #[doc = " Whether or not the interpolation will be compressed in order to display all the colors of the gradient both in canonical and non canonical vectors"]
    #[doc = "Default: YES"]
    pub m_bCompressedInterpolation: bool,
}
#[test]
fn bindgen_test_layout_cocos2d_CCLayerGradient() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCLayerGradient>(),
        536usize,
        concat!("Size of: ", stringify!(cocos2d_CCLayerGradient))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCLayerGradient>(),
        8usize,
        concat!("Alignment of ", stringify!(cocos2d_CCLayerGradient))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cocos2d_CCLayerGradient>())).m_startColor as *const _ as usize
        },
        512usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCLayerGradient),
            "::",
            stringify!(m_startColor)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cocos2d_CCLayerGradient>())).m_endColor as *const _ as usize
        },
        515usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCLayerGradient),
            "::",
            stringify!(m_endColor)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cocos2d_CCLayerGradient>())).m_cStartOpacity as *const _ as usize
        },
        518usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCLayerGradient),
            "::",
            stringify!(m_cStartOpacity)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cocos2d_CCLayerGradient>())).m_cEndOpacity as *const _ as usize
        },
        519usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCLayerGradient),
            "::",
            stringify!(m_cEndOpacity)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cocos2d_CCLayerGradient>())).m_AlongVector as *const _ as usize
        },
        520usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCLayerGradient),
            "::",
            stringify!(m_AlongVector)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cocos2d_CCLayerGradient>())).m_bCompressedInterpolation
                as *const _ as usize
        },
        528usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCLayerGradient),
            "::",
            stringify!(m_bCompressedInterpolation)
        )
    );
}
extern "C" {
    #[doc = " Creates a full-screen CCLayer with a gradient between start and end."]
    #[link_name = "\u{1}?create@CCLayerGradient@cocos2d@@SAPEAV12@AEBU_ccColor4B@2@0@Z"]
    pub fn cocos2d_CCLayerGradient_create(
        start: *const cocos2d_ccColor4B,
        end: *const cocos2d_ccColor4B,
    ) -> *mut cocos2d_CCLayerGradient;
}
extern "C" {
    #[doc = " Creates a full-screen CCLayer with a gradient between start and end in the direction of v."]
    #[link_name = "\u{1}?create@CCLayerGradient@cocos2d@@SAPEAV12@AEBU_ccColor4B@2@0AEBVCCPoint@2@@Z"]
    pub fn cocos2d_CCLayerGradient_create1(
        start: *const cocos2d_ccColor4B,
        end: *const cocos2d_ccColor4B,
        v: *const cocos2d_CCPoint,
    ) -> *mut cocos2d_CCLayerGradient;
}
extern "C" {
    #[link_name = "\u{1}?create@CCLayerGradient@cocos2d@@SAPEAV12@XZ"]
    pub fn cocos2d_CCLayerGradient_create2() -> *mut cocos2d_CCLayerGradient;
}
impl cocos2d_CCLayerGradient {
    #[inline]
    pub unsafe fn create(
        start: *const cocos2d_ccColor4B,
        end: *const cocos2d_ccColor4B,
    ) -> *mut cocos2d_CCLayerGradient {
        cocos2d_CCLayerGradient_create(start, end)
    }
    #[inline]
    pub unsafe fn create1(
        start: *const cocos2d_ccColor4B,
        end: *const cocos2d_ccColor4B,
        v: *const cocos2d_CCPoint,
    ) -> *mut cocos2d_CCLayerGradient {
        cocos2d_CCLayerGradient_create1(start, end, v)
    }
    #[inline]
    pub unsafe fn create2() -> *mut cocos2d_CCLayerGradient {
        cocos2d_CCLayerGradient_create2()
    }
}
extern "C" {
    #[link_name = "\u{1}?init@CCLayerGradient@cocos2d@@UEAA_NXZ"]
    pub fn cocos2d_CCLayerGradient_init(this: *mut ::std::os::raw::c_void) -> bool;
}
extern "C" {
    #[doc = " Initializes the CCLayer with a gradient between start and end."]
    #[doc = "  @js init"]
    #[link_name = "\u{1}?initWithColor@CCLayerGradient@cocos2d@@UEAA_NAEBU_ccColor4B@2@0@Z"]
    pub fn cocos2d_CCLayerGradient_initWithColor(
        this: *mut ::std::os::raw::c_void,
        start: *const cocos2d_ccColor4B,
        end: *const cocos2d_ccColor4B,
    ) -> bool;
}
extern "C" {
    #[doc = " Initializes the CCLayer with a gradient between start and end in the direction of v."]
    #[doc = "  @js init"]
    #[link_name = "\u{1}?initWithColor@CCLayerGradient@cocos2d@@UEAA_NAEBU_ccColor4B@2@0AEBVCCPoint@2@@Z"]
    pub fn cocos2d_CCLayerGradient_initWithColor1(
        this: *mut ::std::os::raw::c_void,
        start: *const cocos2d_ccColor4B,
        end: *const cocos2d_ccColor4B,
        v: *const cocos2d_CCPoint,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}?getStartColor@CCLayerGradient@cocos2d@@UEAAAEBU_ccColor3B@2@XZ"]
    pub fn cocos2d_CCLayerGradient_getStartColor(
        this: *mut ::std::os::raw::c_void,
    ) -> *const cocos2d_ccColor3B;
}
extern "C" {
    #[link_name = "\u{1}?setStartColor@CCLayerGradient@cocos2d@@UEAAXAEBU_ccColor3B@2@@Z"]
    pub fn cocos2d_CCLayerGradient_setStartColor(
        this: *mut ::std::os::raw::c_void,
        var: *const cocos2d_ccColor3B,
    );
}
extern "C" {
    #[link_name = "\u{1}?getEndColor@CCLayerGradient@cocos2d@@UEAAAEBU_ccColor3B@2@XZ"]
    pub fn cocos2d_CCLayerGradient_getEndColor(
        this: *mut ::std::os::raw::c_void,
    ) -> *const cocos2d_ccColor3B;
}
extern "C" {
    #[link_name = "\u{1}?setEndColor@CCLayerGradient@cocos2d@@UEAAXAEBU_ccColor3B@2@@Z"]
    pub fn cocos2d_CCLayerGradient_setEndColor(
        this: *mut ::std::os::raw::c_void,
        var: *const cocos2d_ccColor3B,
    );
}
extern "C" {
    #[link_name = "\u{1}?getStartOpacity@CCLayerGradient@cocos2d@@UEAAEXZ"]
    pub fn cocos2d_CCLayerGradient_getStartOpacity(this: *mut ::std::os::raw::c_void) -> GLubyte;
}
extern "C" {
    #[link_name = "\u{1}?setStartOpacity@CCLayerGradient@cocos2d@@UEAAXE@Z"]
    pub fn cocos2d_CCLayerGradient_setStartOpacity(this: *mut ::std::os::raw::c_void, var: GLubyte);
}
extern "C" {
    #[link_name = "\u{1}?getEndOpacity@CCLayerGradient@cocos2d@@UEAAEXZ"]
    pub fn cocos2d_CCLayerGradient_getEndOpacity(this: *mut ::std::os::raw::c_void) -> GLubyte;
}
extern "C" {
    #[link_name = "\u{1}?setEndOpacity@CCLayerGradient@cocos2d@@UEAAXE@Z"]
    pub fn cocos2d_CCLayerGradient_setEndOpacity(this: *mut ::std::os::raw::c_void, var: GLubyte);
}
extern "C" {
    #[link_name = "\u{1}?getVector@CCLayerGradient@cocos2d@@UEAAAEBVCCPoint@2@XZ"]
    pub fn cocos2d_CCLayerGradient_getVector(
        this: *mut ::std::os::raw::c_void,
    ) -> *const cocos2d_CCPoint;
}
extern "C" {
    #[link_name = "\u{1}?setVector@CCLayerGradient@cocos2d@@UEAAXAEBVCCPoint@2@@Z"]
    pub fn cocos2d_CCLayerGradient_setVector(
        this: *mut ::std::os::raw::c_void,
        var: *const cocos2d_CCPoint,
    );
}
extern "C" {
    #[link_name = "\u{1}?setCompressedInterpolation@CCLayerGradient@cocos2d@@UEAAX_N@Z"]
    pub fn cocos2d_CCLayerGradient_setCompressedInterpolation(
        this: *mut ::std::os::raw::c_void,
        bCompressedInterpolation: bool,
    );
}
extern "C" {
    #[link_name = "\u{1}?isCompressedInterpolation@CCLayerGradient@cocos2d@@UEAA_NXZ"]
    pub fn cocos2d_CCLayerGradient_isCompressedInterpolation(
        this: *mut ::std::os::raw::c_void,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}?updateColor@CCLayerGradient@cocos2d@@MEAAXXZ"]
    pub fn cocos2d_CCLayerGradient_updateColor(this: *mut ::std::os::raw::c_void);
}
#[doc = " @brief CCMultipleLayer is a CCLayer with the ability to multiplex it's children."]
#[doc = "Features:"]
#[doc = "- It supports one or more children"]
#[doc = "- Only one children will be active a time"]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCLayerMultiplex {
    pub _base: cocos2d_CCLayer,
    pub m_nEnabledLayer: ::std::os::raw::c_uint,
    pub m_pLayers: *mut cocos2d_CCArray,
}
#[test]
fn bindgen_test_layout_cocos2d_CCLayerMultiplex() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCLayerMultiplex>(),
        392usize,
        concat!("Size of: ", stringify!(cocos2d_CCLayerMultiplex))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCLayerMultiplex>(),
        8usize,
        concat!("Alignment of ", stringify!(cocos2d_CCLayerMultiplex))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cocos2d_CCLayerMultiplex>())).m_nEnabledLayer as *const _
                as usize
        },
        376usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCLayerMultiplex),
            "::",
            stringify!(m_nEnabledLayer)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cocos2d_CCLayerMultiplex>())).m_pLayers as *const _ as usize
        },
        384usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCLayerMultiplex),
            "::",
            stringify!(m_pLayers)
        )
    );
}
extern "C" {
    #[doc = " @js NA"]
    #[link_name = "\u{1}?create@CCLayerMultiplex@cocos2d@@SAPEAV12@XZ"]
    pub fn cocos2d_CCLayerMultiplex_create() -> *mut cocos2d_CCLayerMultiplex;
}
extern "C" {
    #[doc = " creates a CCMultiplexLayer with an array of layers."]
    #[doc = " @since v2.1"]
    #[doc = " @js NA"]
    #[link_name = "\u{1}?createWithArray@CCLayerMultiplex@cocos2d@@SAPEAV12@PEAVCCArray@2@@Z"]
    pub fn cocos2d_CCLayerMultiplex_createWithArray(
        arrayOfLayers: *mut cocos2d_CCArray,
    ) -> *mut cocos2d_CCLayerMultiplex;
}
extern "C" {
    #[doc = " creates a CCLayerMultiplex with one or more layers using a variable argument list."]
    #[doc = " @lua NA"]
    #[link_name = "\u{1}?create@CCLayerMultiplex@cocos2d@@SAPEAV12@PEAVCCLayer@2@ZZ"]
    pub fn cocos2d_CCLayerMultiplex_create1(
        layer: *mut cocos2d_CCLayer,
        ...
    ) -> *mut cocos2d_CCLayerMultiplex;
}
extern "C" {
    #[doc = " lua script can not init with undetermined number of variables"]
    #[doc = " so add these functions to be used with lua."]
    #[link_name = "\u{1}?createWithLayer@CCLayerMultiplex@cocos2d@@SAPEAV12@PEAVCCLayer@2@@Z"]
    pub fn cocos2d_CCLayerMultiplex_createWithLayer(
        layer: *mut cocos2d_CCLayer,
    ) -> *mut cocos2d_CCLayerMultiplex;
}
extern "C" {
    #[link_name = "\u{1}?addLayer@CCLayerMultiplex@cocos2d@@QEAAXPEAVCCLayer@2@@Z"]
    pub fn cocos2d_CCLayerMultiplex_addLayer(
        this: *mut cocos2d_CCLayerMultiplex,
        layer: *mut cocos2d_CCLayer,
    );
}
extern "C" {
    #[doc = " initializes a MultiplexLayer with one or more layers using a variable argument list."]
    #[doc = "  @js NA"]
    #[doc = "  @lua NA"]
    #[link_name = "\u{1}?initWithLayers@CCLayerMultiplex@cocos2d@@QEAA_NPEAVCCLayer@2@PEAD@Z"]
    pub fn cocos2d_CCLayerMultiplex_initWithLayers(
        this: *mut cocos2d_CCLayerMultiplex,
        layer: *mut cocos2d_CCLayer,
        params: va_list,
    ) -> bool;
}
extern "C" {
    #[doc = " initializes a CCMultiplexLayer with an array of layers"]
    #[doc = "  @since v2.1"]
    #[doc = "  @lua NA"]
    #[link_name = "\u{1}?initWithArray@CCLayerMultiplex@cocos2d@@QEAA_NPEAVCCArray@2@@Z"]
    pub fn cocos2d_CCLayerMultiplex_initWithArray(
        this: *mut cocos2d_CCLayerMultiplex,
        arrayOfLayers: *mut cocos2d_CCArray,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}?switchTo@CCLayerMultiplex@cocos2d@@QEAAXI@Z"]
    pub fn cocos2d_CCLayerMultiplex_switchTo(
        this: *mut cocos2d_CCLayerMultiplex,
        n: ::std::os::raw::c_uint,
    );
}
extern "C" {
    #[doc = " release the current layer and switches to another layer indexed by n."]
    #[doc = "The current (old) layer will be removed from it's parent with 'cleanup:YES'."]
    #[link_name = "\u{1}?switchToAndReleaseMe@CCLayerMultiplex@cocos2d@@QEAAXI@Z"]
    pub fn cocos2d_CCLayerMultiplex_switchToAndReleaseMe(
        this: *mut cocos2d_CCLayerMultiplex,
        n: ::std::os::raw::c_uint,
    );
}
extern "C" {
    #[doc = " @js ctor"]
    #[doc = " @lua NA"]
    #[link_name = "\u{1}??0CCLayerMultiplex@cocos2d@@QEAA@XZ"]
    pub fn cocos2d_CCLayerMultiplex_CCLayerMultiplex(this: *mut cocos2d_CCLayerMultiplex);
}
impl cocos2d_CCLayerMultiplex {
    #[inline]
    pub unsafe fn create() -> *mut cocos2d_CCLayerMultiplex {
        cocos2d_CCLayerMultiplex_create()
    }
    #[inline]
    pub unsafe fn createWithArray(
        arrayOfLayers: *mut cocos2d_CCArray,
    ) -> *mut cocos2d_CCLayerMultiplex {
        cocos2d_CCLayerMultiplex_createWithArray(arrayOfLayers)
    }
    #[inline]
    pub unsafe fn createWithLayer(layer: *mut cocos2d_CCLayer) -> *mut cocos2d_CCLayerMultiplex {
        cocos2d_CCLayerMultiplex_createWithLayer(layer)
    }
    #[inline]
    pub unsafe fn addLayer(&mut self, layer: *mut cocos2d_CCLayer) {
        cocos2d_CCLayerMultiplex_addLayer(self, layer)
    }
    #[inline]
    pub unsafe fn initWithLayers(&mut self, layer: *mut cocos2d_CCLayer, params: va_list) -> bool {
        cocos2d_CCLayerMultiplex_initWithLayers(self, layer, params)
    }
    #[inline]
    pub unsafe fn initWithArray(&mut self, arrayOfLayers: *mut cocos2d_CCArray) -> bool {
        cocos2d_CCLayerMultiplex_initWithArray(self, arrayOfLayers)
    }
    #[inline]
    pub unsafe fn switchTo(&mut self, n: ::std::os::raw::c_uint) {
        cocos2d_CCLayerMultiplex_switchTo(self, n)
    }
    #[inline]
    pub unsafe fn switchToAndReleaseMe(&mut self, n: ::std::os::raw::c_uint) {
        cocos2d_CCLayerMultiplex_switchToAndReleaseMe(self, n)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cocos2d_CCLayerMultiplex_CCLayerMultiplex(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
}
extern "C" {
    #[doc = " @js NA"]
    #[doc = " @lua NA"]
    #[link_name = "\u{1}??_DCCLayerMultiplex@cocos2d@@QEAAXXZ"]
    pub fn cocos2d_CCLayerMultiplex_CCLayerMultiplex_destructor(
        this: *mut cocos2d_CCLayerMultiplex,
    );
}
#[doc = " @brief CCScene is a subclass of CCNode that is used only as an abstract concept."]
#[doc = ""]
#[doc = "CCScene an CCNode are almost identical with the difference that CCScene has it's"]
#[doc = "anchor point (by default) at the center of the screen."]
#[doc = ""]
#[doc = "For the moment CCScene has no other logic than that, but in future releases it might have"]
#[doc = "additional logic."]
#[doc = ""]
#[doc = "It is a good practice to use and CCScene as the parent of all your nodes."]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCScene {
    pub _base: cocos2d_CCNode,
    pub m_pIDK: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_cocos2d_CCScene() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCScene>(),
        304usize,
        concat!("Size of: ", stringify!(cocos2d_CCScene))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCScene>(),
        8usize,
        concat!("Alignment of ", stringify!(cocos2d_CCScene))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cocos2d_CCScene>())).m_pIDK as *const _ as usize },
        296usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCScene),
            "::",
            stringify!(m_pIDK)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}?create@CCScene@cocos2d@@SAPEAV12@XZ"]
    pub fn cocos2d_CCScene_create() -> *mut cocos2d_CCScene;
}
extern "C" {
    #[link_name = "\u{1}?getHighestChildZ@CCScene@cocos2d@@QEAAHXZ"]
    pub fn cocos2d_CCScene_getHighestChildZ(this: *mut cocos2d_CCScene) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  @js ctor"]
    #[link_name = "\u{1}??0CCScene@cocos2d@@QEAA@XZ"]
    pub fn cocos2d_CCScene_CCScene(this: *mut cocos2d_CCScene);
}
extern "C" {
    #[link_name = "\u{1}??0CCScene@cocos2d@@QEAA@AEBV01@@Z"]
    pub fn cocos2d_CCScene_CCScene1(this: *mut cocos2d_CCScene, arg1: *const cocos2d_CCScene);
}
impl cocos2d_CCScene {
    #[inline]
    pub unsafe fn create() -> *mut cocos2d_CCScene {
        cocos2d_CCScene_create()
    }
    #[inline]
    pub unsafe fn getHighestChildZ(&mut self) -> ::std::os::raw::c_int {
        cocos2d_CCScene_getHighestChildZ(self)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cocos2d_CCScene_CCScene(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new1(arg1: *const cocos2d_CCScene) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cocos2d_CCScene_CCScene1(__bindgen_tmp.as_mut_ptr(), arg1);
        __bindgen_tmp.assume_init()
    }
}
extern "C" {
    #[doc = "  @js NA"]
    #[doc = "  @lua NA"]
    #[link_name = "\u{1}??_DCCScene@cocos2d@@QEAAXXZ"]
    pub fn cocos2d_CCScene_CCScene_destructor(this: *mut cocos2d_CCScene);
}
extern "C" {
    #[link_name = "\u{1}?init@CCScene@cocos2d@@UEAA_NXZ"]
    pub fn cocos2d_CCScene_init(this: *mut ::std::os::raw::c_void) -> bool;
}
#[repr(C)]
pub struct cocos2d_CCTransitionEaseScene__bindgen_vtable(::std::os::raw::c_void);
#[doc = " @brief CCTransitionEaseScene can ease the actions of the scene protocol."]
#[doc = "@since v0.8.2"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cocos2d_CCTransitionEaseScene {
    pub vtable_: *const cocos2d_CCTransitionEaseScene__bindgen_vtable,
}
#[test]
fn bindgen_test_layout_cocos2d_CCTransitionEaseScene() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCTransitionEaseScene>(),
        8usize,
        concat!("Size of: ", stringify!(cocos2d_CCTransitionEaseScene))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCTransitionEaseScene>(),
        8usize,
        concat!("Alignment of ", stringify!(cocos2d_CCTransitionEaseScene))
    );
}
#[doc = " An horizontal orientation where the Left is nearer"]
pub const cocos2d_tOrientation_kCCTransitionOrientationLeftOver: cocos2d_tOrientation = 0;
#[doc = " An horizontal orientation where the Right is nearer"]
pub const cocos2d_tOrientation_kCCTransitionOrientationRightOver: cocos2d_tOrientation = 1;
#[doc = " A vertical orientation where the Up is nearer"]
pub const cocos2d_tOrientation_kCCTransitionOrientationUpOver: cocos2d_tOrientation = 0;
#[doc = " A vertical orientation where the Bottom is nearer"]
pub const cocos2d_tOrientation_kCCTransitionOrientationDownOver: cocos2d_tOrientation = 1;
#[doc = " Orientation Type used by some transitions"]
pub type cocos2d_tOrientation = ::std::os::raw::c_int;
#[doc = " @brief Base class for CCTransition scenes"]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCTransitionScene {
    pub _base: cocos2d_CCScene,
    pub m_pInScene: *mut cocos2d_CCScene,
    pub m_pOutScene: *mut cocos2d_CCScene,
    pub m_fDuration: f32,
    pub m_bIsInSceneOnTop: bool,
    pub m_bIsSendCleanupToScene: bool,
}
#[test]
fn bindgen_test_layout_cocos2d_CCTransitionScene() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCTransitionScene>(),
        328usize,
        concat!("Size of: ", stringify!(cocos2d_CCTransitionScene))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCTransitionScene>(),
        8usize,
        concat!("Alignment of ", stringify!(cocos2d_CCTransitionScene))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cocos2d_CCTransitionScene>())).m_pInScene as *const _ as usize
        },
        304usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCTransitionScene),
            "::",
            stringify!(m_pInScene)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cocos2d_CCTransitionScene>())).m_pOutScene as *const _ as usize
        },
        312usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCTransitionScene),
            "::",
            stringify!(m_pOutScene)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cocos2d_CCTransitionScene>())).m_fDuration as *const _ as usize
        },
        320usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCTransitionScene),
            "::",
            stringify!(m_fDuration)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cocos2d_CCTransitionScene>())).m_bIsInSceneOnTop as *const _
                as usize
        },
        324usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCTransitionScene),
            "::",
            stringify!(m_bIsInSceneOnTop)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cocos2d_CCTransitionScene>())).m_bIsSendCleanupToScene
                as *const _ as usize
        },
        325usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCTransitionScene),
            "::",
            stringify!(m_bIsSendCleanupToScene)
        )
    );
}
extern "C" {
    #[doc = " creates a base transition with duration and incoming scene"]
    #[link_name = "\u{1}?create@CCTransitionScene@cocos2d@@SAPEAV12@MPEAVCCScene@2@@Z"]
    pub fn cocos2d_CCTransitionScene_create(
        t: f32,
        scene: *mut cocos2d_CCScene,
    ) -> *mut cocos2d_CCTransitionScene;
}
extern "C" {
    #[doc = " called after the transition finishes"]
    #[link_name = "\u{1}?finish@CCTransitionScene@cocos2d@@QEAAXXZ"]
    pub fn cocos2d_CCTransitionScene_finish(this: *mut cocos2d_CCTransitionScene);
}
extern "C" {
    #[doc = " used by some transitions to hide the outer scene"]
    #[link_name = "\u{1}?hideOutShowIn@CCTransitionScene@cocos2d@@QEAAXXZ"]
    pub fn cocos2d_CCTransitionScene_hideOutShowIn(this: *mut cocos2d_CCTransitionScene);
}
extern "C" {
    #[doc = "  @js ctor"]
    #[link_name = "\u{1}??0CCTransitionScene@cocos2d@@QEAA@XZ"]
    pub fn cocos2d_CCTransitionScene_CCTransitionScene(this: *mut cocos2d_CCTransitionScene);
}
impl cocos2d_CCTransitionScene {
    #[inline]
    pub unsafe fn create(t: f32, scene: *mut cocos2d_CCScene) -> *mut cocos2d_CCTransitionScene {
        cocos2d_CCTransitionScene_create(t, scene)
    }
    #[inline]
    pub unsafe fn finish(&mut self) {
        cocos2d_CCTransitionScene_finish(self)
    }
    #[inline]
    pub unsafe fn hideOutShowIn(&mut self) {
        cocos2d_CCTransitionScene_hideOutShowIn(self)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cocos2d_CCTransitionScene_CCTransitionScene(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
}
extern "C" {
    #[doc = "  @js NA"]
    #[doc = "  @lua NA"]
    #[link_name = "\u{1}??_DCCTransitionScene@cocos2d@@QEAAXXZ"]
    pub fn cocos2d_CCTransitionScene_CCTransitionScene_destructor(
        this: *mut cocos2d_CCTransitionScene,
    );
}
extern "C" {
    #[link_name = "\u{1}?draw@CCTransitionScene@cocos2d@@UEAAXXZ"]
    pub fn cocos2d_CCTransitionScene_draw(this: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[doc = "  @js NA"]
    #[doc = "  @lua NA"]
    #[link_name = "\u{1}?onEnter@CCTransitionScene@cocos2d@@UEAAXXZ"]
    pub fn cocos2d_CCTransitionScene_onEnter(this: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[doc = "  @js NA"]
    #[doc = "  @lua NA"]
    #[link_name = "\u{1}?onExit@CCTransitionScene@cocos2d@@UEAAXXZ"]
    pub fn cocos2d_CCTransitionScene_onExit(this: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[link_name = "\u{1}?cleanup@CCTransitionScene@cocos2d@@UEAAXXZ"]
    pub fn cocos2d_CCTransitionScene_cleanup(this: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[doc = " initializes a transition with duration and incoming scene"]
    #[link_name = "\u{1}?initWithDuration@CCTransitionScene@cocos2d@@UEAA_NMPEAVCCScene@2@@Z"]
    pub fn cocos2d_CCTransitionScene_initWithDuration(
        this: *mut ::std::os::raw::c_void,
        t: f32,
        scene: *mut cocos2d_CCScene,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}?sceneOrder@CCTransitionScene@cocos2d@@MEAAXXZ"]
    pub fn cocos2d_CCTransitionScene_sceneOrder(this: *mut ::std::os::raw::c_void);
}
#[doc = " @brief A CCTransition that supports orientation like."]
#[doc = " Possible orientation: LeftOver, RightOver, UpOver, DownOver"]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCTransitionSceneOriented {
    pub _base: cocos2d_CCTransitionScene,
    pub m_eOrientation: cocos2d_tOrientation,
}
#[test]
fn bindgen_test_layout_cocos2d_CCTransitionSceneOriented() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCTransitionSceneOriented>(),
        336usize,
        concat!("Size of: ", stringify!(cocos2d_CCTransitionSceneOriented))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCTransitionSceneOriented>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(cocos2d_CCTransitionSceneOriented)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cocos2d_CCTransitionSceneOriented>())).m_eOrientation as *const _
                as usize
        },
        328usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCTransitionSceneOriented),
            "::",
            stringify!(m_eOrientation)
        )
    );
}
extern "C" {
    #[doc = " creates a base transition with duration and incoming scene"]
    #[link_name = "\u{1}?create@CCTransitionSceneOriented@cocos2d@@SAPEAV12@MPEAVCCScene@2@W4tOrientation@2@@Z"]
    pub fn cocos2d_CCTransitionSceneOriented_create(
        t: f32,
        scene: *mut cocos2d_CCScene,
        orientation: cocos2d_tOrientation,
    ) -> *mut cocos2d_CCTransitionSceneOriented;
}
extern "C" {
    #[doc = "  @js ctor"]
    #[link_name = "\u{1}??0CCTransitionSceneOriented@cocos2d@@QEAA@XZ"]
    pub fn cocos2d_CCTransitionSceneOriented_CCTransitionSceneOriented(
        this: *mut cocos2d_CCTransitionSceneOriented,
    );
}
impl cocos2d_CCTransitionSceneOriented {
    #[inline]
    pub unsafe fn create(
        t: f32,
        scene: *mut cocos2d_CCScene,
        orientation: cocos2d_tOrientation,
    ) -> *mut cocos2d_CCTransitionSceneOriented {
        cocos2d_CCTransitionSceneOriented_create(t, scene, orientation)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cocos2d_CCTransitionSceneOriented_CCTransitionSceneOriented(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
}
extern "C" {
    #[doc = "  @js NA"]
    #[doc = "  @lua NA"]
    #[link_name = "\u{1}??_DCCTransitionSceneOriented@cocos2d@@QEAAXXZ"]
    pub fn cocos2d_CCTransitionSceneOriented_CCTransitionSceneOriented_destructor(
        this: *mut cocos2d_CCTransitionSceneOriented,
    );
}
extern "C" {
    #[doc = " initializes a transition with duration and incoming scene"]
    #[link_name = "\u{1}?initWithDuration@CCTransitionSceneOriented@cocos2d@@UEAA_NMPEAVCCScene@2@W4tOrientation@2@@Z"]
    pub fn cocos2d_CCTransitionSceneOriented_initWithDuration(
        this: *mut ::std::os::raw::c_void,
        t: f32,
        scene: *mut cocos2d_CCScene,
        orientation: cocos2d_tOrientation,
    ) -> bool;
}
#[doc = " @brief CCTransitionRotoZoom:"]
#[doc = "Rotate and zoom out the outgoing scene, and then rotate and zoom in the incoming"]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCTransitionRotoZoom {
    pub _base: cocos2d_CCTransitionScene,
}
#[test]
fn bindgen_test_layout_cocos2d_CCTransitionRotoZoom() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCTransitionRotoZoom>(),
        328usize,
        concat!("Size of: ", stringify!(cocos2d_CCTransitionRotoZoom))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCTransitionRotoZoom>(),
        8usize,
        concat!("Alignment of ", stringify!(cocos2d_CCTransitionRotoZoom))
    );
}
extern "C" {
    #[link_name = "\u{1}?create@CCTransitionRotoZoom@cocos2d@@SAPEAV12@MPEAVCCScene@2@@Z"]
    pub fn cocos2d_CCTransitionRotoZoom_create(
        t: f32,
        scene: *mut cocos2d_CCScene,
    ) -> *mut cocos2d_CCTransitionRotoZoom;
}
extern "C" {
    #[doc = "  @js ctor"]
    #[link_name = "\u{1}??0CCTransitionRotoZoom@cocos2d@@QEAA@XZ"]
    pub fn cocos2d_CCTransitionRotoZoom_CCTransitionRotoZoom(
        this: *mut cocos2d_CCTransitionRotoZoom,
    );
}
impl cocos2d_CCTransitionRotoZoom {
    #[inline]
    pub unsafe fn create(t: f32, scene: *mut cocos2d_CCScene) -> *mut cocos2d_CCTransitionRotoZoom {
        cocos2d_CCTransitionRotoZoom_create(t, scene)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cocos2d_CCTransitionRotoZoom_CCTransitionRotoZoom(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
}
extern "C" {
    #[doc = "  @js NA"]
    #[doc = "  @lua NA"]
    #[link_name = "\u{1}??_DCCTransitionRotoZoom@cocos2d@@QEAAXXZ"]
    pub fn cocos2d_CCTransitionRotoZoom_CCTransitionRotoZoom_destructor(
        this: *mut cocos2d_CCTransitionRotoZoom,
    );
}
extern "C" {
    #[doc = "  @js NA"]
    #[doc = "  @lua NA"]
    #[link_name = "\u{1}?onEnter@CCTransitionRotoZoom@cocos2d@@UEAAXXZ"]
    pub fn cocos2d_CCTransitionRotoZoom_onEnter(this: *mut ::std::os::raw::c_void);
}
#[doc = " @brief CCTransitionJumpZoom:"]
#[doc = "Zoom out and jump the outgoing scene, and then jump and zoom in the incoming"]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCTransitionJumpZoom {
    pub _base: cocos2d_CCTransitionScene,
}
#[test]
fn bindgen_test_layout_cocos2d_CCTransitionJumpZoom() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCTransitionJumpZoom>(),
        328usize,
        concat!("Size of: ", stringify!(cocos2d_CCTransitionJumpZoom))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCTransitionJumpZoom>(),
        8usize,
        concat!("Alignment of ", stringify!(cocos2d_CCTransitionJumpZoom))
    );
}
extern "C" {
    #[link_name = "\u{1}?create@CCTransitionJumpZoom@cocos2d@@SAPEAV12@MPEAVCCScene@2@@Z"]
    pub fn cocos2d_CCTransitionJumpZoom_create(
        t: f32,
        scene: *mut cocos2d_CCScene,
    ) -> *mut cocos2d_CCTransitionJumpZoom;
}
extern "C" {
    #[doc = "  @js ctor"]
    #[link_name = "\u{1}??0CCTransitionJumpZoom@cocos2d@@QEAA@XZ"]
    pub fn cocos2d_CCTransitionJumpZoom_CCTransitionJumpZoom(
        this: *mut cocos2d_CCTransitionJumpZoom,
    );
}
impl cocos2d_CCTransitionJumpZoom {
    #[inline]
    pub unsafe fn create(t: f32, scene: *mut cocos2d_CCScene) -> *mut cocos2d_CCTransitionJumpZoom {
        cocos2d_CCTransitionJumpZoom_create(t, scene)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cocos2d_CCTransitionJumpZoom_CCTransitionJumpZoom(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
}
extern "C" {
    #[doc = "  @js NA"]
    #[doc = "  @lua NA"]
    #[link_name = "\u{1}??_DCCTransitionJumpZoom@cocos2d@@QEAAXXZ"]
    pub fn cocos2d_CCTransitionJumpZoom_CCTransitionJumpZoom_destructor(
        this: *mut cocos2d_CCTransitionJumpZoom,
    );
}
extern "C" {
    #[doc = "  @js NA"]
    #[doc = "  @lua NA"]
    #[link_name = "\u{1}?onEnter@CCTransitionJumpZoom@cocos2d@@UEAAXXZ"]
    pub fn cocos2d_CCTransitionJumpZoom_onEnter(this: *mut ::std::os::raw::c_void);
}
#[doc = " @brief CCTransitionMoveInL:"]
#[doc = "Move in from to the left the incoming scene."]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCTransitionMoveInL {
    pub _base: cocos2d_CCTransitionScene,
    pub _base_1: cocos2d_CCTransitionEaseScene,
}
#[test]
fn bindgen_test_layout_cocos2d_CCTransitionMoveInL() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCTransitionMoveInL>(),
        336usize,
        concat!("Size of: ", stringify!(cocos2d_CCTransitionMoveInL))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCTransitionMoveInL>(),
        8usize,
        concat!("Alignment of ", stringify!(cocos2d_CCTransitionMoveInL))
    );
}
extern "C" {
    #[link_name = "\u{1}?create@CCTransitionMoveInL@cocos2d@@SAPEAV12@MPEAVCCScene@2@@Z"]
    pub fn cocos2d_CCTransitionMoveInL_create(
        t: f32,
        scene: *mut cocos2d_CCScene,
    ) -> *mut cocos2d_CCTransitionMoveInL;
}
extern "C" {
    #[doc = "  @js ctor"]
    #[link_name = "\u{1}??0CCTransitionMoveInL@cocos2d@@QEAA@XZ"]
    pub fn cocos2d_CCTransitionMoveInL_CCTransitionMoveInL(this: *mut cocos2d_CCTransitionMoveInL);
}
impl cocos2d_CCTransitionMoveInL {
    #[inline]
    pub unsafe fn create(t: f32, scene: *mut cocos2d_CCScene) -> *mut cocos2d_CCTransitionMoveInL {
        cocos2d_CCTransitionMoveInL_create(t, scene)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cocos2d_CCTransitionMoveInL_CCTransitionMoveInL(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
}
extern "C" {
    #[doc = "  @js NA"]
    #[doc = "  @lua NA"]
    #[link_name = "\u{1}??_DCCTransitionMoveInL@cocos2d@@QEAAXXZ"]
    pub fn cocos2d_CCTransitionMoveInL_CCTransitionMoveInL_destructor(
        this: *mut cocos2d_CCTransitionMoveInL,
    );
}
extern "C" {
    #[doc = " initializes the scenes"]
    #[link_name = "\u{1}?initScenes@CCTransitionMoveInL@cocos2d@@UEAAXXZ"]
    pub fn cocos2d_CCTransitionMoveInL_initScenes(this: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[doc = " returns the action that will be performed"]
    #[link_name = "\u{1}?action@CCTransitionMoveInL@cocos2d@@UEAAPEAVCCActionInterval@2@XZ"]
    pub fn cocos2d_CCTransitionMoveInL_action(
        this: *mut ::std::os::raw::c_void,
    ) -> *mut cocos2d_CCActionInterval;
}
extern "C" {
    #[link_name = "\u{1}?easeActionWithAction@CCTransitionMoveInL@cocos2d@@UEAAPEAVCCActionInterval@2@PEAV32@@Z"]
    pub fn cocos2d_CCTransitionMoveInL_easeActionWithAction(
        this: *mut ::std::os::raw::c_void,
        action: *mut cocos2d_CCActionInterval,
    ) -> *mut cocos2d_CCActionInterval;
}
extern "C" {
    #[doc = "  @js NA"]
    #[doc = "  @lua NA"]
    #[link_name = "\u{1}?onEnter@CCTransitionMoveInL@cocos2d@@UEAAXXZ"]
    pub fn cocos2d_CCTransitionMoveInL_onEnter(this: *mut ::std::os::raw::c_void);
}
#[doc = " @brief CCTransitionMoveInR:"]
#[doc = "Move in from to the right the incoming scene."]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCTransitionMoveInR {
    pub _base: cocos2d_CCTransitionMoveInL,
}
#[test]
fn bindgen_test_layout_cocos2d_CCTransitionMoveInR() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCTransitionMoveInR>(),
        336usize,
        concat!("Size of: ", stringify!(cocos2d_CCTransitionMoveInR))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCTransitionMoveInR>(),
        8usize,
        concat!("Alignment of ", stringify!(cocos2d_CCTransitionMoveInR))
    );
}
extern "C" {
    #[link_name = "\u{1}?create@CCTransitionMoveInR@cocos2d@@SAPEAV12@MPEAVCCScene@2@@Z"]
    pub fn cocos2d_CCTransitionMoveInR_create(
        t: f32,
        scene: *mut cocos2d_CCScene,
    ) -> *mut cocos2d_CCTransitionMoveInR;
}
extern "C" {
    #[doc = "  @js ctor"]
    #[link_name = "\u{1}??0CCTransitionMoveInR@cocos2d@@QEAA@XZ"]
    pub fn cocos2d_CCTransitionMoveInR_CCTransitionMoveInR(this: *mut cocos2d_CCTransitionMoveInR);
}
impl cocos2d_CCTransitionMoveInR {
    #[inline]
    pub unsafe fn create(t: f32, scene: *mut cocos2d_CCScene) -> *mut cocos2d_CCTransitionMoveInR {
        cocos2d_CCTransitionMoveInR_create(t, scene)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cocos2d_CCTransitionMoveInR_CCTransitionMoveInR(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
}
extern "C" {
    #[doc = "  @js NA"]
    #[doc = "  @lua NA"]
    #[link_name = "\u{1}??_DCCTransitionMoveInR@cocos2d@@QEAAXXZ"]
    pub fn cocos2d_CCTransitionMoveInR_CCTransitionMoveInR_destructor(
        this: *mut cocos2d_CCTransitionMoveInR,
    );
}
extern "C" {
    #[link_name = "\u{1}?initScenes@CCTransitionMoveInR@cocos2d@@UEAAXXZ"]
    pub fn cocos2d_CCTransitionMoveInR_initScenes(this: *mut ::std::os::raw::c_void);
}
#[doc = " @brief CCTransitionMoveInT:"]
#[doc = "Move in from to the top the incoming scene."]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCTransitionMoveInT {
    pub _base: cocos2d_CCTransitionMoveInL,
}
#[test]
fn bindgen_test_layout_cocos2d_CCTransitionMoveInT() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCTransitionMoveInT>(),
        336usize,
        concat!("Size of: ", stringify!(cocos2d_CCTransitionMoveInT))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCTransitionMoveInT>(),
        8usize,
        concat!("Alignment of ", stringify!(cocos2d_CCTransitionMoveInT))
    );
}
extern "C" {
    #[link_name = "\u{1}?create@CCTransitionMoveInT@cocos2d@@SAPEAV12@MPEAVCCScene@2@@Z"]
    pub fn cocos2d_CCTransitionMoveInT_create(
        t: f32,
        scene: *mut cocos2d_CCScene,
    ) -> *mut cocos2d_CCTransitionMoveInT;
}
extern "C" {
    #[doc = "  @js ctor"]
    #[link_name = "\u{1}??0CCTransitionMoveInT@cocos2d@@QEAA@XZ"]
    pub fn cocos2d_CCTransitionMoveInT_CCTransitionMoveInT(this: *mut cocos2d_CCTransitionMoveInT);
}
impl cocos2d_CCTransitionMoveInT {
    #[inline]
    pub unsafe fn create(t: f32, scene: *mut cocos2d_CCScene) -> *mut cocos2d_CCTransitionMoveInT {
        cocos2d_CCTransitionMoveInT_create(t, scene)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cocos2d_CCTransitionMoveInT_CCTransitionMoveInT(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
}
extern "C" {
    #[doc = "  @js NA"]
    #[doc = "  @lua NA"]
    #[link_name = "\u{1}??_DCCTransitionMoveInT@cocos2d@@QEAAXXZ"]
    pub fn cocos2d_CCTransitionMoveInT_CCTransitionMoveInT_destructor(
        this: *mut cocos2d_CCTransitionMoveInT,
    );
}
extern "C" {
    #[link_name = "\u{1}?initScenes@CCTransitionMoveInT@cocos2d@@UEAAXXZ"]
    pub fn cocos2d_CCTransitionMoveInT_initScenes(this: *mut ::std::os::raw::c_void);
}
#[doc = " @brief CCTransitionMoveInB:"]
#[doc = "Move in from to the bottom the incoming scene."]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCTransitionMoveInB {
    pub _base: cocos2d_CCTransitionMoveInL,
}
#[test]
fn bindgen_test_layout_cocos2d_CCTransitionMoveInB() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCTransitionMoveInB>(),
        336usize,
        concat!("Size of: ", stringify!(cocos2d_CCTransitionMoveInB))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCTransitionMoveInB>(),
        8usize,
        concat!("Alignment of ", stringify!(cocos2d_CCTransitionMoveInB))
    );
}
extern "C" {
    #[link_name = "\u{1}?create@CCTransitionMoveInB@cocos2d@@SAPEAV12@MPEAVCCScene@2@@Z"]
    pub fn cocos2d_CCTransitionMoveInB_create(
        t: f32,
        scene: *mut cocos2d_CCScene,
    ) -> *mut cocos2d_CCTransitionMoveInB;
}
extern "C" {
    #[doc = "  @js ctor"]
    #[link_name = "\u{1}??0CCTransitionMoveInB@cocos2d@@QEAA@XZ"]
    pub fn cocos2d_CCTransitionMoveInB_CCTransitionMoveInB(this: *mut cocos2d_CCTransitionMoveInB);
}
impl cocos2d_CCTransitionMoveInB {
    #[inline]
    pub unsafe fn create(t: f32, scene: *mut cocos2d_CCScene) -> *mut cocos2d_CCTransitionMoveInB {
        cocos2d_CCTransitionMoveInB_create(t, scene)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cocos2d_CCTransitionMoveInB_CCTransitionMoveInB(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
}
extern "C" {
    #[doc = "  @js NA"]
    #[doc = "  @lua NA"]
    #[link_name = "\u{1}??_DCCTransitionMoveInB@cocos2d@@QEAAXXZ"]
    pub fn cocos2d_CCTransitionMoveInB_CCTransitionMoveInB_destructor(
        this: *mut cocos2d_CCTransitionMoveInB,
    );
}
extern "C" {
    #[link_name = "\u{1}?initScenes@CCTransitionMoveInB@cocos2d@@UEAAXXZ"]
    pub fn cocos2d_CCTransitionMoveInB_initScenes(this: *mut ::std::os::raw::c_void);
}
#[doc = " @brief CCTransitionSlideInL:"]
#[doc = "Slide in the incoming scene from the left border."]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCTransitionSlideInL {
    pub _base: cocos2d_CCTransitionScene,
    pub _base_1: cocos2d_CCTransitionEaseScene,
}
#[test]
fn bindgen_test_layout_cocos2d_CCTransitionSlideInL() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCTransitionSlideInL>(),
        336usize,
        concat!("Size of: ", stringify!(cocos2d_CCTransitionSlideInL))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCTransitionSlideInL>(),
        8usize,
        concat!("Alignment of ", stringify!(cocos2d_CCTransitionSlideInL))
    );
}
extern "C" {
    #[link_name = "\u{1}?create@CCTransitionSlideInL@cocos2d@@SAPEAV12@MPEAVCCScene@2@@Z"]
    pub fn cocos2d_CCTransitionSlideInL_create(
        t: f32,
        scene: *mut cocos2d_CCScene,
    ) -> *mut cocos2d_CCTransitionSlideInL;
}
extern "C" {
    #[doc = "  @js ctor"]
    #[link_name = "\u{1}??0CCTransitionSlideInL@cocos2d@@QEAA@XZ"]
    pub fn cocos2d_CCTransitionSlideInL_CCTransitionSlideInL(
        this: *mut cocos2d_CCTransitionSlideInL,
    );
}
impl cocos2d_CCTransitionSlideInL {
    #[inline]
    pub unsafe fn create(t: f32, scene: *mut cocos2d_CCScene) -> *mut cocos2d_CCTransitionSlideInL {
        cocos2d_CCTransitionSlideInL_create(t, scene)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cocos2d_CCTransitionSlideInL_CCTransitionSlideInL(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
}
extern "C" {
    #[doc = "  @js NA"]
    #[doc = "  @lua NA"]
    #[link_name = "\u{1}??_DCCTransitionSlideInL@cocos2d@@QEAAXXZ"]
    pub fn cocos2d_CCTransitionSlideInL_CCTransitionSlideInL_destructor(
        this: *mut cocos2d_CCTransitionSlideInL,
    );
}
extern "C" {
    #[doc = " initializes the scenes"]
    #[link_name = "\u{1}?initScenes@CCTransitionSlideInL@cocos2d@@UEAAXXZ"]
    pub fn cocos2d_CCTransitionSlideInL_initScenes(this: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[doc = " returns the action that will be performed by the incoming and outgoing scene"]
    #[link_name = "\u{1}?action@CCTransitionSlideInL@cocos2d@@UEAAPEAVCCActionInterval@2@XZ"]
    pub fn cocos2d_CCTransitionSlideInL_action(
        this: *mut ::std::os::raw::c_void,
    ) -> *mut cocos2d_CCActionInterval;
}
extern "C" {
    #[doc = "  @js NA"]
    #[doc = "  @lua NA"]
    #[link_name = "\u{1}?onEnter@CCTransitionSlideInL@cocos2d@@UEAAXXZ"]
    pub fn cocos2d_CCTransitionSlideInL_onEnter(this: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[link_name = "\u{1}?easeActionWithAction@CCTransitionSlideInL@cocos2d@@UEAAPEAVCCActionInterval@2@PEAV32@@Z"]
    pub fn cocos2d_CCTransitionSlideInL_easeActionWithAction(
        this: *mut ::std::os::raw::c_void,
        action: *mut cocos2d_CCActionInterval,
    ) -> *mut cocos2d_CCActionInterval;
}
extern "C" {
    #[link_name = "\u{1}?sceneOrder@CCTransitionSlideInL@cocos2d@@MEAAXXZ"]
    pub fn cocos2d_CCTransitionSlideInL_sceneOrder(this: *mut ::std::os::raw::c_void);
}
#[doc = " @brief CCTransitionSlideInR:"]
#[doc = "Slide in the incoming scene from the right border."]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCTransitionSlideInR {
    pub _base: cocos2d_CCTransitionSlideInL,
}
#[test]
fn bindgen_test_layout_cocos2d_CCTransitionSlideInR() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCTransitionSlideInR>(),
        336usize,
        concat!("Size of: ", stringify!(cocos2d_CCTransitionSlideInR))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCTransitionSlideInR>(),
        8usize,
        concat!("Alignment of ", stringify!(cocos2d_CCTransitionSlideInR))
    );
}
extern "C" {
    #[link_name = "\u{1}?create@CCTransitionSlideInR@cocos2d@@SAPEAV12@MPEAVCCScene@2@@Z"]
    pub fn cocos2d_CCTransitionSlideInR_create(
        t: f32,
        scene: *mut cocos2d_CCScene,
    ) -> *mut cocos2d_CCTransitionSlideInR;
}
extern "C" {
    #[doc = "  @js ctor"]
    #[link_name = "\u{1}??0CCTransitionSlideInR@cocos2d@@QEAA@XZ"]
    pub fn cocos2d_CCTransitionSlideInR_CCTransitionSlideInR(
        this: *mut cocos2d_CCTransitionSlideInR,
    );
}
impl cocos2d_CCTransitionSlideInR {
    #[inline]
    pub unsafe fn create(t: f32, scene: *mut cocos2d_CCScene) -> *mut cocos2d_CCTransitionSlideInR {
        cocos2d_CCTransitionSlideInR_create(t, scene)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cocos2d_CCTransitionSlideInR_CCTransitionSlideInR(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
}
extern "C" {
    #[doc = "  @js NA"]
    #[doc = "  @lua NA"]
    #[link_name = "\u{1}??_DCCTransitionSlideInR@cocos2d@@QEAAXXZ"]
    pub fn cocos2d_CCTransitionSlideInR_CCTransitionSlideInR_destructor(
        this: *mut cocos2d_CCTransitionSlideInR,
    );
}
extern "C" {
    #[doc = " initializes the scenes"]
    #[link_name = "\u{1}?initScenes@CCTransitionSlideInR@cocos2d@@UEAAXXZ"]
    pub fn cocos2d_CCTransitionSlideInR_initScenes(this: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[doc = " returns the action that will be performed by the incoming and outgoing scene"]
    #[link_name = "\u{1}?action@CCTransitionSlideInR@cocos2d@@UEAAPEAVCCActionInterval@2@XZ"]
    pub fn cocos2d_CCTransitionSlideInR_action(
        this: *mut ::std::os::raw::c_void,
    ) -> *mut cocos2d_CCActionInterval;
}
extern "C" {
    #[link_name = "\u{1}?sceneOrder@CCTransitionSlideInR@cocos2d@@MEAAXXZ"]
    pub fn cocos2d_CCTransitionSlideInR_sceneOrder(this: *mut ::std::os::raw::c_void);
}
#[doc = " @brief CCTransitionSlideInB:"]
#[doc = "Slide in the incoming scene from the bottom border."]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCTransitionSlideInB {
    pub _base: cocos2d_CCTransitionSlideInL,
}
#[test]
fn bindgen_test_layout_cocos2d_CCTransitionSlideInB() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCTransitionSlideInB>(),
        336usize,
        concat!("Size of: ", stringify!(cocos2d_CCTransitionSlideInB))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCTransitionSlideInB>(),
        8usize,
        concat!("Alignment of ", stringify!(cocos2d_CCTransitionSlideInB))
    );
}
extern "C" {
    #[link_name = "\u{1}?create@CCTransitionSlideInB@cocos2d@@SAPEAV12@MPEAVCCScene@2@@Z"]
    pub fn cocos2d_CCTransitionSlideInB_create(
        t: f32,
        scene: *mut cocos2d_CCScene,
    ) -> *mut cocos2d_CCTransitionSlideInB;
}
extern "C" {
    #[doc = "  @js ctor"]
    #[link_name = "\u{1}??0CCTransitionSlideInB@cocos2d@@QEAA@XZ"]
    pub fn cocos2d_CCTransitionSlideInB_CCTransitionSlideInB(
        this: *mut cocos2d_CCTransitionSlideInB,
    );
}
impl cocos2d_CCTransitionSlideInB {
    #[inline]
    pub unsafe fn create(t: f32, scene: *mut cocos2d_CCScene) -> *mut cocos2d_CCTransitionSlideInB {
        cocos2d_CCTransitionSlideInB_create(t, scene)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cocos2d_CCTransitionSlideInB_CCTransitionSlideInB(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
}
extern "C" {
    #[doc = "  @js NA"]
    #[doc = "  @lua NA"]
    #[link_name = "\u{1}??_DCCTransitionSlideInB@cocos2d@@QEAAXXZ"]
    pub fn cocos2d_CCTransitionSlideInB_CCTransitionSlideInB_destructor(
        this: *mut cocos2d_CCTransitionSlideInB,
    );
}
extern "C" {
    #[doc = " initializes the scenes"]
    #[link_name = "\u{1}?initScenes@CCTransitionSlideInB@cocos2d@@UEAAXXZ"]
    pub fn cocos2d_CCTransitionSlideInB_initScenes(this: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[doc = " returns the action that will be performed by the incoming and outgoing scene"]
    #[link_name = "\u{1}?action@CCTransitionSlideInB@cocos2d@@UEAAPEAVCCActionInterval@2@XZ"]
    pub fn cocos2d_CCTransitionSlideInB_action(
        this: *mut ::std::os::raw::c_void,
    ) -> *mut cocos2d_CCActionInterval;
}
extern "C" {
    #[link_name = "\u{1}?sceneOrder@CCTransitionSlideInB@cocos2d@@MEAAXXZ"]
    pub fn cocos2d_CCTransitionSlideInB_sceneOrder(this: *mut ::std::os::raw::c_void);
}
#[doc = " @brief CCTransitionSlideInT:"]
#[doc = "Slide in the incoming scene from the top border."]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCTransitionSlideInT {
    pub _base: cocos2d_CCTransitionSlideInL,
}
#[test]
fn bindgen_test_layout_cocos2d_CCTransitionSlideInT() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCTransitionSlideInT>(),
        336usize,
        concat!("Size of: ", stringify!(cocos2d_CCTransitionSlideInT))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCTransitionSlideInT>(),
        8usize,
        concat!("Alignment of ", stringify!(cocos2d_CCTransitionSlideInT))
    );
}
extern "C" {
    #[link_name = "\u{1}?create@CCTransitionSlideInT@cocos2d@@SAPEAV12@MPEAVCCScene@2@@Z"]
    pub fn cocos2d_CCTransitionSlideInT_create(
        t: f32,
        scene: *mut cocos2d_CCScene,
    ) -> *mut cocos2d_CCTransitionSlideInT;
}
extern "C" {
    #[doc = "  @js ctor"]
    #[link_name = "\u{1}??0CCTransitionSlideInT@cocos2d@@QEAA@XZ"]
    pub fn cocos2d_CCTransitionSlideInT_CCTransitionSlideInT(
        this: *mut cocos2d_CCTransitionSlideInT,
    );
}
impl cocos2d_CCTransitionSlideInT {
    #[inline]
    pub unsafe fn create(t: f32, scene: *mut cocos2d_CCScene) -> *mut cocos2d_CCTransitionSlideInT {
        cocos2d_CCTransitionSlideInT_create(t, scene)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cocos2d_CCTransitionSlideInT_CCTransitionSlideInT(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
}
extern "C" {
    #[doc = "  @js NA"]
    #[doc = "  @lua NA"]
    #[link_name = "\u{1}??_DCCTransitionSlideInT@cocos2d@@QEAAXXZ"]
    pub fn cocos2d_CCTransitionSlideInT_CCTransitionSlideInT_destructor(
        this: *mut cocos2d_CCTransitionSlideInT,
    );
}
extern "C" {
    #[doc = " initializes the scenes"]
    #[link_name = "\u{1}?initScenes@CCTransitionSlideInT@cocos2d@@UEAAXXZ"]
    pub fn cocos2d_CCTransitionSlideInT_initScenes(this: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[doc = " returns the action that will be performed by the incoming and outgoing scene"]
    #[link_name = "\u{1}?action@CCTransitionSlideInT@cocos2d@@UEAAPEAVCCActionInterval@2@XZ"]
    pub fn cocos2d_CCTransitionSlideInT_action(
        this: *mut ::std::os::raw::c_void,
    ) -> *mut cocos2d_CCActionInterval;
}
extern "C" {
    #[link_name = "\u{1}?sceneOrder@CCTransitionSlideInT@cocos2d@@MEAAXXZ"]
    pub fn cocos2d_CCTransitionSlideInT_sceneOrder(this: *mut ::std::os::raw::c_void);
}
#[doc = "@brief Shrink the outgoing scene while grow the incoming scene"]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCTransitionShrinkGrow {
    pub _base: cocos2d_CCTransitionScene,
    pub _base_1: cocos2d_CCTransitionEaseScene,
}
#[test]
fn bindgen_test_layout_cocos2d_CCTransitionShrinkGrow() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCTransitionShrinkGrow>(),
        336usize,
        concat!("Size of: ", stringify!(cocos2d_CCTransitionShrinkGrow))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCTransitionShrinkGrow>(),
        8usize,
        concat!("Alignment of ", stringify!(cocos2d_CCTransitionShrinkGrow))
    );
}
extern "C" {
    #[link_name = "\u{1}?create@CCTransitionShrinkGrow@cocos2d@@SAPEAV12@MPEAVCCScene@2@@Z"]
    pub fn cocos2d_CCTransitionShrinkGrow_create(
        t: f32,
        scene: *mut cocos2d_CCScene,
    ) -> *mut cocos2d_CCTransitionShrinkGrow;
}
extern "C" {
    #[doc = "  @js ctor"]
    #[link_name = "\u{1}??0CCTransitionShrinkGrow@cocos2d@@QEAA@XZ"]
    pub fn cocos2d_CCTransitionShrinkGrow_CCTransitionShrinkGrow(
        this: *mut cocos2d_CCTransitionShrinkGrow,
    );
}
impl cocos2d_CCTransitionShrinkGrow {
    #[inline]
    pub unsafe fn create(
        t: f32,
        scene: *mut cocos2d_CCScene,
    ) -> *mut cocos2d_CCTransitionShrinkGrow {
        cocos2d_CCTransitionShrinkGrow_create(t, scene)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cocos2d_CCTransitionShrinkGrow_CCTransitionShrinkGrow(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
}
extern "C" {
    #[doc = "  @js NA"]
    #[doc = "  @lua NA"]
    #[link_name = "\u{1}??_DCCTransitionShrinkGrow@cocos2d@@QEAAXXZ"]
    pub fn cocos2d_CCTransitionShrinkGrow_CCTransitionShrinkGrow_destructor(
        this: *mut cocos2d_CCTransitionShrinkGrow,
    );
}
extern "C" {
    #[doc = "  @js NA"]
    #[doc = "  @lua NA"]
    #[link_name = "\u{1}?onEnter@CCTransitionShrinkGrow@cocos2d@@UEAAXXZ"]
    pub fn cocos2d_CCTransitionShrinkGrow_onEnter(this: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[link_name = "\u{1}?easeActionWithAction@CCTransitionShrinkGrow@cocos2d@@UEAAPEAVCCActionInterval@2@PEAV32@@Z"]
    pub fn cocos2d_CCTransitionShrinkGrow_easeActionWithAction(
        this: *mut ::std::os::raw::c_void,
        action: *mut cocos2d_CCActionInterval,
    ) -> *mut cocos2d_CCActionInterval;
}
#[doc = " @brief CCTransitionFlipX:"]
#[doc = "Flips the screen horizontally."]
#[doc = "The front face is the outgoing scene and the back face is the incoming scene."]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCTransitionFlipX {
    pub _base: cocos2d_CCTransitionSceneOriented,
}
#[test]
fn bindgen_test_layout_cocos2d_CCTransitionFlipX() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCTransitionFlipX>(),
        336usize,
        concat!("Size of: ", stringify!(cocos2d_CCTransitionFlipX))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCTransitionFlipX>(),
        8usize,
        concat!("Alignment of ", stringify!(cocos2d_CCTransitionFlipX))
    );
}
extern "C" {
    #[link_name = "\u{1}?create@CCTransitionFlipX@cocos2d@@SAPEAV12@MPEAVCCScene@2@W4tOrientation@2@@Z"]
    pub fn cocos2d_CCTransitionFlipX_create(
        t: f32,
        s: *mut cocos2d_CCScene,
        o: cocos2d_tOrientation,
    ) -> *mut cocos2d_CCTransitionFlipX;
}
extern "C" {
    #[link_name = "\u{1}?create@CCTransitionFlipX@cocos2d@@SAPEAV12@MPEAVCCScene@2@@Z"]
    pub fn cocos2d_CCTransitionFlipX_create1(
        t: f32,
        s: *mut cocos2d_CCScene,
    ) -> *mut cocos2d_CCTransitionFlipX;
}
extern "C" {
    #[doc = "  @js ctor"]
    #[link_name = "\u{1}??0CCTransitionFlipX@cocos2d@@QEAA@XZ"]
    pub fn cocos2d_CCTransitionFlipX_CCTransitionFlipX(this: *mut cocos2d_CCTransitionFlipX);
}
impl cocos2d_CCTransitionFlipX {
    #[inline]
    pub unsafe fn create(
        t: f32,
        s: *mut cocos2d_CCScene,
        o: cocos2d_tOrientation,
    ) -> *mut cocos2d_CCTransitionFlipX {
        cocos2d_CCTransitionFlipX_create(t, s, o)
    }
    #[inline]
    pub unsafe fn create1(t: f32, s: *mut cocos2d_CCScene) -> *mut cocos2d_CCTransitionFlipX {
        cocos2d_CCTransitionFlipX_create1(t, s)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cocos2d_CCTransitionFlipX_CCTransitionFlipX(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
}
extern "C" {
    #[doc = "  @js NA"]
    #[doc = "  @lua NA"]
    #[link_name = "\u{1}??_DCCTransitionFlipX@cocos2d@@QEAAXXZ"]
    pub fn cocos2d_CCTransitionFlipX_CCTransitionFlipX_destructor(
        this: *mut cocos2d_CCTransitionFlipX,
    );
}
extern "C" {
    #[doc = "  @js NA"]
    #[doc = "  @lua NA"]
    #[link_name = "\u{1}?onEnter@CCTransitionFlipX@cocos2d@@UEAAXXZ"]
    pub fn cocos2d_CCTransitionFlipX_onEnter(this: *mut ::std::os::raw::c_void);
}
#[doc = " @brief CCTransitionFlipY:"]
#[doc = "Flips the screen vertically."]
#[doc = "The front face is the outgoing scene and the back face is the incoming scene."]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCTransitionFlipY {
    pub _base: cocos2d_CCTransitionSceneOriented,
}
#[test]
fn bindgen_test_layout_cocos2d_CCTransitionFlipY() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCTransitionFlipY>(),
        336usize,
        concat!("Size of: ", stringify!(cocos2d_CCTransitionFlipY))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCTransitionFlipY>(),
        8usize,
        concat!("Alignment of ", stringify!(cocos2d_CCTransitionFlipY))
    );
}
extern "C" {
    #[link_name = "\u{1}?create@CCTransitionFlipY@cocos2d@@SAPEAV12@MPEAVCCScene@2@W4tOrientation@2@@Z"]
    pub fn cocos2d_CCTransitionFlipY_create(
        t: f32,
        s: *mut cocos2d_CCScene,
        o: cocos2d_tOrientation,
    ) -> *mut cocos2d_CCTransitionFlipY;
}
extern "C" {
    #[link_name = "\u{1}?create@CCTransitionFlipY@cocos2d@@SAPEAV12@MPEAVCCScene@2@@Z"]
    pub fn cocos2d_CCTransitionFlipY_create1(
        t: f32,
        s: *mut cocos2d_CCScene,
    ) -> *mut cocos2d_CCTransitionFlipY;
}
extern "C" {
    #[doc = "  @js ctor"]
    #[link_name = "\u{1}??0CCTransitionFlipY@cocos2d@@QEAA@XZ"]
    pub fn cocos2d_CCTransitionFlipY_CCTransitionFlipY(this: *mut cocos2d_CCTransitionFlipY);
}
impl cocos2d_CCTransitionFlipY {
    #[inline]
    pub unsafe fn create(
        t: f32,
        s: *mut cocos2d_CCScene,
        o: cocos2d_tOrientation,
    ) -> *mut cocos2d_CCTransitionFlipY {
        cocos2d_CCTransitionFlipY_create(t, s, o)
    }
    #[inline]
    pub unsafe fn create1(t: f32, s: *mut cocos2d_CCScene) -> *mut cocos2d_CCTransitionFlipY {
        cocos2d_CCTransitionFlipY_create1(t, s)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cocos2d_CCTransitionFlipY_CCTransitionFlipY(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
}
extern "C" {
    #[doc = "  @js NA"]
    #[doc = "  @lua NA"]
    #[link_name = "\u{1}??_DCCTransitionFlipY@cocos2d@@QEAAXXZ"]
    pub fn cocos2d_CCTransitionFlipY_CCTransitionFlipY_destructor(
        this: *mut cocos2d_CCTransitionFlipY,
    );
}
extern "C" {
    #[doc = "  @js NA"]
    #[doc = "  @lua NA"]
    #[link_name = "\u{1}?onEnter@CCTransitionFlipY@cocos2d@@UEAAXXZ"]
    pub fn cocos2d_CCTransitionFlipY_onEnter(this: *mut ::std::os::raw::c_void);
}
#[doc = " @brief CCTransitionFlipAngular:"]
#[doc = "Flips the screen half horizontally and half vertically."]
#[doc = "The front face is the outgoing scene and the back face is the incoming scene."]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCTransitionFlipAngular {
    pub _base: cocos2d_CCTransitionSceneOriented,
}
#[test]
fn bindgen_test_layout_cocos2d_CCTransitionFlipAngular() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCTransitionFlipAngular>(),
        336usize,
        concat!("Size of: ", stringify!(cocos2d_CCTransitionFlipAngular))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCTransitionFlipAngular>(),
        8usize,
        concat!("Alignment of ", stringify!(cocos2d_CCTransitionFlipAngular))
    );
}
extern "C" {
    #[link_name = "\u{1}?create@CCTransitionFlipAngular@cocos2d@@SAPEAV12@MPEAVCCScene@2@W4tOrientation@2@@Z"]
    pub fn cocos2d_CCTransitionFlipAngular_create(
        t: f32,
        s: *mut cocos2d_CCScene,
        o: cocos2d_tOrientation,
    ) -> *mut cocos2d_CCTransitionFlipAngular;
}
extern "C" {
    #[link_name = "\u{1}?create@CCTransitionFlipAngular@cocos2d@@SAPEAV12@MPEAVCCScene@2@@Z"]
    pub fn cocos2d_CCTransitionFlipAngular_create1(
        t: f32,
        s: *mut cocos2d_CCScene,
    ) -> *mut cocos2d_CCTransitionFlipAngular;
}
extern "C" {
    #[doc = "  @js ctor"]
    #[link_name = "\u{1}??0CCTransitionFlipAngular@cocos2d@@QEAA@XZ"]
    pub fn cocos2d_CCTransitionFlipAngular_CCTransitionFlipAngular(
        this: *mut cocos2d_CCTransitionFlipAngular,
    );
}
impl cocos2d_CCTransitionFlipAngular {
    #[inline]
    pub unsafe fn create(
        t: f32,
        s: *mut cocos2d_CCScene,
        o: cocos2d_tOrientation,
    ) -> *mut cocos2d_CCTransitionFlipAngular {
        cocos2d_CCTransitionFlipAngular_create(t, s, o)
    }
    #[inline]
    pub unsafe fn create1(t: f32, s: *mut cocos2d_CCScene) -> *mut cocos2d_CCTransitionFlipAngular {
        cocos2d_CCTransitionFlipAngular_create1(t, s)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cocos2d_CCTransitionFlipAngular_CCTransitionFlipAngular(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
}
extern "C" {
    #[doc = "  @js NA"]
    #[doc = "  @lua NA"]
    #[link_name = "\u{1}??_DCCTransitionFlipAngular@cocos2d@@QEAAXXZ"]
    pub fn cocos2d_CCTransitionFlipAngular_CCTransitionFlipAngular_destructor(
        this: *mut cocos2d_CCTransitionFlipAngular,
    );
}
extern "C" {
    #[doc = "  @js NA"]
    #[doc = "  @lua NA"]
    #[link_name = "\u{1}?onEnter@CCTransitionFlipAngular@cocos2d@@UEAAXXZ"]
    pub fn cocos2d_CCTransitionFlipAngular_onEnter(this: *mut ::std::os::raw::c_void);
}
#[doc = " @brief CCTransitionZoomFlipX:"]
#[doc = "Flips the screen horizontally doing a zoom out/in"]
#[doc = "The front face is the outgoing scene and the back face is the incoming scene."]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCTransitionZoomFlipX {
    pub _base: cocos2d_CCTransitionSceneOriented,
}
#[test]
fn bindgen_test_layout_cocos2d_CCTransitionZoomFlipX() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCTransitionZoomFlipX>(),
        336usize,
        concat!("Size of: ", stringify!(cocos2d_CCTransitionZoomFlipX))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCTransitionZoomFlipX>(),
        8usize,
        concat!("Alignment of ", stringify!(cocos2d_CCTransitionZoomFlipX))
    );
}
extern "C" {
    #[link_name = "\u{1}?create@CCTransitionZoomFlipX@cocos2d@@SAPEAV12@MPEAVCCScene@2@W4tOrientation@2@@Z"]
    pub fn cocos2d_CCTransitionZoomFlipX_create(
        t: f32,
        s: *mut cocos2d_CCScene,
        o: cocos2d_tOrientation,
    ) -> *mut cocos2d_CCTransitionZoomFlipX;
}
extern "C" {
    #[link_name = "\u{1}?create@CCTransitionZoomFlipX@cocos2d@@SAPEAV12@MPEAVCCScene@2@@Z"]
    pub fn cocos2d_CCTransitionZoomFlipX_create1(
        t: f32,
        s: *mut cocos2d_CCScene,
    ) -> *mut cocos2d_CCTransitionZoomFlipX;
}
extern "C" {
    #[doc = "  @js ctor"]
    #[link_name = "\u{1}??0CCTransitionZoomFlipX@cocos2d@@QEAA@XZ"]
    pub fn cocos2d_CCTransitionZoomFlipX_CCTransitionZoomFlipX(
        this: *mut cocos2d_CCTransitionZoomFlipX,
    );
}
impl cocos2d_CCTransitionZoomFlipX {
    #[inline]
    pub unsafe fn create(
        t: f32,
        s: *mut cocos2d_CCScene,
        o: cocos2d_tOrientation,
    ) -> *mut cocos2d_CCTransitionZoomFlipX {
        cocos2d_CCTransitionZoomFlipX_create(t, s, o)
    }
    #[inline]
    pub unsafe fn create1(t: f32, s: *mut cocos2d_CCScene) -> *mut cocos2d_CCTransitionZoomFlipX {
        cocos2d_CCTransitionZoomFlipX_create1(t, s)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cocos2d_CCTransitionZoomFlipX_CCTransitionZoomFlipX(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
}
extern "C" {
    #[doc = "  @js NA"]
    #[doc = "  @lua NA"]
    #[link_name = "\u{1}??_DCCTransitionZoomFlipX@cocos2d@@QEAAXXZ"]
    pub fn cocos2d_CCTransitionZoomFlipX_CCTransitionZoomFlipX_destructor(
        this: *mut cocos2d_CCTransitionZoomFlipX,
    );
}
extern "C" {
    #[doc = "  @js NA"]
    #[doc = "  @lua NA"]
    #[link_name = "\u{1}?onEnter@CCTransitionZoomFlipX@cocos2d@@UEAAXXZ"]
    pub fn cocos2d_CCTransitionZoomFlipX_onEnter(this: *mut ::std::os::raw::c_void);
}
#[doc = " @brief CCTransitionZoomFlipY:"]
#[doc = "Flips the screen vertically doing a little zooming out/in"]
#[doc = "The front face is the outgoing scene and the back face is the incoming scene."]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCTransitionZoomFlipY {
    pub _base: cocos2d_CCTransitionSceneOriented,
}
#[test]
fn bindgen_test_layout_cocos2d_CCTransitionZoomFlipY() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCTransitionZoomFlipY>(),
        336usize,
        concat!("Size of: ", stringify!(cocos2d_CCTransitionZoomFlipY))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCTransitionZoomFlipY>(),
        8usize,
        concat!("Alignment of ", stringify!(cocos2d_CCTransitionZoomFlipY))
    );
}
extern "C" {
    #[link_name = "\u{1}?create@CCTransitionZoomFlipY@cocos2d@@SAPEAV12@MPEAVCCScene@2@W4tOrientation@2@@Z"]
    pub fn cocos2d_CCTransitionZoomFlipY_create(
        t: f32,
        s: *mut cocos2d_CCScene,
        o: cocos2d_tOrientation,
    ) -> *mut cocos2d_CCTransitionZoomFlipY;
}
extern "C" {
    #[link_name = "\u{1}?create@CCTransitionZoomFlipY@cocos2d@@SAPEAV12@MPEAVCCScene@2@@Z"]
    pub fn cocos2d_CCTransitionZoomFlipY_create1(
        t: f32,
        s: *mut cocos2d_CCScene,
    ) -> *mut cocos2d_CCTransitionZoomFlipY;
}
extern "C" {
    #[doc = "  @js ctor"]
    #[link_name = "\u{1}??0CCTransitionZoomFlipY@cocos2d@@QEAA@XZ"]
    pub fn cocos2d_CCTransitionZoomFlipY_CCTransitionZoomFlipY(
        this: *mut cocos2d_CCTransitionZoomFlipY,
    );
}
impl cocos2d_CCTransitionZoomFlipY {
    #[inline]
    pub unsafe fn create(
        t: f32,
        s: *mut cocos2d_CCScene,
        o: cocos2d_tOrientation,
    ) -> *mut cocos2d_CCTransitionZoomFlipY {
        cocos2d_CCTransitionZoomFlipY_create(t, s, o)
    }
    #[inline]
    pub unsafe fn create1(t: f32, s: *mut cocos2d_CCScene) -> *mut cocos2d_CCTransitionZoomFlipY {
        cocos2d_CCTransitionZoomFlipY_create1(t, s)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cocos2d_CCTransitionZoomFlipY_CCTransitionZoomFlipY(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
}
extern "C" {
    #[doc = "  @js NA"]
    #[doc = "  @lua NA"]
    #[link_name = "\u{1}??_DCCTransitionZoomFlipY@cocos2d@@QEAAXXZ"]
    pub fn cocos2d_CCTransitionZoomFlipY_CCTransitionZoomFlipY_destructor(
        this: *mut cocos2d_CCTransitionZoomFlipY,
    );
}
extern "C" {
    #[doc = "  @js NA"]
    #[doc = "  @lua NA"]
    #[link_name = "\u{1}?onEnter@CCTransitionZoomFlipY@cocos2d@@UEAAXXZ"]
    pub fn cocos2d_CCTransitionZoomFlipY_onEnter(this: *mut ::std::os::raw::c_void);
}
#[doc = " @brief CCTransitionZoomFlipAngular:"]
#[doc = "Flips the screen half horizontally and half vertically doing a little zooming out/in."]
#[doc = "The front face is the outgoing scene and the back face is the incoming scene."]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCTransitionZoomFlipAngular {
    pub _base: cocos2d_CCTransitionSceneOriented,
}
#[test]
fn bindgen_test_layout_cocos2d_CCTransitionZoomFlipAngular() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCTransitionZoomFlipAngular>(),
        336usize,
        concat!("Size of: ", stringify!(cocos2d_CCTransitionZoomFlipAngular))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCTransitionZoomFlipAngular>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(cocos2d_CCTransitionZoomFlipAngular)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}?create@CCTransitionZoomFlipAngular@cocos2d@@SAPEAV12@MPEAVCCScene@2@W4tOrientation@2@@Z"]
    pub fn cocos2d_CCTransitionZoomFlipAngular_create(
        t: f32,
        s: *mut cocos2d_CCScene,
        o: cocos2d_tOrientation,
    ) -> *mut cocos2d_CCTransitionZoomFlipAngular;
}
extern "C" {
    #[link_name = "\u{1}?create@CCTransitionZoomFlipAngular@cocos2d@@SAPEAV12@MPEAVCCScene@2@@Z"]
    pub fn cocos2d_CCTransitionZoomFlipAngular_create1(
        t: f32,
        s: *mut cocos2d_CCScene,
    ) -> *mut cocos2d_CCTransitionZoomFlipAngular;
}
extern "C" {
    #[doc = "  @js ctor"]
    #[link_name = "\u{1}??0CCTransitionZoomFlipAngular@cocos2d@@QEAA@XZ"]
    pub fn cocos2d_CCTransitionZoomFlipAngular_CCTransitionZoomFlipAngular(
        this: *mut cocos2d_CCTransitionZoomFlipAngular,
    );
}
impl cocos2d_CCTransitionZoomFlipAngular {
    #[inline]
    pub unsafe fn create(
        t: f32,
        s: *mut cocos2d_CCScene,
        o: cocos2d_tOrientation,
    ) -> *mut cocos2d_CCTransitionZoomFlipAngular {
        cocos2d_CCTransitionZoomFlipAngular_create(t, s, o)
    }
    #[inline]
    pub unsafe fn create1(
        t: f32,
        s: *mut cocos2d_CCScene,
    ) -> *mut cocos2d_CCTransitionZoomFlipAngular {
        cocos2d_CCTransitionZoomFlipAngular_create1(t, s)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cocos2d_CCTransitionZoomFlipAngular_CCTransitionZoomFlipAngular(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
}
extern "C" {
    #[doc = "  @js NA"]
    #[doc = "  @lua NA"]
    #[link_name = "\u{1}??_DCCTransitionZoomFlipAngular@cocos2d@@QEAAXXZ"]
    pub fn cocos2d_CCTransitionZoomFlipAngular_CCTransitionZoomFlipAngular_destructor(
        this: *mut cocos2d_CCTransitionZoomFlipAngular,
    );
}
extern "C" {
    #[doc = "  @js NA"]
    #[doc = "  @lua NA"]
    #[link_name = "\u{1}?onEnter@CCTransitionZoomFlipAngular@cocos2d@@UEAAXXZ"]
    pub fn cocos2d_CCTransitionZoomFlipAngular_onEnter(this: *mut ::std::os::raw::c_void);
}
#[doc = " @brief CCTransitionFade:"]
#[doc = "Fade out the outgoing scene and then fade in the incoming scene.'''"]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCTransitionFade {
    pub _base: cocos2d_CCTransitionScene,
    pub m_tColor: cocos2d_ccColor4B,
}
#[test]
fn bindgen_test_layout_cocos2d_CCTransitionFade() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCTransitionFade>(),
        336usize,
        concat!("Size of: ", stringify!(cocos2d_CCTransitionFade))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCTransitionFade>(),
        8usize,
        concat!("Alignment of ", stringify!(cocos2d_CCTransitionFade))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cocos2d_CCTransitionFade>())).m_tColor as *const _ as usize
        },
        328usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCTransitionFade),
            "::",
            stringify!(m_tColor)
        )
    );
}
extern "C" {
    #[doc = " creates the transition with a duration and with an RGB color"]
    #[doc = " Example: FadeTransition::create(2, scene, ccc3(255,0,0); // red color"]
    #[link_name = "\u{1}?create@CCTransitionFade@cocos2d@@SAPEAV12@MPEAVCCScene@2@AEBU_ccColor3B@2@@Z"]
    pub fn cocos2d_CCTransitionFade_create(
        duration: f32,
        scene: *mut cocos2d_CCScene,
        color: *const cocos2d_ccColor3B,
    ) -> *mut cocos2d_CCTransitionFade;
}
extern "C" {
    #[link_name = "\u{1}?create@CCTransitionFade@cocos2d@@SAPEAV12@MPEAVCCScene@2@@Z"]
    pub fn cocos2d_CCTransitionFade_create1(
        duration: f32,
        scene: *mut cocos2d_CCScene,
    ) -> *mut cocos2d_CCTransitionFade;
}
extern "C" {
    #[doc = "  @js ctor"]
    #[link_name = "\u{1}??0CCTransitionFade@cocos2d@@QEAA@XZ"]
    pub fn cocos2d_CCTransitionFade_CCTransitionFade(this: *mut cocos2d_CCTransitionFade);
}
impl cocos2d_CCTransitionFade {
    #[inline]
    pub unsafe fn create(
        duration: f32,
        scene: *mut cocos2d_CCScene,
        color: *const cocos2d_ccColor3B,
    ) -> *mut cocos2d_CCTransitionFade {
        cocos2d_CCTransitionFade_create(duration, scene, color)
    }
    #[inline]
    pub unsafe fn create1(
        duration: f32,
        scene: *mut cocos2d_CCScene,
    ) -> *mut cocos2d_CCTransitionFade {
        cocos2d_CCTransitionFade_create1(duration, scene)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cocos2d_CCTransitionFade_CCTransitionFade(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
}
extern "C" {
    #[doc = "  @js NA"]
    #[doc = "  @lua NA"]
    #[link_name = "\u{1}??_DCCTransitionFade@cocos2d@@QEAAXXZ"]
    pub fn cocos2d_CCTransitionFade_CCTransitionFade_destructor(
        this: *mut cocos2d_CCTransitionFade,
    );
}
extern "C" {
    #[doc = " initializes the transition with a duration and with an RGB color"]
    #[link_name = "\u{1}?initWithDuration@CCTransitionFade@cocos2d@@UEAA_NMPEAVCCScene@2@AEBU_ccColor3B@2@@Z"]
    pub fn cocos2d_CCTransitionFade_initWithDuration(
        this: *mut ::std::os::raw::c_void,
        t: f32,
        scene: *mut cocos2d_CCScene,
        color: *const cocos2d_ccColor3B,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}?initWithDuration@CCTransitionFade@cocos2d@@UEAA_NMPEAVCCScene@2@@Z"]
    pub fn cocos2d_CCTransitionFade_initWithDuration1(
        this: *mut ::std::os::raw::c_void,
        t: f32,
        scene: *mut cocos2d_CCScene,
    ) -> bool;
}
extern "C" {
    #[doc = "  @js NA"]
    #[doc = "  @lua NA"]
    #[link_name = "\u{1}?onEnter@CCTransitionFade@cocos2d@@UEAAXXZ"]
    pub fn cocos2d_CCTransitionFade_onEnter(this: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[doc = "  @js NA"]
    #[doc = "  @lua NA"]
    #[link_name = "\u{1}?onExit@CCTransitionFade@cocos2d@@UEAAXXZ"]
    pub fn cocos2d_CCTransitionFade_onExit(this: *mut ::std::os::raw::c_void);
}
#[doc = "@brief CCTransitionCrossFade:"]
#[doc = "Cross fades two scenes using the CCRenderTexture object."]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCTransitionCrossFade {
    pub _base: cocos2d_CCTransitionScene,
}
#[test]
fn bindgen_test_layout_cocos2d_CCTransitionCrossFade() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCTransitionCrossFade>(),
        328usize,
        concat!("Size of: ", stringify!(cocos2d_CCTransitionCrossFade))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCTransitionCrossFade>(),
        8usize,
        concat!("Alignment of ", stringify!(cocos2d_CCTransitionCrossFade))
    );
}
extern "C" {
    #[link_name = "\u{1}?create@CCTransitionCrossFade@cocos2d@@SAPEAV12@MPEAVCCScene@2@@Z"]
    pub fn cocos2d_CCTransitionCrossFade_create(
        t: f32,
        scene: *mut cocos2d_CCScene,
    ) -> *mut cocos2d_CCTransitionCrossFade;
}
extern "C" {
    #[doc = "  @js ctor"]
    #[link_name = "\u{1}??0CCTransitionCrossFade@cocos2d@@QEAA@XZ"]
    pub fn cocos2d_CCTransitionCrossFade_CCTransitionCrossFade(
        this: *mut cocos2d_CCTransitionCrossFade,
    );
}
impl cocos2d_CCTransitionCrossFade {
    #[inline]
    pub unsafe fn create(
        t: f32,
        scene: *mut cocos2d_CCScene,
    ) -> *mut cocos2d_CCTransitionCrossFade {
        cocos2d_CCTransitionCrossFade_create(t, scene)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cocos2d_CCTransitionCrossFade_CCTransitionCrossFade(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
}
extern "C" {
    #[doc = "  @js NA"]
    #[doc = "  @lua NA"]
    #[link_name = "\u{1}??_DCCTransitionCrossFade@cocos2d@@QEAAXXZ"]
    pub fn cocos2d_CCTransitionCrossFade_CCTransitionCrossFade_destructor(
        this: *mut cocos2d_CCTransitionCrossFade,
    );
}
extern "C" {
    #[link_name = "\u{1}?draw@CCTransitionCrossFade@cocos2d@@UEAAXXZ"]
    pub fn cocos2d_CCTransitionCrossFade_draw(this: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[doc = "  @js NA"]
    #[doc = "  @lua NA"]
    #[link_name = "\u{1}?onEnter@CCTransitionCrossFade@cocos2d@@UEAAXXZ"]
    pub fn cocos2d_CCTransitionCrossFade_onEnter(this: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[doc = "  @js NA"]
    #[doc = "  @lua NA"]
    #[link_name = "\u{1}?onExit@CCTransitionCrossFade@cocos2d@@UEAAXXZ"]
    pub fn cocos2d_CCTransitionCrossFade_onExit(this: *mut ::std::os::raw::c_void);
}
#[doc = " @brief CCTransitionTurnOffTiles:"]
#[doc = "Turn off the tiles of the outgoing scene in random order"]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCTransitionTurnOffTiles {
    pub _base: cocos2d_CCTransitionScene,
    pub _base_1: cocos2d_CCTransitionEaseScene,
}
#[test]
fn bindgen_test_layout_cocos2d_CCTransitionTurnOffTiles() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCTransitionTurnOffTiles>(),
        336usize,
        concat!("Size of: ", stringify!(cocos2d_CCTransitionTurnOffTiles))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCTransitionTurnOffTiles>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(cocos2d_CCTransitionTurnOffTiles)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}?create@CCTransitionTurnOffTiles@cocos2d@@SAPEAV12@MPEAVCCScene@2@@Z"]
    pub fn cocos2d_CCTransitionTurnOffTiles_create(
        t: f32,
        scene: *mut cocos2d_CCScene,
    ) -> *mut cocos2d_CCTransitionTurnOffTiles;
}
extern "C" {
    #[doc = "  @js ctor"]
    #[link_name = "\u{1}??0CCTransitionTurnOffTiles@cocos2d@@QEAA@XZ"]
    pub fn cocos2d_CCTransitionTurnOffTiles_CCTransitionTurnOffTiles(
        this: *mut cocos2d_CCTransitionTurnOffTiles,
    );
}
impl cocos2d_CCTransitionTurnOffTiles {
    #[inline]
    pub unsafe fn create(
        t: f32,
        scene: *mut cocos2d_CCScene,
    ) -> *mut cocos2d_CCTransitionTurnOffTiles {
        cocos2d_CCTransitionTurnOffTiles_create(t, scene)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cocos2d_CCTransitionTurnOffTiles_CCTransitionTurnOffTiles(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
}
extern "C" {
    #[doc = "  @js NA"]
    #[doc = "  @lua NA"]
    #[link_name = "\u{1}??_DCCTransitionTurnOffTiles@cocos2d@@QEAAXXZ"]
    pub fn cocos2d_CCTransitionTurnOffTiles_CCTransitionTurnOffTiles_destructor(
        this: *mut cocos2d_CCTransitionTurnOffTiles,
    );
}
extern "C" {
    #[doc = "  @js NA"]
    #[doc = "  @lua NA"]
    #[link_name = "\u{1}?onEnter@CCTransitionTurnOffTiles@cocos2d@@UEAAXXZ"]
    pub fn cocos2d_CCTransitionTurnOffTiles_onEnter(this: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[link_name = "\u{1}?easeActionWithAction@CCTransitionTurnOffTiles@cocos2d@@UEAAPEAVCCActionInterval@2@PEAV32@@Z"]
    pub fn cocos2d_CCTransitionTurnOffTiles_easeActionWithAction(
        this: *mut ::std::os::raw::c_void,
        action: *mut cocos2d_CCActionInterval,
    ) -> *mut cocos2d_CCActionInterval;
}
extern "C" {
    #[link_name = "\u{1}?sceneOrder@CCTransitionTurnOffTiles@cocos2d@@MEAAXXZ"]
    pub fn cocos2d_CCTransitionTurnOffTiles_sceneOrder(this: *mut ::std::os::raw::c_void);
}
#[doc = " @brief CCTransitionSplitCols:"]
#[doc = "The odd columns goes upwards while the even columns goes downwards."]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCTransitionSplitCols {
    pub _base: cocos2d_CCTransitionScene,
    pub _base_1: cocos2d_CCTransitionEaseScene,
}
#[test]
fn bindgen_test_layout_cocos2d_CCTransitionSplitCols() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCTransitionSplitCols>(),
        336usize,
        concat!("Size of: ", stringify!(cocos2d_CCTransitionSplitCols))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCTransitionSplitCols>(),
        8usize,
        concat!("Alignment of ", stringify!(cocos2d_CCTransitionSplitCols))
    );
}
extern "C" {
    #[link_name = "\u{1}?create@CCTransitionSplitCols@cocos2d@@SAPEAV12@MPEAVCCScene@2@@Z"]
    pub fn cocos2d_CCTransitionSplitCols_create(
        t: f32,
        scene: *mut cocos2d_CCScene,
    ) -> *mut cocos2d_CCTransitionSplitCols;
}
extern "C" {
    #[doc = "  @js ctor"]
    #[link_name = "\u{1}??0CCTransitionSplitCols@cocos2d@@QEAA@XZ"]
    pub fn cocos2d_CCTransitionSplitCols_CCTransitionSplitCols(
        this: *mut cocos2d_CCTransitionSplitCols,
    );
}
impl cocos2d_CCTransitionSplitCols {
    #[inline]
    pub unsafe fn create(
        t: f32,
        scene: *mut cocos2d_CCScene,
    ) -> *mut cocos2d_CCTransitionSplitCols {
        cocos2d_CCTransitionSplitCols_create(t, scene)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cocos2d_CCTransitionSplitCols_CCTransitionSplitCols(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
}
extern "C" {
    #[doc = "  @js NA"]
    #[doc = "  @lua NA"]
    #[link_name = "\u{1}??_DCCTransitionSplitCols@cocos2d@@QEAAXXZ"]
    pub fn cocos2d_CCTransitionSplitCols_CCTransitionSplitCols_destructor(
        this: *mut cocos2d_CCTransitionSplitCols,
    );
}
extern "C" {
    #[link_name = "\u{1}?action@CCTransitionSplitCols@cocos2d@@UEAAPEAVCCActionInterval@2@XZ"]
    pub fn cocos2d_CCTransitionSplitCols_action(
        this: *mut ::std::os::raw::c_void,
    ) -> *mut cocos2d_CCActionInterval;
}
extern "C" {
    #[doc = "  @js NA"]
    #[doc = "  @lua NA"]
    #[link_name = "\u{1}?onEnter@CCTransitionSplitCols@cocos2d@@UEAAXXZ"]
    pub fn cocos2d_CCTransitionSplitCols_onEnter(this: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[link_name = "\u{1}?easeActionWithAction@CCTransitionSplitCols@cocos2d@@UEAAPEAVCCActionInterval@2@PEAV32@@Z"]
    pub fn cocos2d_CCTransitionSplitCols_easeActionWithAction(
        this: *mut ::std::os::raw::c_void,
        action: *mut cocos2d_CCActionInterval,
    ) -> *mut cocos2d_CCActionInterval;
}
#[doc = " @brief CCTransitionSplitRows:"]
#[doc = "The odd rows goes to the left while the even rows goes to the right."]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCTransitionSplitRows {
    pub _base: cocos2d_CCTransitionSplitCols,
}
#[test]
fn bindgen_test_layout_cocos2d_CCTransitionSplitRows() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCTransitionSplitRows>(),
        336usize,
        concat!("Size of: ", stringify!(cocos2d_CCTransitionSplitRows))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCTransitionSplitRows>(),
        8usize,
        concat!("Alignment of ", stringify!(cocos2d_CCTransitionSplitRows))
    );
}
extern "C" {
    #[link_name = "\u{1}?create@CCTransitionSplitRows@cocos2d@@SAPEAV12@MPEAVCCScene@2@@Z"]
    pub fn cocos2d_CCTransitionSplitRows_create(
        t: f32,
        scene: *mut cocos2d_CCScene,
    ) -> *mut cocos2d_CCTransitionSplitRows;
}
extern "C" {
    #[doc = "  @js ctor"]
    #[link_name = "\u{1}??0CCTransitionSplitRows@cocos2d@@QEAA@XZ"]
    pub fn cocos2d_CCTransitionSplitRows_CCTransitionSplitRows(
        this: *mut cocos2d_CCTransitionSplitRows,
    );
}
impl cocos2d_CCTransitionSplitRows {
    #[inline]
    pub unsafe fn create(
        t: f32,
        scene: *mut cocos2d_CCScene,
    ) -> *mut cocos2d_CCTransitionSplitRows {
        cocos2d_CCTransitionSplitRows_create(t, scene)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cocos2d_CCTransitionSplitRows_CCTransitionSplitRows(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
}
extern "C" {
    #[doc = "  @js NA"]
    #[doc = "  @lua NA"]
    #[link_name = "\u{1}??_DCCTransitionSplitRows@cocos2d@@QEAAXXZ"]
    pub fn cocos2d_CCTransitionSplitRows_CCTransitionSplitRows_destructor(
        this: *mut cocos2d_CCTransitionSplitRows,
    );
}
extern "C" {
    #[link_name = "\u{1}?action@CCTransitionSplitRows@cocos2d@@UEAAPEAVCCActionInterval@2@XZ"]
    pub fn cocos2d_CCTransitionSplitRows_action(
        this: *mut ::std::os::raw::c_void,
    ) -> *mut cocos2d_CCActionInterval;
}
#[doc = " @brief CCTransitionFadeTR:"]
#[doc = "Fade the tiles of the outgoing scene from the left-bottom corner the to top-right corner."]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCTransitionFadeTR {
    pub _base: cocos2d_CCTransitionScene,
    pub _base_1: cocos2d_CCTransitionEaseScene,
}
#[test]
fn bindgen_test_layout_cocos2d_CCTransitionFadeTR() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCTransitionFadeTR>(),
        336usize,
        concat!("Size of: ", stringify!(cocos2d_CCTransitionFadeTR))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCTransitionFadeTR>(),
        8usize,
        concat!("Alignment of ", stringify!(cocos2d_CCTransitionFadeTR))
    );
}
extern "C" {
    #[link_name = "\u{1}?create@CCTransitionFadeTR@cocos2d@@SAPEAV12@MPEAVCCScene@2@@Z"]
    pub fn cocos2d_CCTransitionFadeTR_create(
        t: f32,
        scene: *mut cocos2d_CCScene,
    ) -> *mut cocos2d_CCTransitionFadeTR;
}
extern "C" {
    #[doc = "  @js ctor"]
    #[link_name = "\u{1}??0CCTransitionFadeTR@cocos2d@@QEAA@XZ"]
    pub fn cocos2d_CCTransitionFadeTR_CCTransitionFadeTR(this: *mut cocos2d_CCTransitionFadeTR);
}
impl cocos2d_CCTransitionFadeTR {
    #[inline]
    pub unsafe fn create(t: f32, scene: *mut cocos2d_CCScene) -> *mut cocos2d_CCTransitionFadeTR {
        cocos2d_CCTransitionFadeTR_create(t, scene)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cocos2d_CCTransitionFadeTR_CCTransitionFadeTR(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
}
extern "C" {
    #[doc = "  @js NA"]
    #[doc = "  @lua NA"]
    #[link_name = "\u{1}??_DCCTransitionFadeTR@cocos2d@@QEAAXXZ"]
    pub fn cocos2d_CCTransitionFadeTR_CCTransitionFadeTR_destructor(
        this: *mut cocos2d_CCTransitionFadeTR,
    );
}
extern "C" {
    #[link_name = "\u{1}?actionWithSize@CCTransitionFadeTR@cocos2d@@UEAAPEAVCCActionInterval@2@AEBVCCSize@2@@Z"]
    pub fn cocos2d_CCTransitionFadeTR_actionWithSize(
        this: *mut ::std::os::raw::c_void,
        size: *const cocos2d_CCSize,
    ) -> *mut cocos2d_CCActionInterval;
}
extern "C" {
    #[doc = "  @js NA"]
    #[doc = "  @lua NA"]
    #[link_name = "\u{1}?onEnter@CCTransitionFadeTR@cocos2d@@UEAAXXZ"]
    pub fn cocos2d_CCTransitionFadeTR_onEnter(this: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[link_name = "\u{1}?easeActionWithAction@CCTransitionFadeTR@cocos2d@@UEAAPEAVCCActionInterval@2@PEAV32@@Z"]
    pub fn cocos2d_CCTransitionFadeTR_easeActionWithAction(
        this: *mut ::std::os::raw::c_void,
        action: *mut cocos2d_CCActionInterval,
    ) -> *mut cocos2d_CCActionInterval;
}
extern "C" {
    #[link_name = "\u{1}?sceneOrder@CCTransitionFadeTR@cocos2d@@MEAAXXZ"]
    pub fn cocos2d_CCTransitionFadeTR_sceneOrder(this: *mut ::std::os::raw::c_void);
}
#[doc = " @brief CCTransitionFadeBL:"]
#[doc = "Fade the tiles of the outgoing scene from the top-right corner to the bottom-left corner."]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCTransitionFadeBL {
    pub _base: cocos2d_CCTransitionFadeTR,
}
#[test]
fn bindgen_test_layout_cocos2d_CCTransitionFadeBL() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCTransitionFadeBL>(),
        336usize,
        concat!("Size of: ", stringify!(cocos2d_CCTransitionFadeBL))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCTransitionFadeBL>(),
        8usize,
        concat!("Alignment of ", stringify!(cocos2d_CCTransitionFadeBL))
    );
}
extern "C" {
    #[link_name = "\u{1}?create@CCTransitionFadeBL@cocos2d@@SAPEAV12@MPEAVCCScene@2@@Z"]
    pub fn cocos2d_CCTransitionFadeBL_create(
        t: f32,
        scene: *mut cocos2d_CCScene,
    ) -> *mut cocos2d_CCTransitionFadeBL;
}
extern "C" {
    #[doc = "  @js ctor"]
    #[link_name = "\u{1}??0CCTransitionFadeBL@cocos2d@@QEAA@XZ"]
    pub fn cocos2d_CCTransitionFadeBL_CCTransitionFadeBL(this: *mut cocos2d_CCTransitionFadeBL);
}
impl cocos2d_CCTransitionFadeBL {
    #[inline]
    pub unsafe fn create(t: f32, scene: *mut cocos2d_CCScene) -> *mut cocos2d_CCTransitionFadeBL {
        cocos2d_CCTransitionFadeBL_create(t, scene)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cocos2d_CCTransitionFadeBL_CCTransitionFadeBL(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
}
extern "C" {
    #[doc = "  @js NA"]
    #[doc = "  @lua NA"]
    #[link_name = "\u{1}??_DCCTransitionFadeBL@cocos2d@@QEAAXXZ"]
    pub fn cocos2d_CCTransitionFadeBL_CCTransitionFadeBL_destructor(
        this: *mut cocos2d_CCTransitionFadeBL,
    );
}
extern "C" {
    #[link_name = "\u{1}?actionWithSize@CCTransitionFadeBL@cocos2d@@UEAAPEAVCCActionInterval@2@AEBVCCSize@2@@Z"]
    pub fn cocos2d_CCTransitionFadeBL_actionWithSize(
        this: *mut ::std::os::raw::c_void,
        size: *const cocos2d_CCSize,
    ) -> *mut cocos2d_CCActionInterval;
}
#[doc = " @brief CCTransitionFadeUp:"]
#[doc = " Fade the tiles of the outgoing scene from the bottom to the top."]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCTransitionFadeUp {
    pub _base: cocos2d_CCTransitionFadeTR,
}
#[test]
fn bindgen_test_layout_cocos2d_CCTransitionFadeUp() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCTransitionFadeUp>(),
        336usize,
        concat!("Size of: ", stringify!(cocos2d_CCTransitionFadeUp))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCTransitionFadeUp>(),
        8usize,
        concat!("Alignment of ", stringify!(cocos2d_CCTransitionFadeUp))
    );
}
extern "C" {
    #[link_name = "\u{1}?create@CCTransitionFadeUp@cocos2d@@SAPEAV12@MPEAVCCScene@2@@Z"]
    pub fn cocos2d_CCTransitionFadeUp_create(
        t: f32,
        scene: *mut cocos2d_CCScene,
    ) -> *mut cocos2d_CCTransitionFadeUp;
}
extern "C" {
    #[doc = "  @js ctor"]
    #[link_name = "\u{1}??0CCTransitionFadeUp@cocos2d@@QEAA@XZ"]
    pub fn cocos2d_CCTransitionFadeUp_CCTransitionFadeUp(this: *mut cocos2d_CCTransitionFadeUp);
}
impl cocos2d_CCTransitionFadeUp {
    #[inline]
    pub unsafe fn create(t: f32, scene: *mut cocos2d_CCScene) -> *mut cocos2d_CCTransitionFadeUp {
        cocos2d_CCTransitionFadeUp_create(t, scene)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cocos2d_CCTransitionFadeUp_CCTransitionFadeUp(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
}
extern "C" {
    #[doc = "  @js NA"]
    #[doc = "  @lua NA"]
    #[link_name = "\u{1}??_DCCTransitionFadeUp@cocos2d@@QEAAXXZ"]
    pub fn cocos2d_CCTransitionFadeUp_CCTransitionFadeUp_destructor(
        this: *mut cocos2d_CCTransitionFadeUp,
    );
}
extern "C" {
    #[link_name = "\u{1}?actionWithSize@CCTransitionFadeUp@cocos2d@@UEAAPEAVCCActionInterval@2@AEBVCCSize@2@@Z"]
    pub fn cocos2d_CCTransitionFadeUp_actionWithSize(
        this: *mut ::std::os::raw::c_void,
        size: *const cocos2d_CCSize,
    ) -> *mut cocos2d_CCActionInterval;
}
#[doc = " @brief CCTransitionFadeDown:"]
#[doc = " Fade the tiles of the outgoing scene from the top to the bottom."]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCTransitionFadeDown {
    pub _base: cocos2d_CCTransitionFadeTR,
}
#[test]
fn bindgen_test_layout_cocos2d_CCTransitionFadeDown() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCTransitionFadeDown>(),
        336usize,
        concat!("Size of: ", stringify!(cocos2d_CCTransitionFadeDown))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCTransitionFadeDown>(),
        8usize,
        concat!("Alignment of ", stringify!(cocos2d_CCTransitionFadeDown))
    );
}
extern "C" {
    #[link_name = "\u{1}?create@CCTransitionFadeDown@cocos2d@@SAPEAV12@MPEAVCCScene@2@@Z"]
    pub fn cocos2d_CCTransitionFadeDown_create(
        t: f32,
        scene: *mut cocos2d_CCScene,
    ) -> *mut cocos2d_CCTransitionFadeDown;
}
extern "C" {
    #[doc = "  @js ctor"]
    #[link_name = "\u{1}??0CCTransitionFadeDown@cocos2d@@QEAA@XZ"]
    pub fn cocos2d_CCTransitionFadeDown_CCTransitionFadeDown(
        this: *mut cocos2d_CCTransitionFadeDown,
    );
}
impl cocos2d_CCTransitionFadeDown {
    #[inline]
    pub unsafe fn create(t: f32, scene: *mut cocos2d_CCScene) -> *mut cocos2d_CCTransitionFadeDown {
        cocos2d_CCTransitionFadeDown_create(t, scene)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cocos2d_CCTransitionFadeDown_CCTransitionFadeDown(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
}
extern "C" {
    #[doc = "  @js NA"]
    #[doc = "  @lua NA"]
    #[link_name = "\u{1}??_DCCTransitionFadeDown@cocos2d@@QEAAXXZ"]
    pub fn cocos2d_CCTransitionFadeDown_CCTransitionFadeDown_destructor(
        this: *mut cocos2d_CCTransitionFadeDown,
    );
}
extern "C" {
    #[link_name = "\u{1}?actionWithSize@CCTransitionFadeDown@cocos2d@@UEAAPEAVCCActionInterval@2@AEBVCCSize@2@@Z"]
    pub fn cocos2d_CCTransitionFadeDown_actionWithSize(
        this: *mut ::std::os::raw::c_void,
        size: *const cocos2d_CCSize,
    ) -> *mut cocos2d_CCActionInterval;
}
#[doc = "@brief A transition which peels back the bottom right hand corner of a scene"]
#[doc = "to transition to the scene beneath it simulating a page turn."]
#[doc = ""]
#[doc = "This uses a 3DAction so it's strongly recommended that depth buffering"]
#[doc = "is turned on in CCDirector using:"]
#[doc = ""]
#[doc = "CCDirector::sharedDirector()->setDepthBufferFormat(kDepthBuffer16);"]
#[doc = ""]
#[doc = "@since v0.8.2"]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCTransitionPageTurn {
    pub _base: cocos2d_CCTransitionScene,
    pub m_bBack: bool,
}
#[test]
fn bindgen_test_layout_cocos2d_CCTransitionPageTurn() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCTransitionPageTurn>(),
        336usize,
        concat!("Size of: ", stringify!(cocos2d_CCTransitionPageTurn))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCTransitionPageTurn>(),
        8usize,
        concat!("Alignment of ", stringify!(cocos2d_CCTransitionPageTurn))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cocos2d_CCTransitionPageTurn>())).m_bBack as *const _ as usize
        },
        328usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCTransitionPageTurn),
            "::",
            stringify!(m_bBack)
        )
    );
}
extern "C" {
    #[doc = " Creates a base transition with duration and incoming scene."]
    #[doc = " If back is true then the effect is reversed to appear as if the incoming"]
    #[doc = " scene is being turned from left over the outgoing scene."]
    #[link_name = "\u{1}?create@CCTransitionPageTurn@cocos2d@@SAPEAV12@MPEAVCCScene@2@_N@Z"]
    pub fn cocos2d_CCTransitionPageTurn_create(
        t: f32,
        scene: *mut cocos2d_CCScene,
        backwards: bool,
    ) -> *mut cocos2d_CCTransitionPageTurn;
}
extern "C" {
    #[link_name = "\u{1}?actionWithSize@CCTransitionPageTurn@cocos2d@@QEAAPEAVCCActionInterval@2@AEBVCCSize@2@@Z"]
    pub fn cocos2d_CCTransitionPageTurn_actionWithSize(
        this: *mut cocos2d_CCTransitionPageTurn,
        vector: *const cocos2d_CCSize,
    ) -> *mut cocos2d_CCActionInterval;
}
extern "C" {
    #[doc = "  @js ctor"]
    #[link_name = "\u{1}??0CCTransitionPageTurn@cocos2d@@QEAA@XZ"]
    pub fn cocos2d_CCTransitionPageTurn_CCTransitionPageTurn(
        this: *mut cocos2d_CCTransitionPageTurn,
    );
}
impl cocos2d_CCTransitionPageTurn {
    #[inline]
    pub unsafe fn create(
        t: f32,
        scene: *mut cocos2d_CCScene,
        backwards: bool,
    ) -> *mut cocos2d_CCTransitionPageTurn {
        cocos2d_CCTransitionPageTurn_create(t, scene, backwards)
    }
    #[inline]
    pub unsafe fn actionWithSize(
        &mut self,
        vector: *const cocos2d_CCSize,
    ) -> *mut cocos2d_CCActionInterval {
        cocos2d_CCTransitionPageTurn_actionWithSize(self, vector)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cocos2d_CCTransitionPageTurn_CCTransitionPageTurn(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
}
extern "C" {
    #[doc = "  @js NA"]
    #[doc = "  @lua NA"]
    #[link_name = "\u{1}??_DCCTransitionPageTurn@cocos2d@@QEAAXXZ"]
    pub fn cocos2d_CCTransitionPageTurn_CCTransitionPageTurn_destructor(
        this: *mut cocos2d_CCTransitionPageTurn,
    );
}
extern "C" {
    #[doc = " Creates a base transition with duration and incoming scene."]
    #[doc = " If back is true then the effect is reversed to appear as if the incoming"]
    #[doc = " scene is being turned from left over the outgoing scene."]
    #[link_name = "\u{1}?initWithDuration@CCTransitionPageTurn@cocos2d@@UEAA_NMPEAVCCScene@2@_N@Z"]
    pub fn cocos2d_CCTransitionPageTurn_initWithDuration(
        this: *mut ::std::os::raw::c_void,
        t: f32,
        scene: *mut cocos2d_CCScene,
        backwards: bool,
    ) -> bool;
}
extern "C" {
    #[doc = "  @js NA"]
    #[doc = "  @lua NA"]
    #[link_name = "\u{1}?onEnter@CCTransitionPageTurn@cocos2d@@UEAAXXZ"]
    pub fn cocos2d_CCTransitionPageTurn_onEnter(this: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[link_name = "\u{1}?sceneOrder@CCTransitionPageTurn@cocos2d@@MEAAXXZ"]
    pub fn cocos2d_CCTransitionPageTurn_sceneOrder(this: *mut ::std::os::raw::c_void);
}
#[doc = " @addtogroup transition"]
#[doc = " @{"]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCTransitionProgress {
    pub _base: cocos2d_CCTransitionScene,
    pub m_fTo: f32,
    pub m_fFrom: f32,
    pub m_pSceneToBeModified: *mut cocos2d_CCScene,
}
#[test]
fn bindgen_test_layout_cocos2d_CCTransitionProgress() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCTransitionProgress>(),
        344usize,
        concat!("Size of: ", stringify!(cocos2d_CCTransitionProgress))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCTransitionProgress>(),
        8usize,
        concat!("Alignment of ", stringify!(cocos2d_CCTransitionProgress))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cocos2d_CCTransitionProgress>())).m_fTo as *const _ as usize
        },
        328usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCTransitionProgress),
            "::",
            stringify!(m_fTo)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cocos2d_CCTransitionProgress>())).m_fFrom as *const _ as usize
        },
        332usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCTransitionProgress),
            "::",
            stringify!(m_fFrom)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cocos2d_CCTransitionProgress>())).m_pSceneToBeModified
                as *const _ as usize
        },
        336usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCTransitionProgress),
            "::",
            stringify!(m_pSceneToBeModified)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}?create@CCTransitionProgress@cocos2d@@SAPEAV12@MPEAVCCScene@2@@Z"]
    pub fn cocos2d_CCTransitionProgress_create(
        t: f32,
        scene: *mut cocos2d_CCScene,
    ) -> *mut cocos2d_CCTransitionProgress;
}
extern "C" {
    #[doc = "  @js ctor"]
    #[link_name = "\u{1}??0CCTransitionProgress@cocos2d@@QEAA@XZ"]
    pub fn cocos2d_CCTransitionProgress_CCTransitionProgress(
        this: *mut cocos2d_CCTransitionProgress,
    );
}
impl cocos2d_CCTransitionProgress {
    #[inline]
    pub unsafe fn create(t: f32, scene: *mut cocos2d_CCScene) -> *mut cocos2d_CCTransitionProgress {
        cocos2d_CCTransitionProgress_create(t, scene)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cocos2d_CCTransitionProgress_CCTransitionProgress(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
}
extern "C" {
    #[doc = "  @js NA"]
    #[doc = "  @lua NA"]
    #[link_name = "\u{1}?onEnter@CCTransitionProgress@cocos2d@@UEAAXXZ"]
    pub fn cocos2d_CCTransitionProgress_onEnter(this: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[doc = "  @js NA"]
    #[doc = "  @lua NA"]
    #[link_name = "\u{1}?onExit@CCTransitionProgress@cocos2d@@UEAAXXZ"]
    pub fn cocos2d_CCTransitionProgress_onExit(this: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[link_name = "\u{1}?progressTimerNodeWithRenderTexture@CCTransitionProgress@cocos2d@@MEAAPEAVCCProgressTimer@2@PEAVCCRenderTexture@2@@Z"]
    pub fn cocos2d_CCTransitionProgress_progressTimerNodeWithRenderTexture(
        this: *mut ::std::os::raw::c_void,
        texture: *mut cocos2d_CCRenderTexture,
    ) -> *mut cocos2d_CCProgressTimer;
}
extern "C" {
    #[link_name = "\u{1}?setupTransition@CCTransitionProgress@cocos2d@@MEAAXXZ"]
    pub fn cocos2d_CCTransitionProgress_setupTransition(this: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[link_name = "\u{1}?sceneOrder@CCTransitionProgress@cocos2d@@MEAAXXZ"]
    pub fn cocos2d_CCTransitionProgress_sceneOrder(this: *mut ::std::os::raw::c_void);
}
#[doc = " CCTransitionRadialCCW transition."]
#[doc = "A counter clock-wise radial transition to the next scene"]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCTransitionProgressRadialCCW {
    pub _base: cocos2d_CCTransitionProgress,
}
#[test]
fn bindgen_test_layout_cocos2d_CCTransitionProgressRadialCCW() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCTransitionProgressRadialCCW>(),
        344usize,
        concat!(
            "Size of: ",
            stringify!(cocos2d_CCTransitionProgressRadialCCW)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCTransitionProgressRadialCCW>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(cocos2d_CCTransitionProgressRadialCCW)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}?create@CCTransitionProgressRadialCCW@cocos2d@@SAPEAV12@MPEAVCCScene@2@@Z"]
    pub fn cocos2d_CCTransitionProgressRadialCCW_create(
        t: f32,
        scene: *mut cocos2d_CCScene,
    ) -> *mut cocos2d_CCTransitionProgressRadialCCW;
}
impl cocos2d_CCTransitionProgressRadialCCW {
    #[inline]
    pub unsafe fn create(
        t: f32,
        scene: *mut cocos2d_CCScene,
    ) -> *mut cocos2d_CCTransitionProgressRadialCCW {
        cocos2d_CCTransitionProgressRadialCCW_create(t, scene)
    }
}
extern "C" {
    #[link_name = "\u{1}?progressTimerNodeWithRenderTexture@CCTransitionProgressRadialCCW@cocos2d@@MEAAPEAVCCProgressTimer@2@PEAVCCRenderTexture@2@@Z"]
    pub fn cocos2d_CCTransitionProgressRadialCCW_progressTimerNodeWithRenderTexture(
        this: *mut ::std::os::raw::c_void,
        texture: *mut cocos2d_CCRenderTexture,
    ) -> *mut cocos2d_CCProgressTimer;
}
#[doc = " CCTransitionRadialCW transition."]
#[doc = "A counter clock-wise radial transition to the next scene"]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCTransitionProgressRadialCW {
    pub _base: cocos2d_CCTransitionProgress,
}
#[test]
fn bindgen_test_layout_cocos2d_CCTransitionProgressRadialCW() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCTransitionProgressRadialCW>(),
        344usize,
        concat!(
            "Size of: ",
            stringify!(cocos2d_CCTransitionProgressRadialCW)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCTransitionProgressRadialCW>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(cocos2d_CCTransitionProgressRadialCW)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}?create@CCTransitionProgressRadialCW@cocos2d@@SAPEAV12@MPEAVCCScene@2@@Z"]
    pub fn cocos2d_CCTransitionProgressRadialCW_create(
        t: f32,
        scene: *mut cocos2d_CCScene,
    ) -> *mut cocos2d_CCTransitionProgressRadialCW;
}
impl cocos2d_CCTransitionProgressRadialCW {
    #[inline]
    pub unsafe fn create(
        t: f32,
        scene: *mut cocos2d_CCScene,
    ) -> *mut cocos2d_CCTransitionProgressRadialCW {
        cocos2d_CCTransitionProgressRadialCW_create(t, scene)
    }
}
extern "C" {
    #[link_name = "\u{1}?progressTimerNodeWithRenderTexture@CCTransitionProgressRadialCW@cocos2d@@MEAAPEAVCCProgressTimer@2@PEAVCCRenderTexture@2@@Z"]
    pub fn cocos2d_CCTransitionProgressRadialCW_progressTimerNodeWithRenderTexture(
        this: *mut ::std::os::raw::c_void,
        texture: *mut cocos2d_CCRenderTexture,
    ) -> *mut cocos2d_CCProgressTimer;
}
#[doc = " CCTransitionProgressHorizontal transition."]
#[doc = "A  clock-wise radial transition to the next scene"]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCTransitionProgressHorizontal {
    pub _base: cocos2d_CCTransitionProgress,
}
#[test]
fn bindgen_test_layout_cocos2d_CCTransitionProgressHorizontal() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCTransitionProgressHorizontal>(),
        344usize,
        concat!(
            "Size of: ",
            stringify!(cocos2d_CCTransitionProgressHorizontal)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCTransitionProgressHorizontal>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(cocos2d_CCTransitionProgressHorizontal)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}?create@CCTransitionProgressHorizontal@cocos2d@@SAPEAV12@MPEAVCCScene@2@@Z"]
    pub fn cocos2d_CCTransitionProgressHorizontal_create(
        t: f32,
        scene: *mut cocos2d_CCScene,
    ) -> *mut cocos2d_CCTransitionProgressHorizontal;
}
impl cocos2d_CCTransitionProgressHorizontal {
    #[inline]
    pub unsafe fn create(
        t: f32,
        scene: *mut cocos2d_CCScene,
    ) -> *mut cocos2d_CCTransitionProgressHorizontal {
        cocos2d_CCTransitionProgressHorizontal_create(t, scene)
    }
}
extern "C" {
    #[link_name = "\u{1}?progressTimerNodeWithRenderTexture@CCTransitionProgressHorizontal@cocos2d@@MEAAPEAVCCProgressTimer@2@PEAVCCRenderTexture@2@@Z"]
    pub fn cocos2d_CCTransitionProgressHorizontal_progressTimerNodeWithRenderTexture(
        this: *mut ::std::os::raw::c_void,
        texture: *mut cocos2d_CCRenderTexture,
    ) -> *mut cocos2d_CCProgressTimer;
}
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCTransitionProgressVertical {
    pub _base: cocos2d_CCTransitionProgress,
}
#[test]
fn bindgen_test_layout_cocos2d_CCTransitionProgressVertical() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCTransitionProgressVertical>(),
        344usize,
        concat!(
            "Size of: ",
            stringify!(cocos2d_CCTransitionProgressVertical)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCTransitionProgressVertical>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(cocos2d_CCTransitionProgressVertical)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}?create@CCTransitionProgressVertical@cocos2d@@SAPEAV12@MPEAVCCScene@2@@Z"]
    pub fn cocos2d_CCTransitionProgressVertical_create(
        t: f32,
        scene: *mut cocos2d_CCScene,
    ) -> *mut cocos2d_CCTransitionProgressVertical;
}
impl cocos2d_CCTransitionProgressVertical {
    #[inline]
    pub unsafe fn create(
        t: f32,
        scene: *mut cocos2d_CCScene,
    ) -> *mut cocos2d_CCTransitionProgressVertical {
        cocos2d_CCTransitionProgressVertical_create(t, scene)
    }
}
extern "C" {
    #[link_name = "\u{1}?progressTimerNodeWithRenderTexture@CCTransitionProgressVertical@cocos2d@@MEAAPEAVCCProgressTimer@2@PEAVCCRenderTexture@2@@Z"]
    pub fn cocos2d_CCTransitionProgressVertical_progressTimerNodeWithRenderTexture(
        this: *mut ::std::os::raw::c_void,
        texture: *mut cocos2d_CCRenderTexture,
    ) -> *mut cocos2d_CCProgressTimer;
}
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCTransitionProgressInOut {
    pub _base: cocos2d_CCTransitionProgress,
}
#[test]
fn bindgen_test_layout_cocos2d_CCTransitionProgressInOut() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCTransitionProgressInOut>(),
        344usize,
        concat!("Size of: ", stringify!(cocos2d_CCTransitionProgressInOut))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCTransitionProgressInOut>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(cocos2d_CCTransitionProgressInOut)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}?create@CCTransitionProgressInOut@cocos2d@@SAPEAV12@MPEAVCCScene@2@@Z"]
    pub fn cocos2d_CCTransitionProgressInOut_create(
        t: f32,
        scene: *mut cocos2d_CCScene,
    ) -> *mut cocos2d_CCTransitionProgressInOut;
}
impl cocos2d_CCTransitionProgressInOut {
    #[inline]
    pub unsafe fn create(
        t: f32,
        scene: *mut cocos2d_CCScene,
    ) -> *mut cocos2d_CCTransitionProgressInOut {
        cocos2d_CCTransitionProgressInOut_create(t, scene)
    }
}
extern "C" {
    #[link_name = "\u{1}?progressTimerNodeWithRenderTexture@CCTransitionProgressInOut@cocos2d@@MEAAPEAVCCProgressTimer@2@PEAVCCRenderTexture@2@@Z"]
    pub fn cocos2d_CCTransitionProgressInOut_progressTimerNodeWithRenderTexture(
        this: *mut ::std::os::raw::c_void,
        texture: *mut cocos2d_CCRenderTexture,
    ) -> *mut cocos2d_CCProgressTimer;
}
extern "C" {
    #[link_name = "\u{1}?sceneOrder@CCTransitionProgressInOut@cocos2d@@MEAAXXZ"]
    pub fn cocos2d_CCTransitionProgressInOut_sceneOrder(this: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[link_name = "\u{1}?setupTransition@CCTransitionProgressInOut@cocos2d@@MEAAXXZ"]
    pub fn cocos2d_CCTransitionProgressInOut_setupTransition(this: *mut ::std::os::raw::c_void);
}
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCTransitionProgressOutIn {
    pub _base: cocos2d_CCTransitionProgress,
}
#[test]
fn bindgen_test_layout_cocos2d_CCTransitionProgressOutIn() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCTransitionProgressOutIn>(),
        344usize,
        concat!("Size of: ", stringify!(cocos2d_CCTransitionProgressOutIn))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCTransitionProgressOutIn>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(cocos2d_CCTransitionProgressOutIn)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}?create@CCTransitionProgressOutIn@cocos2d@@SAPEAV12@MPEAVCCScene@2@@Z"]
    pub fn cocos2d_CCTransitionProgressOutIn_create(
        t: f32,
        scene: *mut cocos2d_CCScene,
    ) -> *mut cocos2d_CCTransitionProgressOutIn;
}
impl cocos2d_CCTransitionProgressOutIn {
    #[inline]
    pub unsafe fn create(
        t: f32,
        scene: *mut cocos2d_CCScene,
    ) -> *mut cocos2d_CCTransitionProgressOutIn {
        cocos2d_CCTransitionProgressOutIn_create(t, scene)
    }
}
extern "C" {
    #[link_name = "\u{1}?progressTimerNodeWithRenderTexture@CCTransitionProgressOutIn@cocos2d@@MEAAPEAVCCProgressTimer@2@PEAVCCRenderTexture@2@@Z"]
    pub fn cocos2d_CCTransitionProgressOutIn_progressTimerNodeWithRenderTexture(
        this: *mut ::std::os::raw::c_void,
        texture: *mut cocos2d_CCRenderTexture,
    ) -> *mut cocos2d_CCProgressTimer;
}
#[doc = " @brief CCMenuItem base class"]
#[doc = ""]
#[doc = "  Subclass CCMenuItem (or any subclass) to create your custom CCMenuItem objects."]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCMenuItem {
    pub _base: cocos2d_CCNodeRGBA,
    #[doc = " whether or not the item is selected"]
    #[doc = "@since v0.8.2"]
    pub m_bSelected: bool,
    pub m_bEnabled: bool,
    pub m_pListener: *mut cocos2d_CCObject,
    pub m_pfnSelector: cocos2d_SEL_MenuHandler,
    pub m_nScriptTapHandler: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_cocos2d_CCMenuItem() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCMenuItem>(),
        352usize,
        concat!("Size of: ", stringify!(cocos2d_CCMenuItem))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCMenuItem>(),
        8usize,
        concat!("Alignment of ", stringify!(cocos2d_CCMenuItem))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cocos2d_CCMenuItem>())).m_bSelected as *const _ as usize },
        320usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCMenuItem),
            "::",
            stringify!(m_bSelected)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cocos2d_CCMenuItem>())).m_bEnabled as *const _ as usize },
        321usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCMenuItem),
            "::",
            stringify!(m_bEnabled)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cocos2d_CCMenuItem>())).m_pListener as *const _ as usize },
        328usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCMenuItem),
            "::",
            stringify!(m_pListener)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cocos2d_CCMenuItem>())).m_pfnSelector as *const _ as usize
        },
        336usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCMenuItem),
            "::",
            stringify!(m_pfnSelector)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cocos2d_CCMenuItem>())).m_nScriptTapHandler as *const _ as usize
        },
        344usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCMenuItem),
            "::",
            stringify!(m_nScriptTapHandler)
        )
    );
}
extern "C" {
    #[doc = " Creates a CCMenuItem with no target/selector"]
    #[doc = " @js NA"]
    #[doc = " @lua NA"]
    #[link_name = "\u{1}?create@CCMenuItem@cocos2d@@SAPEAV12@XZ"]
    pub fn cocos2d_CCMenuItem_create() -> *mut cocos2d_CCMenuItem;
}
extern "C" {
    #[doc = " Creates a CCMenuItem with a target/selector"]
    #[link_name = "\u{1}?create@CCMenuItem@cocos2d@@SAPEAV12@PEAVCCObject@2@P832@EAAX0@Z@Z"]
    pub fn cocos2d_CCMenuItem_create1(
        rec: *mut cocos2d_CCObject,
        selector: cocos2d_SEL_MenuHandler,
    ) -> *mut cocos2d_CCMenuItem;
}
extern "C" {
    #[doc = " Initializes a CCMenuItem with a target/selector"]
    #[doc = " @lua NA"]
    #[link_name = "\u{1}?initWithTarget@CCMenuItem@cocos2d@@QEAA_NPEAVCCObject@2@P832@EAAX0@Z@Z"]
    pub fn cocos2d_CCMenuItem_initWithTarget(
        this: *mut cocos2d_CCMenuItem,
        rec: *mut cocos2d_CCObject,
        selector: cocos2d_SEL_MenuHandler,
    ) -> bool;
}
extern "C" {
    #[doc = " Returns the outside box"]
    #[link_name = "\u{1}?rect@CCMenuItem@cocos2d@@QEAA?AVCCRect@2@XZ"]
    pub fn cocos2d_CCMenuItem_rect(this: *mut cocos2d_CCMenuItem) -> cocos2d_CCRect;
}
extern "C" {
    #[doc = " set the target/selector of the menu item"]
    #[link_name = "\u{1}?setTarget@CCMenuItem@cocos2d@@QEAAXPEAVCCObject@2@P832@EAAX0@Z@Z"]
    pub fn cocos2d_CCMenuItem_setTarget(
        this: *mut cocos2d_CCMenuItem,
        rec: *mut cocos2d_CCObject,
        selector: cocos2d_SEL_MenuHandler,
    );
}
impl cocos2d_CCMenuItem {
    #[inline]
    pub unsafe fn create() -> *mut cocos2d_CCMenuItem {
        cocos2d_CCMenuItem_create()
    }
    #[inline]
    pub unsafe fn create1(
        rec: *mut cocos2d_CCObject,
        selector: cocos2d_SEL_MenuHandler,
    ) -> *mut cocos2d_CCMenuItem {
        cocos2d_CCMenuItem_create1(rec, selector)
    }
    #[inline]
    pub unsafe fn initWithTarget(
        &mut self,
        rec: *mut cocos2d_CCObject,
        selector: cocos2d_SEL_MenuHandler,
    ) -> bool {
        cocos2d_CCMenuItem_initWithTarget(self, rec, selector)
    }
    #[inline]
    pub unsafe fn rect(&mut self) -> cocos2d_CCRect {
        cocos2d_CCMenuItem_rect(self)
    }
    #[inline]
    pub unsafe fn setTarget(
        &mut self,
        rec: *mut cocos2d_CCObject,
        selector: cocos2d_SEL_MenuHandler,
    ) {
        cocos2d_CCMenuItem_setTarget(self, rec, selector)
    }
}
extern "C" {
    #[doc = " @js NA"]
    #[doc = " @lua NA"]
    #[link_name = "\u{1}??_DCCMenuItem@cocos2d@@QEAAXXZ"]
    pub fn cocos2d_CCMenuItem_CCMenuItem_destructor(this: *mut cocos2d_CCMenuItem);
}
extern "C" {
    #[doc = " Activate the item"]
    #[link_name = "\u{1}?activate@CCMenuItem@cocos2d@@UEAAXXZ"]
    pub fn cocos2d_CCMenuItem_activate(this: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[doc = " The item was selected (not activated), similar to \"mouse-over\""]
    #[link_name = "\u{1}?selected@CCMenuItem@cocos2d@@UEAAXXZ"]
    pub fn cocos2d_CCMenuItem_selected(this: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[doc = " The item was unselected"]
    #[link_name = "\u{1}?unselected@CCMenuItem@cocos2d@@UEAAXXZ"]
    pub fn cocos2d_CCMenuItem_unselected(this: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[doc = " Register menu handler script function"]
    #[link_name = "\u{1}?registerScriptTapHandler@CCMenuItem@cocos2d@@UEAAXH@Z"]
    pub fn cocos2d_CCMenuItem_registerScriptTapHandler(
        this: *mut ::std::os::raw::c_void,
        nHandler: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}?unregisterScriptTapHandler@CCMenuItem@cocos2d@@UEAAXXZ"]
    pub fn cocos2d_CCMenuItem_unregisterScriptTapHandler(this: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[link_name = "\u{1}?isEnabled@CCMenuItem@cocos2d@@UEAA_NXZ"]
    pub fn cocos2d_CCMenuItem_isEnabled(this: *mut ::std::os::raw::c_void) -> bool;
}
extern "C" {
    #[link_name = "\u{1}?setEnabled@CCMenuItem@cocos2d@@UEAAX_N@Z"]
    pub fn cocos2d_CCMenuItem_setEnabled(this: *mut ::std::os::raw::c_void, value: bool);
}
extern "C" {
    #[link_name = "\u{1}?isSelected@CCMenuItem@cocos2d@@UEAA_NXZ"]
    pub fn cocos2d_CCMenuItem_isSelected(this: *mut ::std::os::raw::c_void) -> bool;
}
#[doc = " @brief An abstract class for \"label\" CCMenuItemLabel items"]
#[doc = "Any CCNode that supports the CCLabelProtocol protocol can be added."]
#[doc = "Supported nodes:"]
#[doc = "- CCBitmapFontAtlas"]
#[doc = "- CCLabelAtlas"]
#[doc = "- CCLabelTTF"]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCMenuItemLabel {
    pub _base: cocos2d_CCMenuItem,
    pub m_tDisabledColor: cocos2d_ccColor3B,
    pub m_pLabel: *mut cocos2d_CCNode,
    pub m_tColorBackup: cocos2d_ccColor3B,
    pub m_fOriginalScale: f32,
}
#[test]
fn bindgen_test_layout_cocos2d_CCMenuItemLabel() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCMenuItemLabel>(),
        376usize,
        concat!("Size of: ", stringify!(cocos2d_CCMenuItemLabel))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCMenuItemLabel>(),
        8usize,
        concat!("Alignment of ", stringify!(cocos2d_CCMenuItemLabel))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cocos2d_CCMenuItemLabel>())).m_tDisabledColor as *const _
                as usize
        },
        352usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCMenuItemLabel),
            "::",
            stringify!(m_tDisabledColor)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cocos2d_CCMenuItemLabel>())).m_pLabel as *const _ as usize
        },
        360usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCMenuItemLabel),
            "::",
            stringify!(m_pLabel)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cocos2d_CCMenuItemLabel>())).m_tColorBackup as *const _ as usize
        },
        368usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCMenuItemLabel),
            "::",
            stringify!(m_tColorBackup)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cocos2d_CCMenuItemLabel>())).m_fOriginalScale as *const _
                as usize
        },
        372usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCMenuItemLabel),
            "::",
            stringify!(m_fOriginalScale)
        )
    );
}
extern "C" {
    #[doc = " creates a CCMenuItemLabel with a Label, target and selector"]
    #[doc = " @lua NA"]
    #[link_name = "\u{1}?create@CCMenuItemLabel@cocos2d@@SAPEAV12@PEAVCCNode@2@PEAVCCObject@2@P842@EAAX1@Z@Z"]
    pub fn cocos2d_CCMenuItemLabel_create(
        label: *mut cocos2d_CCNode,
        target: *mut cocos2d_CCObject,
        selector: cocos2d_SEL_MenuHandler,
    ) -> *mut cocos2d_CCMenuItemLabel;
}
extern "C" {
    #[doc = " creates a CCMenuItemLabel with a Label. Target and selector will be nil"]
    #[link_name = "\u{1}?create@CCMenuItemLabel@cocos2d@@SAPEAV12@PEAVCCNode@2@@Z"]
    pub fn cocos2d_CCMenuItemLabel_create1(
        label: *mut cocos2d_CCNode,
    ) -> *mut cocos2d_CCMenuItemLabel;
}
extern "C" {
    #[doc = " initializes a CCMenuItemLabel with a Label, target and selector"]
    #[link_name = "\u{1}?initWithLabel@CCMenuItemLabel@cocos2d@@QEAA_NPEAVCCNode@2@PEAVCCObject@2@P842@EAAX1@Z@Z"]
    pub fn cocos2d_CCMenuItemLabel_initWithLabel(
        this: *mut cocos2d_CCMenuItemLabel,
        label: *mut cocos2d_CCNode,
        target: *mut cocos2d_CCObject,
        selector: cocos2d_SEL_MenuHandler,
    ) -> bool;
}
extern "C" {
    #[doc = " sets a new string to the inner label"]
    #[link_name = "\u{1}?setString@CCMenuItemLabel@cocos2d@@QEAAXPEBD@Z"]
    pub fn cocos2d_CCMenuItemLabel_setString(
        this: *mut cocos2d_CCMenuItemLabel,
        label: *const ::std::os::raw::c_char,
    );
}
impl cocos2d_CCMenuItemLabel {
    #[inline]
    pub unsafe fn create(
        label: *mut cocos2d_CCNode,
        target: *mut cocos2d_CCObject,
        selector: cocos2d_SEL_MenuHandler,
    ) -> *mut cocos2d_CCMenuItemLabel {
        cocos2d_CCMenuItemLabel_create(label, target, selector)
    }
    #[inline]
    pub unsafe fn create1(label: *mut cocos2d_CCNode) -> *mut cocos2d_CCMenuItemLabel {
        cocos2d_CCMenuItemLabel_create1(label)
    }
    #[inline]
    pub unsafe fn initWithLabel(
        &mut self,
        label: *mut cocos2d_CCNode,
        target: *mut cocos2d_CCObject,
        selector: cocos2d_SEL_MenuHandler,
    ) -> bool {
        cocos2d_CCMenuItemLabel_initWithLabel(self, label, target, selector)
    }
    #[inline]
    pub unsafe fn setString(&mut self, label: *const ::std::os::raw::c_char) {
        cocos2d_CCMenuItemLabel_setString(self, label)
    }
}
extern "C" {
    #[link_name = "\u{1}?getDisabledColor@CCMenuItemLabel@cocos2d@@UEAAAEBU_ccColor3B@2@XZ"]
    pub fn cocos2d_CCMenuItemLabel_getDisabledColor(
        this: *mut ::std::os::raw::c_void,
    ) -> *const cocos2d_ccColor3B;
}
extern "C" {
    #[link_name = "\u{1}?setDisabledColor@CCMenuItemLabel@cocos2d@@UEAAXAEBU_ccColor3B@2@@Z"]
    pub fn cocos2d_CCMenuItemLabel_setDisabledColor(
        this: *mut ::std::os::raw::c_void,
        var: *const cocos2d_ccColor3B,
    );
}
extern "C" {
    #[link_name = "\u{1}?getLabel@CCMenuItemLabel@cocos2d@@UEAAPEAVCCNode@2@XZ"]
    pub fn cocos2d_CCMenuItemLabel_getLabel(
        this: *mut ::std::os::raw::c_void,
    ) -> *mut cocos2d_CCNode;
}
extern "C" {
    #[link_name = "\u{1}?setLabel@CCMenuItemLabel@cocos2d@@UEAAXPEAVCCNode@2@@Z"]
    pub fn cocos2d_CCMenuItemLabel_setLabel(
        this: *mut ::std::os::raw::c_void,
        var: *mut cocos2d_CCNode,
    );
}
extern "C" {
    #[doc = " @js NA"]
    #[doc = " @lua NA"]
    #[link_name = "\u{1}??_DCCMenuItemLabel@cocos2d@@QEAAXXZ"]
    pub fn cocos2d_CCMenuItemLabel_CCMenuItemLabel_destructor(this: *mut cocos2d_CCMenuItemLabel);
}
extern "C" {
    #[link_name = "\u{1}?activate@CCMenuItemLabel@cocos2d@@UEAAXXZ"]
    pub fn cocos2d_CCMenuItemLabel_activate(this: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[link_name = "\u{1}?selected@CCMenuItemLabel@cocos2d@@UEAAXXZ"]
    pub fn cocos2d_CCMenuItemLabel_selected(this: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[link_name = "\u{1}?unselected@CCMenuItemLabel@cocos2d@@UEAAXXZ"]
    pub fn cocos2d_CCMenuItemLabel_unselected(this: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[doc = " Enable or disabled the CCMenuItemFont"]
    #[doc = "@warning setEnabled changes the RGB color of the font"]
    #[link_name = "\u{1}?setEnabled@CCMenuItemLabel@cocos2d@@UEAAX_N@Z"]
    pub fn cocos2d_CCMenuItemLabel_setEnabled(this: *mut ::std::os::raw::c_void, enabled: bool);
}
#[doc = " @brief A CCMenuItemAtlasFont"]
#[doc = "Helper class that creates a MenuItemLabel class with a LabelAtlas"]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCMenuItemAtlasFont {
    pub _base: cocos2d_CCMenuItemLabel,
}
#[test]
fn bindgen_test_layout_cocos2d_CCMenuItemAtlasFont() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCMenuItemAtlasFont>(),
        376usize,
        concat!("Size of: ", stringify!(cocos2d_CCMenuItemAtlasFont))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCMenuItemAtlasFont>(),
        8usize,
        concat!("Alignment of ", stringify!(cocos2d_CCMenuItemAtlasFont))
    );
}
extern "C" {
    #[doc = " creates a menu item from a string and atlas with a target/selector"]
    #[link_name = "\u{1}?create@CCMenuItemAtlasFont@cocos2d@@SAPEAV12@PEBD0HHD@Z"]
    pub fn cocos2d_CCMenuItemAtlasFont_create(
        value: *const ::std::os::raw::c_char,
        charMapFile: *const ::std::os::raw::c_char,
        itemWidth: ::std::os::raw::c_int,
        itemHeight: ::std::os::raw::c_int,
        startCharMap: ::std::os::raw::c_char,
    ) -> *mut cocos2d_CCMenuItemAtlasFont;
}
extern "C" {
    #[doc = " creates a menu item from a string and atlas. Use it with MenuItemToggle"]
    #[doc = " @lua NA"]
    #[link_name = "\u{1}?create@CCMenuItemAtlasFont@cocos2d@@SAPEAV12@PEBD0HHDPEAVCCObject@2@P832@EAAX1@Z@Z"]
    pub fn cocos2d_CCMenuItemAtlasFont_create1(
        value: *const ::std::os::raw::c_char,
        charMapFile: *const ::std::os::raw::c_char,
        itemWidth: ::std::os::raw::c_int,
        itemHeight: ::std::os::raw::c_int,
        startCharMap: ::std::os::raw::c_char,
        target: *mut cocos2d_CCObject,
        selector: cocos2d_SEL_MenuHandler,
    ) -> *mut cocos2d_CCMenuItemAtlasFont;
}
extern "C" {
    #[doc = " initializes a menu item from a string and atlas with a target/selector"]
    #[link_name = "\u{1}?initWithString@CCMenuItemAtlasFont@cocos2d@@QEAA_NPEBD0HHDPEAVCCObject@2@P832@EAAX1@Z@Z"]
    pub fn cocos2d_CCMenuItemAtlasFont_initWithString(
        this: *mut cocos2d_CCMenuItemAtlasFont,
        value: *const ::std::os::raw::c_char,
        charMapFile: *const ::std::os::raw::c_char,
        itemWidth: ::std::os::raw::c_int,
        itemHeight: ::std::os::raw::c_int,
        startCharMap: ::std::os::raw::c_char,
        target: *mut cocos2d_CCObject,
        selector: cocos2d_SEL_MenuHandler,
    ) -> bool;
}
impl cocos2d_CCMenuItemAtlasFont {
    #[inline]
    pub unsafe fn create(
        value: *const ::std::os::raw::c_char,
        charMapFile: *const ::std::os::raw::c_char,
        itemWidth: ::std::os::raw::c_int,
        itemHeight: ::std::os::raw::c_int,
        startCharMap: ::std::os::raw::c_char,
    ) -> *mut cocos2d_CCMenuItemAtlasFont {
        cocos2d_CCMenuItemAtlasFont_create(value, charMapFile, itemWidth, itemHeight, startCharMap)
    }
    #[inline]
    pub unsafe fn create1(
        value: *const ::std::os::raw::c_char,
        charMapFile: *const ::std::os::raw::c_char,
        itemWidth: ::std::os::raw::c_int,
        itemHeight: ::std::os::raw::c_int,
        startCharMap: ::std::os::raw::c_char,
        target: *mut cocos2d_CCObject,
        selector: cocos2d_SEL_MenuHandler,
    ) -> *mut cocos2d_CCMenuItemAtlasFont {
        cocos2d_CCMenuItemAtlasFont_create1(
            value,
            charMapFile,
            itemWidth,
            itemHeight,
            startCharMap,
            target,
            selector,
        )
    }
    #[inline]
    pub unsafe fn initWithString(
        &mut self,
        value: *const ::std::os::raw::c_char,
        charMapFile: *const ::std::os::raw::c_char,
        itemWidth: ::std::os::raw::c_int,
        itemHeight: ::std::os::raw::c_int,
        startCharMap: ::std::os::raw::c_char,
        target: *mut cocos2d_CCObject,
        selector: cocos2d_SEL_MenuHandler,
    ) -> bool {
        cocos2d_CCMenuItemAtlasFont_initWithString(
            self,
            value,
            charMapFile,
            itemWidth,
            itemHeight,
            startCharMap,
            target,
            selector,
        )
    }
}
#[doc = " @brief A CCMenuItemFont"]
#[doc = "Helper class that creates a CCMenuItemLabel class with a Label"]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCMenuItemFont {
    pub _base: cocos2d_CCMenuItemLabel,
    pub m_uFontSize: ::std::os::raw::c_uint,
    pub m_strFontName: std_string,
}
#[test]
fn bindgen_test_layout_cocos2d_CCMenuItemFont() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCMenuItemFont>(),
        416usize,
        concat!("Size of: ", stringify!(cocos2d_CCMenuItemFont))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCMenuItemFont>(),
        8usize,
        concat!("Alignment of ", stringify!(cocos2d_CCMenuItemFont))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cocos2d_CCMenuItemFont>())).m_uFontSize as *const _ as usize
        },
        376usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCMenuItemFont),
            "::",
            stringify!(m_uFontSize)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cocos2d_CCMenuItemFont>())).m_strFontName as *const _ as usize
        },
        384usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCMenuItemFont),
            "::",
            stringify!(m_strFontName)
        )
    );
}
extern "C" {
    #[doc = " set default font size"]
    #[link_name = "\u{1}?setFontSize@CCMenuItemFont@cocos2d@@SAXI@Z"]
    pub fn cocos2d_CCMenuItemFont_setFontSize(s: ::std::os::raw::c_uint);
}
extern "C" {
    #[doc = " get default font size"]
    #[link_name = "\u{1}?fontSize@CCMenuItemFont@cocos2d@@SAIXZ"]
    pub fn cocos2d_CCMenuItemFont_fontSize() -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " set the default font name"]
    #[link_name = "\u{1}?setFontName@CCMenuItemFont@cocos2d@@SAXPEBD@Z"]
    pub fn cocos2d_CCMenuItemFont_setFontName(name: *const ::std::os::raw::c_char);
}
extern "C" {
    #[doc = " get the default font name"]
    #[link_name = "\u{1}?fontName@CCMenuItemFont@cocos2d@@SAPEBDXZ"]
    pub fn cocos2d_CCMenuItemFont_fontName() -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " creates a menu item from a string without target/selector. To be used with CCMenuItemToggle"]
    #[link_name = "\u{1}?create@CCMenuItemFont@cocos2d@@SAPEAV12@PEBD@Z"]
    pub fn cocos2d_CCMenuItemFont_create(
        value: *const ::std::os::raw::c_char,
    ) -> *mut cocos2d_CCMenuItemFont;
}
extern "C" {
    #[doc = " creates a menu item from a string with a target/selector"]
    #[doc = " @lua NA"]
    #[link_name = "\u{1}?create@CCMenuItemFont@cocos2d@@SAPEAV12@PEBDPEAVCCObject@2@P832@EAAX1@Z@Z"]
    pub fn cocos2d_CCMenuItemFont_create1(
        value: *const ::std::os::raw::c_char,
        target: *mut cocos2d_CCObject,
        selector: cocos2d_SEL_MenuHandler,
    ) -> *mut cocos2d_CCMenuItemFont;
}
extern "C" {
    #[doc = " initializes a menu item from a string with a target/selector"]
    #[link_name = "\u{1}?initWithString@CCMenuItemFont@cocos2d@@QEAA_NPEBDPEAVCCObject@2@P832@EAAX1@Z@Z"]
    pub fn cocos2d_CCMenuItemFont_initWithString(
        this: *mut cocos2d_CCMenuItemFont,
        value: *const ::std::os::raw::c_char,
        target: *mut cocos2d_CCObject,
        selector: cocos2d_SEL_MenuHandler,
    ) -> bool;
}
extern "C" {
    #[doc = " set font size"]
    #[doc = " c++ can not overload static and non-static member functions with the same parameter types"]
    #[doc = " so change the name to setFontSizeObj"]
    #[doc = " @js setFontSize"]
    #[link_name = "\u{1}?setFontSizeObj@CCMenuItemFont@cocos2d@@QEAAXI@Z"]
    pub fn cocos2d_CCMenuItemFont_setFontSizeObj(
        this: *mut cocos2d_CCMenuItemFont,
        s: ::std::os::raw::c_uint,
    );
}
extern "C" {
    #[doc = " get font size"]
    #[doc = "  @js fontSize"]
    #[link_name = "\u{1}?fontSizeObj@CCMenuItemFont@cocos2d@@QEAAIXZ"]
    pub fn cocos2d_CCMenuItemFont_fontSizeObj(
        this: *mut cocos2d_CCMenuItemFont,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " set the font name"]
    #[doc = " c++ can not overload static and non-static member functions with the same parameter types"]
    #[doc = " so change the name to setFontNameObj"]
    #[doc = " @js setFontName"]
    #[link_name = "\u{1}?setFontNameObj@CCMenuItemFont@cocos2d@@QEAAXPEBD@Z"]
    pub fn cocos2d_CCMenuItemFont_setFontNameObj(
        this: *mut cocos2d_CCMenuItemFont,
        name: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    #[doc = "  @js fontName"]
    #[link_name = "\u{1}?fontNameObj@CCMenuItemFont@cocos2d@@QEAAPEBDXZ"]
    pub fn cocos2d_CCMenuItemFont_fontNameObj(
        this: *mut cocos2d_CCMenuItemFont,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}?recreateLabel@CCMenuItemFont@cocos2d@@IEAAXXZ"]
    pub fn cocos2d_CCMenuItemFont_recreateLabel(this: *mut cocos2d_CCMenuItemFont);
}
impl cocos2d_CCMenuItemFont {
    #[inline]
    pub unsafe fn setFontSize(s: ::std::os::raw::c_uint) {
        cocos2d_CCMenuItemFont_setFontSize(s)
    }
    #[inline]
    pub unsafe fn fontSize() -> ::std::os::raw::c_uint {
        cocos2d_CCMenuItemFont_fontSize()
    }
    #[inline]
    pub unsafe fn setFontName(name: *const ::std::os::raw::c_char) {
        cocos2d_CCMenuItemFont_setFontName(name)
    }
    #[inline]
    pub unsafe fn fontName() -> *const ::std::os::raw::c_char {
        cocos2d_CCMenuItemFont_fontName()
    }
    #[inline]
    pub unsafe fn create(value: *const ::std::os::raw::c_char) -> *mut cocos2d_CCMenuItemFont {
        cocos2d_CCMenuItemFont_create(value)
    }
    #[inline]
    pub unsafe fn create1(
        value: *const ::std::os::raw::c_char,
        target: *mut cocos2d_CCObject,
        selector: cocos2d_SEL_MenuHandler,
    ) -> *mut cocos2d_CCMenuItemFont {
        cocos2d_CCMenuItemFont_create1(value, target, selector)
    }
    #[inline]
    pub unsafe fn initWithString(
        &mut self,
        value: *const ::std::os::raw::c_char,
        target: *mut cocos2d_CCObject,
        selector: cocos2d_SEL_MenuHandler,
    ) -> bool {
        cocos2d_CCMenuItemFont_initWithString(self, value, target, selector)
    }
    #[inline]
    pub unsafe fn setFontSizeObj(&mut self, s: ::std::os::raw::c_uint) {
        cocos2d_CCMenuItemFont_setFontSizeObj(self, s)
    }
    #[inline]
    pub unsafe fn fontSizeObj(&mut self) -> ::std::os::raw::c_uint {
        cocos2d_CCMenuItemFont_fontSizeObj(self)
    }
    #[inline]
    pub unsafe fn setFontNameObj(&mut self, name: *const ::std::os::raw::c_char) {
        cocos2d_CCMenuItemFont_setFontNameObj(self, name)
    }
    #[inline]
    pub unsafe fn fontNameObj(&mut self) -> *const ::std::os::raw::c_char {
        cocos2d_CCMenuItemFont_fontNameObj(self)
    }
    #[inline]
    pub unsafe fn recreateLabel(&mut self) {
        cocos2d_CCMenuItemFont_recreateLabel(self)
    }
}
#[doc = " @brief CCMenuItemSprite accepts CCNode<CCRGBAProtocol> objects as items."]
#[doc = "The images has 3 different states:"]
#[doc = "- unselected image"]
#[doc = "- selected image"]
#[doc = "- disabled image"]
#[doc = ""]
#[doc = "@since v0.8.0"]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCMenuItemSprite {
    pub _base: cocos2d_CCMenuItem,
    pub m_pNormalImage: *mut cocos2d_CCNode,
    pub m_pSelectedImage: *mut cocos2d_CCNode,
    pub m_pDisabledImage: *mut cocos2d_CCNode,
}
#[test]
fn bindgen_test_layout_cocos2d_CCMenuItemSprite() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCMenuItemSprite>(),
        376usize,
        concat!("Size of: ", stringify!(cocos2d_CCMenuItemSprite))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCMenuItemSprite>(),
        8usize,
        concat!("Alignment of ", stringify!(cocos2d_CCMenuItemSprite))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cocos2d_CCMenuItemSprite>())).m_pNormalImage as *const _ as usize
        },
        352usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCMenuItemSprite),
            "::",
            stringify!(m_pNormalImage)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cocos2d_CCMenuItemSprite>())).m_pSelectedImage as *const _
                as usize
        },
        360usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCMenuItemSprite),
            "::",
            stringify!(m_pSelectedImage)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cocos2d_CCMenuItemSprite>())).m_pDisabledImage as *const _
                as usize
        },
        368usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCMenuItemSprite),
            "::",
            stringify!(m_pDisabledImage)
        )
    );
}
extern "C" {
    #[doc = " creates a menu item with a normal, selected and disabled image"]
    #[link_name = "\u{1}?create@CCMenuItemSprite@cocos2d@@SAPEAV12@PEAVCCNode@2@00@Z"]
    pub fn cocos2d_CCMenuItemSprite_create(
        normalSprite: *mut cocos2d_CCNode,
        selectedSprite: *mut cocos2d_CCNode,
        disabledSprite: *mut cocos2d_CCNode,
    ) -> *mut cocos2d_CCMenuItemSprite;
}
extern "C" {
    #[doc = " creates a menu item with a normal and selected image with target/selector"]
    #[doc = " @lua NA"]
    #[link_name = "\u{1}?create@CCMenuItemSprite@cocos2d@@SAPEAV12@PEAVCCNode@2@0PEAVCCObject@2@P842@EAAX1@Z@Z"]
    pub fn cocos2d_CCMenuItemSprite_create1(
        normalSprite: *mut cocos2d_CCNode,
        selectedSprite: *mut cocos2d_CCNode,
        target: *mut cocos2d_CCObject,
        selector: cocos2d_SEL_MenuHandler,
    ) -> *mut cocos2d_CCMenuItemSprite;
}
extern "C" {
    #[doc = " creates a menu item with a normal,selected  and disabled image with target/selector"]
    #[doc = " @lua NA"]
    #[link_name = "\u{1}?create@CCMenuItemSprite@cocos2d@@SAPEAV12@PEAVCCNode@2@00PEAVCCObject@2@P842@EAAX1@Z@Z"]
    pub fn cocos2d_CCMenuItemSprite_create2(
        normalSprite: *mut cocos2d_CCNode,
        selectedSprite: *mut cocos2d_CCNode,
        disabledSprite: *mut cocos2d_CCNode,
        target: *mut cocos2d_CCObject,
        selector: cocos2d_SEL_MenuHandler,
    ) -> *mut cocos2d_CCMenuItemSprite;
}
extern "C" {
    #[doc = " initializes a menu item with a normal, selected  and disabled image with target/selector"]
    #[link_name = "\u{1}?initWithNormalSprite@CCMenuItemSprite@cocos2d@@QEAA_NPEAVCCNode@2@00PEAVCCObject@2@P842@EAAX1@Z@Z"]
    pub fn cocos2d_CCMenuItemSprite_initWithNormalSprite(
        this: *mut cocos2d_CCMenuItemSprite,
        normalSprite: *mut cocos2d_CCNode,
        selectedSprite: *mut cocos2d_CCNode,
        disabledSprite: *mut cocos2d_CCNode,
        target: *mut cocos2d_CCObject,
        selector: cocos2d_SEL_MenuHandler,
    ) -> bool;
}
impl cocos2d_CCMenuItemSprite {
    #[inline]
    pub unsafe fn create(
        normalSprite: *mut cocos2d_CCNode,
        selectedSprite: *mut cocos2d_CCNode,
        disabledSprite: *mut cocos2d_CCNode,
    ) -> *mut cocos2d_CCMenuItemSprite {
        cocos2d_CCMenuItemSprite_create(normalSprite, selectedSprite, disabledSprite)
    }
    #[inline]
    pub unsafe fn create1(
        normalSprite: *mut cocos2d_CCNode,
        selectedSprite: *mut cocos2d_CCNode,
        target: *mut cocos2d_CCObject,
        selector: cocos2d_SEL_MenuHandler,
    ) -> *mut cocos2d_CCMenuItemSprite {
        cocos2d_CCMenuItemSprite_create1(normalSprite, selectedSprite, target, selector)
    }
    #[inline]
    pub unsafe fn create2(
        normalSprite: *mut cocos2d_CCNode,
        selectedSprite: *mut cocos2d_CCNode,
        disabledSprite: *mut cocos2d_CCNode,
        target: *mut cocos2d_CCObject,
        selector: cocos2d_SEL_MenuHandler,
    ) -> *mut cocos2d_CCMenuItemSprite {
        cocos2d_CCMenuItemSprite_create2(
            normalSprite,
            selectedSprite,
            disabledSprite,
            target,
            selector,
        )
    }
    #[inline]
    pub unsafe fn initWithNormalSprite(
        &mut self,
        normalSprite: *mut cocos2d_CCNode,
        selectedSprite: *mut cocos2d_CCNode,
        disabledSprite: *mut cocos2d_CCNode,
        target: *mut cocos2d_CCObject,
        selector: cocos2d_SEL_MenuHandler,
    ) -> bool {
        cocos2d_CCMenuItemSprite_initWithNormalSprite(
            self,
            normalSprite,
            selectedSprite,
            disabledSprite,
            target,
            selector,
        )
    }
}
extern "C" {
    #[link_name = "\u{1}?getNormalImage@CCMenuItemSprite@cocos2d@@UEAAPEAVCCNode@2@XZ"]
    pub fn cocos2d_CCMenuItemSprite_getNormalImage(
        this: *mut ::std::os::raw::c_void,
    ) -> *mut cocos2d_CCNode;
}
extern "C" {
    #[link_name = "\u{1}?setNormalImage@CCMenuItemSprite@cocos2d@@UEAAXPEAVCCNode@2@@Z"]
    pub fn cocos2d_CCMenuItemSprite_setNormalImage(
        this: *mut ::std::os::raw::c_void,
        var: *mut cocos2d_CCNode,
    );
}
extern "C" {
    #[link_name = "\u{1}?getSelectedImage@CCMenuItemSprite@cocos2d@@UEAAPEAVCCNode@2@XZ"]
    pub fn cocos2d_CCMenuItemSprite_getSelectedImage(
        this: *mut ::std::os::raw::c_void,
    ) -> *mut cocos2d_CCNode;
}
extern "C" {
    #[link_name = "\u{1}?setSelectedImage@CCMenuItemSprite@cocos2d@@UEAAXPEAVCCNode@2@@Z"]
    pub fn cocos2d_CCMenuItemSprite_setSelectedImage(
        this: *mut ::std::os::raw::c_void,
        var: *mut cocos2d_CCNode,
    );
}
extern "C" {
    #[link_name = "\u{1}?getDisabledImage@CCMenuItemSprite@cocos2d@@UEAAPEAVCCNode@2@XZ"]
    pub fn cocos2d_CCMenuItemSprite_getDisabledImage(
        this: *mut ::std::os::raw::c_void,
    ) -> *mut cocos2d_CCNode;
}
extern "C" {
    #[link_name = "\u{1}?setDisabledImage@CCMenuItemSprite@cocos2d@@UEAAXPEAVCCNode@2@@Z"]
    pub fn cocos2d_CCMenuItemSprite_setDisabledImage(
        this: *mut ::std::os::raw::c_void,
        var: *mut cocos2d_CCNode,
    );
}
extern "C" {
    #[doc = "@since v0.99.5"]
    #[link_name = "\u{1}?selected@CCMenuItemSprite@cocos2d@@UEAAXXZ"]
    pub fn cocos2d_CCMenuItemSprite_selected(this: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[link_name = "\u{1}?unselected@CCMenuItemSprite@cocos2d@@UEAAXXZ"]
    pub fn cocos2d_CCMenuItemSprite_unselected(this: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[link_name = "\u{1}?setEnabled@CCMenuItemSprite@cocos2d@@UEAAX_N@Z"]
    pub fn cocos2d_CCMenuItemSprite_setEnabled(this: *mut ::std::os::raw::c_void, bEnabled: bool);
}
extern "C" {
    #[link_name = "\u{1}?updateImagesVisibility@CCMenuItemSprite@cocos2d@@MEAAXXZ"]
    pub fn cocos2d_CCMenuItemSprite_updateImagesVisibility(this: *mut ::std::os::raw::c_void);
}
#[doc = " @brief CCMenuItemImage accepts images as items."]
#[doc = "The images has 3 different states:"]
#[doc = "- unselected image"]
#[doc = "- selected image"]
#[doc = "- disabled image"]
#[doc = ""]
#[doc = "For best results try that all images are of the same size"]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCMenuItemImage {
    pub _base: cocos2d_CCMenuItemSprite,
}
#[test]
fn bindgen_test_layout_cocos2d_CCMenuItemImage() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCMenuItemImage>(),
        376usize,
        concat!("Size of: ", stringify!(cocos2d_CCMenuItemImage))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCMenuItemImage>(),
        8usize,
        concat!("Alignment of ", stringify!(cocos2d_CCMenuItemImage))
    );
}
extern "C" {
    #[doc = " creates a menu item with a normal and selected image"]
    #[link_name = "\u{1}?create@CCMenuItemImage@cocos2d@@SAPEAV12@PEBD0@Z"]
    pub fn cocos2d_CCMenuItemImage_create(
        normalImage: *const ::std::os::raw::c_char,
        selectedImage: *const ::std::os::raw::c_char,
    ) -> *mut cocos2d_CCMenuItemImage;
}
extern "C" {
    #[doc = " creates a menu item with a normal,selected  and disabled image"]
    #[link_name = "\u{1}?create@CCMenuItemImage@cocos2d@@SAPEAV12@PEBD00@Z"]
    pub fn cocos2d_CCMenuItemImage_create1(
        normalImage: *const ::std::os::raw::c_char,
        selectedImage: *const ::std::os::raw::c_char,
        disabledImage: *const ::std::os::raw::c_char,
    ) -> *mut cocos2d_CCMenuItemImage;
}
extern "C" {
    #[doc = " creates a menu item with a normal and selected image with target/selector"]
    #[doc = " @lua NA"]
    #[link_name = "\u{1}?create@CCMenuItemImage@cocos2d@@SAPEAV12@PEBD0PEAVCCObject@2@P832@EAAX1@Z@Z"]
    pub fn cocos2d_CCMenuItemImage_create2(
        normalImage: *const ::std::os::raw::c_char,
        selectedImage: *const ::std::os::raw::c_char,
        target: *mut cocos2d_CCObject,
        selector: cocos2d_SEL_MenuHandler,
    ) -> *mut cocos2d_CCMenuItemImage;
}
extern "C" {
    #[doc = " creates a menu item with a normal,selected  and disabled image with target/selector"]
    #[doc = " @lua NA"]
    #[link_name = "\u{1}?create@CCMenuItemImage@cocos2d@@SAPEAV12@PEBD00PEAVCCObject@2@P832@EAAX1@Z@Z"]
    pub fn cocos2d_CCMenuItemImage_create3(
        normalImage: *const ::std::os::raw::c_char,
        selectedImage: *const ::std::os::raw::c_char,
        disabledImage: *const ::std::os::raw::c_char,
        target: *mut cocos2d_CCObject,
        selector: cocos2d_SEL_MenuHandler,
    ) -> *mut cocos2d_CCMenuItemImage;
}
extern "C" {
    #[doc = " initializes a menu item with a normal, selected  and disabled image with target/selector"]
    #[link_name = "\u{1}?initWithNormalImage@CCMenuItemImage@cocos2d@@QEAA_NPEBD00PEAVCCObject@2@P832@EAAX1@Z@Z"]
    pub fn cocos2d_CCMenuItemImage_initWithNormalImage(
        this: *mut cocos2d_CCMenuItemImage,
        normalImage: *const ::std::os::raw::c_char,
        selectedImage: *const ::std::os::raw::c_char,
        disabledImage: *const ::std::os::raw::c_char,
        target: *mut cocos2d_CCObject,
        selector: cocos2d_SEL_MenuHandler,
    ) -> bool;
}
extern "C" {
    #[doc = " sets the sprite frame for the normal image"]
    #[link_name = "\u{1}?setNormalSpriteFrame@CCMenuItemImage@cocos2d@@QEAAXPEAVCCSpriteFrame@2@@Z"]
    pub fn cocos2d_CCMenuItemImage_setNormalSpriteFrame(
        this: *mut cocos2d_CCMenuItemImage,
        frame: *mut cocos2d_CCSpriteFrame,
    );
}
extern "C" {
    #[doc = " sets the sprite frame for the selected image"]
    #[link_name = "\u{1}?setSelectedSpriteFrame@CCMenuItemImage@cocos2d@@QEAAXPEAVCCSpriteFrame@2@@Z"]
    pub fn cocos2d_CCMenuItemImage_setSelectedSpriteFrame(
        this: *mut cocos2d_CCMenuItemImage,
        frame: *mut cocos2d_CCSpriteFrame,
    );
}
extern "C" {
    #[doc = " sets the sprite frame for the disabled image"]
    #[link_name = "\u{1}?setDisabledSpriteFrame@CCMenuItemImage@cocos2d@@QEAAXPEAVCCSpriteFrame@2@@Z"]
    pub fn cocos2d_CCMenuItemImage_setDisabledSpriteFrame(
        this: *mut cocos2d_CCMenuItemImage,
        frame: *mut cocos2d_CCSpriteFrame,
    );
}
extern "C" {
    #[doc = " Creates an CCMenuItemImage."]
    #[doc = " @js NA"]
    #[link_name = "\u{1}?create@CCMenuItemImage@cocos2d@@SAPEAV12@XZ"]
    pub fn cocos2d_CCMenuItemImage_create4() -> *mut cocos2d_CCMenuItemImage;
}
impl cocos2d_CCMenuItemImage {
    #[inline]
    pub unsafe fn create(
        normalImage: *const ::std::os::raw::c_char,
        selectedImage: *const ::std::os::raw::c_char,
    ) -> *mut cocos2d_CCMenuItemImage {
        cocos2d_CCMenuItemImage_create(normalImage, selectedImage)
    }
    #[inline]
    pub unsafe fn create1(
        normalImage: *const ::std::os::raw::c_char,
        selectedImage: *const ::std::os::raw::c_char,
        disabledImage: *const ::std::os::raw::c_char,
    ) -> *mut cocos2d_CCMenuItemImage {
        cocos2d_CCMenuItemImage_create1(normalImage, selectedImage, disabledImage)
    }
    #[inline]
    pub unsafe fn create2(
        normalImage: *const ::std::os::raw::c_char,
        selectedImage: *const ::std::os::raw::c_char,
        target: *mut cocos2d_CCObject,
        selector: cocos2d_SEL_MenuHandler,
    ) -> *mut cocos2d_CCMenuItemImage {
        cocos2d_CCMenuItemImage_create2(normalImage, selectedImage, target, selector)
    }
    #[inline]
    pub unsafe fn create3(
        normalImage: *const ::std::os::raw::c_char,
        selectedImage: *const ::std::os::raw::c_char,
        disabledImage: *const ::std::os::raw::c_char,
        target: *mut cocos2d_CCObject,
        selector: cocos2d_SEL_MenuHandler,
    ) -> *mut cocos2d_CCMenuItemImage {
        cocos2d_CCMenuItemImage_create3(normalImage, selectedImage, disabledImage, target, selector)
    }
    #[inline]
    pub unsafe fn initWithNormalImage(
        &mut self,
        normalImage: *const ::std::os::raw::c_char,
        selectedImage: *const ::std::os::raw::c_char,
        disabledImage: *const ::std::os::raw::c_char,
        target: *mut cocos2d_CCObject,
        selector: cocos2d_SEL_MenuHandler,
    ) -> bool {
        cocos2d_CCMenuItemImage_initWithNormalImage(
            self,
            normalImage,
            selectedImage,
            disabledImage,
            target,
            selector,
        )
    }
    #[inline]
    pub unsafe fn setNormalSpriteFrame(&mut self, frame: *mut cocos2d_CCSpriteFrame) {
        cocos2d_CCMenuItemImage_setNormalSpriteFrame(self, frame)
    }
    #[inline]
    pub unsafe fn setSelectedSpriteFrame(&mut self, frame: *mut cocos2d_CCSpriteFrame) {
        cocos2d_CCMenuItemImage_setSelectedSpriteFrame(self, frame)
    }
    #[inline]
    pub unsafe fn setDisabledSpriteFrame(&mut self, frame: *mut cocos2d_CCSpriteFrame) {
        cocos2d_CCMenuItemImage_setDisabledSpriteFrame(self, frame)
    }
    #[inline]
    pub unsafe fn create4() -> *mut cocos2d_CCMenuItemImage {
        cocos2d_CCMenuItemImage_create4()
    }
}
extern "C" {
    #[link_name = "\u{1}?init@CCMenuItemImage@cocos2d@@UEAA_NXZ"]
    pub fn cocos2d_CCMenuItemImage_init(this: *mut ::std::os::raw::c_void) -> bool;
}
#[doc = " @brief A CCMenuItemToggle"]
#[doc = "A simple container class that \"toggles\" it's inner items"]
#[doc = "The inner items can be any MenuItem"]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCMenuItemToggle {
    pub _base: cocos2d_CCMenuItem,
    pub m_uSelectedIndex: ::std::os::raw::c_uint,
    pub m_pSubItems: *mut cocos2d_CCArray,
}
#[test]
fn bindgen_test_layout_cocos2d_CCMenuItemToggle() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCMenuItemToggle>(),
        368usize,
        concat!("Size of: ", stringify!(cocos2d_CCMenuItemToggle))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCMenuItemToggle>(),
        8usize,
        concat!("Alignment of ", stringify!(cocos2d_CCMenuItemToggle))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cocos2d_CCMenuItemToggle>())).m_uSelectedIndex as *const _
                as usize
        },
        352usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCMenuItemToggle),
            "::",
            stringify!(m_uSelectedIndex)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cocos2d_CCMenuItemToggle>())).m_pSubItems as *const _ as usize
        },
        360usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCMenuItemToggle),
            "::",
            stringify!(m_pSubItems)
        )
    );
}
extern "C" {
    #[doc = " creates a menu item from a CCArray with a target selector"]
    #[link_name = "\u{1}?createWithTarget@CCMenuItemToggle@cocos2d@@SAPEAV12@PEAVCCObject@2@P832@EAAX0@ZPEAVCCArray@2@@Z"]
    pub fn cocos2d_CCMenuItemToggle_createWithTarget(
        target: *mut cocos2d_CCObject,
        selector: cocos2d_SEL_MenuHandler,
        menuItems: *mut cocos2d_CCArray,
    ) -> *mut cocos2d_CCMenuItemToggle;
}
extern "C" {
    #[doc = " creates a menu item from a list of items with a target/selector"]
    #[link_name = "\u{1}?createWithTarget@CCMenuItemToggle@cocos2d@@SAPEAV12@PEAVCCObject@2@P832@EAAX0@ZPEAVCCMenuItem@2@ZZ"]
    pub fn cocos2d_CCMenuItemToggle_createWithTarget1(
        target: *mut cocos2d_CCObject,
        selector: cocos2d_SEL_MenuHandler,
        item: *mut cocos2d_CCMenuItem,
        ...
    ) -> *mut cocos2d_CCMenuItemToggle;
}
extern "C" {
    #[doc = " creates a menu item with no target/selector and no items"]
    #[doc = " @js NA"]
    #[doc = " @lua NA"]
    #[link_name = "\u{1}?create@CCMenuItemToggle@cocos2d@@SAPEAV12@XZ"]
    pub fn cocos2d_CCMenuItemToggle_create() -> *mut cocos2d_CCMenuItemToggle;
}
extern "C" {
    #[doc = " initializes a menu item from a list of items with a target selector"]
    #[link_name = "\u{1}?initWithTarget@CCMenuItemToggle@cocos2d@@QEAA_NPEAVCCObject@2@P832@EAAX0@ZPEAVCCMenuItem@2@PEAD@Z"]
    pub fn cocos2d_CCMenuItemToggle_initWithTarget(
        this: *mut cocos2d_CCMenuItemToggle,
        target: *mut cocos2d_CCObject,
        selector: cocos2d_SEL_MenuHandler,
        item: *mut cocos2d_CCMenuItem,
        args: va_list,
    ) -> bool;
}
extern "C" {
    #[doc = " creates a menu item with a item"]
    #[link_name = "\u{1}?create@CCMenuItemToggle@cocos2d@@SAPEAV12@PEAVCCMenuItem@2@@Z"]
    pub fn cocos2d_CCMenuItemToggle_create1(
        item: *mut cocos2d_CCMenuItem,
    ) -> *mut cocos2d_CCMenuItemToggle;
}
extern "C" {
    #[doc = " initializes a menu item with a item"]
    #[link_name = "\u{1}?initWithItem@CCMenuItemToggle@cocos2d@@QEAA_NPEAVCCMenuItem@2@@Z"]
    pub fn cocos2d_CCMenuItemToggle_initWithItem(
        this: *mut cocos2d_CCMenuItemToggle,
        item: *mut cocos2d_CCMenuItem,
    ) -> bool;
}
extern "C" {
    #[doc = " add more menu item"]
    #[link_name = "\u{1}?addSubItem@CCMenuItemToggle@cocos2d@@QEAAXPEAVCCMenuItem@2@@Z"]
    pub fn cocos2d_CCMenuItemToggle_addSubItem(
        this: *mut cocos2d_CCMenuItemToggle,
        item: *mut cocos2d_CCMenuItem,
    );
}
extern "C" {
    #[doc = " return the selected item"]
    #[link_name = "\u{1}?selectedItem@CCMenuItemToggle@cocos2d@@QEAAPEAVCCMenuItem@2@XZ"]
    pub fn cocos2d_CCMenuItemToggle_selectedItem(
        this: *mut cocos2d_CCMenuItemToggle,
    ) -> *mut cocos2d_CCMenuItem;
}
impl cocos2d_CCMenuItemToggle {
    #[inline]
    pub unsafe fn createWithTarget(
        target: *mut cocos2d_CCObject,
        selector: cocos2d_SEL_MenuHandler,
        menuItems: *mut cocos2d_CCArray,
    ) -> *mut cocos2d_CCMenuItemToggle {
        cocos2d_CCMenuItemToggle_createWithTarget(target, selector, menuItems)
    }
    #[inline]
    pub unsafe fn create() -> *mut cocos2d_CCMenuItemToggle {
        cocos2d_CCMenuItemToggle_create()
    }
    #[inline]
    pub unsafe fn initWithTarget(
        &mut self,
        target: *mut cocos2d_CCObject,
        selector: cocos2d_SEL_MenuHandler,
        item: *mut cocos2d_CCMenuItem,
        args: va_list,
    ) -> bool {
        cocos2d_CCMenuItemToggle_initWithTarget(self, target, selector, item, args)
    }
    #[inline]
    pub unsafe fn create1(item: *mut cocos2d_CCMenuItem) -> *mut cocos2d_CCMenuItemToggle {
        cocos2d_CCMenuItemToggle_create1(item)
    }
    #[inline]
    pub unsafe fn initWithItem(&mut self, item: *mut cocos2d_CCMenuItem) -> bool {
        cocos2d_CCMenuItemToggle_initWithItem(self, item)
    }
    #[inline]
    pub unsafe fn addSubItem(&mut self, item: *mut cocos2d_CCMenuItem) {
        cocos2d_CCMenuItemToggle_addSubItem(self, item)
    }
    #[inline]
    pub unsafe fn selectedItem(&mut self) -> *mut cocos2d_CCMenuItem {
        cocos2d_CCMenuItemToggle_selectedItem(self)
    }
}
extern "C" {
    #[link_name = "\u{1}?getSelectedIndex@CCMenuItemToggle@cocos2d@@UEAAIXZ"]
    pub fn cocos2d_CCMenuItemToggle_getSelectedIndex(
        this: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[link_name = "\u{1}?setSelectedIndex@CCMenuItemToggle@cocos2d@@UEAAXI@Z"]
    pub fn cocos2d_CCMenuItemToggle_setSelectedIndex(
        this: *mut ::std::os::raw::c_void,
        var: ::std::os::raw::c_uint,
    );
}
extern "C" {
    #[link_name = "\u{1}?getSubItems@CCMenuItemToggle@cocos2d@@UEAAPEAVCCArray@2@XZ"]
    pub fn cocos2d_CCMenuItemToggle_getSubItems(
        this: *mut ::std::os::raw::c_void,
    ) -> *mut cocos2d_CCArray;
}
extern "C" {
    #[link_name = "\u{1}?setSubItems@CCMenuItemToggle@cocos2d@@UEAAXPEAVCCArray@2@@Z"]
    pub fn cocos2d_CCMenuItemToggle_setSubItems(
        this: *mut ::std::os::raw::c_void,
        var: *mut cocos2d_CCArray,
    );
}
extern "C" {
    #[doc = " @js NA"]
    #[doc = " @lua NA"]
    #[link_name = "\u{1}??_DCCMenuItemToggle@cocos2d@@QEAAXXZ"]
    pub fn cocos2d_CCMenuItemToggle_CCMenuItemToggle_destructor(
        this: *mut cocos2d_CCMenuItemToggle,
    );
}
extern "C" {
    #[link_name = "\u{1}?activate@CCMenuItemToggle@cocos2d@@UEAAXXZ"]
    pub fn cocos2d_CCMenuItemToggle_activate(this: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[link_name = "\u{1}?selected@CCMenuItemToggle@cocos2d@@UEAAXXZ"]
    pub fn cocos2d_CCMenuItemToggle_selected(this: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[link_name = "\u{1}?unselected@CCMenuItemToggle@cocos2d@@UEAAXXZ"]
    pub fn cocos2d_CCMenuItemToggle_unselected(this: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[link_name = "\u{1}?setEnabled@CCMenuItemToggle@cocos2d@@UEAAX_N@Z"]
    pub fn cocos2d_CCMenuItemToggle_setEnabled(this: *mut ::std::os::raw::c_void, var: bool);
}
pub const cocos2d_tCCMenuState_kCCMenuStateWaiting: cocos2d_tCCMenuState = 0;
pub const cocos2d_tCCMenuState_kCCMenuStateTrackingTouch: cocos2d_tCCMenuState = 1;
#[doc = " @addtogroup GUI"]
#[doc = " @{"]
#[doc = " @addtogroup menu"]
#[doc = " @{"]
pub type cocos2d_tCCMenuState = ::std::os::raw::c_int;
pub const kCCMenuHandlerPriority: ::std::os::raw::c_int = -128;
pub type cocos2d__bindgen_ty_8 = ::std::os::raw::c_int;
#[doc = " @brief A CCMenu"]
#[doc = ""]
#[doc = " Features and Limitation:"]
#[doc = "  - You can add MenuItem objects in runtime using addChild:"]
#[doc = "  - But the only accepted children are MenuItem objects"]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCMenu {
    pub _base: cocos2d_CCLayerRGBA,
    #[doc = " whether or not the menu will receive events"]
    pub m_bEnabled: bool,
    pub m_eState: cocos2d_tCCMenuState,
    pub m_pSelectedItem: *mut cocos2d_CCMenuItem,
}
#[test]
fn bindgen_test_layout_cocos2d_CCMenu() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCMenu>(),
        416usize,
        concat!("Size of: ", stringify!(cocos2d_CCMenu))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCMenu>(),
        8usize,
        concat!("Alignment of ", stringify!(cocos2d_CCMenu))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cocos2d_CCMenu>())).m_bEnabled as *const _ as usize },
        400usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCMenu),
            "::",
            stringify!(m_bEnabled)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cocos2d_CCMenu>())).m_eState as *const _ as usize },
        404usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCMenu),
            "::",
            stringify!(m_eState)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cocos2d_CCMenu>())).m_pSelectedItem as *const _ as usize },
        408usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCMenu),
            "::",
            stringify!(m_pSelectedItem)
        )
    );
}
extern "C" {
    #[doc = " creates an empty CCMenu"]
    #[link_name = "\u{1}?create@CCMenu@cocos2d@@SAPEAV12@XZ"]
    pub fn cocos2d_CCMenu_create() -> *mut cocos2d_CCMenu;
}
extern "C" {
    #[doc = " creates a CCMenu with CCMenuItem objects"]
    #[doc = " @lua NA"]
    #[link_name = "\u{1}?create@CCMenu@cocos2d@@SAPEAV12@PEAVCCMenuItem@2@ZZ"]
    pub fn cocos2d_CCMenu_create1(item: *mut cocos2d_CCMenuItem, ...) -> *mut cocos2d_CCMenu;
}
extern "C" {
    #[doc = " creates a CCMenu with a CCArray of CCMenuItem objects"]
    #[doc = " @js NA"]
    #[link_name = "\u{1}?createWithArray@CCMenu@cocos2d@@SAPEAV12@PEAVCCArray@2@@Z"]
    pub fn cocos2d_CCMenu_createWithArray(
        pArrayOfItems: *mut cocos2d_CCArray,
    ) -> *mut cocos2d_CCMenu;
}
extern "C" {
    #[doc = " creates a CCMenu with it's item, then use addChild() to add"]
    #[doc = " other items. It is used for script, it can't init with undetermined"]
    #[doc = " number of variables."]
    #[doc = " @js NA"]
    #[link_name = "\u{1}?createWithItem@CCMenu@cocos2d@@SAPEAV12@PEAVCCMenuItem@2@@Z"]
    pub fn cocos2d_CCMenu_createWithItem(item: *mut cocos2d_CCMenuItem) -> *mut cocos2d_CCMenu;
}
extern "C" {
    #[doc = " creates a CCMenu with CCMenuItem objects"]
    #[doc = " @js NA"]
    #[doc = " @lua NA"]
    #[link_name = "\u{1}?createWithItems@CCMenu@cocos2d@@SAPEAV12@PEAVCCMenuItem@2@PEAD@Z"]
    pub fn cocos2d_CCMenu_createWithItems(
        firstItem: *mut cocos2d_CCMenuItem,
        args: va_list,
    ) -> *mut cocos2d_CCMenu;
}
extern "C" {
    #[doc = " initializes a CCMenu with a NSArray of CCMenuItem objects"]
    #[doc = " @lua NA"]
    #[link_name = "\u{1}?initWithArray@CCMenu@cocos2d@@QEAA_NPEAVCCArray@2@@Z"]
    pub fn cocos2d_CCMenu_initWithArray(
        this: *mut cocos2d_CCMenu,
        pArrayOfItems: *mut cocos2d_CCArray,
    ) -> bool;
}
extern "C" {
    #[doc = " align items vertically"]
    #[link_name = "\u{1}?alignItemsVertically@CCMenu@cocos2d@@QEAAXXZ"]
    pub fn cocos2d_CCMenu_alignItemsVertically(this: *mut cocos2d_CCMenu);
}
extern "C" {
    #[doc = " align items vertically with padding"]
    #[doc = "@since v0.7.2"]
    #[link_name = "\u{1}?alignItemsVerticallyWithPadding@CCMenu@cocos2d@@QEAAXM@Z"]
    pub fn cocos2d_CCMenu_alignItemsVerticallyWithPadding(this: *mut cocos2d_CCMenu, padding: f32);
}
extern "C" {
    #[doc = " align items horizontally"]
    #[link_name = "\u{1}?alignItemsHorizontally@CCMenu@cocos2d@@QEAAXXZ"]
    pub fn cocos2d_CCMenu_alignItemsHorizontally(this: *mut cocos2d_CCMenu);
}
extern "C" {
    #[doc = " align items horizontally with padding"]
    #[doc = "@since v0.7.2"]
    #[link_name = "\u{1}?alignItemsHorizontallyWithPadding@CCMenu@cocos2d@@QEAAXM@Z"]
    pub fn cocos2d_CCMenu_alignItemsHorizontallyWithPadding(
        this: *mut cocos2d_CCMenu,
        padding: f32,
    );
}
extern "C" {
    #[doc = " align items in rows of columns"]
    #[doc = " @code"]
    #[doc = " when this function bound to js,the input params are changed"]
    #[doc = " js:var alignItemsInColumns(...)"]
    #[doc = " @endcode"]
    #[doc = " @lua NA"]
    #[link_name = "\u{1}?alignItemsInColumns@CCMenu@cocos2d@@QEAAXIZZ"]
    pub fn cocos2d_CCMenu_alignItemsInColumns(
        this: *mut cocos2d_CCMenu,
        columns: ::std::os::raw::c_uint,
        ...
    );
}
extern "C" {
    #[doc = " @js NA"]
    #[doc = " @lua NA"]
    #[link_name = "\u{1}?alignItemsInColumns@CCMenu@cocos2d@@QEAAXIPEAD@Z"]
    pub fn cocos2d_CCMenu_alignItemsInColumns1(
        this: *mut cocos2d_CCMenu,
        columns: ::std::os::raw::c_uint,
        args: va_list,
    );
}
extern "C" {
    #[doc = " @js NA"]
    #[link_name = "\u{1}?alignItemsInColumnsWithArray@CCMenu@cocos2d@@QEAAXPEAVCCArray@2@@Z"]
    pub fn cocos2d_CCMenu_alignItemsInColumnsWithArray(
        this: *mut cocos2d_CCMenu,
        rows: *mut cocos2d_CCArray,
    );
}
extern "C" {
    #[doc = " align items in columns of rows"]
    #[doc = " @code"]
    #[doc = " when this function bound to js,the input params are changed"]
    #[doc = " js:var alignItemsInRows(...)"]
    #[doc = " @endcode"]
    #[doc = " @lua NA"]
    #[link_name = "\u{1}?alignItemsInRows@CCMenu@cocos2d@@QEAAXIZZ"]
    pub fn cocos2d_CCMenu_alignItemsInRows(
        this: *mut cocos2d_CCMenu,
        rows: ::std::os::raw::c_uint,
        ...
    );
}
extern "C" {
    #[doc = " @js NA"]
    #[doc = " @lua NA"]
    #[link_name = "\u{1}?alignItemsInRows@CCMenu@cocos2d@@QEAAXIPEAD@Z"]
    pub fn cocos2d_CCMenu_alignItemsInRows1(
        this: *mut cocos2d_CCMenu,
        rows: ::std::os::raw::c_uint,
        args: va_list,
    );
}
extern "C" {
    #[doc = " @js NA"]
    #[link_name = "\u{1}?alignItemsInRowsWithArray@CCMenu@cocos2d@@QEAAXPEAVCCArray@2@@Z"]
    pub fn cocos2d_CCMenu_alignItemsInRowsWithArray(
        this: *mut cocos2d_CCMenu,
        columns: *mut cocos2d_CCArray,
    );
}
extern "C" {
    #[doc = " set event handler priority. By default it is: kCCMenuTouchPriority"]
    #[link_name = "\u{1}?setHandlerPriority@CCMenu@cocos2d@@QEAAXH@Z"]
    pub fn cocos2d_CCMenu_setHandlerPriority(
        this: *mut cocos2d_CCMenu,
        newPriority: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}?itemForTouch@CCMenu@cocos2d@@IEAAPEAVCCMenuItem@2@PEAVCCTouch@2@@Z"]
    pub fn cocos2d_CCMenu_itemForTouch(
        this: *mut cocos2d_CCMenu,
        touch: *mut cocos2d_CCTouch,
    ) -> *mut cocos2d_CCMenuItem;
}
impl cocos2d_CCMenu {
    #[inline]
    pub unsafe fn create() -> *mut cocos2d_CCMenu {
        cocos2d_CCMenu_create()
    }
    #[inline]
    pub unsafe fn createWithArray(pArrayOfItems: *mut cocos2d_CCArray) -> *mut cocos2d_CCMenu {
        cocos2d_CCMenu_createWithArray(pArrayOfItems)
    }
    #[inline]
    pub unsafe fn createWithItem(item: *mut cocos2d_CCMenuItem) -> *mut cocos2d_CCMenu {
        cocos2d_CCMenu_createWithItem(item)
    }
    #[inline]
    pub unsafe fn createWithItems(
        firstItem: *mut cocos2d_CCMenuItem,
        args: va_list,
    ) -> *mut cocos2d_CCMenu {
        cocos2d_CCMenu_createWithItems(firstItem, args)
    }
    #[inline]
    pub unsafe fn initWithArray(&mut self, pArrayOfItems: *mut cocos2d_CCArray) -> bool {
        cocos2d_CCMenu_initWithArray(self, pArrayOfItems)
    }
    #[inline]
    pub unsafe fn alignItemsVertically(&mut self) {
        cocos2d_CCMenu_alignItemsVertically(self)
    }
    #[inline]
    pub unsafe fn alignItemsVerticallyWithPadding(&mut self, padding: f32) {
        cocos2d_CCMenu_alignItemsVerticallyWithPadding(self, padding)
    }
    #[inline]
    pub unsafe fn alignItemsHorizontally(&mut self) {
        cocos2d_CCMenu_alignItemsHorizontally(self)
    }
    #[inline]
    pub unsafe fn alignItemsHorizontallyWithPadding(&mut self, padding: f32) {
        cocos2d_CCMenu_alignItemsHorizontallyWithPadding(self, padding)
    }
    #[inline]
    pub unsafe fn alignItemsInColumns(&mut self, columns: ::std::os::raw::c_uint, args: va_list) {
        cocos2d_CCMenu_alignItemsInColumns1(self, columns, args)
    }
    #[inline]
    pub unsafe fn alignItemsInColumnsWithArray(&mut self, rows: *mut cocos2d_CCArray) {
        cocos2d_CCMenu_alignItemsInColumnsWithArray(self, rows)
    }
    #[inline]
    pub unsafe fn alignItemsInRows(&mut self, rows: ::std::os::raw::c_uint, args: va_list) {
        cocos2d_CCMenu_alignItemsInRows1(self, rows, args)
    }
    #[inline]
    pub unsafe fn alignItemsInRowsWithArray(&mut self, columns: *mut cocos2d_CCArray) {
        cocos2d_CCMenu_alignItemsInRowsWithArray(self, columns)
    }
    #[inline]
    pub unsafe fn setHandlerPriority(&mut self, newPriority: ::std::os::raw::c_int) {
        cocos2d_CCMenu_setHandlerPriority(self, newPriority)
    }
    #[inline]
    pub unsafe fn itemForTouch(&mut self, touch: *mut cocos2d_CCTouch) -> *mut cocos2d_CCMenuItem {
        cocos2d_CCMenu_itemForTouch(self, touch)
    }
}
extern "C" {
    #[doc = " initializes an empty CCMenu"]
    #[link_name = "\u{1}?init@CCMenu@cocos2d@@UEAA_NXZ"]
    pub fn cocos2d_CCMenu_init(this: *mut ::std::os::raw::c_void) -> bool;
}
extern "C" {
    #[link_name = "\u{1}?addChild@CCMenu@cocos2d@@UEAAXPEAVCCNode@2@@Z"]
    pub fn cocos2d_CCMenu_addChild(this: *mut ::std::os::raw::c_void, child: *mut cocos2d_CCNode);
}
extern "C" {
    #[link_name = "\u{1}?addChild@CCMenu@cocos2d@@UEAAXPEAVCCNode@2@H@Z"]
    pub fn cocos2d_CCMenu_addChild1(
        this: *mut ::std::os::raw::c_void,
        child: *mut cocos2d_CCNode,
        zOrder: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}?addChild@CCMenu@cocos2d@@UEAAXPEAVCCNode@2@HH@Z"]
    pub fn cocos2d_CCMenu_addChild2(
        this: *mut ::std::os::raw::c_void,
        child: *mut cocos2d_CCNode,
        zOrder: ::std::os::raw::c_int,
        tag: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}?registerWithTouchDispatcher@CCMenu@cocos2d@@UEAAXXZ"]
    pub fn cocos2d_CCMenu_registerWithTouchDispatcher(this: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[link_name = "\u{1}?removeChild@CCMenu@cocos2d@@UEAAXPEAVCCNode@2@_N@Z"]
    pub fn cocos2d_CCMenu_removeChild(
        this: *mut ::std::os::raw::c_void,
        child: *mut cocos2d_CCNode,
        cleanup: bool,
    );
}
extern "C" {
    #[doc = "@brief For phone event handle functions"]
    #[link_name = "\u{1}?ccTouchBegan@CCMenu@cocos2d@@UEAA_NPEAVCCTouch@2@PEAVCCEvent@2@@Z"]
    pub fn cocos2d_CCMenu_ccTouchBegan(
        this: *mut ::std::os::raw::c_void,
        touch: *mut cocos2d_CCTouch,
        event: *mut cocos2d_CCEvent,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}?ccTouchEnded@CCMenu@cocos2d@@UEAAXPEAVCCTouch@2@PEAVCCEvent@2@@Z"]
    pub fn cocos2d_CCMenu_ccTouchEnded(
        this: *mut ::std::os::raw::c_void,
        touch: *mut cocos2d_CCTouch,
        event: *mut cocos2d_CCEvent,
    );
}
extern "C" {
    #[link_name = "\u{1}?ccTouchCancelled@CCMenu@cocos2d@@UEAAXPEAVCCTouch@2@PEAVCCEvent@2@@Z"]
    pub fn cocos2d_CCMenu_ccTouchCancelled(
        this: *mut ::std::os::raw::c_void,
        touch: *mut cocos2d_CCTouch,
        event: *mut cocos2d_CCEvent,
    );
}
extern "C" {
    #[link_name = "\u{1}?ccTouchMoved@CCMenu@cocos2d@@UEAAXPEAVCCTouch@2@PEAVCCEvent@2@@Z"]
    pub fn cocos2d_CCMenu_ccTouchMoved(
        this: *mut ::std::os::raw::c_void,
        touch: *mut cocos2d_CCTouch,
        event: *mut cocos2d_CCEvent,
    );
}
extern "C" {
    #[doc = "@since v0.99.5"]
    #[doc = "override onExit"]
    #[doc = "  @js NA"]
    #[doc = "  @lua NA"]
    #[link_name = "\u{1}?onExit@CCMenu@cocos2d@@UEAAXXZ"]
    pub fn cocos2d_CCMenu_onExit(this: *mut ::std::os::raw::c_void);
}
#[doc = " CCClippingNode is a subclass of CCNode."]
#[doc = "It draws its content (childs) clipped using a stencil."]
#[doc = "The stencil is an other CCNode that will not be drawn."]
#[doc = "The clipping is done using the alpha part of the stencil (adjusted with an alphaThreshold)."]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCClippingNode {
    pub _base: cocos2d_CCNode,
    pub m_pStencil: *mut cocos2d_CCNode,
    pub m_fAlphaThreshold: GLfloat,
    pub m_bInverted: bool,
}
#[test]
fn bindgen_test_layout_cocos2d_CCClippingNode() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCClippingNode>(),
        312usize,
        concat!("Size of: ", stringify!(cocos2d_CCClippingNode))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCClippingNode>(),
        8usize,
        concat!("Alignment of ", stringify!(cocos2d_CCClippingNode))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cocos2d_CCClippingNode>())).m_pStencil as *const _ as usize
        },
        296usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCClippingNode),
            "::",
            stringify!(m_pStencil)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cocos2d_CCClippingNode>())).m_fAlphaThreshold as *const _
                as usize
        },
        304usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCClippingNode),
            "::",
            stringify!(m_fAlphaThreshold)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cocos2d_CCClippingNode>())).m_bInverted as *const _ as usize
        },
        308usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCClippingNode),
            "::",
            stringify!(m_bInverted)
        )
    );
}
extern "C" {
    #[doc = " Creates and initializes a clipping node without a stencil."]
    #[link_name = "\u{1}?create@CCClippingNode@cocos2d@@SAPEAV12@XZ"]
    pub fn cocos2d_CCClippingNode_create() -> *mut cocos2d_CCClippingNode;
}
extern "C" {
    #[doc = " Creates and initializes a clipping node with an other node as its stencil."]
    #[doc = "The stencil node will be retained."]
    #[link_name = "\u{1}?create@CCClippingNode@cocos2d@@SAPEAV12@PEAVCCNode@2@@Z"]
    pub fn cocos2d_CCClippingNode_create1(
        pStencil: *mut cocos2d_CCNode,
    ) -> *mut cocos2d_CCClippingNode;
}
extern "C" {
    #[doc = " The CCNode to use as a stencil to do the clipping."]
    #[doc = "The stencil node will be retained."]
    #[doc = "This default to nil."]
    #[link_name = "\u{1}?getStencil@CCClippingNode@cocos2d@@QEBAPEAVCCNode@2@XZ"]
    pub fn cocos2d_CCClippingNode_getStencil(
        this: *const cocos2d_CCClippingNode,
    ) -> *mut cocos2d_CCNode;
}
extern "C" {
    #[link_name = "\u{1}?setStencil@CCClippingNode@cocos2d@@QEAAXPEAVCCNode@2@@Z"]
    pub fn cocos2d_CCClippingNode_setStencil(
        this: *mut cocos2d_CCClippingNode,
        pStencil: *mut cocos2d_CCNode,
    );
}
extern "C" {
    #[doc = " The alpha threshold."]
    #[doc = "The content is drawn only where the stencil have pixel with alpha greater than the alphaThreshold."]
    #[doc = "Should be a float between 0 and 1."]
    #[doc = "This default to 1 (so alpha test is disabled)."]
    #[link_name = "\u{1}?getAlphaThreshold@CCClippingNode@cocos2d@@QEBAMXZ"]
    pub fn cocos2d_CCClippingNode_getAlphaThreshold(this: *const cocos2d_CCClippingNode)
        -> GLfloat;
}
extern "C" {
    #[link_name = "\u{1}?setAlphaThreshold@CCClippingNode@cocos2d@@QEAAXM@Z"]
    pub fn cocos2d_CCClippingNode_setAlphaThreshold(
        this: *mut cocos2d_CCClippingNode,
        fAlphaThreshold: GLfloat,
    );
}
extern "C" {
    #[doc = " Inverted. If this is set to YES,"]
    #[doc = "the stencil is inverted, so the content is drawn where the stencil is NOT drawn."]
    #[doc = "This default to NO."]
    #[link_name = "\u{1}?isInverted@CCClippingNode@cocos2d@@QEBA_NXZ"]
    pub fn cocos2d_CCClippingNode_isInverted(this: *const cocos2d_CCClippingNode) -> bool;
}
extern "C" {
    #[link_name = "\u{1}?setInverted@CCClippingNode@cocos2d@@QEAAX_N@Z"]
    pub fn cocos2d_CCClippingNode_setInverted(this: *mut cocos2d_CCClippingNode, bInverted: bool);
}
extern "C" {
    #[link_name = "\u{1}??0CCClippingNode@cocos2d@@IEAA@XZ"]
    pub fn cocos2d_CCClippingNode_CCClippingNode(this: *mut cocos2d_CCClippingNode);
}
impl cocos2d_CCClippingNode {
    #[inline]
    pub unsafe fn create() -> *mut cocos2d_CCClippingNode {
        cocos2d_CCClippingNode_create()
    }
    #[inline]
    pub unsafe fn create1(pStencil: *mut cocos2d_CCNode) -> *mut cocos2d_CCClippingNode {
        cocos2d_CCClippingNode_create1(pStencil)
    }
    #[inline]
    pub unsafe fn getStencil(&self) -> *mut cocos2d_CCNode {
        cocos2d_CCClippingNode_getStencil(self)
    }
    #[inline]
    pub unsafe fn setStencil(&mut self, pStencil: *mut cocos2d_CCNode) {
        cocos2d_CCClippingNode_setStencil(self, pStencil)
    }
    #[inline]
    pub unsafe fn getAlphaThreshold(&self) -> GLfloat {
        cocos2d_CCClippingNode_getAlphaThreshold(self)
    }
    #[inline]
    pub unsafe fn setAlphaThreshold(&mut self, fAlphaThreshold: GLfloat) {
        cocos2d_CCClippingNode_setAlphaThreshold(self, fAlphaThreshold)
    }
    #[inline]
    pub unsafe fn isInverted(&self) -> bool {
        cocos2d_CCClippingNode_isInverted(self)
    }
    #[inline]
    pub unsafe fn setInverted(&mut self, bInverted: bool) {
        cocos2d_CCClippingNode_setInverted(self, bInverted)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cocos2d_CCClippingNode_CCClippingNode(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
}
extern "C" {
    #[doc = " @js NA"]
    #[doc = " @lua NA"]
    #[link_name = "\u{1}??_DCCClippingNode@cocos2d@@QEAAXXZ"]
    pub fn cocos2d_CCClippingNode_CCClippingNode_destructor(this: *mut cocos2d_CCClippingNode);
}
extern "C" {
    #[doc = " Initializes a clipping node without a stencil."]
    #[link_name = "\u{1}?init@CCClippingNode@cocos2d@@UEAA_NXZ"]
    pub fn cocos2d_CCClippingNode_init(this: *mut ::std::os::raw::c_void) -> bool;
}
extern "C" {
    #[doc = " Initializes a clipping node with an other node as its stencil."]
    #[doc = "The stencil node will be retained, and its parent will be set to this clipping node."]
    #[link_name = "\u{1}?init@CCClippingNode@cocos2d@@UEAA_NPEAVCCNode@2@@Z"]
    pub fn cocos2d_CCClippingNode_init1(
        this: *mut ::std::os::raw::c_void,
        pStencil: *mut cocos2d_CCNode,
    ) -> bool;
}
extern "C" {
    #[doc = "  @js NA"]
    #[doc = "  @lua NA"]
    #[link_name = "\u{1}?onEnter@CCClippingNode@cocos2d@@UEAAXXZ"]
    pub fn cocos2d_CCClippingNode_onEnter(this: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[doc = "  @js NA"]
    #[doc = "  @lua NA"]
    #[link_name = "\u{1}?onEnterTransitionDidFinish@CCClippingNode@cocos2d@@UEAAXXZ"]
    pub fn cocos2d_CCClippingNode_onEnterTransitionDidFinish(this: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[doc = "  @js NA"]
    #[doc = "  @lua NA"]
    #[link_name = "\u{1}?onExitTransitionDidStart@CCClippingNode@cocos2d@@UEAAXXZ"]
    pub fn cocos2d_CCClippingNode_onExitTransitionDidStart(this: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[doc = "  @js NA"]
    #[doc = "  @lua NA"]
    #[link_name = "\u{1}?onExit@CCClippingNode@cocos2d@@UEAAXXZ"]
    pub fn cocos2d_CCClippingNode_onExit(this: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[link_name = "\u{1}?visit@CCClippingNode@cocos2d@@UEAAXXZ"]
    pub fn cocos2d_CCClippingNode_visit(this: *mut ::std::os::raw::c_void);
}
#[doc = " MotionStreak."]
#[doc = "Creates a trailing path."]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCMotionStreak {
    pub _base: cocos2d_CCNodeRGBA,
    pub _base_1: cocos2d_CCTextureProtocol,
    pub m_bFastMode: bool,
    pub m_bStartingPositionInitialized: bool,
    #[doc = " texture used for the motion streak"]
    pub m_pTexture: *mut cocos2d_CCTexture2D,
    pub m_tBlendFunc: cocos2d_ccBlendFunc,
    pub m_tPositionR: cocos2d_CCPoint,
    pub m_fStroke: f32,
    pub m_fFadeDelta: f32,
    pub m_fMinSeg: f32,
    pub m_uMaxPoints: ::std::os::raw::c_uint,
    pub m_uNuPoints: ::std::os::raw::c_uint,
    pub m_uPreviousNuPoints: ::std::os::raw::c_uint,
    #[doc = " Pointers"]
    pub m_pPointVertexes: *mut cocos2d_CCPoint,
    pub m_pPointState: *mut f32,
    pub m_pVertices: *mut cocos2d_ccVertex2F,
    pub m_pColorPointer: *mut GLubyte,
    pub m_pTexCoords: *mut cocos2d_ccTex2F,
}
#[test]
fn bindgen_test_layout_cocos2d_CCMotionStreak() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCMotionStreak>(),
        424usize,
        concat!("Size of: ", stringify!(cocos2d_CCMotionStreak))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCMotionStreak>(),
        8usize,
        concat!("Alignment of ", stringify!(cocos2d_CCMotionStreak))
    );
}
extern "C" {
    #[doc = " creates and initializes a motion streak with fade in seconds, minimum segments, stroke's width, color, texture filename"]
    #[link_name = "\u{1}?create@CCMotionStreak@cocos2d@@SAPEAV12@MMMAEBU_ccColor3B@2@PEBD@Z"]
    pub fn cocos2d_CCMotionStreak_create(
        fade: f32,
        minSeg: f32,
        stroke: f32,
        color: *const cocos2d_ccColor3B,
        path: *const ::std::os::raw::c_char,
    ) -> *mut cocos2d_CCMotionStreak;
}
extern "C" {
    #[doc = " creates and initializes a motion streak with fade in seconds, minimum segments, stroke's width, color, texture"]
    #[link_name = "\u{1}?create@CCMotionStreak@cocos2d@@SAPEAV12@MMMAEBU_ccColor3B@2@PEAVCCTexture2D@2@@Z"]
    pub fn cocos2d_CCMotionStreak_create1(
        fade: f32,
        minSeg: f32,
        stroke: f32,
        color: *const cocos2d_ccColor3B,
        texture: *mut cocos2d_CCTexture2D,
    ) -> *mut cocos2d_CCMotionStreak;
}
extern "C" {
    #[doc = " initializes a motion streak with fade in seconds, minimum segments, stroke's width, color and texture filename"]
    #[link_name = "\u{1}?initWithFade@CCMotionStreak@cocos2d@@QEAA_NMMMAEBU_ccColor3B@2@PEBD@Z"]
    pub fn cocos2d_CCMotionStreak_initWithFade(
        this: *mut cocos2d_CCMotionStreak,
        fade: f32,
        minSeg: f32,
        stroke: f32,
        color: *const cocos2d_ccColor3B,
        path: *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    #[doc = " initializes a motion streak with fade in seconds, minimum segments, stroke's width, color and texture"]
    #[link_name = "\u{1}?initWithFade@CCMotionStreak@cocos2d@@QEAA_NMMMAEBU_ccColor3B@2@PEAVCCTexture2D@2@@Z"]
    pub fn cocos2d_CCMotionStreak_initWithFade1(
        this: *mut cocos2d_CCMotionStreak,
        fade: f32,
        minSeg: f32,
        stroke: f32,
        color: *const cocos2d_ccColor3B,
        texture: *mut cocos2d_CCTexture2D,
    ) -> bool;
}
extern "C" {
    #[doc = " color used for the tint"]
    #[link_name = "\u{1}?tintWithColor@CCMotionStreak@cocos2d@@QEAAXU_ccColor3B@2@@Z"]
    pub fn cocos2d_CCMotionStreak_tintWithColor(
        this: *mut cocos2d_CCMotionStreak,
        colors: cocos2d_ccColor3B,
    );
}
extern "C" {
    #[doc = " Remove all living segments of the ribbon"]
    #[link_name = "\u{1}?reset@CCMotionStreak@cocos2d@@QEAAXXZ"]
    pub fn cocos2d_CCMotionStreak_reset(this: *mut cocos2d_CCMotionStreak);
}
extern "C" {
    #[doc = " @js ctor"]
    #[link_name = "\u{1}??0CCMotionStreak@cocos2d@@QEAA@XZ"]
    pub fn cocos2d_CCMotionStreak_CCMotionStreak(this: *mut cocos2d_CCMotionStreak);
}
impl cocos2d_CCMotionStreak {
    #[inline]
    pub unsafe fn create(
        fade: f32,
        minSeg: f32,
        stroke: f32,
        color: *const cocos2d_ccColor3B,
        path: *const ::std::os::raw::c_char,
    ) -> *mut cocos2d_CCMotionStreak {
        cocos2d_CCMotionStreak_create(fade, minSeg, stroke, color, path)
    }
    #[inline]
    pub unsafe fn create1(
        fade: f32,
        minSeg: f32,
        stroke: f32,
        color: *const cocos2d_ccColor3B,
        texture: *mut cocos2d_CCTexture2D,
    ) -> *mut cocos2d_CCMotionStreak {
        cocos2d_CCMotionStreak_create1(fade, minSeg, stroke, color, texture)
    }
    #[inline]
    pub unsafe fn initWithFade(
        &mut self,
        fade: f32,
        minSeg: f32,
        stroke: f32,
        color: *const cocos2d_ccColor3B,
        path: *const ::std::os::raw::c_char,
    ) -> bool {
        cocos2d_CCMotionStreak_initWithFade(self, fade, minSeg, stroke, color, path)
    }
    #[inline]
    pub unsafe fn initWithFade1(
        &mut self,
        fade: f32,
        minSeg: f32,
        stroke: f32,
        color: *const cocos2d_ccColor3B,
        texture: *mut cocos2d_CCTexture2D,
    ) -> bool {
        cocos2d_CCMotionStreak_initWithFade1(self, fade, minSeg, stroke, color, texture)
    }
    #[inline]
    pub unsafe fn tintWithColor(&mut self, colors: cocos2d_ccColor3B) {
        cocos2d_CCMotionStreak_tintWithColor(self, colors)
    }
    #[inline]
    pub unsafe fn reset(&mut self) {
        cocos2d_CCMotionStreak_reset(self)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cocos2d_CCMotionStreak_CCMotionStreak(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
}
extern "C" {
    #[doc = " @js NA"]
    #[doc = " @lua NA"]
    #[link_name = "\u{1}??_DCCMotionStreak@cocos2d@@QEAAXXZ"]
    pub fn cocos2d_CCMotionStreak_CCMotionStreak_destructor(this: *mut cocos2d_CCMotionStreak);
}
extern "C" {
    #[doc = " Override super methods"]
    #[link_name = "\u{1}?setPosition@CCMotionStreak@cocos2d@@UEAAXAEBVCCPoint@2@@Z"]
    pub fn cocos2d_CCMotionStreak_setPosition(
        this: *mut ::std::os::raw::c_void,
        position: *const cocos2d_CCPoint,
    );
}
extern "C" {
    #[link_name = "\u{1}?draw@CCMotionStreak@cocos2d@@UEAAXXZ"]
    pub fn cocos2d_CCMotionStreak_draw(this: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[link_name = "\u{1}?update@CCMotionStreak@cocos2d@@UEAAXM@Z"]
    pub fn cocos2d_CCMotionStreak_update(this: *mut ::std::os::raw::c_void, delta: f32);
}
extern "C" {
    #[link_name = "\u{1}?getTexture@CCMotionStreak@cocos2d@@UEAAPEAVCCTexture2D@2@XZ"]
    pub fn cocos2d_CCMotionStreak_getTexture(
        this: *mut ::std::os::raw::c_void,
    ) -> *mut cocos2d_CCTexture2D;
}
extern "C" {
    #[link_name = "\u{1}?setTexture@CCMotionStreak@cocos2d@@UEAAXPEAVCCTexture2D@2@@Z"]
    pub fn cocos2d_CCMotionStreak_setTexture(
        this: *mut ::std::os::raw::c_void,
        texture: *mut cocos2d_CCTexture2D,
    );
}
extern "C" {
    #[doc = " @js NA"]
    #[link_name = "\u{1}?setBlendFunc@CCMotionStreak@cocos2d@@UEAAXU_ccBlendFunc@2@@Z"]
    pub fn cocos2d_CCMotionStreak_setBlendFunc(
        this: *mut ::std::os::raw::c_void,
        blendFunc: cocos2d_ccBlendFunc,
    );
}
extern "C" {
    #[doc = " @js NA"]
    #[link_name = "\u{1}?getBlendFunc@CCMotionStreak@cocos2d@@UEAA?AU_ccBlendFunc@2@XZ"]
    pub fn cocos2d_CCMotionStreak_getBlendFunc(
        this: *mut ::std::os::raw::c_void,
    ) -> cocos2d_ccBlendFunc;
}
extern "C" {
    #[link_name = "\u{1}?getOpacity@CCMotionStreak@cocos2d@@UEAAEXZ"]
    pub fn cocos2d_CCMotionStreak_getOpacity(this: *mut ::std::os::raw::c_void) -> GLubyte;
}
extern "C" {
    #[link_name = "\u{1}?setOpacity@CCMotionStreak@cocos2d@@UEAAXE@Z"]
    pub fn cocos2d_CCMotionStreak_setOpacity(this: *mut ::std::os::raw::c_void, opacity: GLubyte);
}
extern "C" {
    #[link_name = "\u{1}?setOpacityModifyRGB@CCMotionStreak@cocos2d@@UEAAX_N@Z"]
    pub fn cocos2d_CCMotionStreak_setOpacityModifyRGB(
        this: *mut ::std::os::raw::c_void,
        bValue: bool,
    );
}
extern "C" {
    #[link_name = "\u{1}?isOpacityModifyRGB@CCMotionStreak@cocos2d@@UEAA_NXZ"]
    pub fn cocos2d_CCMotionStreak_isOpacityModifyRGB(this: *mut ::std::os::raw::c_void) -> bool;
}
#[doc = " Radial Counter-Clockwise"]
pub const cocos2d_CCProgressTimerType_kCCProgressTimerTypeRadial: cocos2d_CCProgressTimerType = 0;
#[doc = " Bar"]
pub const cocos2d_CCProgressTimerType_kCCProgressTimerTypeBar: cocos2d_CCProgressTimerType = 1;
#[doc = " Types of progress"]
#[doc = "@since v0.99.1"]
pub type cocos2d_CCProgressTimerType = ::std::os::raw::c_int;
#[doc = "@brief CCProgressTimer is a subclass of CCNode."]
#[doc = "It renders the inner sprite according to the percentage."]
#[doc = "The progress can be Radial, Horizontal or vertical."]
#[doc = "@since v0.99.1"]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCProgressTimer {
    pub _base: cocos2d_CCNodeRGBA,
    pub m_eType: cocos2d_CCProgressTimerType,
    pub m_fPercentage: f32,
    pub m_pSprite: *mut cocos2d_CCSprite,
    pub m_nVertexDataCount: ::std::os::raw::c_int,
    pub m_pVertexData: *mut cocos2d_ccV2F_C4B_T2F,
    pub m_tMidpoint: cocos2d_CCPoint,
    pub m_tBarChangeRate: cocos2d_CCPoint,
    pub m_bReverseDirection: bool,
}
#[test]
fn bindgen_test_layout_cocos2d_CCProgressTimer() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCProgressTimer>(),
        376usize,
        concat!("Size of: ", stringify!(cocos2d_CCProgressTimer))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCProgressTimer>(),
        8usize,
        concat!("Alignment of ", stringify!(cocos2d_CCProgressTimer))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cocos2d_CCProgressTimer>())).m_eType as *const _ as usize },
        320usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCProgressTimer),
            "::",
            stringify!(m_eType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cocos2d_CCProgressTimer>())).m_fPercentage as *const _ as usize
        },
        324usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCProgressTimer),
            "::",
            stringify!(m_fPercentage)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cocos2d_CCProgressTimer>())).m_pSprite as *const _ as usize
        },
        328usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCProgressTimer),
            "::",
            stringify!(m_pSprite)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cocos2d_CCProgressTimer>())).m_nVertexDataCount as *const _
                as usize
        },
        336usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCProgressTimer),
            "::",
            stringify!(m_nVertexDataCount)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cocos2d_CCProgressTimer>())).m_pVertexData as *const _ as usize
        },
        344usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCProgressTimer),
            "::",
            stringify!(m_pVertexData)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cocos2d_CCProgressTimer>())).m_tMidpoint as *const _ as usize
        },
        352usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCProgressTimer),
            "::",
            stringify!(m_tMidpoint)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cocos2d_CCProgressTimer>())).m_tBarChangeRate as *const _
                as usize
        },
        360usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCProgressTimer),
            "::",
            stringify!(m_tBarChangeRate)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cocos2d_CCProgressTimer>())).m_bReverseDirection as *const _
                as usize
        },
        368usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCProgressTimer),
            "::",
            stringify!(m_bReverseDirection)
        )
    );
}
extern "C" {
    #[doc = " Initializes a progress timer with the sprite as the shape the timer goes through"]
    #[link_name = "\u{1}?initWithSprite@CCProgressTimer@cocos2d@@QEAA_NPEAVCCSprite@2@@Z"]
    pub fn cocos2d_CCProgressTimer_initWithSprite(
        this: *mut cocos2d_CCProgressTimer,
        sp: *mut cocos2d_CCSprite,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}?setPercentage@CCProgressTimer@cocos2d@@QEAAXM@Z"]
    pub fn cocos2d_CCProgressTimer_setPercentage(
        this: *mut cocos2d_CCProgressTimer,
        fPercentage: f32,
    );
}
extern "C" {
    #[link_name = "\u{1}?setSprite@CCProgressTimer@cocos2d@@QEAAXPEAVCCSprite@2@@Z"]
    pub fn cocos2d_CCProgressTimer_setSprite(
        this: *mut cocos2d_CCProgressTimer,
        pSprite: *mut cocos2d_CCSprite,
    );
}
extern "C" {
    #[link_name = "\u{1}?setType@CCProgressTimer@cocos2d@@QEAAXW4CCProgressTimerType@2@@Z"]
    pub fn cocos2d_CCProgressTimer_setType(
        this: *mut cocos2d_CCProgressTimer,
        type_: cocos2d_CCProgressTimerType,
    );
}
extern "C" {
    #[doc = "  @js setReverseDirection"]
    #[link_name = "\u{1}?setReverseProgress@CCProgressTimer@cocos2d@@QEAAX_N@Z"]
    pub fn cocos2d_CCProgressTimer_setReverseProgress(
        this: *mut cocos2d_CCProgressTimer,
        reverse: bool,
    );
}
extern "C" {
    #[link_name = "\u{1}?setAnchorPoint@CCProgressTimer@cocos2d@@QEAAXVCCPoint@2@@Z"]
    pub fn cocos2d_CCProgressTimer_setAnchorPoint(
        this: *mut cocos2d_CCProgressTimer,
        anchorPoint: cocos2d_CCPoint,
    );
}
extern "C" {
    #[doc = " Creates a progress timer with the sprite as the shape the timer goes through"]
    #[link_name = "\u{1}?create@CCProgressTimer@cocos2d@@SAPEAV12@PEAVCCSprite@2@@Z"]
    pub fn cocos2d_CCProgressTimer_create(
        sp: *mut cocos2d_CCSprite,
    ) -> *mut cocos2d_CCProgressTimer;
}
extern "C" {
    #[link_name = "\u{1}?textureCoordFromAlphaPoint@CCProgressTimer@cocos2d@@IEAA?AU_ccTex2F@2@VCCPoint@2@@Z"]
    pub fn cocos2d_CCProgressTimer_textureCoordFromAlphaPoint(
        this: *mut cocos2d_CCProgressTimer,
        alpha: cocos2d_CCPoint,
    ) -> cocos2d_ccTex2F;
}
extern "C" {
    #[link_name = "\u{1}?vertexFromAlphaPoint@CCProgressTimer@cocos2d@@IEAA?AU_ccVertex2F@2@VCCPoint@2@@Z"]
    pub fn cocos2d_CCProgressTimer_vertexFromAlphaPoint(
        this: *mut cocos2d_CCProgressTimer,
        alpha: cocos2d_CCPoint,
    ) -> cocos2d_ccVertex2F;
}
extern "C" {
    #[link_name = "\u{1}?updateProgress@CCProgressTimer@cocos2d@@IEAAXXZ"]
    pub fn cocos2d_CCProgressTimer_updateProgress(this: *mut cocos2d_CCProgressTimer);
}
extern "C" {
    #[link_name = "\u{1}?updateBar@CCProgressTimer@cocos2d@@IEAAXXZ"]
    pub fn cocos2d_CCProgressTimer_updateBar(this: *mut cocos2d_CCProgressTimer);
}
extern "C" {
    #[link_name = "\u{1}?updateRadial@CCProgressTimer@cocos2d@@IEAAXXZ"]
    pub fn cocos2d_CCProgressTimer_updateRadial(this: *mut cocos2d_CCProgressTimer);
}
extern "C" {
    #[link_name = "\u{1}?updateColor@CCProgressTimer@cocos2d@@IEAAXXZ"]
    pub fn cocos2d_CCProgressTimer_updateColor(this: *mut cocos2d_CCProgressTimer);
}
extern "C" {
    #[link_name = "\u{1}?boundaryTexCoord@CCProgressTimer@cocos2d@@IEAA?AVCCPoint@2@D@Z"]
    pub fn cocos2d_CCProgressTimer_boundaryTexCoord(
        this: *mut cocos2d_CCProgressTimer,
        index: ::std::os::raw::c_char,
    ) -> cocos2d_CCPoint;
}
extern "C" {
    #[doc = " @js ctor"]
    #[link_name = "\u{1}??0CCProgressTimer@cocos2d@@QEAA@XZ"]
    pub fn cocos2d_CCProgressTimer_CCProgressTimer(this: *mut cocos2d_CCProgressTimer);
}
impl cocos2d_CCProgressTimer {
    #[inline]
    pub unsafe fn initWithSprite(&mut self, sp: *mut cocos2d_CCSprite) -> bool {
        cocos2d_CCProgressTimer_initWithSprite(self, sp)
    }
    #[inline]
    pub unsafe fn setPercentage(&mut self, fPercentage: f32) {
        cocos2d_CCProgressTimer_setPercentage(self, fPercentage)
    }
    #[inline]
    pub unsafe fn setSprite(&mut self, pSprite: *mut cocos2d_CCSprite) {
        cocos2d_CCProgressTimer_setSprite(self, pSprite)
    }
    #[inline]
    pub unsafe fn setType(&mut self, type_: cocos2d_CCProgressTimerType) {
        cocos2d_CCProgressTimer_setType(self, type_)
    }
    #[inline]
    pub unsafe fn setReverseProgress(&mut self, reverse: bool) {
        cocos2d_CCProgressTimer_setReverseProgress(self, reverse)
    }
    #[inline]
    pub unsafe fn setAnchorPoint(&mut self, anchorPoint: cocos2d_CCPoint) {
        cocos2d_CCProgressTimer_setAnchorPoint(self, anchorPoint)
    }
    #[inline]
    pub unsafe fn create(sp: *mut cocos2d_CCSprite) -> *mut cocos2d_CCProgressTimer {
        cocos2d_CCProgressTimer_create(sp)
    }
    #[inline]
    pub unsafe fn textureCoordFromAlphaPoint(&mut self, alpha: cocos2d_CCPoint) -> cocos2d_ccTex2F {
        cocos2d_CCProgressTimer_textureCoordFromAlphaPoint(self, alpha)
    }
    #[inline]
    pub unsafe fn vertexFromAlphaPoint(&mut self, alpha: cocos2d_CCPoint) -> cocos2d_ccVertex2F {
        cocos2d_CCProgressTimer_vertexFromAlphaPoint(self, alpha)
    }
    #[inline]
    pub unsafe fn updateProgress(&mut self) {
        cocos2d_CCProgressTimer_updateProgress(self)
    }
    #[inline]
    pub unsafe fn updateBar(&mut self) {
        cocos2d_CCProgressTimer_updateBar(self)
    }
    #[inline]
    pub unsafe fn updateRadial(&mut self) {
        cocos2d_CCProgressTimer_updateRadial(self)
    }
    #[inline]
    pub unsafe fn updateColor(&mut self) {
        cocos2d_CCProgressTimer_updateColor(self)
    }
    #[inline]
    pub unsafe fn boundaryTexCoord(&mut self, index: ::std::os::raw::c_char) -> cocos2d_CCPoint {
        cocos2d_CCProgressTimer_boundaryTexCoord(self, index)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cocos2d_CCProgressTimer_CCProgressTimer(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
}
extern "C" {
    #[doc = " @js NA"]
    #[doc = " @lua NA"]
    #[link_name = "\u{1}??_DCCProgressTimer@cocos2d@@QEAAXXZ"]
    pub fn cocos2d_CCProgressTimer_CCProgressTimer_destructor(this: *mut cocos2d_CCProgressTimer);
}
extern "C" {
    #[link_name = "\u{1}?draw@CCProgressTimer@cocos2d@@UEAAXXZ"]
    pub fn cocos2d_CCProgressTimer_draw(this: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[link_name = "\u{1}?setColor@CCProgressTimer@cocos2d@@UEAAXAEBU_ccColor3B@2@@Z"]
    pub fn cocos2d_CCProgressTimer_setColor(
        this: *mut ::std::os::raw::c_void,
        color: *const cocos2d_ccColor3B,
    );
}
extern "C" {
    #[link_name = "\u{1}?getColor@CCProgressTimer@cocos2d@@UEBAAEBU_ccColor3B@2@XZ"]
    pub fn cocos2d_CCProgressTimer_getColor(
        this: *mut ::std::os::raw::c_void,
    ) -> *const cocos2d_ccColor3B;
}
extern "C" {
    #[link_name = "\u{1}?getOpacity@CCProgressTimer@cocos2d@@UEBAEXZ"]
    pub fn cocos2d_CCProgressTimer_getOpacity(this: *mut ::std::os::raw::c_void) -> GLubyte;
}
extern "C" {
    #[link_name = "\u{1}?setOpacity@CCProgressTimer@cocos2d@@UEAAXE@Z"]
    pub fn cocos2d_CCProgressTimer_setOpacity(this: *mut ::std::os::raw::c_void, opacity: GLubyte);
}
extern "C" {
    #[link_name = "\u{1}?getMidpoint@CCProgressTimer@cocos2d@@UEAA?AVCCPoint@2@XZ"]
    pub fn cocos2d_CCProgressTimer_getMidpoint(
        this: *mut ::std::os::raw::c_void,
    ) -> cocos2d_CCPoint;
}
extern "C" {
    #[link_name = "\u{1}?setMidpoint@CCProgressTimer@cocos2d@@UEAAXVCCPoint@2@@Z"]
    pub fn cocos2d_CCProgressTimer_setMidpoint(
        this: *mut ::std::os::raw::c_void,
        var: cocos2d_CCPoint,
    );
}
pub const cocos2d_eImageFormat_kCCImageFormatJPEG: cocos2d_eImageFormat = 0;
pub const cocos2d_eImageFormat_kCCImageFormatPNG: cocos2d_eImageFormat = 1;
#[doc = " @addtogroup textures"]
#[doc = " @{"]
pub type cocos2d_eImageFormat = ::std::os::raw::c_int;
#[doc = " @addtogroup textures"]
#[doc = " @{"]
pub use self::cocos2d_eImageFormat as cocos2d_tCCImageFormat;
#[doc = "@brief CCRenderTexture is a generic rendering target. To render things into it,"]
#[doc = "simply construct a render target, call begin on it, call visit on any cocos"]
#[doc = "scenes or objects to render them, and call end. For convenience, render texture"]
#[doc = "adds a sprite as it's display child with the results, so you can simply add"]
#[doc = "the render texture to your scene and treat it like any other CocosNode."]
#[doc = "There are also functions for saving the render texture to disk in PNG or JPG format."]
#[doc = ""]
#[doc = "@since v0.8.1"]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCRenderTexture {
    pub _base: cocos2d_CCNode,
    pub m_pSprite: *mut cocos2d_CCSprite,
    pub m_uFBO: GLuint,
    pub m_uDepthRenderBufffer: GLuint,
    pub m_nOldFBO: GLint,
    pub m_pTexture: *mut cocos2d_CCTexture2D,
    pub m_pTextureCopy: *mut cocos2d_CCTexture2D,
    pub m_pUITextureImage: *mut cocos2d_CCImage,
    pub m_ePixelFormat: GLenum,
    pub m_uClearFlags: GLbitfield,
    pub m_sClearColor: cocos2d_ccColor4F,
    pub m_fClearDepth: GLclampf,
    pub m_nClearStencil: GLint,
    pub m_bAutoDraw: bool,
}
#[test]
fn bindgen_test_layout_cocos2d_CCRenderTexture() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCRenderTexture>(),
        384usize,
        concat!("Size of: ", stringify!(cocos2d_CCRenderTexture))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCRenderTexture>(),
        8usize,
        concat!("Alignment of ", stringify!(cocos2d_CCRenderTexture))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cocos2d_CCRenderTexture>())).m_pSprite as *const _ as usize
        },
        296usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCRenderTexture),
            "::",
            stringify!(m_pSprite)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cocos2d_CCRenderTexture>())).m_uFBO as *const _ as usize },
        304usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCRenderTexture),
            "::",
            stringify!(m_uFBO)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cocos2d_CCRenderTexture>())).m_uDepthRenderBufffer as *const _
                as usize
        },
        308usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCRenderTexture),
            "::",
            stringify!(m_uDepthRenderBufffer)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cocos2d_CCRenderTexture>())).m_nOldFBO as *const _ as usize
        },
        312usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCRenderTexture),
            "::",
            stringify!(m_nOldFBO)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cocos2d_CCRenderTexture>())).m_pTexture as *const _ as usize
        },
        320usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCRenderTexture),
            "::",
            stringify!(m_pTexture)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cocos2d_CCRenderTexture>())).m_pTextureCopy as *const _ as usize
        },
        328usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCRenderTexture),
            "::",
            stringify!(m_pTextureCopy)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cocos2d_CCRenderTexture>())).m_pUITextureImage as *const _
                as usize
        },
        336usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCRenderTexture),
            "::",
            stringify!(m_pUITextureImage)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cocos2d_CCRenderTexture>())).m_ePixelFormat as *const _ as usize
        },
        344usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCRenderTexture),
            "::",
            stringify!(m_ePixelFormat)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cocos2d_CCRenderTexture>())).m_uClearFlags as *const _ as usize
        },
        348usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCRenderTexture),
            "::",
            stringify!(m_uClearFlags)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cocos2d_CCRenderTexture>())).m_sClearColor as *const _ as usize
        },
        352usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCRenderTexture),
            "::",
            stringify!(m_sClearColor)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cocos2d_CCRenderTexture>())).m_fClearDepth as *const _ as usize
        },
        368usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCRenderTexture),
            "::",
            stringify!(m_fClearDepth)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cocos2d_CCRenderTexture>())).m_nClearStencil as *const _ as usize
        },
        372usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCRenderTexture),
            "::",
            stringify!(m_nClearStencil)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cocos2d_CCRenderTexture>())).m_bAutoDraw as *const _ as usize
        },
        376usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCRenderTexture),
            "::",
            stringify!(m_bAutoDraw)
        )
    );
}
extern "C" {
    #[doc = " initializes a RenderTexture object with width and height in Points and a pixel format( only RGB and RGBA formats are valid ) and depthStencil format"]
    #[link_name = "\u{1}?create@CCRenderTexture@cocos2d@@SAPEAV12@HHW4CCTexture2DPixelFormat@2@I@Z"]
    pub fn cocos2d_CCRenderTexture_create(
        w: ::std::os::raw::c_int,
        h: ::std::os::raw::c_int,
        eFormat: cocos2d_CCTexture2DPixelFormat,
        uDepthStencilFormat: GLuint,
    ) -> *mut cocos2d_CCRenderTexture;
}
extern "C" {
    #[doc = " creates a RenderTexture object with width and height in Points and a pixel format, only RGB and RGBA formats are valid"]
    #[link_name = "\u{1}?create@CCRenderTexture@cocos2d@@SAPEAV12@HHW4CCTexture2DPixelFormat@2@@Z"]
    pub fn cocos2d_CCRenderTexture_create1(
        w: ::std::os::raw::c_int,
        h: ::std::os::raw::c_int,
        eFormat: cocos2d_CCTexture2DPixelFormat,
    ) -> *mut cocos2d_CCRenderTexture;
}
extern "C" {
    #[doc = " creates a RenderTexture object with width and height in Points, pixel format is RGBA8888"]
    #[link_name = "\u{1}?create@CCRenderTexture@cocos2d@@SAPEAV12@HH@Z"]
    pub fn cocos2d_CCRenderTexture_create2(
        w: ::std::os::raw::c_int,
        h: ::std::os::raw::c_int,
    ) -> *mut cocos2d_CCRenderTexture;
}
extern "C" {
    #[doc = " initializes a RenderTexture object with width and height in Points and a pixel format, only RGB and RGBA formats are valid"]
    #[link_name = "\u{1}?initWithWidthAndHeight@CCRenderTexture@cocos2d@@QEAA_NHHW4CCTexture2DPixelFormat@2@@Z"]
    pub fn cocos2d_CCRenderTexture_initWithWidthAndHeight(
        this: *mut cocos2d_CCRenderTexture,
        w: ::std::os::raw::c_int,
        h: ::std::os::raw::c_int,
        eFormat: cocos2d_CCTexture2DPixelFormat,
    ) -> bool;
}
extern "C" {
    #[doc = " initializes a RenderTexture object with width and height in Points and a pixel format( only RGB and RGBA formats are valid ) and depthStencil format"]
    #[link_name = "\u{1}?initWithWidthAndHeight@CCRenderTexture@cocos2d@@QEAA_NHHW4CCTexture2DPixelFormat@2@I@Z"]
    pub fn cocos2d_CCRenderTexture_initWithWidthAndHeight1(
        this: *mut cocos2d_CCRenderTexture,
        w: ::std::os::raw::c_int,
        h: ::std::os::raw::c_int,
        eFormat: cocos2d_CCTexture2DPixelFormat,
        uDepthStencilFormat: GLuint,
    ) -> bool;
}
extern "C" {
    #[doc = " starts grabbing"]
    #[link_name = "\u{1}?begin@CCRenderTexture@cocos2d@@QEAAXXZ"]
    pub fn cocos2d_CCRenderTexture_begin(this: *mut cocos2d_CCRenderTexture);
}
extern "C" {
    #[doc = " starts rendering to the texture while clearing the texture first."]
    #[doc = "This is more efficient then calling -clear first and then -begin"]
    #[link_name = "\u{1}?beginWithClear@CCRenderTexture@cocos2d@@QEAAXMMMM@Z"]
    pub fn cocos2d_CCRenderTexture_beginWithClear(
        this: *mut cocos2d_CCRenderTexture,
        r: f32,
        g: f32,
        b: f32,
        a: f32,
    );
}
extern "C" {
    #[doc = " starts rendering to the texture while clearing the texture first."]
    #[doc = "This is more efficient then calling -clear first and then -begin"]
    #[link_name = "\u{1}?beginWithClear@CCRenderTexture@cocos2d@@QEAAXMMMMM@Z"]
    pub fn cocos2d_CCRenderTexture_beginWithClear1(
        this: *mut cocos2d_CCRenderTexture,
        r: f32,
        g: f32,
        b: f32,
        a: f32,
        depthValue: f32,
    );
}
extern "C" {
    #[doc = " starts rendering to the texture while clearing the texture first."]
    #[doc = "This is more efficient then calling -clear first and then -begin"]
    #[link_name = "\u{1}?beginWithClear@CCRenderTexture@cocos2d@@QEAAXMMMMMH@Z"]
    pub fn cocos2d_CCRenderTexture_beginWithClear2(
        this: *mut cocos2d_CCRenderTexture,
        r: f32,
        g: f32,
        b: f32,
        a: f32,
        depthValue: f32,
        stencilValue: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " ends grabbing"]
    #[link_name = "\u{1}?end@CCRenderTexture@cocos2d@@QEAAXXZ"]
    pub fn cocos2d_CCRenderTexture_end(this: *mut cocos2d_CCRenderTexture);
}
extern "C" {
    #[doc = " clears the texture with a color"]
    #[link_name = "\u{1}?clear@CCRenderTexture@cocos2d@@QEAAXMMMM@Z"]
    pub fn cocos2d_CCRenderTexture_clear(
        this: *mut cocos2d_CCRenderTexture,
        r: f32,
        g: f32,
        b: f32,
        a: f32,
    );
}
extern "C" {
    #[doc = " clears the texture with a specified depth value"]
    #[link_name = "\u{1}?clearDepth@CCRenderTexture@cocos2d@@QEAAXM@Z"]
    pub fn cocos2d_CCRenderTexture_clearDepth(this: *mut cocos2d_CCRenderTexture, depthValue: f32);
}
extern "C" {
    #[doc = " clears the texture with a specified stencil value"]
    #[link_name = "\u{1}?clearStencil@CCRenderTexture@cocos2d@@QEAAXH@Z"]
    pub fn cocos2d_CCRenderTexture_clearStencil(
        this: *mut cocos2d_CCRenderTexture,
        stencilValue: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}?newCCImage@CCRenderTexture@cocos2d@@QEAAPEAVCCImage@2@_N@Z"]
    pub fn cocos2d_CCRenderTexture_newCCImage(
        this: *mut cocos2d_CCRenderTexture,
        flipImage: bool,
    ) -> *mut cocos2d_CCImage;
}
extern "C" {
    #[doc = " saves the texture into a file using JPEG format. The file will be saved in the Documents folder."]
    #[doc = "Returns YES if the operation is successful."]
    #[link_name = "\u{1}?saveToFile@CCRenderTexture@cocos2d@@QEAA_NPEBD@Z"]
    pub fn cocos2d_CCRenderTexture_saveToFile(
        this: *mut cocos2d_CCRenderTexture,
        szFilePath: *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    #[doc = " saves the texture into a file. The format could be JPG or PNG. The file will be saved in the Documents folder."]
    #[doc = "Returns YES if the operation is successful."]
    #[link_name = "\u{1}?saveToFile@CCRenderTexture@cocos2d@@QEAA_NPEBDW4eImageFormat@2@@Z"]
    pub fn cocos2d_CCRenderTexture_saveToFile1(
        this: *mut cocos2d_CCRenderTexture,
        name: *const ::std::os::raw::c_char,
        format: cocos2d_tCCImageFormat,
    ) -> bool;
}
extern "C" {
    #[doc = " Listen \"come to background\" message, and save render texture."]
    #[doc = "It only has effect on Android."]
    #[link_name = "\u{1}?listenToBackground@CCRenderTexture@cocos2d@@QEAAXPEAVCCObject@2@@Z"]
    pub fn cocos2d_CCRenderTexture_listenToBackground(
        this: *mut cocos2d_CCRenderTexture,
        obj: *mut cocos2d_CCObject,
    );
}
extern "C" {
    #[doc = " Listen \"come to foreground\" message and restore the frame buffer object"]
    #[doc = "It only has effect on Android."]
    #[link_name = "\u{1}?listenToForeground@CCRenderTexture@cocos2d@@QEAAXPEAVCCObject@2@@Z"]
    pub fn cocos2d_CCRenderTexture_listenToForeground(
        this: *mut cocos2d_CCRenderTexture,
        obj: *mut cocos2d_CCObject,
    );
}
extern "C" {
    #[doc = " Valid flags: GL_COLOR_BUFFER_BIT, GL_DEPTH_BUFFER_BIT, GL_STENCIL_BUFFER_BIT. They can be OR'ed. Valid when \"autoDraw is YES."]
    #[link_name = "\u{1}?getClearFlags@CCRenderTexture@cocos2d@@QEBAIXZ"]
    pub fn cocos2d_CCRenderTexture_getClearFlags(
        this: *const cocos2d_CCRenderTexture,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[link_name = "\u{1}?setClearFlags@CCRenderTexture@cocos2d@@QEAAXI@Z"]
    pub fn cocos2d_CCRenderTexture_setClearFlags(
        this: *mut cocos2d_CCRenderTexture,
        uClearFlags: ::std::os::raw::c_uint,
    );
}
extern "C" {
    #[doc = " Clear color value. Valid only when \"autoDraw\" is true."]
    #[link_name = "\u{1}?getClearColor@CCRenderTexture@cocos2d@@QEBAAEBU_ccColor4F@2@XZ"]
    pub fn cocos2d_CCRenderTexture_getClearColor(
        this: *const cocos2d_CCRenderTexture,
    ) -> *const cocos2d_ccColor4F;
}
extern "C" {
    #[link_name = "\u{1}?setClearColor@CCRenderTexture@cocos2d@@QEAAXAEBU_ccColor4F@2@@Z"]
    pub fn cocos2d_CCRenderTexture_setClearColor(
        this: *mut cocos2d_CCRenderTexture,
        clearColor: *const cocos2d_ccColor4F,
    );
}
extern "C" {
    #[doc = " Value for clearDepth. Valid only when autoDraw is true."]
    #[link_name = "\u{1}?getClearDepth@CCRenderTexture@cocos2d@@QEBAMXZ"]
    pub fn cocos2d_CCRenderTexture_getClearDepth(this: *const cocos2d_CCRenderTexture) -> f32;
}
extern "C" {
    #[link_name = "\u{1}?setClearDepth@CCRenderTexture@cocos2d@@QEAAXM@Z"]
    pub fn cocos2d_CCRenderTexture_setClearDepth(
        this: *mut cocos2d_CCRenderTexture,
        fClearDepth: f32,
    );
}
extern "C" {
    #[doc = " Value for clear Stencil. Valid only when autoDraw is true"]
    #[link_name = "\u{1}?getClearStencil@CCRenderTexture@cocos2d@@QEBAHXZ"]
    pub fn cocos2d_CCRenderTexture_getClearStencil(
        this: *const cocos2d_CCRenderTexture,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}?setClearStencil@CCRenderTexture@cocos2d@@QEAAXM@Z"]
    pub fn cocos2d_CCRenderTexture_setClearStencil(
        this: *mut cocos2d_CCRenderTexture,
        fClearStencil: f32,
    );
}
extern "C" {
    #[doc = " When enabled, it will render its children into the texture automatically. Disabled by default for compatiblity reasons."]
    #[doc = "Will be enabled in the future."]
    #[link_name = "\u{1}?isAutoDraw@CCRenderTexture@cocos2d@@QEBA_NXZ"]
    pub fn cocos2d_CCRenderTexture_isAutoDraw(this: *const cocos2d_CCRenderTexture) -> bool;
}
extern "C" {
    #[link_name = "\u{1}?setAutoDraw@CCRenderTexture@cocos2d@@QEAAX_N@Z"]
    pub fn cocos2d_CCRenderTexture_setAutoDraw(this: *mut cocos2d_CCRenderTexture, bAutoDraw: bool);
}
extern "C" {
    #[doc = " @js ctor"]
    #[link_name = "\u{1}??0CCRenderTexture@cocos2d@@QEAA@XZ"]
    pub fn cocos2d_CCRenderTexture_CCRenderTexture(this: *mut cocos2d_CCRenderTexture);
}
impl cocos2d_CCRenderTexture {
    #[inline]
    pub unsafe fn create(
        w: ::std::os::raw::c_int,
        h: ::std::os::raw::c_int,
        eFormat: cocos2d_CCTexture2DPixelFormat,
        uDepthStencilFormat: GLuint,
    ) -> *mut cocos2d_CCRenderTexture {
        cocos2d_CCRenderTexture_create(w, h, eFormat, uDepthStencilFormat)
    }
    #[inline]
    pub unsafe fn create1(
        w: ::std::os::raw::c_int,
        h: ::std::os::raw::c_int,
        eFormat: cocos2d_CCTexture2DPixelFormat,
    ) -> *mut cocos2d_CCRenderTexture {
        cocos2d_CCRenderTexture_create1(w, h, eFormat)
    }
    #[inline]
    pub unsafe fn create2(
        w: ::std::os::raw::c_int,
        h: ::std::os::raw::c_int,
    ) -> *mut cocos2d_CCRenderTexture {
        cocos2d_CCRenderTexture_create2(w, h)
    }
    #[inline]
    pub unsafe fn initWithWidthAndHeight(
        &mut self,
        w: ::std::os::raw::c_int,
        h: ::std::os::raw::c_int,
        eFormat: cocos2d_CCTexture2DPixelFormat,
    ) -> bool {
        cocos2d_CCRenderTexture_initWithWidthAndHeight(self, w, h, eFormat)
    }
    #[inline]
    pub unsafe fn initWithWidthAndHeight1(
        &mut self,
        w: ::std::os::raw::c_int,
        h: ::std::os::raw::c_int,
        eFormat: cocos2d_CCTexture2DPixelFormat,
        uDepthStencilFormat: GLuint,
    ) -> bool {
        cocos2d_CCRenderTexture_initWithWidthAndHeight1(self, w, h, eFormat, uDepthStencilFormat)
    }
    #[inline]
    pub unsafe fn begin(&mut self) {
        cocos2d_CCRenderTexture_begin(self)
    }
    #[inline]
    pub unsafe fn beginWithClear(&mut self, r: f32, g: f32, b: f32, a: f32) {
        cocos2d_CCRenderTexture_beginWithClear(self, r, g, b, a)
    }
    #[inline]
    pub unsafe fn beginWithClear1(&mut self, r: f32, g: f32, b: f32, a: f32, depthValue: f32) {
        cocos2d_CCRenderTexture_beginWithClear1(self, r, g, b, a, depthValue)
    }
    #[inline]
    pub unsafe fn beginWithClear2(
        &mut self,
        r: f32,
        g: f32,
        b: f32,
        a: f32,
        depthValue: f32,
        stencilValue: ::std::os::raw::c_int,
    ) {
        cocos2d_CCRenderTexture_beginWithClear2(self, r, g, b, a, depthValue, stencilValue)
    }
    #[inline]
    pub unsafe fn end(&mut self) {
        cocos2d_CCRenderTexture_end(self)
    }
    #[inline]
    pub unsafe fn clear(&mut self, r: f32, g: f32, b: f32, a: f32) {
        cocos2d_CCRenderTexture_clear(self, r, g, b, a)
    }
    #[inline]
    pub unsafe fn clearDepth(&mut self, depthValue: f32) {
        cocos2d_CCRenderTexture_clearDepth(self, depthValue)
    }
    #[inline]
    pub unsafe fn clearStencil(&mut self, stencilValue: ::std::os::raw::c_int) {
        cocos2d_CCRenderTexture_clearStencil(self, stencilValue)
    }
    #[inline]
    pub unsafe fn newCCImage(&mut self, flipImage: bool) -> *mut cocos2d_CCImage {
        cocos2d_CCRenderTexture_newCCImage(self, flipImage)
    }
    #[inline]
    pub unsafe fn saveToFile(&mut self, szFilePath: *const ::std::os::raw::c_char) -> bool {
        cocos2d_CCRenderTexture_saveToFile(self, szFilePath)
    }
    #[inline]
    pub unsafe fn saveToFile1(
        &mut self,
        name: *const ::std::os::raw::c_char,
        format: cocos2d_tCCImageFormat,
    ) -> bool {
        cocos2d_CCRenderTexture_saveToFile1(self, name, format)
    }
    #[inline]
    pub unsafe fn listenToBackground(&mut self, obj: *mut cocos2d_CCObject) {
        cocos2d_CCRenderTexture_listenToBackground(self, obj)
    }
    #[inline]
    pub unsafe fn listenToForeground(&mut self, obj: *mut cocos2d_CCObject) {
        cocos2d_CCRenderTexture_listenToForeground(self, obj)
    }
    #[inline]
    pub unsafe fn getClearFlags(&self) -> ::std::os::raw::c_uint {
        cocos2d_CCRenderTexture_getClearFlags(self)
    }
    #[inline]
    pub unsafe fn setClearFlags(&mut self, uClearFlags: ::std::os::raw::c_uint) {
        cocos2d_CCRenderTexture_setClearFlags(self, uClearFlags)
    }
    #[inline]
    pub unsafe fn getClearColor(&self) -> *const cocos2d_ccColor4F {
        cocos2d_CCRenderTexture_getClearColor(self)
    }
    #[inline]
    pub unsafe fn setClearColor(&mut self, clearColor: *const cocos2d_ccColor4F) {
        cocos2d_CCRenderTexture_setClearColor(self, clearColor)
    }
    #[inline]
    pub unsafe fn getClearDepth(&self) -> f32 {
        cocos2d_CCRenderTexture_getClearDepth(self)
    }
    #[inline]
    pub unsafe fn setClearDepth(&mut self, fClearDepth: f32) {
        cocos2d_CCRenderTexture_setClearDepth(self, fClearDepth)
    }
    #[inline]
    pub unsafe fn getClearStencil(&self) -> ::std::os::raw::c_int {
        cocos2d_CCRenderTexture_getClearStencil(self)
    }
    #[inline]
    pub unsafe fn setClearStencil(&mut self, fClearStencil: f32) {
        cocos2d_CCRenderTexture_setClearStencil(self, fClearStencil)
    }
    #[inline]
    pub unsafe fn isAutoDraw(&self) -> bool {
        cocos2d_CCRenderTexture_isAutoDraw(self)
    }
    #[inline]
    pub unsafe fn setAutoDraw(&mut self, bAutoDraw: bool) {
        cocos2d_CCRenderTexture_setAutoDraw(self, bAutoDraw)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cocos2d_CCRenderTexture_CCRenderTexture(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
}
extern "C" {
    #[link_name = "\u{1}?getSprite@CCRenderTexture@cocos2d@@UEAAPEAVCCSprite@2@XZ"]
    pub fn cocos2d_CCRenderTexture_getSprite(
        this: *mut ::std::os::raw::c_void,
    ) -> *mut cocos2d_CCSprite;
}
extern "C" {
    #[link_name = "\u{1}?setSprite@CCRenderTexture@cocos2d@@UEAAXPEAVCCSprite@2@@Z"]
    pub fn cocos2d_CCRenderTexture_setSprite(
        this: *mut ::std::os::raw::c_void,
        var: *mut cocos2d_CCSprite,
    );
}
extern "C" {
    #[doc = " @js NA"]
    #[doc = " @lua NA"]
    #[link_name = "\u{1}??_DCCRenderTexture@cocos2d@@QEAAXXZ"]
    pub fn cocos2d_CCRenderTexture_CCRenderTexture_destructor(this: *mut cocos2d_CCRenderTexture);
}
extern "C" {
    #[link_name = "\u{1}?visit@CCRenderTexture@cocos2d@@UEAAXXZ"]
    pub fn cocos2d_CCRenderTexture_visit(this: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[link_name = "\u{1}?draw@CCRenderTexture@cocos2d@@UEAAXXZ"]
    pub fn cocos2d_CCRenderTexture_draw(this: *mut ::std::os::raw::c_void);
}
#[doc = " CCParticleBatchNode is like a batch node: if it contains children, it will draw them in 1 single OpenGL call"]
#[doc = " (often known as \"batch draw\")."]
#[doc = ""]
#[doc = " A CCParticleBatchNode can reference one and only one texture (one image file, one texture atlas)."]
#[doc = " Only the CCParticleSystems that are contained in that texture can be added to the CCSpriteBatchNode."]
#[doc = " All CCParticleSystems added to a CCSpriteBatchNode are drawn in one OpenGL ES draw call."]
#[doc = " If the CCParticleSystems are not added to a CCParticleBatchNode then an OpenGL ES draw call will be needed for each one, which is less efficient."]
#[doc = ""]
#[doc = ""]
#[doc = " Limitations:"]
#[doc = " - At the moment only CCParticleSystemQuad is supported"]
#[doc = " - All systems need to be drawn with the same parameters, blend function, aliasing, texture"]
#[doc = ""]
#[doc = " Most efficient usage"]
#[doc = " - Initialize the ParticleBatchNode with the texture and enough capacity for all the particle systems"]
#[doc = " - Initialize all particle systems and add them as child to the batch node"]
#[doc = " @since v1.1"]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCParticleBatchNode {
    pub _base: cocos2d_CCNode,
    pub _base_1: cocos2d_CCTextureProtocol,
    pub m_pTextureAtlas: *mut cocos2d_CCTextureAtlas,
    #[doc = " the blend function used for drawing the quads"]
    pub m_tBlendFunc: cocos2d_ccBlendFunc,
}
#[test]
fn bindgen_test_layout_cocos2d_CCParticleBatchNode() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCParticleBatchNode>(),
        320usize,
        concat!("Size of: ", stringify!(cocos2d_CCParticleBatchNode))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCParticleBatchNode>(),
        8usize,
        concat!("Alignment of ", stringify!(cocos2d_CCParticleBatchNode))
    );
}
extern "C" {
    #[doc = " initializes the particle system with CCTexture2D, a capacity of particles, which particle system to use"]
    #[link_name = "\u{1}?createWithTexture@CCParticleBatchNode@cocos2d@@SAPEAV12@PEAVCCTexture2D@2@I@Z"]
    pub fn cocos2d_CCParticleBatchNode_createWithTexture(
        tex: *mut cocos2d_CCTexture2D,
        capacity: ::std::os::raw::c_uint,
    ) -> *mut cocos2d_CCParticleBatchNode;
}
extern "C" {
    #[doc = " initializes the particle system with the name of a file on disk (for a list of supported formats look at the CCTexture2D class), a capacity of particles"]
    #[link_name = "\u{1}?create@CCParticleBatchNode@cocos2d@@SAPEAV12@PEBDI@Z"]
    pub fn cocos2d_CCParticleBatchNode_create(
        fileImage: *const ::std::os::raw::c_char,
        capacity: ::std::os::raw::c_uint,
    ) -> *mut cocos2d_CCParticleBatchNode;
}
extern "C" {
    #[doc = " initializes the particle system with CCTexture2D, a capacity of particles"]
    #[link_name = "\u{1}?initWithTexture@CCParticleBatchNode@cocos2d@@QEAA_NPEAVCCTexture2D@2@I@Z"]
    pub fn cocos2d_CCParticleBatchNode_initWithTexture(
        this: *mut cocos2d_CCParticleBatchNode,
        tex: *mut cocos2d_CCTexture2D,
        capacity: ::std::os::raw::c_uint,
    ) -> bool;
}
extern "C" {
    #[doc = " initializes the particle system with the name of a file on disk (for a list of supported formats look at the CCTexture2D class), a capacity of particles"]
    #[link_name = "\u{1}?initWithFile@CCParticleBatchNode@cocos2d@@QEAA_NPEBDI@Z"]
    pub fn cocos2d_CCParticleBatchNode_initWithFile(
        this: *mut cocos2d_CCParticleBatchNode,
        fileImage: *const ::std::os::raw::c_char,
        capacity: ::std::os::raw::c_uint,
    ) -> bool;
}
extern "C" {
    #[doc = " Inserts a child into the CCParticleBatchNode"]
    #[link_name = "\u{1}?insertChild@CCParticleBatchNode@cocos2d@@QEAAXPEAVCCParticleSystem@2@I@Z"]
    pub fn cocos2d_CCParticleBatchNode_insertChild(
        this: *mut cocos2d_CCParticleBatchNode,
        pSystem: *mut cocos2d_CCParticleSystem,
        index: ::std::os::raw::c_uint,
    );
}
extern "C" {
    #[link_name = "\u{1}?removeChildAtIndex@CCParticleBatchNode@cocos2d@@QEAAXI_N@Z"]
    pub fn cocos2d_CCParticleBatchNode_removeChildAtIndex(
        this: *mut cocos2d_CCParticleBatchNode,
        index: ::std::os::raw::c_uint,
        doCleanup: bool,
    );
}
extern "C" {
    #[doc = " disables a particle by inserting a 0'd quad into the texture atlas"]
    #[link_name = "\u{1}?disableParticle@CCParticleBatchNode@cocos2d@@QEAAXI@Z"]
    pub fn cocos2d_CCParticleBatchNode_disableParticle(
        this: *mut cocos2d_CCParticleBatchNode,
        particleIndex: ::std::os::raw::c_uint,
    );
}
extern "C" {
    #[doc = " @js ctor"]
    #[link_name = "\u{1}??0CCParticleBatchNode@cocos2d@@QEAA@XZ"]
    pub fn cocos2d_CCParticleBatchNode_CCParticleBatchNode(this: *mut cocos2d_CCParticleBatchNode);
}
impl cocos2d_CCParticleBatchNode {
    #[inline]
    pub unsafe fn createWithTexture(
        tex: *mut cocos2d_CCTexture2D,
        capacity: ::std::os::raw::c_uint,
    ) -> *mut cocos2d_CCParticleBatchNode {
        cocos2d_CCParticleBatchNode_createWithTexture(tex, capacity)
    }
    #[inline]
    pub unsafe fn create(
        fileImage: *const ::std::os::raw::c_char,
        capacity: ::std::os::raw::c_uint,
    ) -> *mut cocos2d_CCParticleBatchNode {
        cocos2d_CCParticleBatchNode_create(fileImage, capacity)
    }
    #[inline]
    pub unsafe fn initWithTexture(
        &mut self,
        tex: *mut cocos2d_CCTexture2D,
        capacity: ::std::os::raw::c_uint,
    ) -> bool {
        cocos2d_CCParticleBatchNode_initWithTexture(self, tex, capacity)
    }
    #[inline]
    pub unsafe fn initWithFile(
        &mut self,
        fileImage: *const ::std::os::raw::c_char,
        capacity: ::std::os::raw::c_uint,
    ) -> bool {
        cocos2d_CCParticleBatchNode_initWithFile(self, fileImage, capacity)
    }
    #[inline]
    pub unsafe fn insertChild(
        &mut self,
        pSystem: *mut cocos2d_CCParticleSystem,
        index: ::std::os::raw::c_uint,
    ) {
        cocos2d_CCParticleBatchNode_insertChild(self, pSystem, index)
    }
    #[inline]
    pub unsafe fn removeChildAtIndex(&mut self, index: ::std::os::raw::c_uint, doCleanup: bool) {
        cocos2d_CCParticleBatchNode_removeChildAtIndex(self, index, doCleanup)
    }
    #[inline]
    pub unsafe fn disableParticle(&mut self, particleIndex: ::std::os::raw::c_uint) {
        cocos2d_CCParticleBatchNode_disableParticle(self, particleIndex)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cocos2d_CCParticleBatchNode_CCParticleBatchNode(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
}
extern "C" {
    #[doc = " @js NA"]
    #[doc = " @lua NA"]
    #[link_name = "\u{1}??_DCCParticleBatchNode@cocos2d@@QEAAXXZ"]
    pub fn cocos2d_CCParticleBatchNode_CCParticleBatchNode_destructor(
        this: *mut cocos2d_CCParticleBatchNode,
    );
}
extern "C" {
    #[doc = " Add a child into the CCParticleBatchNode"]
    #[link_name = "\u{1}?addChild@CCParticleBatchNode@cocos2d@@UEAAXPEAVCCNode@2@@Z"]
    pub fn cocos2d_CCParticleBatchNode_addChild(
        this: *mut ::std::os::raw::c_void,
        child: *mut cocos2d_CCNode,
    );
}
extern "C" {
    #[link_name = "\u{1}?addChild@CCParticleBatchNode@cocos2d@@UEAAXPEAVCCNode@2@H@Z"]
    pub fn cocos2d_CCParticleBatchNode_addChild1(
        this: *mut ::std::os::raw::c_void,
        child: *mut cocos2d_CCNode,
        zOrder: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}?addChild@CCParticleBatchNode@cocos2d@@UEAAXPEAVCCNode@2@HH@Z"]
    pub fn cocos2d_CCParticleBatchNode_addChild2(
        this: *mut ::std::os::raw::c_void,
        child: *mut cocos2d_CCNode,
        zOrder: ::std::os::raw::c_int,
        tag: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " remove child from the CCParticleBatchNode"]
    #[link_name = "\u{1}?removeChild@CCParticleBatchNode@cocos2d@@UEAAXPEAVCCNode@2@_N@Z"]
    pub fn cocos2d_CCParticleBatchNode_removeChild(
        this: *mut ::std::os::raw::c_void,
        child: *mut cocos2d_CCNode,
        cleanup: bool,
    );
}
extern "C" {
    #[link_name = "\u{1}?reorderChild@CCParticleBatchNode@cocos2d@@UEAAXPEAVCCNode@2@H@Z"]
    pub fn cocos2d_CCParticleBatchNode_reorderChild(
        this: *mut ::std::os::raw::c_void,
        child: *mut cocos2d_CCNode,
        zOrder: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}?removeAllChildrenWithCleanup@CCParticleBatchNode@cocos2d@@UEAAX_N@Z"]
    pub fn cocos2d_CCParticleBatchNode_removeAllChildrenWithCleanup(
        this: *mut ::std::os::raw::c_void,
        doCleanup: bool,
    );
}
extern "C" {
    #[link_name = "\u{1}?draw@CCParticleBatchNode@cocos2d@@UEAAXXZ"]
    pub fn cocos2d_CCParticleBatchNode_draw(this: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[link_name = "\u{1}?getTexture@CCParticleBatchNode@cocos2d@@UEAAPEAVCCTexture2D@2@XZ"]
    pub fn cocos2d_CCParticleBatchNode_getTexture(
        this: *mut ::std::os::raw::c_void,
    ) -> *mut cocos2d_CCTexture2D;
}
extern "C" {
    #[link_name = "\u{1}?setTexture@CCParticleBatchNode@cocos2d@@UEAAXPEAVCCTexture2D@2@@Z"]
    pub fn cocos2d_CCParticleBatchNode_setTexture(
        this: *mut ::std::os::raw::c_void,
        texture: *mut cocos2d_CCTexture2D,
    );
}
extern "C" {
    #[link_name = "\u{1}?setBlendFunc@CCParticleBatchNode@cocos2d@@UEAAXU_ccBlendFunc@2@@Z"]
    pub fn cocos2d_CCParticleBatchNode_setBlendFunc(
        this: *mut ::std::os::raw::c_void,
        blendFunc: cocos2d_ccBlendFunc,
    );
}
extern "C" {
    #[doc = " returns the blending function used for the texture"]
    #[doc = " @js NA"]
    #[link_name = "\u{1}?getBlendFunc@CCParticleBatchNode@cocos2d@@UEAA?AU_ccBlendFunc@2@XZ"]
    pub fn cocos2d_CCParticleBatchNode_getBlendFunc(
        this: *mut ::std::os::raw::c_void,
    ) -> cocos2d_ccBlendFunc;
}
extern "C" {
    #[link_name = "\u{1}?visit@CCParticleBatchNode@cocos2d@@UEAAXXZ"]
    pub fn cocos2d_CCParticleBatchNode_visit(this: *mut ::std::os::raw::c_void);
}
#[doc = " The Particle emitter lives forever"]
pub const kCCParticleDurationInfinity: ::std::os::raw::c_int = -1;
#[doc = " The starting size of the particle is equal to the ending size"]
pub const kCCParticleStartSizeEqualToEndSize: ::std::os::raw::c_int = -1;
#[doc = " The starting radius of the particle is equal to the ending radius"]
pub const kCCParticleStartRadiusEqualToEndRadius: ::std::os::raw::c_int = -1;
#[doc = " The starting radius of the particle is equal to the ending radius"]
pub const kParticleStartSizeEqualToEndSize: ::std::os::raw::c_int = -1;
#[doc = " The starting radius of the particle is equal to the ending radius"]
pub const kParticleDurationInfinity: ::std::os::raw::c_int = -1;
pub type cocos2d__bindgen_ty_9 = ::std::os::raw::c_int;
#[doc = " Gravity mode (A mode)"]
pub const kCCParticleModeGravity: ::std::os::raw::c_int = 0;
#[doc = " Radius mode (B mode)"]
pub const kCCParticleModeRadius: ::std::os::raw::c_int = 1;
pub type cocos2d__bindgen_ty_10 = ::std::os::raw::c_int;
#[doc = " Living particles are attached to the world and are unaffected by emitter repositioning."]
pub const cocos2d_tCCPositionType_kCCPositionTypeFree: cocos2d_tCCPositionType = 0;
#[doc = " Living particles are attached to the world but will follow the emitter repositioning."]
#[doc = "Use case: Attach an emitter to an sprite, and you want that the emitter follows the sprite."]
pub const cocos2d_tCCPositionType_kCCPositionTypeRelative: cocos2d_tCCPositionType = 1;
#[doc = " Living particles are attached to the emitter and are translated along with it."]
pub const cocos2d_tCCPositionType_kCCPositionTypeGrouped: cocos2d_tCCPositionType = 2;
#[doc = " @typedef tCCPositionType"]
#[doc = "possible types of particle positions"]
pub type cocos2d_tCCPositionType = ::std::os::raw::c_int;
pub const kPositionTypeFree: ::std::os::raw::c_int = 0;
pub const kPositionTypeGrouped: ::std::os::raw::c_int = 2;
pub type cocos2d__bindgen_ty_11 = ::std::os::raw::c_int;
#[doc = "Structure that contains the values of each particle"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cocos2d_sCCParticle {
    pub pos: cocos2d_CCPoint,
    pub startPos: cocos2d_CCPoint,
    pub color: cocos2d_ccColor4F,
    pub deltaColor: cocos2d_ccColor4F,
    pub size: f32,
    pub deltaSize: f32,
    pub rotation: f32,
    pub deltaRotation: f32,
    pub timeToLive: f32,
    pub atlasIndex: ::std::os::raw::c_uint,
    pub modeA: cocos2d_sCCParticle__bindgen_ty_1,
    pub modeB: cocos2d_sCCParticle__bindgen_ty_2,
}
#[doc = "! Mode A: gravity, direction, radial accel, tangential accel"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cocos2d_sCCParticle__bindgen_ty_1 {
    pub dir: cocos2d_CCPoint,
    pub radialAccel: f32,
    pub tangentialAccel: f32,
}
#[test]
fn bindgen_test_layout_cocos2d_sCCParticle__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d_sCCParticle__bindgen_ty_1>(),
        16usize,
        concat!("Size of: ", stringify!(cocos2d_sCCParticle__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_sCCParticle__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(cocos2d_sCCParticle__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cocos2d_sCCParticle__bindgen_ty_1>())).dir as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_sCCParticle__bindgen_ty_1),
            "::",
            stringify!(dir)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cocos2d_sCCParticle__bindgen_ty_1>())).radialAccel as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_sCCParticle__bindgen_ty_1),
            "::",
            stringify!(radialAccel)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cocos2d_sCCParticle__bindgen_ty_1>())).tangentialAccel
                as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_sCCParticle__bindgen_ty_1),
            "::",
            stringify!(tangentialAccel)
        )
    );
}
#[doc = "! Mode B: radius mode"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cocos2d_sCCParticle__bindgen_ty_2 {
    pub angle: f32,
    pub degreesPerSecond: f32,
    pub radius: f32,
    pub deltaRadius: f32,
}
#[test]
fn bindgen_test_layout_cocos2d_sCCParticle__bindgen_ty_2() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d_sCCParticle__bindgen_ty_2>(),
        16usize,
        concat!("Size of: ", stringify!(cocos2d_sCCParticle__bindgen_ty_2))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_sCCParticle__bindgen_ty_2>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(cocos2d_sCCParticle__bindgen_ty_2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cocos2d_sCCParticle__bindgen_ty_2>())).angle as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_sCCParticle__bindgen_ty_2),
            "::",
            stringify!(angle)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cocos2d_sCCParticle__bindgen_ty_2>())).degreesPerSecond
                as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_sCCParticle__bindgen_ty_2),
            "::",
            stringify!(degreesPerSecond)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cocos2d_sCCParticle__bindgen_ty_2>())).radius as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_sCCParticle__bindgen_ty_2),
            "::",
            stringify!(radius)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cocos2d_sCCParticle__bindgen_ty_2>())).deltaRadius as *const _
                as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_sCCParticle__bindgen_ty_2),
            "::",
            stringify!(deltaRadius)
        )
    );
}
#[test]
fn bindgen_test_layout_cocos2d_sCCParticle() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d_sCCParticle>(),
        104usize,
        concat!("Size of: ", stringify!(cocos2d_sCCParticle))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_sCCParticle>(),
        4usize,
        concat!("Alignment of ", stringify!(cocos2d_sCCParticle))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cocos2d_sCCParticle>())).pos as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_sCCParticle),
            "::",
            stringify!(pos)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cocos2d_sCCParticle>())).startPos as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_sCCParticle),
            "::",
            stringify!(startPos)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cocos2d_sCCParticle>())).color as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_sCCParticle),
            "::",
            stringify!(color)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cocos2d_sCCParticle>())).deltaColor as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_sCCParticle),
            "::",
            stringify!(deltaColor)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cocos2d_sCCParticle>())).size as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_sCCParticle),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cocos2d_sCCParticle>())).deltaSize as *const _ as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_sCCParticle),
            "::",
            stringify!(deltaSize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cocos2d_sCCParticle>())).rotation as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_sCCParticle),
            "::",
            stringify!(rotation)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cocos2d_sCCParticle>())).deltaRotation as *const _ as usize
        },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_sCCParticle),
            "::",
            stringify!(deltaRotation)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cocos2d_sCCParticle>())).timeToLive as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_sCCParticle),
            "::",
            stringify!(timeToLive)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cocos2d_sCCParticle>())).atlasIndex as *const _ as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_sCCParticle),
            "::",
            stringify!(atlasIndex)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cocos2d_sCCParticle>())).modeA as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_sCCParticle),
            "::",
            stringify!(modeA)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cocos2d_sCCParticle>())).modeB as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_sCCParticle),
            "::",
            stringify!(modeB)
        )
    );
}
#[doc = "Structure that contains the values of each particle"]
pub type cocos2d_tCCParticle = cocos2d_sCCParticle;
#[doc = " @brief Particle System base class."]
#[doc = "Attributes of a Particle System:"]
#[doc = "- emission rate of the particles"]
#[doc = "- Gravity Mode (Mode A):"]
#[doc = "- gravity"]
#[doc = "- direction"]
#[doc = "- speed +-  variance"]
#[doc = "- tangential acceleration +- variance"]
#[doc = "- radial acceleration +- variance"]
#[doc = "- Radius Mode (Mode B):"]
#[doc = "- startRadius +- variance"]
#[doc = "- endRadius +- variance"]
#[doc = "- rotate +- variance"]
#[doc = "- Properties common to all modes:"]
#[doc = "- life +- life variance"]
#[doc = "- start spin +- variance"]
#[doc = "- end spin +- variance"]
#[doc = "- start size +- variance"]
#[doc = "- end size +- variance"]
#[doc = "- start color +- variance"]
#[doc = "- end color +- variance"]
#[doc = "- life +- variance"]
#[doc = "- blending function"]
#[doc = "- texture"]
#[doc = ""]
#[doc = "cocos2d also supports particles generated by Particle Designer (http://particledesigner.71squared.com/)."]
#[doc = "'Radius Mode' in Particle Designer uses a fixed emit rate of 30 hz. Since that can't be guaranteed in cocos2d,"]
#[doc = "cocos2d uses a another approach, but the results are almost identical."]
#[doc = ""]
#[doc = "cocos2d supports all the variables used by Particle Designer plus a bit more:"]
#[doc = "- spinning particles (supported when using CCParticleSystemQuad)"]
#[doc = "- tangential acceleration (Gravity mode)"]
#[doc = "- radial acceleration (Gravity mode)"]
#[doc = "- radius direction (Radius mode) (Particle Designer supports outwards to inwards direction only)"]
#[doc = ""]
#[doc = "It is possible to customize any of the above mentioned properties in runtime. Example:"]
#[doc = ""]
#[doc = "@code"]
#[doc = "emitter.radialAccel = 15;"]
#[doc = "emitter.startSpin = 0;"]
#[doc = "@endcode"]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCParticleSystem {
    pub _base: cocos2d_CCNode,
    pub _base_1: cocos2d_CCTextureProtocol,
    pub m_sPlistFile: std_string,
    #[doc = "! time elapsed since the start of the system (in seconds)"]
    pub m_fElapsed: f32,
    pub modeA: cocos2d_CCParticleSystem__bindgen_ty_1,
    pub modeB: cocos2d_CCParticleSystem__bindgen_ty_2,
    #[doc = "! Array of particles"]
    pub m_pParticles: *mut cocos2d_tCCParticle,
    #[doc = "! How many particles can be emitted per second"]
    pub m_fEmitCounter: f32,
    #[doc = "!  particle idx"]
    pub m_uParticleIdx: ::std::os::raw::c_uint,
    pub m_pBatchNode: *mut cocos2d_CCParticleBatchNode,
    pub m_uAtlasIndex: ::std::os::raw::c_uint,
    pub m_bTransformSystemDirty: bool,
    pub m_uAllocatedParticles: ::std::os::raw::c_uint,
    #[doc = " Is the emitter active"]
    pub m_bIsActive: bool,
    pub m_uParticleCount: ::std::os::raw::c_uint,
    pub m_fDuration: f32,
    pub m_tSourcePosition: cocos2d_CCPoint,
    pub m_tPosVar: cocos2d_CCPoint,
    pub m_fLife: f32,
    pub m_fLifeVar: f32,
    pub m_fAngle: f32,
    pub m_fAngleVar: f32,
    pub m_fStartSize: f32,
    pub m_fStartSizeVar: f32,
    pub m_fEndSize: f32,
    pub m_fEndSizeVar: f32,
    pub m_tStartColor: cocos2d_ccColor4F,
    pub m_tStartColorVar: cocos2d_ccColor4F,
    pub m_tEndColor: cocos2d_ccColor4F,
    pub m_tEndColorVar: cocos2d_ccColor4F,
    pub m_fStartSpin: f32,
    pub m_fStartSpinVar: f32,
    pub m_fEndSpin: f32,
    pub m_fEndSpinVar: f32,
    pub m_fEmissionRate: f32,
    pub m_uTotalParticles: ::std::os::raw::c_uint,
    pub m_pTexture: *mut cocos2d_CCTexture2D,
    pub m_tBlendFunc: cocos2d_ccBlendFunc,
    pub m_bOpacityModifyRGB: bool,
    #[doc = " whether or not the particles are using blend additive."]
    #[doc = "If enabled, the following blending function will be used."]
    #[doc = "@code"]
    #[doc = "source blend function = GL_SRC_ALPHA;"]
    #[doc = "dest blend function = GL_ONE;"]
    #[doc = "@endcode"]
    pub m_bIsBlendAdditive: bool,
    pub m_ePositionType: cocos2d_tCCPositionType,
    #[doc = " whether or not the node will be auto-removed when it has no particles left."]
    #[doc = "By default it is false."]
    #[doc = "@since v0.8"]
    pub m_bIsAutoRemoveOnFinish: bool,
    pub m_nEmitterMode: ::std::os::raw::c_int,
}
#[doc = "! Mode A:Gravity + Tangential Accel + Radial Accel"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cocos2d_CCParticleSystem__bindgen_ty_1 {
    #[doc = " Gravity value. Only available in 'Gravity' mode."]
    pub gravity: cocos2d_CCPoint,
    #[doc = " speed of each particle. Only available in 'Gravity' mode."]
    pub speed: f32,
    #[doc = " speed variance of each particle. Only available in 'Gravity' mode."]
    pub speedVar: f32,
    #[doc = " tangential acceleration of each particle. Only available in 'Gravity' mode."]
    pub tangentialAccel: f32,
    #[doc = " tangential acceleration variance of each particle. Only available in 'Gravity' mode."]
    pub tangentialAccelVar: f32,
    #[doc = " radial acceleration of each particle. Only available in 'Gravity' mode."]
    pub radialAccel: f32,
    #[doc = " radial acceleration variance of each particle. Only available in 'Gravity' mode."]
    pub radialAccelVar: f32,
    #[doc = " set the rotation of each particle to its direction Only available in 'Gravity' mode."]
    pub rotationIsDir: bool,
}
#[test]
fn bindgen_test_layout_cocos2d_CCParticleSystem__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCParticleSystem__bindgen_ty_1>(),
        36usize,
        concat!(
            "Size of: ",
            stringify!(cocos2d_CCParticleSystem__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCParticleSystem__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(cocos2d_CCParticleSystem__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cocos2d_CCParticleSystem__bindgen_ty_1>())).gravity as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCParticleSystem__bindgen_ty_1),
            "::",
            stringify!(gravity)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cocos2d_CCParticleSystem__bindgen_ty_1>())).speed as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCParticleSystem__bindgen_ty_1),
            "::",
            stringify!(speed)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cocos2d_CCParticleSystem__bindgen_ty_1>())).speedVar as *const _
                as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCParticleSystem__bindgen_ty_1),
            "::",
            stringify!(speedVar)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cocos2d_CCParticleSystem__bindgen_ty_1>())).tangentialAccel
                as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCParticleSystem__bindgen_ty_1),
            "::",
            stringify!(tangentialAccel)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cocos2d_CCParticleSystem__bindgen_ty_1>())).tangentialAccelVar
                as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCParticleSystem__bindgen_ty_1),
            "::",
            stringify!(tangentialAccelVar)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cocos2d_CCParticleSystem__bindgen_ty_1>())).radialAccel
                as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCParticleSystem__bindgen_ty_1),
            "::",
            stringify!(radialAccel)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cocos2d_CCParticleSystem__bindgen_ty_1>())).radialAccelVar
                as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCParticleSystem__bindgen_ty_1),
            "::",
            stringify!(radialAccelVar)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cocos2d_CCParticleSystem__bindgen_ty_1>())).rotationIsDir
                as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCParticleSystem__bindgen_ty_1),
            "::",
            stringify!(rotationIsDir)
        )
    );
}
#[doc = "! Mode B: circular movement (gravity, radial accel and tangential accel don't are not used in this mode)"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cocos2d_CCParticleSystem__bindgen_ty_2 {
    #[doc = " The starting radius of the particles. Only available in 'Radius' mode."]
    pub startRadius: f32,
    #[doc = " The starting radius variance of the particles. Only available in 'Radius' mode."]
    pub startRadiusVar: f32,
    #[doc = " The ending radius of the particles. Only available in 'Radius' mode."]
    pub endRadius: f32,
    #[doc = " The ending radius variance of the particles. Only available in 'Radius' mode."]
    pub endRadiusVar: f32,
    #[doc = " Number of degrees to rotate a particle around the source pos per second. Only available in 'Radius' mode."]
    pub rotatePerSecond: f32,
    #[doc = " Variance in degrees for rotatePerSecond. Only available in 'Radius' mode."]
    pub rotatePerSecondVar: f32,
}
#[test]
fn bindgen_test_layout_cocos2d_CCParticleSystem__bindgen_ty_2() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCParticleSystem__bindgen_ty_2>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(cocos2d_CCParticleSystem__bindgen_ty_2)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCParticleSystem__bindgen_ty_2>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(cocos2d_CCParticleSystem__bindgen_ty_2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cocos2d_CCParticleSystem__bindgen_ty_2>())).startRadius
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCParticleSystem__bindgen_ty_2),
            "::",
            stringify!(startRadius)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cocos2d_CCParticleSystem__bindgen_ty_2>())).startRadiusVar
                as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCParticleSystem__bindgen_ty_2),
            "::",
            stringify!(startRadiusVar)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cocos2d_CCParticleSystem__bindgen_ty_2>())).endRadius as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCParticleSystem__bindgen_ty_2),
            "::",
            stringify!(endRadius)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cocos2d_CCParticleSystem__bindgen_ty_2>())).endRadiusVar
                as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCParticleSystem__bindgen_ty_2),
            "::",
            stringify!(endRadiusVar)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cocos2d_CCParticleSystem__bindgen_ty_2>())).rotatePerSecond
                as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCParticleSystem__bindgen_ty_2),
            "::",
            stringify!(rotatePerSecond)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cocos2d_CCParticleSystem__bindgen_ty_2>())).rotatePerSecondVar
                as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCParticleSystem__bindgen_ty_2),
            "::",
            stringify!(rotatePerSecondVar)
        )
    );
}
#[test]
fn bindgen_test_layout_cocos2d_CCParticleSystem() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCParticleSystem>(),
        616usize,
        concat!("Size of: ", stringify!(cocos2d_CCParticleSystem))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCParticleSystem>(),
        8usize,
        concat!("Alignment of ", stringify!(cocos2d_CCParticleSystem))
    );
}
extern "C" {
    #[doc = " creates an initializes a CCParticleSystem from a plist file."]
    #[doc = "This plist files can be created manually or with Particle Designer:"]
    #[doc = "http://particledesigner.71squared.com/"]
    #[doc = "@since v2.0"]
    #[link_name = "\u{1}?create@CCParticleSystem@cocos2d@@SAPEAV12@PEBD@Z"]
    pub fn cocos2d_CCParticleSystem_create(
        plistFile: *const ::std::os::raw::c_char,
    ) -> *mut cocos2d_CCParticleSystem;
}
extern "C" {
    #[doc = "! create a system with a fixed number of particles"]
    #[link_name = "\u{1}?createWithTotalParticles@CCParticleSystem@cocos2d@@SAPEAV12@I@Z"]
    pub fn cocos2d_CCParticleSystem_createWithTotalParticles(
        numberOfParticles: ::std::os::raw::c_uint,
    ) -> *mut cocos2d_CCParticleSystem;
}
extern "C" {
    #[doc = " initializes a CCParticleSystem from a plist file."]
    #[doc = "This plist files can be created manually or with Particle Designer:"]
    #[doc = "http://particledesigner.71squared.com/"]
    #[doc = "@since v0.99.3"]
    #[link_name = "\u{1}?initWithFile@CCParticleSystem@cocos2d@@QEAA_NPEBD@Z"]
    pub fn cocos2d_CCParticleSystem_initWithFile(
        this: *mut cocos2d_CCParticleSystem,
        plistFile: *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    #[doc = " initializes a CCQuadParticleSystem from a CCDictionary."]
    #[doc = "@since v0.99.3"]
    #[link_name = "\u{1}?initWithDictionary@CCParticleSystem@cocos2d@@QEAA_NPEAVCCDictionary@2@@Z"]
    pub fn cocos2d_CCParticleSystem_initWithDictionary(
        this: *mut cocos2d_CCParticleSystem,
        dictionary: *mut cocos2d_CCDictionary,
    ) -> bool;
}
extern "C" {
    #[doc = " initializes a particle system from a NSDictionary and the path from where to load the png"]
    #[doc = "@since v2.1"]
    #[link_name = "\u{1}?initWithDictionary@CCParticleSystem@cocos2d@@QEAA_NPEAVCCDictionary@2@PEBD@Z"]
    pub fn cocos2d_CCParticleSystem_initWithDictionary1(
        this: *mut cocos2d_CCParticleSystem,
        dictionary: *mut cocos2d_CCDictionary,
        dirname: *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    #[doc = "! Add a particle to the emitter"]
    #[link_name = "\u{1}?addParticle@CCParticleSystem@cocos2d@@QEAA_NXZ"]
    pub fn cocos2d_CCParticleSystem_addParticle(this: *mut cocos2d_CCParticleSystem) -> bool;
}
extern "C" {
    #[doc = "! Initializes a particle"]
    #[link_name = "\u{1}?initParticle@CCParticleSystem@cocos2d@@QEAAXPEAUsCCParticle@2@@Z"]
    pub fn cocos2d_CCParticleSystem_initParticle(
        this: *mut cocos2d_CCParticleSystem,
        particle: *mut cocos2d_tCCParticle,
    );
}
extern "C" {
    #[doc = "! stop emitting particles. Running particles will continue to run until they die"]
    #[link_name = "\u{1}?stopSystem@CCParticleSystem@cocos2d@@QEAAXXZ"]
    pub fn cocos2d_CCParticleSystem_stopSystem(this: *mut cocos2d_CCParticleSystem);
}
extern "C" {
    #[doc = "! Kill all living particles."]
    #[link_name = "\u{1}?resetSystem@CCParticleSystem@cocos2d@@QEAAXXZ"]
    pub fn cocos2d_CCParticleSystem_resetSystem(this: *mut cocos2d_CCParticleSystem);
}
extern "C" {
    #[doc = "! whether or not the system is full"]
    #[link_name = "\u{1}?isFull@CCParticleSystem@cocos2d@@QEAA_NXZ"]
    pub fn cocos2d_CCParticleSystem_isFull(this: *mut cocos2d_CCParticleSystem) -> bool;
}
extern "C" {
    #[doc = " @js ctor"]
    #[link_name = "\u{1}??0CCParticleSystem@cocos2d@@QEAA@XZ"]
    pub fn cocos2d_CCParticleSystem_CCParticleSystem(this: *mut cocos2d_CCParticleSystem);
}
impl cocos2d_CCParticleSystem {
    #[inline]
    pub unsafe fn create(
        plistFile: *const ::std::os::raw::c_char,
    ) -> *mut cocos2d_CCParticleSystem {
        cocos2d_CCParticleSystem_create(plistFile)
    }
    #[inline]
    pub unsafe fn createWithTotalParticles(
        numberOfParticles: ::std::os::raw::c_uint,
    ) -> *mut cocos2d_CCParticleSystem {
        cocos2d_CCParticleSystem_createWithTotalParticles(numberOfParticles)
    }
    #[inline]
    pub unsafe fn initWithFile(&mut self, plistFile: *const ::std::os::raw::c_char) -> bool {
        cocos2d_CCParticleSystem_initWithFile(self, plistFile)
    }
    #[inline]
    pub unsafe fn initWithDictionary(&mut self, dictionary: *mut cocos2d_CCDictionary) -> bool {
        cocos2d_CCParticleSystem_initWithDictionary(self, dictionary)
    }
    #[inline]
    pub unsafe fn initWithDictionary1(
        &mut self,
        dictionary: *mut cocos2d_CCDictionary,
        dirname: *const ::std::os::raw::c_char,
    ) -> bool {
        cocos2d_CCParticleSystem_initWithDictionary1(self, dictionary, dirname)
    }
    #[inline]
    pub unsafe fn addParticle(&mut self) -> bool {
        cocos2d_CCParticleSystem_addParticle(self)
    }
    #[inline]
    pub unsafe fn initParticle(&mut self, particle: *mut cocos2d_tCCParticle) {
        cocos2d_CCParticleSystem_initParticle(self, particle)
    }
    #[inline]
    pub unsafe fn stopSystem(&mut self) {
        cocos2d_CCParticleSystem_stopSystem(self)
    }
    #[inline]
    pub unsafe fn resetSystem(&mut self) {
        cocos2d_CCParticleSystem_resetSystem(self)
    }
    #[inline]
    pub unsafe fn isFull(&mut self) -> bool {
        cocos2d_CCParticleSystem_isFull(self)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cocos2d_CCParticleSystem_CCParticleSystem(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
}
extern "C" {
    #[link_name = "\u{1}?getBatchNode@CCParticleSystem@cocos2d@@UEAAPEAVCCParticleBatchNode@2@XZ"]
    pub fn cocos2d_CCParticleSystem_getBatchNode(
        this: *mut ::std::os::raw::c_void,
    ) -> *mut cocos2d_CCParticleBatchNode;
}
extern "C" {
    #[link_name = "\u{1}?setBatchNode@CCParticleSystem@cocos2d@@UEAAXPEAVCCParticleBatchNode@2@@Z"]
    pub fn cocos2d_CCParticleSystem_setBatchNode(
        this: *mut ::std::os::raw::c_void,
        var: *mut cocos2d_CCParticleBatchNode,
    );
}
extern "C" {
    #[link_name = "\u{1}?getParticleCount@CCParticleSystem@cocos2d@@UEAAIXZ"]
    pub fn cocos2d_CCParticleSystem_getParticleCount(
        this: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[link_name = "\u{1}?getDuration@CCParticleSystem@cocos2d@@UEAAMXZ"]
    pub fn cocos2d_CCParticleSystem_getDuration(this: *mut ::std::os::raw::c_void) -> f32;
}
extern "C" {
    #[link_name = "\u{1}?setDuration@CCParticleSystem@cocos2d@@UEAAXM@Z"]
    pub fn cocos2d_CCParticleSystem_setDuration(this: *mut ::std::os::raw::c_void, var: f32);
}
extern "C" {
    #[link_name = "\u{1}?getSourcePosition@CCParticleSystem@cocos2d@@UEAAAEBVCCPoint@2@XZ"]
    pub fn cocos2d_CCParticleSystem_getSourcePosition(
        this: *mut ::std::os::raw::c_void,
    ) -> *const cocos2d_CCPoint;
}
extern "C" {
    #[link_name = "\u{1}?setSourcePosition@CCParticleSystem@cocos2d@@UEAAXAEBVCCPoint@2@@Z"]
    pub fn cocos2d_CCParticleSystem_setSourcePosition(
        this: *mut ::std::os::raw::c_void,
        var: *const cocos2d_CCPoint,
    );
}
extern "C" {
    #[link_name = "\u{1}?getPosVar@CCParticleSystem@cocos2d@@UEAAAEBVCCPoint@2@XZ"]
    pub fn cocos2d_CCParticleSystem_getPosVar(
        this: *mut ::std::os::raw::c_void,
    ) -> *const cocos2d_CCPoint;
}
extern "C" {
    #[link_name = "\u{1}?setPosVar@CCParticleSystem@cocos2d@@UEAAXAEBVCCPoint@2@@Z"]
    pub fn cocos2d_CCParticleSystem_setPosVar(
        this: *mut ::std::os::raw::c_void,
        var: *const cocos2d_CCPoint,
    );
}
extern "C" {
    #[link_name = "\u{1}?getLife@CCParticleSystem@cocos2d@@UEAAMXZ"]
    pub fn cocos2d_CCParticleSystem_getLife(this: *mut ::std::os::raw::c_void) -> f32;
}
extern "C" {
    #[link_name = "\u{1}?setLife@CCParticleSystem@cocos2d@@UEAAXM@Z"]
    pub fn cocos2d_CCParticleSystem_setLife(this: *mut ::std::os::raw::c_void, var: f32);
}
extern "C" {
    #[link_name = "\u{1}?getLifeVar@CCParticleSystem@cocos2d@@UEAAMXZ"]
    pub fn cocos2d_CCParticleSystem_getLifeVar(this: *mut ::std::os::raw::c_void) -> f32;
}
extern "C" {
    #[link_name = "\u{1}?setLifeVar@CCParticleSystem@cocos2d@@UEAAXM@Z"]
    pub fn cocos2d_CCParticleSystem_setLifeVar(this: *mut ::std::os::raw::c_void, var: f32);
}
extern "C" {
    #[link_name = "\u{1}?getAngle@CCParticleSystem@cocos2d@@UEAAMXZ"]
    pub fn cocos2d_CCParticleSystem_getAngle(this: *mut ::std::os::raw::c_void) -> f32;
}
extern "C" {
    #[link_name = "\u{1}?setAngle@CCParticleSystem@cocos2d@@UEAAXM@Z"]
    pub fn cocos2d_CCParticleSystem_setAngle(this: *mut ::std::os::raw::c_void, var: f32);
}
extern "C" {
    #[link_name = "\u{1}?getAngleVar@CCParticleSystem@cocos2d@@UEAAMXZ"]
    pub fn cocos2d_CCParticleSystem_getAngleVar(this: *mut ::std::os::raw::c_void) -> f32;
}
extern "C" {
    #[link_name = "\u{1}?setAngleVar@CCParticleSystem@cocos2d@@UEAAXM@Z"]
    pub fn cocos2d_CCParticleSystem_setAngleVar(this: *mut ::std::os::raw::c_void, var: f32);
}
extern "C" {
    #[doc = ""]
    #[link_name = "\u{1}?getGravity@CCParticleSystem@cocos2d@@UEAAAEBVCCPoint@2@XZ"]
    pub fn cocos2d_CCParticleSystem_getGravity(
        this: *mut ::std::os::raw::c_void,
    ) -> *const cocos2d_CCPoint;
}
extern "C" {
    #[link_name = "\u{1}?setGravity@CCParticleSystem@cocos2d@@UEAAXAEBVCCPoint@2@@Z"]
    pub fn cocos2d_CCParticleSystem_setGravity(
        this: *mut ::std::os::raw::c_void,
        g: *const cocos2d_CCPoint,
    );
}
extern "C" {
    #[link_name = "\u{1}?getSpeed@CCParticleSystem@cocos2d@@UEAAMXZ"]
    pub fn cocos2d_CCParticleSystem_getSpeed(this: *mut ::std::os::raw::c_void) -> f32;
}
extern "C" {
    #[link_name = "\u{1}?setSpeed@CCParticleSystem@cocos2d@@UEAAXM@Z"]
    pub fn cocos2d_CCParticleSystem_setSpeed(this: *mut ::std::os::raw::c_void, speed: f32);
}
extern "C" {
    #[link_name = "\u{1}?getSpeedVar@CCParticleSystem@cocos2d@@UEAAMXZ"]
    pub fn cocos2d_CCParticleSystem_getSpeedVar(this: *mut ::std::os::raw::c_void) -> f32;
}
extern "C" {
    #[link_name = "\u{1}?setSpeedVar@CCParticleSystem@cocos2d@@UEAAXM@Z"]
    pub fn cocos2d_CCParticleSystem_setSpeedVar(this: *mut ::std::os::raw::c_void, speed: f32);
}
extern "C" {
    #[link_name = "\u{1}?getTangentialAccel@CCParticleSystem@cocos2d@@UEAAMXZ"]
    pub fn cocos2d_CCParticleSystem_getTangentialAccel(this: *mut ::std::os::raw::c_void) -> f32;
}
extern "C" {
    #[link_name = "\u{1}?setTangentialAccel@CCParticleSystem@cocos2d@@UEAAXM@Z"]
    pub fn cocos2d_CCParticleSystem_setTangentialAccel(this: *mut ::std::os::raw::c_void, t: f32);
}
extern "C" {
    #[link_name = "\u{1}?getTangentialAccelVar@CCParticleSystem@cocos2d@@UEAAMXZ"]
    pub fn cocos2d_CCParticleSystem_getTangentialAccelVar(this: *mut ::std::os::raw::c_void)
        -> f32;
}
extern "C" {
    #[link_name = "\u{1}?setTangentialAccelVar@CCParticleSystem@cocos2d@@UEAAXM@Z"]
    pub fn cocos2d_CCParticleSystem_setTangentialAccelVar(
        this: *mut ::std::os::raw::c_void,
        t: f32,
    );
}
extern "C" {
    #[link_name = "\u{1}?getRadialAccel@CCParticleSystem@cocos2d@@UEAAMXZ"]
    pub fn cocos2d_CCParticleSystem_getRadialAccel(this: *mut ::std::os::raw::c_void) -> f32;
}
extern "C" {
    #[link_name = "\u{1}?setRadialAccel@CCParticleSystem@cocos2d@@UEAAXM@Z"]
    pub fn cocos2d_CCParticleSystem_setRadialAccel(this: *mut ::std::os::raw::c_void, t: f32);
}
extern "C" {
    #[link_name = "\u{1}?getRadialAccelVar@CCParticleSystem@cocos2d@@UEAAMXZ"]
    pub fn cocos2d_CCParticleSystem_getRadialAccelVar(this: *mut ::std::os::raw::c_void) -> f32;
}
extern "C" {
    #[link_name = "\u{1}?setRadialAccelVar@CCParticleSystem@cocos2d@@UEAAXM@Z"]
    pub fn cocos2d_CCParticleSystem_setRadialAccelVar(this: *mut ::std::os::raw::c_void, t: f32);
}
extern "C" {
    #[link_name = "\u{1}?getRotationIsDir@CCParticleSystem@cocos2d@@UEAA_NXZ"]
    pub fn cocos2d_CCParticleSystem_getRotationIsDir(this: *mut ::std::os::raw::c_void) -> bool;
}
extern "C" {
    #[link_name = "\u{1}?setRotationIsDir@CCParticleSystem@cocos2d@@UEAAX_N@Z"]
    pub fn cocos2d_CCParticleSystem_setRotationIsDir(this: *mut ::std::os::raw::c_void, t: bool);
}
extern "C" {
    #[link_name = "\u{1}?getStartRadius@CCParticleSystem@cocos2d@@UEAAMXZ"]
    pub fn cocos2d_CCParticleSystem_getStartRadius(this: *mut ::std::os::raw::c_void) -> f32;
}
extern "C" {
    #[link_name = "\u{1}?setStartRadius@CCParticleSystem@cocos2d@@UEAAXM@Z"]
    pub fn cocos2d_CCParticleSystem_setStartRadius(
        this: *mut ::std::os::raw::c_void,
        startRadius: f32,
    );
}
extern "C" {
    #[link_name = "\u{1}?getStartRadiusVar@CCParticleSystem@cocos2d@@UEAAMXZ"]
    pub fn cocos2d_CCParticleSystem_getStartRadiusVar(this: *mut ::std::os::raw::c_void) -> f32;
}
extern "C" {
    #[link_name = "\u{1}?setStartRadiusVar@CCParticleSystem@cocos2d@@UEAAXM@Z"]
    pub fn cocos2d_CCParticleSystem_setStartRadiusVar(
        this: *mut ::std::os::raw::c_void,
        startRadiusVar: f32,
    );
}
extern "C" {
    #[link_name = "\u{1}?getEndRadius@CCParticleSystem@cocos2d@@UEAAMXZ"]
    pub fn cocos2d_CCParticleSystem_getEndRadius(this: *mut ::std::os::raw::c_void) -> f32;
}
extern "C" {
    #[link_name = "\u{1}?setEndRadius@CCParticleSystem@cocos2d@@UEAAXM@Z"]
    pub fn cocos2d_CCParticleSystem_setEndRadius(this: *mut ::std::os::raw::c_void, endRadius: f32);
}
extern "C" {
    #[link_name = "\u{1}?getEndRadiusVar@CCParticleSystem@cocos2d@@UEAAMXZ"]
    pub fn cocos2d_CCParticleSystem_getEndRadiusVar(this: *mut ::std::os::raw::c_void) -> f32;
}
extern "C" {
    #[link_name = "\u{1}?setEndRadiusVar@CCParticleSystem@cocos2d@@UEAAXM@Z"]
    pub fn cocos2d_CCParticleSystem_setEndRadiusVar(
        this: *mut ::std::os::raw::c_void,
        endRadiusVar: f32,
    );
}
extern "C" {
    #[link_name = "\u{1}?getRotatePerSecond@CCParticleSystem@cocos2d@@UEAAMXZ"]
    pub fn cocos2d_CCParticleSystem_getRotatePerSecond(this: *mut ::std::os::raw::c_void) -> f32;
}
extern "C" {
    #[link_name = "\u{1}?setRotatePerSecond@CCParticleSystem@cocos2d@@UEAAXM@Z"]
    pub fn cocos2d_CCParticleSystem_setRotatePerSecond(
        this: *mut ::std::os::raw::c_void,
        degrees: f32,
    );
}
extern "C" {
    #[link_name = "\u{1}?getRotatePerSecondVar@CCParticleSystem@cocos2d@@UEAAMXZ"]
    pub fn cocos2d_CCParticleSystem_getRotatePerSecondVar(this: *mut ::std::os::raw::c_void)
        -> f32;
}
extern "C" {
    #[link_name = "\u{1}?setRotatePerSecondVar@CCParticleSystem@cocos2d@@UEAAXM@Z"]
    pub fn cocos2d_CCParticleSystem_setRotatePerSecondVar(
        this: *mut ::std::os::raw::c_void,
        degrees: f32,
    );
}
extern "C" {
    #[link_name = "\u{1}?setScale@CCParticleSystem@cocos2d@@UEAAXM@Z"]
    pub fn cocos2d_CCParticleSystem_setScale(this: *mut ::std::os::raw::c_void, s: f32);
}
extern "C" {
    #[link_name = "\u{1}?setRotation@CCParticleSystem@cocos2d@@UEAAXM@Z"]
    pub fn cocos2d_CCParticleSystem_setRotation(
        this: *mut ::std::os::raw::c_void,
        newRotation: f32,
    );
}
extern "C" {
    #[link_name = "\u{1}?setScaleX@CCParticleSystem@cocos2d@@UEAAXM@Z"]
    pub fn cocos2d_CCParticleSystem_setScaleX(this: *mut ::std::os::raw::c_void, newScaleX: f32);
}
extern "C" {
    #[link_name = "\u{1}?setScaleY@CCParticleSystem@cocos2d@@UEAAXM@Z"]
    pub fn cocos2d_CCParticleSystem_setScaleY(this: *mut ::std::os::raw::c_void, newScaleY: f32);
}
extern "C" {
    #[link_name = "\u{1}?isActive@CCParticleSystem@cocos2d@@UEAA_NXZ"]
    pub fn cocos2d_CCParticleSystem_isActive(this: *mut ::std::os::raw::c_void) -> bool;
}
extern "C" {
    #[link_name = "\u{1}?isBlendAdditive@CCParticleSystem@cocos2d@@UEAA_NXZ"]
    pub fn cocos2d_CCParticleSystem_isBlendAdditive(this: *mut ::std::os::raw::c_void) -> bool;
}
extern "C" {
    #[link_name = "\u{1}?setBlendAdditive@CCParticleSystem@cocos2d@@UEAAX_N@Z"]
    pub fn cocos2d_CCParticleSystem_setBlendAdditive(
        this: *mut ::std::os::raw::c_void,
        value: bool,
    );
}
extern "C" {
    #[link_name = "\u{1}?getStartSize@CCParticleSystem@cocos2d@@UEAAMXZ"]
    pub fn cocos2d_CCParticleSystem_getStartSize(this: *mut ::std::os::raw::c_void) -> f32;
}
extern "C" {
    #[link_name = "\u{1}?setStartSize@CCParticleSystem@cocos2d@@UEAAXM@Z"]
    pub fn cocos2d_CCParticleSystem_setStartSize(this: *mut ::std::os::raw::c_void, var: f32);
}
extern "C" {
    #[link_name = "\u{1}?getStartSizeVar@CCParticleSystem@cocos2d@@UEAAMXZ"]
    pub fn cocos2d_CCParticleSystem_getStartSizeVar(this: *mut ::std::os::raw::c_void) -> f32;
}
extern "C" {
    #[link_name = "\u{1}?setStartSizeVar@CCParticleSystem@cocos2d@@UEAAXM@Z"]
    pub fn cocos2d_CCParticleSystem_setStartSizeVar(this: *mut ::std::os::raw::c_void, var: f32);
}
extern "C" {
    #[link_name = "\u{1}?getEndSize@CCParticleSystem@cocos2d@@UEAAMXZ"]
    pub fn cocos2d_CCParticleSystem_getEndSize(this: *mut ::std::os::raw::c_void) -> f32;
}
extern "C" {
    #[link_name = "\u{1}?setEndSize@CCParticleSystem@cocos2d@@UEAAXM@Z"]
    pub fn cocos2d_CCParticleSystem_setEndSize(this: *mut ::std::os::raw::c_void, var: f32);
}
extern "C" {
    #[link_name = "\u{1}?getEndSizeVar@CCParticleSystem@cocos2d@@UEAAMXZ"]
    pub fn cocos2d_CCParticleSystem_getEndSizeVar(this: *mut ::std::os::raw::c_void) -> f32;
}
extern "C" {
    #[link_name = "\u{1}?setEndSizeVar@CCParticleSystem@cocos2d@@UEAAXM@Z"]
    pub fn cocos2d_CCParticleSystem_setEndSizeVar(this: *mut ::std::os::raw::c_void, var: f32);
}
extern "C" {
    #[link_name = "\u{1}?getStartColor@CCParticleSystem@cocos2d@@UEAAAEBU_ccColor4F@2@XZ"]
    pub fn cocos2d_CCParticleSystem_getStartColor(
        this: *mut ::std::os::raw::c_void,
    ) -> *const cocos2d_ccColor4F;
}
extern "C" {
    #[link_name = "\u{1}?setStartColor@CCParticleSystem@cocos2d@@UEAAXAEBU_ccColor4F@2@@Z"]
    pub fn cocos2d_CCParticleSystem_setStartColor(
        this: *mut ::std::os::raw::c_void,
        var: *const cocos2d_ccColor4F,
    );
}
extern "C" {
    #[link_name = "\u{1}?getStartColorVar@CCParticleSystem@cocos2d@@UEAAAEBU_ccColor4F@2@XZ"]
    pub fn cocos2d_CCParticleSystem_getStartColorVar(
        this: *mut ::std::os::raw::c_void,
    ) -> *const cocos2d_ccColor4F;
}
extern "C" {
    #[link_name = "\u{1}?setStartColorVar@CCParticleSystem@cocos2d@@UEAAXAEBU_ccColor4F@2@@Z"]
    pub fn cocos2d_CCParticleSystem_setStartColorVar(
        this: *mut ::std::os::raw::c_void,
        var: *const cocos2d_ccColor4F,
    );
}
extern "C" {
    #[link_name = "\u{1}?getEndColor@CCParticleSystem@cocos2d@@UEAAAEBU_ccColor4F@2@XZ"]
    pub fn cocos2d_CCParticleSystem_getEndColor(
        this: *mut ::std::os::raw::c_void,
    ) -> *const cocos2d_ccColor4F;
}
extern "C" {
    #[link_name = "\u{1}?setEndColor@CCParticleSystem@cocos2d@@UEAAXAEBU_ccColor4F@2@@Z"]
    pub fn cocos2d_CCParticleSystem_setEndColor(
        this: *mut ::std::os::raw::c_void,
        var: *const cocos2d_ccColor4F,
    );
}
extern "C" {
    #[link_name = "\u{1}?getEndColorVar@CCParticleSystem@cocos2d@@UEAAAEBU_ccColor4F@2@XZ"]
    pub fn cocos2d_CCParticleSystem_getEndColorVar(
        this: *mut ::std::os::raw::c_void,
    ) -> *const cocos2d_ccColor4F;
}
extern "C" {
    #[link_name = "\u{1}?setEndColorVar@CCParticleSystem@cocos2d@@UEAAXAEBU_ccColor4F@2@@Z"]
    pub fn cocos2d_CCParticleSystem_setEndColorVar(
        this: *mut ::std::os::raw::c_void,
        var: *const cocos2d_ccColor4F,
    );
}
extern "C" {
    #[link_name = "\u{1}?getStartSpin@CCParticleSystem@cocos2d@@UEAAMXZ"]
    pub fn cocos2d_CCParticleSystem_getStartSpin(this: *mut ::std::os::raw::c_void) -> f32;
}
extern "C" {
    #[link_name = "\u{1}?setStartSpin@CCParticleSystem@cocos2d@@UEAAXM@Z"]
    pub fn cocos2d_CCParticleSystem_setStartSpin(this: *mut ::std::os::raw::c_void, var: f32);
}
extern "C" {
    #[link_name = "\u{1}?getStartSpinVar@CCParticleSystem@cocos2d@@UEAAMXZ"]
    pub fn cocos2d_CCParticleSystem_getStartSpinVar(this: *mut ::std::os::raw::c_void) -> f32;
}
extern "C" {
    #[link_name = "\u{1}?setStartSpinVar@CCParticleSystem@cocos2d@@UEAAXM@Z"]
    pub fn cocos2d_CCParticleSystem_setStartSpinVar(this: *mut ::std::os::raw::c_void, var: f32);
}
extern "C" {
    #[link_name = "\u{1}?getEndSpin@CCParticleSystem@cocos2d@@UEAAMXZ"]
    pub fn cocos2d_CCParticleSystem_getEndSpin(this: *mut ::std::os::raw::c_void) -> f32;
}
extern "C" {
    #[link_name = "\u{1}?setEndSpin@CCParticleSystem@cocos2d@@UEAAXM@Z"]
    pub fn cocos2d_CCParticleSystem_setEndSpin(this: *mut ::std::os::raw::c_void, var: f32);
}
extern "C" {
    #[link_name = "\u{1}?getEndSpinVar@CCParticleSystem@cocos2d@@UEAAMXZ"]
    pub fn cocos2d_CCParticleSystem_getEndSpinVar(this: *mut ::std::os::raw::c_void) -> f32;
}
extern "C" {
    #[link_name = "\u{1}?setEndSpinVar@CCParticleSystem@cocos2d@@UEAAXM@Z"]
    pub fn cocos2d_CCParticleSystem_setEndSpinVar(this: *mut ::std::os::raw::c_void, var: f32);
}
extern "C" {
    #[link_name = "\u{1}?getEmissionRate@CCParticleSystem@cocos2d@@UEAAMXZ"]
    pub fn cocos2d_CCParticleSystem_getEmissionRate(this: *mut ::std::os::raw::c_void) -> f32;
}
extern "C" {
    #[link_name = "\u{1}?setEmissionRate@CCParticleSystem@cocos2d@@UEAAXM@Z"]
    pub fn cocos2d_CCParticleSystem_setEmissionRate(this: *mut ::std::os::raw::c_void, var: f32);
}
extern "C" {
    #[link_name = "\u{1}?getTotalParticles@CCParticleSystem@cocos2d@@UEAAIXZ"]
    pub fn cocos2d_CCParticleSystem_getTotalParticles(
        this: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[link_name = "\u{1}?setTotalParticles@CCParticleSystem@cocos2d@@UEAAXI@Z"]
    pub fn cocos2d_CCParticleSystem_setTotalParticles(
        this: *mut ::std::os::raw::c_void,
        var: ::std::os::raw::c_uint,
    );
}
extern "C" {
    #[link_name = "\u{1}?getTexture@CCParticleSystem@cocos2d@@UEAAPEAVCCTexture2D@2@XZ"]
    pub fn cocos2d_CCParticleSystem_getTexture(
        this: *mut ::std::os::raw::c_void,
    ) -> *mut cocos2d_CCTexture2D;
}
extern "C" {
    #[link_name = "\u{1}?setTexture@CCParticleSystem@cocos2d@@UEAAXPEAVCCTexture2D@2@@Z"]
    pub fn cocos2d_CCParticleSystem_setTexture(
        this: *mut ::std::os::raw::c_void,
        var: *mut cocos2d_CCTexture2D,
    );
}
extern "C" {
    #[link_name = "\u{1}?getBlendFunc@CCParticleSystem@cocos2d@@UEAA?AU_ccBlendFunc@2@XZ"]
    pub fn cocos2d_CCParticleSystem_getBlendFunc(
        this: *mut ::std::os::raw::c_void,
    ) -> cocos2d_ccBlendFunc;
}
extern "C" {
    #[link_name = "\u{1}?setBlendFunc@CCParticleSystem@cocos2d@@UEAAXU_ccBlendFunc@2@@Z"]
    pub fn cocos2d_CCParticleSystem_setBlendFunc(
        this: *mut ::std::os::raw::c_void,
        var: cocos2d_ccBlendFunc,
    );
}
extern "C" {
    #[link_name = "\u{1}?getOpacityModifyRGB@CCParticleSystem@cocos2d@@UEAA_NXZ"]
    pub fn cocos2d_CCParticleSystem_getOpacityModifyRGB(this: *mut ::std::os::raw::c_void) -> bool;
}
extern "C" {
    #[link_name = "\u{1}?setOpacityModifyRGB@CCParticleSystem@cocos2d@@UEAAX_N@Z"]
    pub fn cocos2d_CCParticleSystem_setOpacityModifyRGB(
        this: *mut ::std::os::raw::c_void,
        var: bool,
    );
}
extern "C" {
    #[link_name = "\u{1}?getPositionType@CCParticleSystem@cocos2d@@UEAA?AW4tCCPositionType@2@XZ"]
    pub fn cocos2d_CCParticleSystem_getPositionType(
        this: *mut ::std::os::raw::c_void,
    ) -> cocos2d_tCCPositionType;
}
extern "C" {
    #[link_name = "\u{1}?setPositionType@CCParticleSystem@cocos2d@@UEAAXW4tCCPositionType@2@@Z"]
    pub fn cocos2d_CCParticleSystem_setPositionType(
        this: *mut ::std::os::raw::c_void,
        var: cocos2d_tCCPositionType,
    );
}
extern "C" {
    #[link_name = "\u{1}?isAutoRemoveOnFinish@CCParticleSystem@cocos2d@@UEAA_NXZ"]
    pub fn cocos2d_CCParticleSystem_isAutoRemoveOnFinish(this: *mut ::std::os::raw::c_void)
        -> bool;
}
extern "C" {
    #[link_name = "\u{1}?setAutoRemoveOnFinish@CCParticleSystem@cocos2d@@UEAAX_N@Z"]
    pub fn cocos2d_CCParticleSystem_setAutoRemoveOnFinish(
        this: *mut ::std::os::raw::c_void,
        var: bool,
    );
}
extern "C" {
    #[link_name = "\u{1}?getEmitterMode@CCParticleSystem@cocos2d@@UEAAHXZ"]
    pub fn cocos2d_CCParticleSystem_getEmitterMode(
        this: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}?setEmitterMode@CCParticleSystem@cocos2d@@UEAAXH@Z"]
    pub fn cocos2d_CCParticleSystem_setEmitterMode(
        this: *mut ::std::os::raw::c_void,
        var: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " @js NA"]
    #[doc = " @lua NA"]
    #[link_name = "\u{1}??_DCCParticleSystem@cocos2d@@QEAAXXZ"]
    pub fn cocos2d_CCParticleSystem_CCParticleSystem_destructor(
        this: *mut cocos2d_CCParticleSystem,
    );
}
extern "C" {
    #[doc = " initializes a CCParticleSystem"]
    #[link_name = "\u{1}?init@CCParticleSystem@cocos2d@@UEAA_NXZ"]
    pub fn cocos2d_CCParticleSystem_init(this: *mut ::std::os::raw::c_void) -> bool;
}
extern "C" {
    #[doc = "! Initializes a system with a fixed number of particles"]
    #[link_name = "\u{1}?initWithTotalParticles@CCParticleSystem@cocos2d@@UEAA_NI@Z"]
    pub fn cocos2d_CCParticleSystem_initWithTotalParticles(
        this: *mut ::std::os::raw::c_void,
        numberOfParticles: ::std::os::raw::c_uint,
    ) -> bool;
}
extern "C" {
    #[doc = "! should be overridden by subclasses"]
    #[link_name = "\u{1}?updateQuadWithParticle@CCParticleSystem@cocos2d@@UEAAXPEAUsCCParticle@2@AEBVCCPoint@2@@Z"]
    pub fn cocos2d_CCParticleSystem_updateQuadWithParticle(
        this: *mut ::std::os::raw::c_void,
        particle: *mut cocos2d_tCCParticle,
        newPosition: *const cocos2d_CCPoint,
    );
}
extern "C" {
    #[doc = "! should be overridden by subclasses"]
    #[link_name = "\u{1}?postStep@CCParticleSystem@cocos2d@@UEAAXXZ"]
    pub fn cocos2d_CCParticleSystem_postStep(this: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[link_name = "\u{1}?update@CCParticleSystem@cocos2d@@UEAAXM@Z"]
    pub fn cocos2d_CCParticleSystem_update(this: *mut ::std::os::raw::c_void, dt: f32);
}
extern "C" {
    #[link_name = "\u{1}?updateWithNoTime@CCParticleSystem@cocos2d@@UEAAXXZ"]
    pub fn cocos2d_CCParticleSystem_updateWithNoTime(this: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[link_name = "\u{1}?updateBlendFunc@CCParticleSystem@cocos2d@@MEAAXXZ"]
    pub fn cocos2d_CCParticleSystem_updateBlendFunc(this: *mut ::std::os::raw::c_void);
}
#[doc = " @brief CCParticleSystemQuad is a subclass of CCParticleSystem"]
#[doc = ""]
#[doc = "It includes all the features of ParticleSystem."]
#[doc = ""]
#[doc = "Special features and Limitations:"]
#[doc = "- Particle size can be any float number."]
#[doc = "- The system can be scaled"]
#[doc = "- The particles can be rotated"]
#[doc = "- It supports subrects"]
#[doc = "- It supports batched rendering since 1.1"]
#[doc = "@since v0.8"]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCParticleSystemQuad {
    pub _base: cocos2d_CCParticleSystem,
    pub m_pQuads: *mut cocos2d_ccV3F_C4B_T2F_Quad,
    pub m_pIndices: *mut GLushort,
    pub m_pBuffersVBO: [GLuint; 2usize],
}
#[test]
fn bindgen_test_layout_cocos2d_CCParticleSystemQuad() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCParticleSystemQuad>(),
        640usize,
        concat!("Size of: ", stringify!(cocos2d_CCParticleSystemQuad))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCParticleSystemQuad>(),
        8usize,
        concat!("Alignment of ", stringify!(cocos2d_CCParticleSystemQuad))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cocos2d_CCParticleSystemQuad>())).m_pQuads as *const _ as usize
        },
        616usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCParticleSystemQuad),
            "::",
            stringify!(m_pQuads)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cocos2d_CCParticleSystemQuad>())).m_pIndices as *const _ as usize
        },
        624usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCParticleSystemQuad),
            "::",
            stringify!(m_pIndices)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cocos2d_CCParticleSystemQuad>())).m_pBuffersVBO as *const _
                as usize
        },
        632usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCParticleSystemQuad),
            "::",
            stringify!(m_pBuffersVBO)
        )
    );
}
extern "C" {
    #[doc = " creates an initializes a CCParticleSystemQuad from a plist file."]
    #[doc = "This plist files can be created manually or with Particle Designer:"]
    #[link_name = "\u{1}?create@CCParticleSystemQuad@cocos2d@@SAPEAV12@PEBD@Z"]
    pub fn cocos2d_CCParticleSystemQuad_create(
        plistFile: *const ::std::os::raw::c_char,
    ) -> *mut cocos2d_CCParticleSystemQuad;
}
extern "C" {
    #[doc = " initializes the indices for the vertices"]
    #[link_name = "\u{1}?initIndices@CCParticleSystemQuad@cocos2d@@QEAAXXZ"]
    pub fn cocos2d_CCParticleSystemQuad_initIndices(this: *mut cocos2d_CCParticleSystemQuad);
}
extern "C" {
    #[doc = " initializes the texture with a rectangle measured Points"]
    #[link_name = "\u{1}?initTexCoordsWithRect@CCParticleSystemQuad@cocos2d@@QEAAXAEBVCCRect@2@@Z"]
    pub fn cocos2d_CCParticleSystemQuad_initTexCoordsWithRect(
        this: *mut cocos2d_CCParticleSystemQuad,
        rect: *const cocos2d_CCRect,
    );
}
extern "C" {
    #[doc = " Sets a new CCSpriteFrame as particle."]
    #[doc = "WARNING: this method is experimental. Use setTexture:withRect instead."]
    #[doc = "@since v0.99.4"]
    #[link_name = "\u{1}?setDisplayFrame@CCParticleSystemQuad@cocos2d@@QEAAXPEAVCCSpriteFrame@2@@Z"]
    pub fn cocos2d_CCParticleSystemQuad_setDisplayFrame(
        this: *mut cocos2d_CCParticleSystemQuad,
        spriteFrame: *mut cocos2d_CCSpriteFrame,
    );
}
extern "C" {
    #[doc = " Sets a new texture with a rect. The rect is in Points."]
    #[doc = "@since v0.99.4"]
    #[link_name = "\u{1}?setTextureWithRect@CCParticleSystemQuad@cocos2d@@QEAAXPEAVCCTexture2D@2@AEBVCCRect@2@@Z"]
    pub fn cocos2d_CCParticleSystemQuad_setTextureWithRect(
        this: *mut cocos2d_CCParticleSystemQuad,
        texture: *mut cocos2d_CCTexture2D,
        rect: *const cocos2d_CCRect,
    );
}
extern "C" {
    #[doc = " listen the event that coming to foreground on Android"]
    #[doc = "  @js NA"]
    #[doc = "  @lua NA"]
    #[link_name = "\u{1}?listenBackToForeground@CCParticleSystemQuad@cocos2d@@QEAAXPEAVCCObject@2@@Z"]
    pub fn cocos2d_CCParticleSystemQuad_listenBackToForeground(
        this: *mut cocos2d_CCParticleSystemQuad,
        obj: *mut cocos2d_CCObject,
    );
}
extern "C" {
    #[link_name = "\u{1}?create@CCParticleSystemQuad@cocos2d@@SAPEAV12@XZ"]
    pub fn cocos2d_CCParticleSystemQuad_create1() -> *mut cocos2d_CCParticleSystemQuad;
}
extern "C" {
    #[link_name = "\u{1}?createWithTotalParticles@CCParticleSystemQuad@cocos2d@@SAPEAV12@I@Z"]
    pub fn cocos2d_CCParticleSystemQuad_createWithTotalParticles(
        numberOfParticles: ::std::os::raw::c_uint,
    ) -> *mut cocos2d_CCParticleSystemQuad;
}
extern "C" {
    #[doc = " @js ctor"]
    #[link_name = "\u{1}??0CCParticleSystemQuad@cocos2d@@QEAA@XZ"]
    pub fn cocos2d_CCParticleSystemQuad_CCParticleSystemQuad(
        this: *mut cocos2d_CCParticleSystemQuad,
    );
}
impl cocos2d_CCParticleSystemQuad {
    #[inline]
    pub unsafe fn create(
        plistFile: *const ::std::os::raw::c_char,
    ) -> *mut cocos2d_CCParticleSystemQuad {
        cocos2d_CCParticleSystemQuad_create(plistFile)
    }
    #[inline]
    pub unsafe fn initIndices(&mut self) {
        cocos2d_CCParticleSystemQuad_initIndices(self)
    }
    #[inline]
    pub unsafe fn initTexCoordsWithRect(&mut self, rect: *const cocos2d_CCRect) {
        cocos2d_CCParticleSystemQuad_initTexCoordsWithRect(self, rect)
    }
    #[inline]
    pub unsafe fn setDisplayFrame(&mut self, spriteFrame: *mut cocos2d_CCSpriteFrame) {
        cocos2d_CCParticleSystemQuad_setDisplayFrame(self, spriteFrame)
    }
    #[inline]
    pub unsafe fn setTextureWithRect(
        &mut self,
        texture: *mut cocos2d_CCTexture2D,
        rect: *const cocos2d_CCRect,
    ) {
        cocos2d_CCParticleSystemQuad_setTextureWithRect(self, texture, rect)
    }
    #[inline]
    pub unsafe fn listenBackToForeground(&mut self, obj: *mut cocos2d_CCObject) {
        cocos2d_CCParticleSystemQuad_listenBackToForeground(self, obj)
    }
    #[inline]
    pub unsafe fn create1() -> *mut cocos2d_CCParticleSystemQuad {
        cocos2d_CCParticleSystemQuad_create1()
    }
    #[inline]
    pub unsafe fn createWithTotalParticles(
        numberOfParticles: ::std::os::raw::c_uint,
    ) -> *mut cocos2d_CCParticleSystemQuad {
        cocos2d_CCParticleSystemQuad_createWithTotalParticles(numberOfParticles)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cocos2d_CCParticleSystemQuad_CCParticleSystemQuad(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
}
extern "C" {
    #[doc = " @js NA"]
    #[doc = " @lua NA"]
    #[link_name = "\u{1}??_DCCParticleSystemQuad@cocos2d@@QEAAXXZ"]
    pub fn cocos2d_CCParticleSystemQuad_CCParticleSystemQuad_destructor(
        this: *mut cocos2d_CCParticleSystemQuad,
    );
}
extern "C" {
    #[doc = " super methods"]
    #[doc = "  @js NA"]
    #[doc = "  @lua NA"]
    #[link_name = "\u{1}?initWithTotalParticles@CCParticleSystemQuad@cocos2d@@UEAA_NI@Z"]
    pub fn cocos2d_CCParticleSystemQuad_initWithTotalParticles(
        this: *mut ::std::os::raw::c_void,
        numberOfParticles: ::std::os::raw::c_uint,
    ) -> bool;
}
extern "C" {
    #[doc = " @js NA"]
    #[link_name = "\u{1}?setTexture@CCParticleSystemQuad@cocos2d@@UEAAXPEAVCCTexture2D@2@@Z"]
    pub fn cocos2d_CCParticleSystemQuad_setTexture(
        this: *mut ::std::os::raw::c_void,
        texture: *mut cocos2d_CCTexture2D,
    );
}
extern "C" {
    #[doc = " @js NA"]
    #[link_name = "\u{1}?updateQuadWithParticle@CCParticleSystemQuad@cocos2d@@UEAAXPEAUsCCParticle@2@AEBVCCPoint@2@@Z"]
    pub fn cocos2d_CCParticleSystemQuad_updateQuadWithParticle(
        this: *mut ::std::os::raw::c_void,
        particle: *mut cocos2d_tCCParticle,
        newPosition: *const cocos2d_CCPoint,
    );
}
extern "C" {
    #[doc = " @js NA"]
    #[link_name = "\u{1}?postStep@CCParticleSystemQuad@cocos2d@@UEAAXXZ"]
    pub fn cocos2d_CCParticleSystemQuad_postStep(this: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[doc = " @js NA"]
    #[doc = " @lua NA"]
    #[link_name = "\u{1}?draw@CCParticleSystemQuad@cocos2d@@UEAAXXZ"]
    pub fn cocos2d_CCParticleSystemQuad_draw(this: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[doc = " @js NA"]
    #[link_name = "\u{1}?setBatchNode@CCParticleSystemQuad@cocos2d@@UEAAXPEAVCCParticleBatchNode@2@@Z"]
    pub fn cocos2d_CCParticleSystemQuad_setBatchNode(
        this: *mut ::std::os::raw::c_void,
        batchNode: *mut cocos2d_CCParticleBatchNode,
    );
}
extern "C" {
    #[doc = " @js NA"]
    #[link_name = "\u{1}?setTotalParticles@CCParticleSystemQuad@cocos2d@@UEAAXI@Z"]
    pub fn cocos2d_CCParticleSystemQuad_setTotalParticles(
        this: *mut ::std::os::raw::c_void,
        tp: ::std::os::raw::c_uint,
    );
}
#[doc = "! @brief A fire particle system"]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCParticleFire {
    pub _base: cocos2d_CCParticleSystemQuad,
}
#[test]
fn bindgen_test_layout_cocos2d_CCParticleFire() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCParticleFire>(),
        640usize,
        concat!("Size of: ", stringify!(cocos2d_CCParticleFire))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCParticleFire>(),
        8usize,
        concat!("Alignment of ", stringify!(cocos2d_CCParticleFire))
    );
}
extern "C" {
    #[link_name = "\u{1}?create@CCParticleFire@cocos2d@@SAPEAV12@XZ"]
    pub fn cocos2d_CCParticleFire_create() -> *mut cocos2d_CCParticleFire;
}
extern "C" {
    #[link_name = "\u{1}?createWithTotalParticles@CCParticleFire@cocos2d@@SAPEAV12@I@Z"]
    pub fn cocos2d_CCParticleFire_createWithTotalParticles(
        numberOfParticles: ::std::os::raw::c_uint,
    ) -> *mut cocos2d_CCParticleFire;
}
impl cocos2d_CCParticleFire {
    #[inline]
    pub unsafe fn create() -> *mut cocos2d_CCParticleFire {
        cocos2d_CCParticleFire_create()
    }
    #[inline]
    pub unsafe fn createWithTotalParticles(
        numberOfParticles: ::std::os::raw::c_uint,
    ) -> *mut cocos2d_CCParticleFire {
        cocos2d_CCParticleFire_createWithTotalParticles(numberOfParticles)
    }
}
extern "C" {
    #[link_name = "\u{1}?initWithTotalParticles@CCParticleFire@cocos2d@@UEAA_NI@Z"]
    pub fn cocos2d_CCParticleFire_initWithTotalParticles(
        this: *mut ::std::os::raw::c_void,
        numberOfParticles: ::std::os::raw::c_uint,
    ) -> bool;
}
#[doc = "! @brief A fireworks particle system"]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCParticleFireworks {
    pub _base: cocos2d_CCParticleSystemQuad,
}
#[test]
fn bindgen_test_layout_cocos2d_CCParticleFireworks() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCParticleFireworks>(),
        640usize,
        concat!("Size of: ", stringify!(cocos2d_CCParticleFireworks))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCParticleFireworks>(),
        8usize,
        concat!("Alignment of ", stringify!(cocos2d_CCParticleFireworks))
    );
}
extern "C" {
    #[link_name = "\u{1}?create@CCParticleFireworks@cocos2d@@SAPEAV12@XZ"]
    pub fn cocos2d_CCParticleFireworks_create() -> *mut cocos2d_CCParticleFireworks;
}
extern "C" {
    #[link_name = "\u{1}?createWithTotalParticles@CCParticleFireworks@cocos2d@@SAPEAV12@I@Z"]
    pub fn cocos2d_CCParticleFireworks_createWithTotalParticles(
        numberOfParticles: ::std::os::raw::c_uint,
    ) -> *mut cocos2d_CCParticleFireworks;
}
impl cocos2d_CCParticleFireworks {
    #[inline]
    pub unsafe fn create() -> *mut cocos2d_CCParticleFireworks {
        cocos2d_CCParticleFireworks_create()
    }
    #[inline]
    pub unsafe fn createWithTotalParticles(
        numberOfParticles: ::std::os::raw::c_uint,
    ) -> *mut cocos2d_CCParticleFireworks {
        cocos2d_CCParticleFireworks_createWithTotalParticles(numberOfParticles)
    }
}
extern "C" {
    #[link_name = "\u{1}?initWithTotalParticles@CCParticleFireworks@cocos2d@@UEAA_NI@Z"]
    pub fn cocos2d_CCParticleFireworks_initWithTotalParticles(
        this: *mut ::std::os::raw::c_void,
        numberOfParticles: ::std::os::raw::c_uint,
    ) -> bool;
}
#[doc = "! @brief A sun particle system"]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCParticleSun {
    pub _base: cocos2d_CCParticleSystemQuad,
}
#[test]
fn bindgen_test_layout_cocos2d_CCParticleSun() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCParticleSun>(),
        640usize,
        concat!("Size of: ", stringify!(cocos2d_CCParticleSun))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCParticleSun>(),
        8usize,
        concat!("Alignment of ", stringify!(cocos2d_CCParticleSun))
    );
}
extern "C" {
    #[link_name = "\u{1}?create@CCParticleSun@cocos2d@@SAPEAV12@XZ"]
    pub fn cocos2d_CCParticleSun_create() -> *mut cocos2d_CCParticleSun;
}
extern "C" {
    #[link_name = "\u{1}?createWithTotalParticles@CCParticleSun@cocos2d@@SAPEAV12@I@Z"]
    pub fn cocos2d_CCParticleSun_createWithTotalParticles(
        numberOfParticles: ::std::os::raw::c_uint,
    ) -> *mut cocos2d_CCParticleSun;
}
impl cocos2d_CCParticleSun {
    #[inline]
    pub unsafe fn create() -> *mut cocos2d_CCParticleSun {
        cocos2d_CCParticleSun_create()
    }
    #[inline]
    pub unsafe fn createWithTotalParticles(
        numberOfParticles: ::std::os::raw::c_uint,
    ) -> *mut cocos2d_CCParticleSun {
        cocos2d_CCParticleSun_createWithTotalParticles(numberOfParticles)
    }
}
extern "C" {
    #[link_name = "\u{1}?initWithTotalParticles@CCParticleSun@cocos2d@@UEAA_NI@Z"]
    pub fn cocos2d_CCParticleSun_initWithTotalParticles(
        this: *mut ::std::os::raw::c_void,
        numberOfParticles: ::std::os::raw::c_uint,
    ) -> bool;
}
#[doc = "! @brief A galaxy particle system"]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCParticleGalaxy {
    pub _base: cocos2d_CCParticleSystemQuad,
}
#[test]
fn bindgen_test_layout_cocos2d_CCParticleGalaxy() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCParticleGalaxy>(),
        640usize,
        concat!("Size of: ", stringify!(cocos2d_CCParticleGalaxy))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCParticleGalaxy>(),
        8usize,
        concat!("Alignment of ", stringify!(cocos2d_CCParticleGalaxy))
    );
}
extern "C" {
    #[link_name = "\u{1}?create@CCParticleGalaxy@cocos2d@@SAPEAV12@XZ"]
    pub fn cocos2d_CCParticleGalaxy_create() -> *mut cocos2d_CCParticleGalaxy;
}
extern "C" {
    #[link_name = "\u{1}?createWithTotalParticles@CCParticleGalaxy@cocos2d@@SAPEAV12@I@Z"]
    pub fn cocos2d_CCParticleGalaxy_createWithTotalParticles(
        numberOfParticles: ::std::os::raw::c_uint,
    ) -> *mut cocos2d_CCParticleGalaxy;
}
impl cocos2d_CCParticleGalaxy {
    #[inline]
    pub unsafe fn create() -> *mut cocos2d_CCParticleGalaxy {
        cocos2d_CCParticleGalaxy_create()
    }
    #[inline]
    pub unsafe fn createWithTotalParticles(
        numberOfParticles: ::std::os::raw::c_uint,
    ) -> *mut cocos2d_CCParticleGalaxy {
        cocos2d_CCParticleGalaxy_createWithTotalParticles(numberOfParticles)
    }
}
extern "C" {
    #[link_name = "\u{1}?initWithTotalParticles@CCParticleGalaxy@cocos2d@@UEAA_NI@Z"]
    pub fn cocos2d_CCParticleGalaxy_initWithTotalParticles(
        this: *mut ::std::os::raw::c_void,
        numberOfParticles: ::std::os::raw::c_uint,
    ) -> bool;
}
#[doc = "! @brief A flower particle system"]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCParticleFlower {
    pub _base: cocos2d_CCParticleSystemQuad,
}
#[test]
fn bindgen_test_layout_cocos2d_CCParticleFlower() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCParticleFlower>(),
        640usize,
        concat!("Size of: ", stringify!(cocos2d_CCParticleFlower))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCParticleFlower>(),
        8usize,
        concat!("Alignment of ", stringify!(cocos2d_CCParticleFlower))
    );
}
extern "C" {
    #[link_name = "\u{1}?create@CCParticleFlower@cocos2d@@SAPEAV12@XZ"]
    pub fn cocos2d_CCParticleFlower_create() -> *mut cocos2d_CCParticleFlower;
}
extern "C" {
    #[link_name = "\u{1}?createWithTotalParticles@CCParticleFlower@cocos2d@@SAPEAV12@I@Z"]
    pub fn cocos2d_CCParticleFlower_createWithTotalParticles(
        numberOfParticles: ::std::os::raw::c_uint,
    ) -> *mut cocos2d_CCParticleFlower;
}
impl cocos2d_CCParticleFlower {
    #[inline]
    pub unsafe fn create() -> *mut cocos2d_CCParticleFlower {
        cocos2d_CCParticleFlower_create()
    }
    #[inline]
    pub unsafe fn createWithTotalParticles(
        numberOfParticles: ::std::os::raw::c_uint,
    ) -> *mut cocos2d_CCParticleFlower {
        cocos2d_CCParticleFlower_createWithTotalParticles(numberOfParticles)
    }
}
extern "C" {
    #[link_name = "\u{1}?initWithTotalParticles@CCParticleFlower@cocos2d@@UEAA_NI@Z"]
    pub fn cocos2d_CCParticleFlower_initWithTotalParticles(
        this: *mut ::std::os::raw::c_void,
        numberOfParticles: ::std::os::raw::c_uint,
    ) -> bool;
}
#[doc = "! @brief A meteor particle system"]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCParticleMeteor {
    pub _base: cocos2d_CCParticleSystemQuad,
}
#[test]
fn bindgen_test_layout_cocos2d_CCParticleMeteor() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCParticleMeteor>(),
        640usize,
        concat!("Size of: ", stringify!(cocos2d_CCParticleMeteor))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCParticleMeteor>(),
        8usize,
        concat!("Alignment of ", stringify!(cocos2d_CCParticleMeteor))
    );
}
extern "C" {
    #[link_name = "\u{1}?create@CCParticleMeteor@cocos2d@@SAPEAV12@XZ"]
    pub fn cocos2d_CCParticleMeteor_create() -> *mut cocos2d_CCParticleMeteor;
}
extern "C" {
    #[link_name = "\u{1}?createWithTotalParticles@CCParticleMeteor@cocos2d@@SAPEAV12@I@Z"]
    pub fn cocos2d_CCParticleMeteor_createWithTotalParticles(
        numberOfParticles: ::std::os::raw::c_uint,
    ) -> *mut cocos2d_CCParticleMeteor;
}
impl cocos2d_CCParticleMeteor {
    #[inline]
    pub unsafe fn create() -> *mut cocos2d_CCParticleMeteor {
        cocos2d_CCParticleMeteor_create()
    }
    #[inline]
    pub unsafe fn createWithTotalParticles(
        numberOfParticles: ::std::os::raw::c_uint,
    ) -> *mut cocos2d_CCParticleMeteor {
        cocos2d_CCParticleMeteor_createWithTotalParticles(numberOfParticles)
    }
}
extern "C" {
    #[link_name = "\u{1}?initWithTotalParticles@CCParticleMeteor@cocos2d@@UEAA_NI@Z"]
    pub fn cocos2d_CCParticleMeteor_initWithTotalParticles(
        this: *mut ::std::os::raw::c_void,
        numberOfParticles: ::std::os::raw::c_uint,
    ) -> bool;
}
#[doc = "! @brief An spiral particle system"]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCParticleSpiral {
    pub _base: cocos2d_CCParticleSystemQuad,
}
#[test]
fn bindgen_test_layout_cocos2d_CCParticleSpiral() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCParticleSpiral>(),
        640usize,
        concat!("Size of: ", stringify!(cocos2d_CCParticleSpiral))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCParticleSpiral>(),
        8usize,
        concat!("Alignment of ", stringify!(cocos2d_CCParticleSpiral))
    );
}
extern "C" {
    #[link_name = "\u{1}?create@CCParticleSpiral@cocos2d@@SAPEAV12@XZ"]
    pub fn cocos2d_CCParticleSpiral_create() -> *mut cocos2d_CCParticleSpiral;
}
extern "C" {
    #[link_name = "\u{1}?createWithTotalParticles@CCParticleSpiral@cocos2d@@SAPEAV12@I@Z"]
    pub fn cocos2d_CCParticleSpiral_createWithTotalParticles(
        numberOfParticles: ::std::os::raw::c_uint,
    ) -> *mut cocos2d_CCParticleSpiral;
}
impl cocos2d_CCParticleSpiral {
    #[inline]
    pub unsafe fn create() -> *mut cocos2d_CCParticleSpiral {
        cocos2d_CCParticleSpiral_create()
    }
    #[inline]
    pub unsafe fn createWithTotalParticles(
        numberOfParticles: ::std::os::raw::c_uint,
    ) -> *mut cocos2d_CCParticleSpiral {
        cocos2d_CCParticleSpiral_createWithTotalParticles(numberOfParticles)
    }
}
extern "C" {
    #[link_name = "\u{1}?initWithTotalParticles@CCParticleSpiral@cocos2d@@UEAA_NI@Z"]
    pub fn cocos2d_CCParticleSpiral_initWithTotalParticles(
        this: *mut ::std::os::raw::c_void,
        numberOfParticles: ::std::os::raw::c_uint,
    ) -> bool;
}
#[doc = "! @brief An explosion particle system"]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCParticleExplosion {
    pub _base: cocos2d_CCParticleSystemQuad,
}
#[test]
fn bindgen_test_layout_cocos2d_CCParticleExplosion() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCParticleExplosion>(),
        640usize,
        concat!("Size of: ", stringify!(cocos2d_CCParticleExplosion))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCParticleExplosion>(),
        8usize,
        concat!("Alignment of ", stringify!(cocos2d_CCParticleExplosion))
    );
}
extern "C" {
    #[link_name = "\u{1}?create@CCParticleExplosion@cocos2d@@SAPEAV12@XZ"]
    pub fn cocos2d_CCParticleExplosion_create() -> *mut cocos2d_CCParticleExplosion;
}
extern "C" {
    #[link_name = "\u{1}?createWithTotalParticles@CCParticleExplosion@cocos2d@@SAPEAV12@I@Z"]
    pub fn cocos2d_CCParticleExplosion_createWithTotalParticles(
        numberOfParticles: ::std::os::raw::c_uint,
    ) -> *mut cocos2d_CCParticleExplosion;
}
impl cocos2d_CCParticleExplosion {
    #[inline]
    pub unsafe fn create() -> *mut cocos2d_CCParticleExplosion {
        cocos2d_CCParticleExplosion_create()
    }
    #[inline]
    pub unsafe fn createWithTotalParticles(
        numberOfParticles: ::std::os::raw::c_uint,
    ) -> *mut cocos2d_CCParticleExplosion {
        cocos2d_CCParticleExplosion_createWithTotalParticles(numberOfParticles)
    }
}
extern "C" {
    #[link_name = "\u{1}?initWithTotalParticles@CCParticleExplosion@cocos2d@@UEAA_NI@Z"]
    pub fn cocos2d_CCParticleExplosion_initWithTotalParticles(
        this: *mut ::std::os::raw::c_void,
        numberOfParticles: ::std::os::raw::c_uint,
    ) -> bool;
}
#[doc = "! @brief An smoke particle system"]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCParticleSmoke {
    pub _base: cocos2d_CCParticleSystemQuad,
}
#[test]
fn bindgen_test_layout_cocos2d_CCParticleSmoke() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCParticleSmoke>(),
        640usize,
        concat!("Size of: ", stringify!(cocos2d_CCParticleSmoke))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCParticleSmoke>(),
        8usize,
        concat!("Alignment of ", stringify!(cocos2d_CCParticleSmoke))
    );
}
extern "C" {
    #[link_name = "\u{1}?create@CCParticleSmoke@cocos2d@@SAPEAV12@XZ"]
    pub fn cocos2d_CCParticleSmoke_create() -> *mut cocos2d_CCParticleSmoke;
}
extern "C" {
    #[link_name = "\u{1}?createWithTotalParticles@CCParticleSmoke@cocos2d@@SAPEAV12@I@Z"]
    pub fn cocos2d_CCParticleSmoke_createWithTotalParticles(
        numberOfParticles: ::std::os::raw::c_uint,
    ) -> *mut cocos2d_CCParticleSmoke;
}
impl cocos2d_CCParticleSmoke {
    #[inline]
    pub unsafe fn create() -> *mut cocos2d_CCParticleSmoke {
        cocos2d_CCParticleSmoke_create()
    }
    #[inline]
    pub unsafe fn createWithTotalParticles(
        numberOfParticles: ::std::os::raw::c_uint,
    ) -> *mut cocos2d_CCParticleSmoke {
        cocos2d_CCParticleSmoke_createWithTotalParticles(numberOfParticles)
    }
}
extern "C" {
    #[link_name = "\u{1}?initWithTotalParticles@CCParticleSmoke@cocos2d@@UEAA_NI@Z"]
    pub fn cocos2d_CCParticleSmoke_initWithTotalParticles(
        this: *mut ::std::os::raw::c_void,
        numberOfParticles: ::std::os::raw::c_uint,
    ) -> bool;
}
#[doc = "! @brief An snow particle system"]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCParticleSnow {
    pub _base: cocos2d_CCParticleSystemQuad,
}
#[test]
fn bindgen_test_layout_cocos2d_CCParticleSnow() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCParticleSnow>(),
        640usize,
        concat!("Size of: ", stringify!(cocos2d_CCParticleSnow))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCParticleSnow>(),
        8usize,
        concat!("Alignment of ", stringify!(cocos2d_CCParticleSnow))
    );
}
extern "C" {
    #[link_name = "\u{1}?create@CCParticleSnow@cocos2d@@SAPEAV12@XZ"]
    pub fn cocos2d_CCParticleSnow_create() -> *mut cocos2d_CCParticleSnow;
}
extern "C" {
    #[link_name = "\u{1}?createWithTotalParticles@CCParticleSnow@cocos2d@@SAPEAV12@I@Z"]
    pub fn cocos2d_CCParticleSnow_createWithTotalParticles(
        numberOfParticles: ::std::os::raw::c_uint,
    ) -> *mut cocos2d_CCParticleSnow;
}
impl cocos2d_CCParticleSnow {
    #[inline]
    pub unsafe fn create() -> *mut cocos2d_CCParticleSnow {
        cocos2d_CCParticleSnow_create()
    }
    #[inline]
    pub unsafe fn createWithTotalParticles(
        numberOfParticles: ::std::os::raw::c_uint,
    ) -> *mut cocos2d_CCParticleSnow {
        cocos2d_CCParticleSnow_createWithTotalParticles(numberOfParticles)
    }
}
extern "C" {
    #[link_name = "\u{1}?initWithTotalParticles@CCParticleSnow@cocos2d@@UEAA_NI@Z"]
    pub fn cocos2d_CCParticleSnow_initWithTotalParticles(
        this: *mut ::std::os::raw::c_void,
        numberOfParticles: ::std::os::raw::c_uint,
    ) -> bool;
}
#[doc = "! @brief A rain particle system"]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCParticleRain {
    pub _base: cocos2d_CCParticleSystemQuad,
}
#[test]
fn bindgen_test_layout_cocos2d_CCParticleRain() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCParticleRain>(),
        640usize,
        concat!("Size of: ", stringify!(cocos2d_CCParticleRain))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCParticleRain>(),
        8usize,
        concat!("Alignment of ", stringify!(cocos2d_CCParticleRain))
    );
}
extern "C" {
    #[link_name = "\u{1}?create@CCParticleRain@cocos2d@@SAPEAV12@XZ"]
    pub fn cocos2d_CCParticleRain_create() -> *mut cocos2d_CCParticleRain;
}
extern "C" {
    #[link_name = "\u{1}?createWithTotalParticles@CCParticleRain@cocos2d@@SAPEAV12@I@Z"]
    pub fn cocos2d_CCParticleRain_createWithTotalParticles(
        numberOfParticles: ::std::os::raw::c_uint,
    ) -> *mut cocos2d_CCParticleRain;
}
impl cocos2d_CCParticleRain {
    #[inline]
    pub unsafe fn create() -> *mut cocos2d_CCParticleRain {
        cocos2d_CCParticleRain_create()
    }
    #[inline]
    pub unsafe fn createWithTotalParticles(
        numberOfParticles: ::std::os::raw::c_uint,
    ) -> *mut cocos2d_CCParticleRain {
        cocos2d_CCParticleRain_createWithTotalParticles(numberOfParticles)
    }
}
extern "C" {
    #[link_name = "\u{1}?initWithTotalParticles@CCParticleRain@cocos2d@@UEAA_NI@Z"]
    pub fn cocos2d_CCParticleRain_initWithTotalParticles(
        this: *mut ::std::os::raw::c_void,
        numberOfParticles: ::std::os::raw::c_uint,
    ) -> bool;
}
#[doc = "@js NA"]
#[doc = "@lua NA"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cocos2d_CCDevice {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout_cocos2d_CCDevice() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCDevice>(),
        1usize,
        concat!("Size of: ", stringify!(cocos2d_CCDevice))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCDevice>(),
        1usize,
        concat!("Alignment of ", stringify!(cocos2d_CCDevice))
    );
}
extern "C" {
    #[doc = "  Gets the DPI of device"]
    #[doc = "  @return The DPI of device."]
    #[link_name = "\u{1}?getDPI@CCDevice@cocos2d@@SAHXZ"]
    pub fn cocos2d_CCDevice_getDPI() -> ::std::os::raw::c_int;
}
impl cocos2d_CCDevice {
    #[inline]
    pub unsafe fn getDPI() -> ::std::os::raw::c_int {
        cocos2d_CCDevice_getDPI()
    }
}
#[doc = "! @brief  Helper class to handle file operations"]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCFileUtils {
    pub _base: cocos2d_TypeInfo,
    #[doc = " Dictionary used to lookup filenames based on a key."]
    #[doc = "  It is used internally by the following methods:"]
    #[doc = ""]
    #[doc = "  std::string fullPathForFilename(const char*);"]
    #[doc = ""]
    #[doc = "  @since v2.1"]
    pub m_pFilenameLookupDict: *mut cocos2d_CCDictionary,
    #[doc = "  The vector contains resolution folders."]
    #[doc = "  The lower index of the element in this vector, the higher priority for this resolution directory."]
    pub m_searchResolutionsOrderArray: [u64; 3usize],
    #[doc = " The vector contains search paths."]
    #[doc = " The lower index of the element in this vector, the higher priority for this search path."]
    pub m_searchPathArray: [u64; 3usize],
    #[doc = "  The default root path of resources."]
    #[doc = "  If the default root path of resources needs to be changed, do it in the `init` method of CCFileUtils's subclass."]
    #[doc = "  For instance:"]
    #[doc = "  On Android, the default root path of resources will be assigned with \"assets/\" in CCFileUtilsAndroid::init()."]
    #[doc = "  Similarly on Blackberry, we assign \"app/native/Resources/\" to this variable in CCFileUtilsBlackberry::init()."]
    pub m_strDefaultResRootPath: std_string,
    #[doc = "  The full path cache. When a file is found, it will be added into this cache."]
    #[doc = "  This variable is used for improving the performance of file search."]
    pub m_fullPathCache: [u64; 2usize],
}
extern "C" {
    #[doc = "  The singleton pointer of CCFileUtils."]
    #[link_name = "\u{1}?s_sharedFileUtils@CCFileUtils@cocos2d@@1PEAV12@EA"]
    pub static mut cocos2d_CCFileUtils_s_sharedFileUtils: *mut cocos2d_CCFileUtils;
}
#[test]
fn bindgen_test_layout_cocos2d_CCFileUtils() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCFileUtils>(),
        112usize,
        concat!("Size of: ", stringify!(cocos2d_CCFileUtils))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCFileUtils>(),
        8usize,
        concat!("Alignment of ", stringify!(cocos2d_CCFileUtils))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cocos2d_CCFileUtils>())).m_pFilenameLookupDict as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCFileUtils),
            "::",
            stringify!(m_pFilenameLookupDict)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cocos2d_CCFileUtils>())).m_searchResolutionsOrderArray
                as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCFileUtils),
            "::",
            stringify!(m_searchResolutionsOrderArray)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cocos2d_CCFileUtils>())).m_searchPathArray as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCFileUtils),
            "::",
            stringify!(m_searchPathArray)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cocos2d_CCFileUtils>())).m_strDefaultResRootPath as *const _
                as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCFileUtils),
            "::",
            stringify!(m_strDefaultResRootPath)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cocos2d_CCFileUtils>())).m_fullPathCache as *const _ as usize
        },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCFileUtils),
            "::",
            stringify!(m_fullPathCache)
        )
    );
}
extern "C" {
    #[doc = "  Gets the instance of CCFileUtils."]
    #[doc = "  @js getInstance"]
    #[link_name = "\u{1}?sharedFileUtils@CCFileUtils@cocos2d@@SAPEAV12@XZ"]
    pub fn cocos2d_CCFileUtils_sharedFileUtils() -> *mut cocos2d_CCFileUtils;
}
extern "C" {
    #[doc = "  Destroys the instance of CCFileUtils."]
    #[link_name = "\u{1}?purgeFileUtils@CCFileUtils@cocos2d@@SAXXZ"]
    pub fn cocos2d_CCFileUtils_purgeFileUtils();
}
extern "C" {
    #[doc = " Removes all paths."]
    #[doc = ""]
    #[doc = " @since v2.2"]
    #[doc = " @lua NA"]
    #[link_name = "\u{1}?removeAllPaths@CCFileUtils@cocos2d@@QEAAXXZ"]
    pub fn cocos2d_CCFileUtils_removeAllPaths(this: *mut cocos2d_CCFileUtils);
}
extern "C" {
    #[doc = "  The default constructor."]
    #[link_name = "\u{1}??0CCFileUtils@cocos2d@@IEAA@XZ"]
    pub fn cocos2d_CCFileUtils_CCFileUtils(this: *mut cocos2d_CCFileUtils);
}
impl cocos2d_CCFileUtils {
    #[inline]
    pub unsafe fn sharedFileUtils() -> *mut cocos2d_CCFileUtils {
        cocos2d_CCFileUtils_sharedFileUtils()
    }
    #[inline]
    pub unsafe fn purgeFileUtils() {
        cocos2d_CCFileUtils_purgeFileUtils()
    }
    #[inline]
    pub unsafe fn removeAllPaths(&mut self) {
        cocos2d_CCFileUtils_removeAllPaths(self)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cocos2d_CCFileUtils_CCFileUtils(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
}
extern "C" {
    #[doc = "  The destructor of CCFileUtils."]
    #[doc = "  @js NA"]
    #[doc = "  @lua NA"]
    #[link_name = "\u{1}??_DCCFileUtils@cocos2d@@QEAAXXZ"]
    pub fn cocos2d_CCFileUtils_CCFileUtils_destructor(this: *mut cocos2d_CCFileUtils);
}
extern "C" {
    #[doc = "  Purges the file searching cache."]
    #[doc = ""]
    #[doc = "  @note It should be invoked after the resources were updated."]
    #[doc = "        For instance, in the CocosPlayer sample, every time you run application from CocosBuilder,"]
    #[doc = "        All the resources will be downloaded to the writable folder, before new js app launchs,"]
    #[doc = "        this method should be invoked to clean the file search cache."]
    #[link_name = "\u{1}?purgeCachedEntries@CCFileUtils@cocos2d@@UEAAXXZ"]
    pub fn cocos2d_CCFileUtils_purgeCachedEntries(this: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[doc = "  Gets resource file data"]
    #[doc = ""]
    #[doc = "  @param[in]  pszFileName The resource file name which contains the path."]
    #[doc = "  @param[in]  pszMode The read mode of the file."]
    #[doc = "  @param[out] pSize If the file read operation succeeds, it will be the data size, otherwise 0."]
    #[doc = "  @return Upon success, a pointer to the data is returned, otherwise NULL."]
    #[doc = "  @warning Recall: you are responsible for calling delete[] on any Non-NULL pointer returned."]
    #[doc = "  @js NA"]
    #[link_name = "\u{1}?getFileData@CCFileUtils@cocos2d@@UEAAPEAEPEBD0PEAK@Z"]
    pub fn cocos2d_CCFileUtils_getFileData(
        this: *mut ::std::os::raw::c_void,
        pszFileName: *const ::std::os::raw::c_char,
        pszMode: *const ::std::os::raw::c_char,
        pSize: *mut ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_uchar;
}
extern "C" {
    #[doc = "  Gets resource file data from a zip file."]
    #[doc = ""]
    #[doc = "  @param[in]  pszFileName The resource file name which contains the relative path of the zip file."]
    #[doc = "  @param[out] pSize If the file read operation succeeds, it will be the data size, otherwise 0."]
    #[doc = "  @return Upon success, a pointer to the data is returned, otherwise NULL."]
    #[doc = "  @warning Recall: you are responsible for calling delete[] on any Non-NULL pointer returned."]
    #[doc = "  @js NA"]
    #[link_name = "\u{1}?getFileDataFromZip@CCFileUtils@cocos2d@@UEAAPEAEPEBD0PEAK@Z"]
    pub fn cocos2d_CCFileUtils_getFileDataFromZip(
        this: *mut ::std::os::raw::c_void,
        pszZipFilePath: *const ::std::os::raw::c_char,
        pszFileName: *const ::std::os::raw::c_char,
        pSize: *mut ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_uchar;
}
extern "C" {
    #[link_name = "\u{1}?fullPathForFilename@CCFileUtils@cocos2d@@UEAA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEBD_N@Z"]
    pub fn cocos2d_CCFileUtils_fullPathForFilename(
        this: *mut ::std::os::raw::c_void,
        pszFileName: *const ::std::os::raw::c_char,
        arg1: bool,
    ) -> std_string;
}
extern "C" {
    #[doc = " Loads the filenameLookup dictionary from the contents of a filename."]
    #[doc = ""]
    #[doc = " @note The plist file name should follow the format below:"]
    #[doc = ""]
    #[doc = " @code"]
    #[doc = " <?xml version=\"1.0\" encoding=\"UTF-8\"?>"]
    #[doc = " <!DOCTYPE plist PUBLIC \"-//Apple//DTD PLIST 1.0//EN\" \"http://www.apple.com/DTDs/PropertyList-1.0.dtd\">"]
    #[doc = " <plist version=\"1.0\">"]
    #[doc = " <dict>"]
    #[doc = "     <key>filenames</key>"]
    #[doc = "     <dict>"]
    #[doc = "         <key>sounds/click.wav</key>"]
    #[doc = "         <string>sounds/click.caf</string>"]
    #[doc = "         <key>sounds/endgame.wav</key>"]
    #[doc = "         <string>sounds/endgame.caf</string>"]
    #[doc = "         <key>sounds/gem-0.wav</key>"]
    #[doc = "         <string>sounds/gem-0.caf</string>"]
    #[doc = "     </dict>"]
    #[doc = "     <key>metadata</key>"]
    #[doc = "     <dict>"]
    #[doc = "         <key>version</key>"]
    #[doc = "         <integer>1</integer>"]
    #[doc = "     </dict>"]
    #[doc = " </dict>"]
    #[doc = " </plist>"]
    #[doc = " @endcode"]
    #[doc = " @param filename The plist file name."]
    #[doc = ""]
    #[doc = " @since v2.1"]
    #[doc = " @loadFilenameLookup"]
    #[link_name = "\u{1}?loadFilenameLookupDictionaryFromFile@CCFileUtils@cocos2d@@UEAAXPEBD@Z"]
    pub fn cocos2d_CCFileUtils_loadFilenameLookupDictionaryFromFile(
        this: *mut ::std::os::raw::c_void,
        filename: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    #[doc = "  Sets the filenameLookup dictionary."]
    #[doc = ""]
    #[doc = "  @param pFilenameLookupDict The dictionary for replacing filename."]
    #[doc = "  @since v2.1"]
    #[doc = "  @lua NA"]
    #[link_name = "\u{1}?setFilenameLookupDictionary@CCFileUtils@cocos2d@@UEAAXPEAVCCDictionary@2@@Z"]
    pub fn cocos2d_CCFileUtils_setFilenameLookupDictionary(
        this: *mut ::std::os::raw::c_void,
        pFilenameLookupDict: *mut cocos2d_CCDictionary,
    );
}
extern "C" {
    #[doc = "  Gets full path from a file name and the path of the reletive file."]
    #[doc = "  @param pszFilename The file name."]
    #[doc = "  @param pszRelativeFile The path of the relative file."]
    #[doc = "  @return The full path."]
    #[doc = "          e.g. pszFilename: hello.png, pszRelativeFile: /User/path1/path2/hello.plist"]
    #[doc = "               Return: /User/path1/path2/hello.pvr (If there a a key(hello.png)-value(hello.pvr) in FilenameLookup dictionary. )"]
    #[doc = ""]
    #[link_name = "\u{1}?fullPathFromRelativeFile@CCFileUtils@cocos2d@@UEAAPEBDPEBD0@Z"]
    pub fn cocos2d_CCFileUtils_fullPathFromRelativeFile(
        this: *mut ::std::os::raw::c_void,
        pszFilename: *const ::std::os::raw::c_char,
        pszRelativeFile: *const ::std::os::raw::c_char,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = "  Sets the array that contains the search order of the resources."]
    #[doc = ""]
    #[doc = "  @param searchResolutionsOrder The source array that contains the search order of the resources."]
    #[doc = "  @see getSearchResolutionsOrder(void), fullPathForFilename(const char*)."]
    #[doc = "  @since v2.1"]
    #[doc = "  @js NA"]
    #[doc = "  @lua NA"]
    #[link_name = "\u{1}?setSearchResolutionsOrder@CCFileUtils@cocos2d@@UEAAXAEBV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@Z"]
    pub fn cocos2d_CCFileUtils_setSearchResolutionsOrder(
        this: *mut ::std::os::raw::c_void,
        searchResolutionsOrder: *const [u64; 3usize],
    );
}
extern "C" {
    #[doc = " Append search order of the resources."]
    #[doc = ""]
    #[doc = " @see setSearchResolutionsOrder(), fullPathForFilename()."]
    #[doc = " @since v2.1"]
    #[link_name = "\u{1}?addSearchResolutionsOrder@CCFileUtils@cocos2d@@UEAAXPEBD@Z"]
    pub fn cocos2d_CCFileUtils_addSearchResolutionsOrder(
        this: *mut ::std::os::raw::c_void,
        order: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    #[doc = "  Gets the array that contains the search order of the resources."]
    #[doc = ""]
    #[doc = "  @see setSearchResolutionsOrder(const std::vector<std::string>&), fullPathForFilename(const char*)."]
    #[doc = "  @since v2.1"]
    #[doc = "  @js NA"]
    #[doc = "  @lua NA"]
    #[link_name = "\u{1}?getSearchResolutionsOrder@CCFileUtils@cocos2d@@UEAAAEBV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@XZ"]
    pub fn cocos2d_CCFileUtils_getSearchResolutionsOrder(
        this: *mut ::std::os::raw::c_void,
    ) -> *const [u64; 3usize];
}
extern "C" {
    #[doc = "  Sets the array of search paths."]
    #[doc = ""]
    #[doc = "  You can use this array to modify the search path of the resources."]
    #[doc = "  If you want to use \"themes\" or search resources in the \"cache\", you can do it easily by adding new entries in this array."]
    #[doc = ""]
    #[doc = "  @note This method could access relative path and absolute path."]
    #[doc = "        If the relative path was passed to the vector, CCFileUtils will add the default resource directory before the relative path."]
    #[doc = "        For instance:"]
    #[doc = "        \tOn Android, the default resource root path is \"assets/\"."]
    #[doc = "        \tIf \"/mnt/sdcard/\" and \"resources-large\" were set to the search paths vector,"]
    #[doc = "        \t\"resources-large\" will be converted to \"assets/resources-large\" since it was a relative path."]
    #[doc = ""]
    #[doc = "  @param searchPaths The array contains search paths."]
    #[doc = "  @see fullPathForFilename(const char*)"]
    #[doc = "  @since v2.1"]
    #[doc = "  @js NA"]
    #[doc = "  @lua NA"]
    #[link_name = "\u{1}?setSearchPaths@CCFileUtils@cocos2d@@UEAAXAEBV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@Z"]
    pub fn cocos2d_CCFileUtils_setSearchPaths(
        this: *mut ::std::os::raw::c_void,
        searchPaths: *const [u64; 3usize],
    );
}
extern "C" {
    #[doc = " Adds a path to search paths."]
    #[doc = ""]
    #[doc = " @since v2.2"]
    #[link_name = "\u{1}?addSearchPath@CCFileUtils@cocos2d@@UEAAXPEBD@Z"]
    pub fn cocos2d_CCFileUtils_addSearchPath(
        this: *mut ::std::os::raw::c_void,
        path: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    #[doc = " Removes a path from search paths."]
    #[doc = ""]
    #[doc = " @since v2.2"]
    #[doc = " @lua NA"]
    #[link_name = "\u{1}?removeSearchPath@CCFileUtils@cocos2d@@UEAAXPEBD@Z"]
    pub fn cocos2d_CCFileUtils_removeSearchPath(
        this: *mut ::std::os::raw::c_void,
        path: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    #[doc = "  Gets the array of search paths."]
    #[doc = ""]
    #[doc = "  @return The array of search paths."]
    #[doc = "  @see fullPathForFilename(const char*)."]
    #[doc = "  @js NA"]
    #[doc = "  @lua NA"]
    #[link_name = "\u{1}?getSearchPaths@CCFileUtils@cocos2d@@UEAAAEBV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@XZ"]
    pub fn cocos2d_CCFileUtils_getSearchPaths(
        this: *mut ::std::os::raw::c_void,
    ) -> *const [u64; 3usize];
}
extern "C" {
    #[doc = "  Checks whether the path is an absolute path."]
    #[doc = ""]
    #[doc = "  @note On Android, if the parameter passed in is relative to \"assets/\", this method will treat it as an absolute path."]
    #[doc = "        Also on Blackberry, path starts with \"app/native/Resources/\" is treated as an absolute path."]
    #[doc = ""]
    #[doc = "  @param strPath The path that needs to be checked."]
    #[doc = "  @return true if it's an absolute path, otherwise it will return false."]
    #[doc = "  @lua NA"]
    #[link_name = "\u{1}?isAbsolutePath@CCFileUtils@cocos2d@@UEAA_NAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z"]
    pub fn cocos2d_CCFileUtils_isAbsolutePath(
        this: *mut ::std::os::raw::c_void,
        strPath: *const std_string,
    ) -> bool;
}
extern "C" {
    #[doc = "  Sets/Gets whether to pop-up a message box when failed to load an image."]
    #[link_name = "\u{1}?setPopupNotify@CCFileUtils@cocos2d@@UEAAX_N@Z"]
    pub fn cocos2d_CCFileUtils_setPopupNotify(this: *mut ::std::os::raw::c_void, bNotify: bool);
}
extern "C" {
    #[link_name = "\u{1}?isPopupNotify@CCFileUtils@cocos2d@@UEAA_NXZ"]
    pub fn cocos2d_CCFileUtils_isPopupNotify(this: *mut ::std::os::raw::c_void) -> bool;
}
extern "C" {
    #[doc = "  Initializes the instance of CCFileUtils. It will set m_searchPathArray and m_searchResolutionsOrderArray to default values."]
    #[doc = ""]
    #[doc = "  @note When you are porting Cocos2d-x to a new platform, you may need to take care of this method."]
    #[doc = "        You could assign a default value to m_strDefaultResRootPath in the subclass of CCFileUtils(e.g. CCFileUtilsAndroid). Then invoke the CCFileUtils::init()."]
    #[doc = "  @return true if successed, otherwise it returns false."]
    #[doc = ""]
    #[link_name = "\u{1}?init@CCFileUtils@cocos2d@@MEAA_NXZ"]
    pub fn cocos2d_CCFileUtils_init(this: *mut ::std::os::raw::c_void) -> bool;
}
extern "C" {
    #[doc = "  Gets the new filename from the filename lookup dictionary."]
    #[doc = "  @param pszFileName The original filename."]
    #[doc = "  @return The new filename after searching in the filename lookup dictionary."]
    #[doc = "          If the original filename wasn't in the dictionary, it will return the original filename."]
    #[link_name = "\u{1}?getNewFilename@CCFileUtils@cocos2d@@MEAA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEBD@Z"]
    pub fn cocos2d_CCFileUtils_getNewFilename(
        this: *mut ::std::os::raw::c_void,
        pszFileName: *const ::std::os::raw::c_char,
    ) -> std_string;
}
extern "C" {
    #[doc = "  Gets full path for filename, resolution directory and search path."]
    #[doc = ""]
    #[doc = "  @param filename The file name."]
    #[doc = "  @param resolutionDirectory The resolution directory."]
    #[doc = "  @param searchPath The search path."]
    #[doc = "  @return The full path of the file. It will return an empty string if the full path of the file doesn't exist."]
    #[link_name = "\u{1}?getPathForFilename@CCFileUtils@cocos2d@@MEAA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV34@00@Z"]
    pub fn cocos2d_CCFileUtils_getPathForFilename(
        this: *mut ::std::os::raw::c_void,
        filename: *const std_string,
        resolutionDirectory: *const std_string,
        searchPath: *const std_string,
    ) -> std_string;
}
extern "C" {
    #[doc = "  Gets full path for the directory and the filename."]
    #[doc = ""]
    #[doc = "  @note Only iOS and Mac need to override this method since they are using"]
    #[doc = "        `[[NSBundle mainBundle] pathForResource: ofType: inDirectory:]` to make a full path."]
    #[doc = "        Other platforms will use the default implementation of this method."]
    #[doc = "  @param strDirectory The directory contains the file we are looking for."]
    #[doc = "  @param strFilename  The name of the file."]
    #[doc = "  @return The full path of the file, if the file can't be found, it will return an empty string."]
    #[link_name = "\u{1}?getFullPathForDirectoryAndFilename@CCFileUtils@cocos2d@@MEAA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV34@0@Z"]
    pub fn cocos2d_CCFileUtils_getFullPathForDirectoryAndFilename(
        this: *mut ::std::os::raw::c_void,
        strDirectory: *const std_string,
        strFilename: *const std_string,
    ) -> std_string;
}
extern "C" {
    #[doc = "  Creates a dictionary by the contents of a file."]
    #[doc = "  @note This method is used internally."]
    #[link_name = "\u{1}?createCCDictionaryWithContentsOfFile@CCFileUtils@cocos2d@@MEAAPEAVCCDictionary@2@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z"]
    pub fn cocos2d_CCFileUtils_createCCDictionaryWithContentsOfFile(
        this: *mut ::std::os::raw::c_void,
        filename: *const std_string,
    ) -> *mut cocos2d_CCDictionary;
}
extern "C" {
    #[doc = "  Write a dictionary to a plist file."]
    #[doc = "  @note This method is used internally."]
    #[link_name = "\u{1}?writeToFile@CCFileUtils@cocos2d@@MEAA_NPEAVCCDictionary@2@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z"]
    pub fn cocos2d_CCFileUtils_writeToFile(
        this: *mut ::std::os::raw::c_void,
        dict: *mut cocos2d_CCDictionary,
        fullPath: *const std_string,
    ) -> bool;
}
extern "C" {
    #[doc = "  Creates an array by the contents of a file."]
    #[doc = "  @note This method is used internally."]
    #[link_name = "\u{1}?createCCArrayWithContentsOfFile@CCFileUtils@cocos2d@@MEAAPEAVCCArray@2@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z"]
    pub fn cocos2d_CCFileUtils_createCCArrayWithContentsOfFile(
        this: *mut ::std::os::raw::c_void,
        filename: *const std_string,
    ) -> *mut cocos2d_CCArray;
}
#[doc = " @addtogroup platform"]
#[doc = " @{"]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCImage {
    pub _base: cocos2d_CCObject,
    pub m_nWidth: ::std::os::raw::c_ushort,
    pub m_nHeight: ::std::os::raw::c_ushort,
    pub m_nBitsPerComponent: ::std::os::raw::c_int,
    pub m_pData: *mut ::std::os::raw::c_uchar,
    pub m_bHasAlpha: bool,
    pub m_bPreMulti: bool,
}
pub const cocos2d_CCImage_EImageFormat_kFmtJpg: cocos2d_CCImage_EImageFormat = 0;
pub const cocos2d_CCImage_EImageFormat_kFmtPng: cocos2d_CCImage_EImageFormat = 1;
pub const cocos2d_CCImage_EImageFormat_kFmtTiff: cocos2d_CCImage_EImageFormat = 2;
pub const cocos2d_CCImage_EImageFormat_kFmtWebp: cocos2d_CCImage_EImageFormat = 3;
pub const cocos2d_CCImage_EImageFormat_kFmtRawData: cocos2d_CCImage_EImageFormat = 4;
pub const cocos2d_CCImage_EImageFormat_kFmtUnKnown: cocos2d_CCImage_EImageFormat = 5;
pub type cocos2d_CCImage_EImageFormat = ::std::os::raw::c_int;
#[doc = "< Horizontal center and vertical center."]
pub const cocos2d_CCImage_ETextAlign_kAlignCenter: cocos2d_CCImage_ETextAlign = 51;
#[doc = "< Horizontal center and vertical top."]
pub const cocos2d_CCImage_ETextAlign_kAlignTop: cocos2d_CCImage_ETextAlign = 19;
#[doc = "< Horizontal right and vertical top."]
pub const cocos2d_CCImage_ETextAlign_kAlignTopRight: cocos2d_CCImage_ETextAlign = 18;
#[doc = "< Horizontal right and vertical center."]
pub const cocos2d_CCImage_ETextAlign_kAlignRight: cocos2d_CCImage_ETextAlign = 50;
#[doc = "< Horizontal right and vertical bottom."]
pub const cocos2d_CCImage_ETextAlign_kAlignBottomRight: cocos2d_CCImage_ETextAlign = 34;
#[doc = "< Horizontal center and vertical bottom."]
pub const cocos2d_CCImage_ETextAlign_kAlignBottom: cocos2d_CCImage_ETextAlign = 35;
#[doc = "< Horizontal left and vertical bottom."]
pub const cocos2d_CCImage_ETextAlign_kAlignBottomLeft: cocos2d_CCImage_ETextAlign = 33;
#[doc = "< Horizontal left and vertical center."]
pub const cocos2d_CCImage_ETextAlign_kAlignLeft: cocos2d_CCImage_ETextAlign = 49;
#[doc = "< Horizontal left and vertical top."]
pub const cocos2d_CCImage_ETextAlign_kAlignTopLeft: cocos2d_CCImage_ETextAlign = 17;
pub type cocos2d_CCImage_ETextAlign = ::std::os::raw::c_int;
#[test]
fn bindgen_test_layout_cocos2d_CCImage() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCImage>(),
        64usize,
        concat!("Size of: ", stringify!(cocos2d_CCImage))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCImage>(),
        8usize,
        concat!("Alignment of ", stringify!(cocos2d_CCImage))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cocos2d_CCImage>())).m_nWidth as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCImage),
            "::",
            stringify!(m_nWidth)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cocos2d_CCImage>())).m_nHeight as *const _ as usize },
        42usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCImage),
            "::",
            stringify!(m_nHeight)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cocos2d_CCImage>())).m_nBitsPerComponent as *const _ as usize
        },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCImage),
            "::",
            stringify!(m_nBitsPerComponent)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cocos2d_CCImage>())).m_pData as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCImage),
            "::",
            stringify!(m_pData)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cocos2d_CCImage>())).m_bHasAlpha as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCImage),
            "::",
            stringify!(m_bHasAlpha)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cocos2d_CCImage>())).m_bPreMulti as *const _ as usize },
        57usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCImage),
            "::",
            stringify!(m_bPreMulti)
        )
    );
}
extern "C" {
    #[doc = "@brief  Load the image from the specified path."]
    #[doc = "@param strPath   the absolute file path."]
    #[doc = "@param imageType the type of image, currently only supporting two types."]
    #[doc = "@return  true if loaded correctly."]
    #[link_name = "\u{1}?initWithImageFile@CCImage@cocos2d@@QEAA_NPEBDW4EImageFormat@12@@Z"]
    pub fn cocos2d_CCImage_initWithImageFile(
        this: *mut cocos2d_CCImage,
        strPath: *const ::std::os::raw::c_char,
        imageType: cocos2d_CCImage_EImageFormat,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}?initWithImageFileThreadSafe@CCImage@cocos2d@@QEAA_NPEBDW4EImageFormat@12@@Z"]
    pub fn cocos2d_CCImage_initWithImageFileThreadSafe(
        this: *mut cocos2d_CCImage,
        fullpath: *const ::std::os::raw::c_char,
        imageType: cocos2d_CCImage_EImageFormat,
    ) -> bool;
}
extern "C" {
    #[doc = "@brief  Load image from stream buffer."]
    #[doc = ""]
    #[doc = "@warning kFmtRawData only supports RGBA8888."]
    #[doc = "@param pBuffer  stream buffer which holds the image data."]
    #[doc = "@param nLength  data length expressed in (number of) bytes."]
    #[doc = "@param nWidth, nHeight, nBitsPerComponent are used for kFmtRawData."]
    #[doc = "@return true if loaded correctly."]
    #[doc = "@js NA"]
    #[link_name = "\u{1}?initWithImageData@CCImage@cocos2d@@QEAA_NPEAXHW4EImageFormat@12@HHH@Z"]
    pub fn cocos2d_CCImage_initWithImageData(
        this: *mut cocos2d_CCImage,
        pData: *mut ::std::os::raw::c_void,
        nDataLen: ::std::os::raw::c_int,
        eFmt: cocos2d_CCImage_EImageFormat,
        nWidth: ::std::os::raw::c_int,
        nHeight: ::std::os::raw::c_int,
        nBitsPerComponent: ::std::os::raw::c_int,
    ) -> bool;
}
extern "C" {
    #[doc = "@brief    Create image with specified string."]
    #[doc = "@param  pText       the text the image will show (cannot be nil)."]
    #[doc = "@param  nWidth      the image width, if 0, the width will match the text's width."]
    #[doc = "@param  nHeight     the image height, if 0, the height will match the text's height."]
    #[doc = "@param  eAlignMask  the test Alignment"]
    #[doc = "@param  pFontName   the name of the font used to draw the text. If nil, use the default system font."]
    #[doc = "@param  nSize       the font size, if 0, use the system default size."]
    #[doc = "@js NA"]
    #[link_name = "\u{1}?initWithString@CCImage@cocos2d@@QEAA_NPEBDHHW4ETextAlign@12@0H@Z"]
    pub fn cocos2d_CCImage_initWithString(
        this: *mut cocos2d_CCImage,
        pText: *const ::std::os::raw::c_char,
        nWidth: ::std::os::raw::c_int,
        nHeight: ::std::os::raw::c_int,
        eAlignMask: cocos2d_CCImage_ETextAlign,
        pFontName: *const ::std::os::raw::c_char,
        nSize: ::std::os::raw::c_int,
    ) -> bool;
}
extern "C" {
    #[doc = "@brief    Save CCImage data to the specified file, with specified format."]
    #[doc = "@param    pszFilePath        the file's absolute path, including file suffix."]
    #[doc = "@param    bIsToRGB        whether the image is saved as RGB format."]
    #[link_name = "\u{1}?saveToFile@CCImage@cocos2d@@QEAA_NPEBD_N@Z"]
    pub fn cocos2d_CCImage_saveToFile(
        this: *mut cocos2d_CCImage,
        pszFilePath: *const ::std::os::raw::c_char,
        bIsToRGB: bool,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}?_initWithJpgData@CCImage@cocos2d@@IEAA_NPEAXH@Z"]
    pub fn cocos2d_CCImage__initWithJpgData(
        this: *mut cocos2d_CCImage,
        pData: *mut ::std::os::raw::c_void,
        nDatalen: ::std::os::raw::c_int,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}?_initWithPngData@CCImage@cocos2d@@IEAA_NPEAXH@Z"]
    pub fn cocos2d_CCImage__initWithPngData(
        this: *mut cocos2d_CCImage,
        pData: *mut ::std::os::raw::c_void,
        nDatalen: ::std::os::raw::c_int,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}?_initWithTiffData@CCImage@cocos2d@@IEAA_NPEAXH@Z"]
    pub fn cocos2d_CCImage__initWithTiffData(
        this: *mut cocos2d_CCImage,
        pData: *mut ::std::os::raw::c_void,
        nDataLen: ::std::os::raw::c_int,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}?_initWithWebpData@CCImage@cocos2d@@IEAA_NPEAXH@Z"]
    pub fn cocos2d_CCImage__initWithWebpData(
        this: *mut cocos2d_CCImage,
        pData: *mut ::std::os::raw::c_void,
        nDataLen: ::std::os::raw::c_int,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}?_initWithRawData@CCImage@cocos2d@@IEAA_NPEAXHHHH_N@Z"]
    pub fn cocos2d_CCImage__initWithRawData(
        this: *mut cocos2d_CCImage,
        pData: *mut ::std::os::raw::c_void,
        nDatalen: ::std::os::raw::c_int,
        nWidth: ::std::os::raw::c_int,
        nHeight: ::std::os::raw::c_int,
        nBitsPerComponent: ::std::os::raw::c_int,
        bPreMulti: bool,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}?_saveImageToPNG@CCImage@cocos2d@@IEAA_NPEBD_N@Z"]
    pub fn cocos2d_CCImage__saveImageToPNG(
        this: *mut cocos2d_CCImage,
        pszFilePath: *const ::std::os::raw::c_char,
        bIsToRGB: bool,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}?_saveImageToJPG@CCImage@cocos2d@@IEAA_NPEBD@Z"]
    pub fn cocos2d_CCImage__saveImageToJPG(
        this: *mut cocos2d_CCImage,
        pszFilePath: *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    #[doc = "@js ctor"]
    #[link_name = "\u{1}??0CCImage@cocos2d@@QEAA@XZ"]
    pub fn cocos2d_CCImage_CCImage(this: *mut cocos2d_CCImage);
}
impl cocos2d_CCImage {
    #[inline]
    pub unsafe fn initWithImageFile(
        &mut self,
        strPath: *const ::std::os::raw::c_char,
        imageType: cocos2d_CCImage_EImageFormat,
    ) -> bool {
        cocos2d_CCImage_initWithImageFile(self, strPath, imageType)
    }
    #[inline]
    pub unsafe fn initWithImageFileThreadSafe(
        &mut self,
        fullpath: *const ::std::os::raw::c_char,
        imageType: cocos2d_CCImage_EImageFormat,
    ) -> bool {
        cocos2d_CCImage_initWithImageFileThreadSafe(self, fullpath, imageType)
    }
    #[inline]
    pub unsafe fn initWithImageData(
        &mut self,
        pData: *mut ::std::os::raw::c_void,
        nDataLen: ::std::os::raw::c_int,
        eFmt: cocos2d_CCImage_EImageFormat,
        nWidth: ::std::os::raw::c_int,
        nHeight: ::std::os::raw::c_int,
        nBitsPerComponent: ::std::os::raw::c_int,
    ) -> bool {
        cocos2d_CCImage_initWithImageData(
            self,
            pData,
            nDataLen,
            eFmt,
            nWidth,
            nHeight,
            nBitsPerComponent,
        )
    }
    #[inline]
    pub unsafe fn initWithString(
        &mut self,
        pText: *const ::std::os::raw::c_char,
        nWidth: ::std::os::raw::c_int,
        nHeight: ::std::os::raw::c_int,
        eAlignMask: cocos2d_CCImage_ETextAlign,
        pFontName: *const ::std::os::raw::c_char,
        nSize: ::std::os::raw::c_int,
    ) -> bool {
        cocos2d_CCImage_initWithString(self, pText, nWidth, nHeight, eAlignMask, pFontName, nSize)
    }
    #[inline]
    pub unsafe fn saveToFile(
        &mut self,
        pszFilePath: *const ::std::os::raw::c_char,
        bIsToRGB: bool,
    ) -> bool {
        cocos2d_CCImage_saveToFile(self, pszFilePath, bIsToRGB)
    }
    #[inline]
    pub unsafe fn _initWithJpgData(
        &mut self,
        pData: *mut ::std::os::raw::c_void,
        nDatalen: ::std::os::raw::c_int,
    ) -> bool {
        cocos2d_CCImage__initWithJpgData(self, pData, nDatalen)
    }
    #[inline]
    pub unsafe fn _initWithPngData(
        &mut self,
        pData: *mut ::std::os::raw::c_void,
        nDatalen: ::std::os::raw::c_int,
    ) -> bool {
        cocos2d_CCImage__initWithPngData(self, pData, nDatalen)
    }
    #[inline]
    pub unsafe fn _initWithTiffData(
        &mut self,
        pData: *mut ::std::os::raw::c_void,
        nDataLen: ::std::os::raw::c_int,
    ) -> bool {
        cocos2d_CCImage__initWithTiffData(self, pData, nDataLen)
    }
    #[inline]
    pub unsafe fn _initWithWebpData(
        &mut self,
        pData: *mut ::std::os::raw::c_void,
        nDataLen: ::std::os::raw::c_int,
    ) -> bool {
        cocos2d_CCImage__initWithWebpData(self, pData, nDataLen)
    }
    #[inline]
    pub unsafe fn _initWithRawData(
        &mut self,
        pData: *mut ::std::os::raw::c_void,
        nDatalen: ::std::os::raw::c_int,
        nWidth: ::std::os::raw::c_int,
        nHeight: ::std::os::raw::c_int,
        nBitsPerComponent: ::std::os::raw::c_int,
        bPreMulti: bool,
    ) -> bool {
        cocos2d_CCImage__initWithRawData(
            self,
            pData,
            nDatalen,
            nWidth,
            nHeight,
            nBitsPerComponent,
            bPreMulti,
        )
    }
    #[inline]
    pub unsafe fn _saveImageToPNG(
        &mut self,
        pszFilePath: *const ::std::os::raw::c_char,
        bIsToRGB: bool,
    ) -> bool {
        cocos2d_CCImage__saveImageToPNG(self, pszFilePath, bIsToRGB)
    }
    #[inline]
    pub unsafe fn _saveImageToJPG(&mut self, pszFilePath: *const ::std::os::raw::c_char) -> bool {
        cocos2d_CCImage__saveImageToJPG(self, pszFilePath)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cocos2d_CCImage_CCImage(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
}
extern "C" {
    #[doc = " @js NA"]
    #[doc = " @lua NA"]
    #[link_name = "\u{1}??_DCCImage@cocos2d@@QEAAXXZ"]
    pub fn cocos2d_CCImage_CCImage_destructor(this: *mut cocos2d_CCImage);
}
#[doc = " @addtogroup platform"]
#[doc = " @{"]
pub type cocos2d_CC_XML_CHAR = ::std::os::raw::c_uchar;
#[repr(C)]
pub struct cocos2d_CCSAXDelegator__bindgen_vtable(::std::os::raw::c_void);
#[doc = " @js NA"]
#[doc = " @lua NA"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cocos2d_CCSAXDelegator {
    pub vtable_: *const cocos2d_CCSAXDelegator__bindgen_vtable,
}
#[test]
fn bindgen_test_layout_cocos2d_CCSAXDelegator() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCSAXDelegator>(),
        8usize,
        concat!("Size of: ", stringify!(cocos2d_CCSAXDelegator))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCSAXDelegator>(),
        8usize,
        concat!("Alignment of ", stringify!(cocos2d_CCSAXDelegator))
    );
}
#[doc = " @js NA"]
#[doc = " @lua NA"]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCSAXParser {
    pub m_pDelegator: *mut cocos2d_CCSAXDelegator,
}
#[test]
fn bindgen_test_layout_cocos2d_CCSAXParser() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCSAXParser>(),
        8usize,
        concat!("Size of: ", stringify!(cocos2d_CCSAXParser))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCSAXParser>(),
        8usize,
        concat!("Alignment of ", stringify!(cocos2d_CCSAXParser))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cocos2d_CCSAXParser>())).m_pDelegator as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCSAXParser),
            "::",
            stringify!(m_pDelegator)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}?init@CCSAXParser@cocos2d@@QEAA_NPEBD@Z"]
    pub fn cocos2d_CCSAXParser_init(
        this: *mut cocos2d_CCSAXParser,
        pszEncoding: *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}?parse@CCSAXParser@cocos2d@@QEAA_NPEBDI@Z"]
    pub fn cocos2d_CCSAXParser_parse(
        this: *mut cocos2d_CCSAXParser,
        pXMLData: *const ::std::os::raw::c_char,
        uDataLength: ::std::os::raw::c_uint,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}?parse@CCSAXParser@cocos2d@@QEAA_NPEBD@Z"]
    pub fn cocos2d_CCSAXParser_parse1(
        this: *mut cocos2d_CCSAXParser,
        pszFile: *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}?setDelegator@CCSAXParser@cocos2d@@QEAAXPEAVCCSAXDelegator@2@@Z"]
    pub fn cocos2d_CCSAXParser_setDelegator(
        this: *mut cocos2d_CCSAXParser,
        pDelegator: *mut cocos2d_CCSAXDelegator,
    );
}
extern "C" {
    #[link_name = "\u{1}?startElement@CCSAXParser@cocos2d@@SAXPEAXPEBEPEAPEBE@Z"]
    pub fn cocos2d_CCSAXParser_startElement(
        ctx: *mut ::std::os::raw::c_void,
        name: *const cocos2d_CC_XML_CHAR,
        atts: *mut *const cocos2d_CC_XML_CHAR,
    );
}
extern "C" {
    #[link_name = "\u{1}?endElement@CCSAXParser@cocos2d@@SAXPEAXPEBE@Z"]
    pub fn cocos2d_CCSAXParser_endElement(
        ctx: *mut ::std::os::raw::c_void,
        name: *const cocos2d_CC_XML_CHAR,
    );
}
extern "C" {
    #[link_name = "\u{1}?textHandler@CCSAXParser@cocos2d@@SAXPEAXPEBEH@Z"]
    pub fn cocos2d_CCSAXParser_textHandler(
        ctx: *mut ::std::os::raw::c_void,
        name: *const cocos2d_CC_XML_CHAR,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}??0CCSAXParser@cocos2d@@QEAA@XZ"]
    pub fn cocos2d_CCSAXParser_CCSAXParser(this: *mut cocos2d_CCSAXParser);
}
extern "C" {
    #[link_name = "\u{1}??_DCCSAXParser@cocos2d@@QEAAXXZ"]
    pub fn cocos2d_CCSAXParser_CCSAXParser_destructor(this: *mut cocos2d_CCSAXParser);
}
impl cocos2d_CCSAXParser {
    #[inline]
    pub unsafe fn init(&mut self, pszEncoding: *const ::std::os::raw::c_char) -> bool {
        cocos2d_CCSAXParser_init(self, pszEncoding)
    }
    #[inline]
    pub unsafe fn parse(
        &mut self,
        pXMLData: *const ::std::os::raw::c_char,
        uDataLength: ::std::os::raw::c_uint,
    ) -> bool {
        cocos2d_CCSAXParser_parse(self, pXMLData, uDataLength)
    }
    #[inline]
    pub unsafe fn parse1(&mut self, pszFile: *const ::std::os::raw::c_char) -> bool {
        cocos2d_CCSAXParser_parse1(self, pszFile)
    }
    #[inline]
    pub unsafe fn setDelegator(&mut self, pDelegator: *mut cocos2d_CCSAXDelegator) {
        cocos2d_CCSAXParser_setDelegator(self, pDelegator)
    }
    #[inline]
    pub unsafe fn startElement(
        ctx: *mut ::std::os::raw::c_void,
        name: *const cocos2d_CC_XML_CHAR,
        atts: *mut *const cocos2d_CC_XML_CHAR,
    ) {
        cocos2d_CCSAXParser_startElement(ctx, name, atts)
    }
    #[inline]
    pub unsafe fn endElement(ctx: *mut ::std::os::raw::c_void, name: *const cocos2d_CC_XML_CHAR) {
        cocos2d_CCSAXParser_endElement(ctx, name)
    }
    #[inline]
    pub unsafe fn textHandler(
        ctx: *mut ::std::os::raw::c_void,
        name: *const cocos2d_CC_XML_CHAR,
        len: ::std::os::raw::c_int,
    ) {
        cocos2d_CCSAXParser_textHandler(ctx, name, len)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cocos2d_CCSAXParser_CCSAXParser(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn destruct(&mut self) {
        cocos2d_CCSAXParser_CCSAXParser_destructor(self)
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCThread {
    pub m_pAutoreasePool: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_cocos2d_CCThread() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCThread>(),
        8usize,
        concat!("Size of: ", stringify!(cocos2d_CCThread))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCThread>(),
        8usize,
        concat!("Alignment of ", stringify!(cocos2d_CCThread))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cocos2d_CCThread>())).m_pAutoreasePool as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCThread),
            "::",
            stringify!(m_pAutoreasePool)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}?createAutoreleasePool@CCThread@cocos2d@@QEAAXXZ"]
    pub fn cocos2d_CCThread_createAutoreleasePool(this: *mut cocos2d_CCThread);
}
extern "C" {
    #[link_name = "\u{1}??_DCCThread@cocos2d@@QEAAXXZ"]
    pub fn cocos2d_CCThread_CCThread_destructor(this: *mut cocos2d_CCThread);
}
impl cocos2d_CCThread {
    #[inline]
    pub unsafe fn createAutoreleasePool(&mut self) {
        cocos2d_CCThread_createAutoreleasePool(self)
    }
    #[inline]
    pub unsafe fn destruct(&mut self) {
        cocos2d_CCThread_CCThread_destructor(self)
    }
}
#[doc = " @addtogroup platform"]
#[doc = " @{"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cocos2d_cc_timeval {
    pub tv_sec: ::std::os::raw::c_long,
    pub tv_usec: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_cocos2d_cc_timeval() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d_cc_timeval>(),
        8usize,
        concat!("Size of: ", stringify!(cocos2d_cc_timeval))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_cc_timeval>(),
        4usize,
        concat!("Alignment of ", stringify!(cocos2d_cc_timeval))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cocos2d_cc_timeval>())).tv_sec as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_cc_timeval),
            "::",
            stringify!(tv_sec)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cocos2d_cc_timeval>())).tv_usec as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_cc_timeval),
            "::",
            stringify!(tv_usec)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cocos2d_CCTime {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout_cocos2d_CCTime() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCTime>(),
        1usize,
        concat!("Size of: ", stringify!(cocos2d_CCTime))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCTime>(),
        1usize,
        concat!("Alignment of ", stringify!(cocos2d_CCTime))
    );
}
extern "C" {
    #[link_name = "\u{1}?gettimeofdayCocos2d@CCTime@cocos2d@@SAHPEAUcc_timeval@2@PEAX@Z"]
    pub fn cocos2d_CCTime_gettimeofdayCocos2d(
        tp: *mut cocos2d_cc_timeval,
        tzp: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}?timersubCocos2d@CCTime@cocos2d@@SANPEAUcc_timeval@2@0@Z"]
    pub fn cocos2d_CCTime_timersubCocos2d(
        start: *mut cocos2d_cc_timeval,
        end: *mut cocos2d_cc_timeval,
    ) -> f64;
}
impl cocos2d_CCTime {
    #[inline]
    pub unsafe fn gettimeofdayCocos2d(
        tp: *mut cocos2d_cc_timeval,
        tzp: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int {
        cocos2d_CCTime_gettimeofdayCocos2d(tp, tzp)
    }
    #[inline]
    pub unsafe fn timersubCocos2d(
        start: *mut cocos2d_cc_timeval,
        end: *mut cocos2d_cc_timeval,
    ) -> f64 {
        cocos2d_CCTime_timersubCocos2d(start, end)
    }
}
pub const cocos2d_TargetPlatform_kTargetWindows: cocos2d_TargetPlatform = 0;
pub const cocos2d_TargetPlatform_kTargetLinux: cocos2d_TargetPlatform = 1;
pub const cocos2d_TargetPlatform_kTargetMacOS: cocos2d_TargetPlatform = 2;
pub const cocos2d_TargetPlatform_kTargetAndroid: cocos2d_TargetPlatform = 3;
pub const cocos2d_TargetPlatform_kTargetIphone: cocos2d_TargetPlatform = 4;
pub const cocos2d_TargetPlatform_kTargetIpad: cocos2d_TargetPlatform = 5;
pub const cocos2d_TargetPlatform_kTargetBlackBerry: cocos2d_TargetPlatform = 6;
pub const cocos2d_TargetPlatform_kTargetNaCl: cocos2d_TargetPlatform = 7;
pub const cocos2d_TargetPlatform_kTargetEmscripten: cocos2d_TargetPlatform = 8;
pub const cocos2d_TargetPlatform_kTargetTizen: cocos2d_TargetPlatform = 9;
pub const cocos2d_TargetPlatform_kTargetWinRT: cocos2d_TargetPlatform = 10;
pub const cocos2d_TargetPlatform_kTargetWP8: cocos2d_TargetPlatform = 11;
pub type cocos2d_TargetPlatform = ::std::os::raw::c_int;
#[repr(C)]
pub struct cocos2d_CCApplicationProtocol__bindgen_vtable(::std::os::raw::c_void);
#[doc = " @addtogroup platform"]
#[doc = " @{"]
#[doc = " @js NA"]
#[doc = " @lua NA"]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCApplicationProtocol {
    pub vtable_: *const cocos2d_CCApplicationProtocol__bindgen_vtable,
}
#[test]
fn bindgen_test_layout_cocos2d_CCApplicationProtocol() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCApplicationProtocol>(),
        8usize,
        concat!("Size of: ", stringify!(cocos2d_CCApplicationProtocol))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCApplicationProtocol>(),
        8usize,
        concat!("Alignment of ", stringify!(cocos2d_CCApplicationProtocol))
    );
}
extern "C" {
    #[link_name = "\u{1}?applicationWillBecomeActive@CCApplicationProtocol@cocos2d@@UEAAXXZ"]
    pub fn cocos2d_CCApplicationProtocol_applicationWillBecomeActive(
        this: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    #[link_name = "\u{1}?applicationWillResignActive@CCApplicationProtocol@cocos2d@@UEAAXXZ"]
    pub fn cocos2d_CCApplicationProtocol_applicationWillResignActive(
        this: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    #[link_name = "\u{1}?trySaveGame@CCApplicationProtocol@cocos2d@@UEAAXXZ"]
    pub fn cocos2d_CCApplicationProtocol_trySaveGame(this: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[link_name = "\u{1}?gameDidSave@CCApplicationProtocol@cocos2d@@UEAAXXZ"]
    pub fn cocos2d_CCApplicationProtocol_gameDidSave(this: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[link_name = "\u{1}?openURL@CCApplicationProtocol@cocos2d@@UEAAXPEBD@Z"]
    pub fn cocos2d_CCApplicationProtocol_openURL(
        this: *mut ::std::os::raw::c_void,
        url: *const ::std::os::raw::c_char,
    );
}
#[repr(C)]
pub struct cocos2d_CCApplication {
    pub _base: cocos2d_CCApplicationProtocol,
    pub m_hInstance: HINSTANCE,
    pub m_hAccelTable: HACCEL,
    pub m_nAnimationInterval: LARGE_INTEGER,
    pub m_resourceRootPath: std_string,
    pub m_startupScriptFilename: std_string,
}
extern "C" {
    #[link_name = "\u{1}?sm_pSharedApplication@CCApplication@cocos2d@@1PEAV12@EA"]
    pub static mut cocos2d_CCApplication_sm_pSharedApplication: *mut cocos2d_CCApplication;
}
#[test]
fn bindgen_test_layout_cocos2d_CCApplication() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCApplication>(),
        96usize,
        concat!("Size of: ", stringify!(cocos2d_CCApplication))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCApplication>(),
        8usize,
        concat!("Alignment of ", stringify!(cocos2d_CCApplication))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cocos2d_CCApplication>())).m_hInstance as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCApplication),
            "::",
            stringify!(m_hInstance)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cocos2d_CCApplication>())).m_hAccelTable as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCApplication),
            "::",
            stringify!(m_hAccelTable)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cocos2d_CCApplication>())).m_nAnimationInterval as *const _
                as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCApplication),
            "::",
            stringify!(m_nAnimationInterval)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cocos2d_CCApplication>())).m_resourceRootPath as *const _
                as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCApplication),
            "::",
            stringify!(m_resourceRootPath)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cocos2d_CCApplication>())).m_startupScriptFilename as *const _
                as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCApplication),
            "::",
            stringify!(m_startupScriptFilename)
        )
    );
}
extern "C" {
    #[doc = "@brief    Get current applicaiton instance."]
    #[doc = "@return Current application instance pointer."]
    #[link_name = "\u{1}?sharedApplication@CCApplication@cocos2d@@SAPEAV12@XZ"]
    pub fn cocos2d_CCApplication_sharedApplication() -> *mut cocos2d_CCApplication;
}
extern "C" {
    #[doc = "  Sets the Resource root path."]
    #[doc = "  @deprecated Please use CCFileUtils::sharedFileUtils()->setSearchPaths() instead."]
    #[link_name = "\u{1}?setResourceRootPath@CCApplication@cocos2d@@QEAAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z"]
    pub fn cocos2d_CCApplication_setResourceRootPath(
        this: *mut cocos2d_CCApplication,
        rootResDir: *const std_string,
    );
}
extern "C" {
    #[doc = "  Gets the Resource root path."]
    #[doc = "  @deprecated Please use CCFileUtils::sharedFileUtils()->getSearchPaths() instead."]
    #[link_name = "\u{1}?getResourceRootPath@CCApplication@cocos2d@@QEAAAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ"]
    pub fn cocos2d_CCApplication_getResourceRootPath(
        this: *mut cocos2d_CCApplication,
    ) -> *const std_string;
}
extern "C" {
    #[link_name = "\u{1}?setStartupScriptFilename@CCApplication@cocos2d@@QEAAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z"]
    pub fn cocos2d_CCApplication_setStartupScriptFilename(
        this: *mut cocos2d_CCApplication,
        startupScriptFile: *const std_string,
    );
}
extern "C" {
    #[link_name = "\u{1}??0CCApplication@cocos2d@@QEAA@XZ"]
    pub fn cocos2d_CCApplication_CCApplication(this: *mut cocos2d_CCApplication);
}
impl cocos2d_CCApplication {
    #[inline]
    pub unsafe fn sharedApplication() -> *mut cocos2d_CCApplication {
        cocos2d_CCApplication_sharedApplication()
    }
    #[inline]
    pub unsafe fn setResourceRootPath(&mut self, rootResDir: *const std_string) {
        cocos2d_CCApplication_setResourceRootPath(self, rootResDir)
    }
    #[inline]
    pub unsafe fn getResourceRootPath(&mut self) -> *const std_string {
        cocos2d_CCApplication_getResourceRootPath(self)
    }
    #[inline]
    pub unsafe fn setStartupScriptFilename(&mut self, startupScriptFile: *const std_string) {
        cocos2d_CCApplication_setStartupScriptFilename(self, startupScriptFile)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cocos2d_CCApplication_CCApplication(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
}
extern "C" {
    #[link_name = "\u{1}??_DCCApplication@cocos2d@@QEAAXXZ"]
    pub fn cocos2d_CCApplication_CCApplication_destructor(this: *mut cocos2d_CCApplication);
}
extern "C" {
    #[link_name = "\u{1}?gameDidSave@CCApplication@cocos2d@@UEAAXXZ"]
    pub fn cocos2d_CCApplication_gameDidSave(this: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[link_name = "\u{1}?setAnimationInterval@CCApplication@cocos2d@@UEAAXN@Z"]
    pub fn cocos2d_CCApplication_setAnimationInterval(
        this: *mut ::std::os::raw::c_void,
        interval: f64,
    );
}
extern "C" {
    #[link_name = "\u{1}?getCurrentLanguage@CCApplication@cocos2d@@UEAA?AW4LanguageType@2@XZ"]
    pub fn cocos2d_CCApplication_getCurrentLanguage(
        this: *mut ::std::os::raw::c_void,
    ) -> cocos2d_ccLanguageType;
}
extern "C" {
    #[doc = "@brief Get target platform"]
    #[link_name = "\u{1}?getTargetPlatform@CCApplication@cocos2d@@UEAA?AW4TargetPlatform@2@XZ"]
    pub fn cocos2d_CCApplication_getTargetPlatform(
        this: *mut ::std::os::raw::c_void,
    ) -> cocos2d_TargetPlatform;
}
extern "C" {
    #[link_name = "\u{1}?openURL@CCApplication@cocos2d@@UEAAXPEBD@Z"]
    pub fn cocos2d_CCApplication_openURL(
        this: *mut ::std::os::raw::c_void,
        url: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    #[link_name = "\u{1}?run@CCApplication@cocos2d@@UEAAHXZ"]
    pub fn cocos2d_CCApplication_run(this: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}?setupGLView@CCApplication@cocos2d@@UEAAXXZ"]
    pub fn cocos2d_CCApplication_setupGLView(this: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[link_name = "\u{1}?platformShutdown@CCApplication@cocos2d@@UEAAXXZ"]
    pub fn cocos2d_CCApplication_platformShutdown(this: *mut ::std::os::raw::c_void);
}
#[repr(C)]
pub struct cocos2d_CCEGLViewProtocol__bindgen_vtable(::std::os::raw::c_void);
#[doc = " @addtogroup platform"]
#[doc = " @{"]
#[doc = " @js NA"]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCEGLViewProtocol {
    pub vtable_: *const cocos2d_CCEGLViewProtocol__bindgen_vtable,
    pub m_pDelegate: *mut cocos2d_EGLTouchDelegate,
    pub m_obScreenSize: cocos2d_CCSize,
    pub m_obDesignResolutionSize: cocos2d_CCSize,
    pub m_obViewPortRect: cocos2d_CCRect,
    pub m_szViewName: [::std::os::raw::c_char; 50usize],
    pub m_fScaleX: f32,
    pub m_fScaleY: f32,
    pub m_eResolutionPolicy: ResolutionPolicy,
}
#[test]
fn bindgen_test_layout_cocos2d_CCEGLViewProtocol() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCEGLViewProtocol>(),
        112usize,
        concat!("Size of: ", stringify!(cocos2d_CCEGLViewProtocol))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCEGLViewProtocol>(),
        8usize,
        concat!("Alignment of ", stringify!(cocos2d_CCEGLViewProtocol))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cocos2d_CCEGLViewProtocol>())).m_pDelegate as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCEGLViewProtocol),
            "::",
            stringify!(m_pDelegate)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cocos2d_CCEGLViewProtocol>())).m_obScreenSize as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCEGLViewProtocol),
            "::",
            stringify!(m_obScreenSize)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cocos2d_CCEGLViewProtocol>())).m_obDesignResolutionSize
                as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCEGLViewProtocol),
            "::",
            stringify!(m_obDesignResolutionSize)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cocos2d_CCEGLViewProtocol>())).m_obViewPortRect as *const _
                as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCEGLViewProtocol),
            "::",
            stringify!(m_obViewPortRect)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cocos2d_CCEGLViewProtocol>())).m_szViewName as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCEGLViewProtocol),
            "::",
            stringify!(m_szViewName)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cocos2d_CCEGLViewProtocol>())).m_fScaleX as *const _ as usize
        },
        100usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCEGLViewProtocol),
            "::",
            stringify!(m_fScaleX)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cocos2d_CCEGLViewProtocol>())).m_fScaleY as *const _ as usize
        },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCEGLViewProtocol),
            "::",
            stringify!(m_fScaleY)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cocos2d_CCEGLViewProtocol>())).m_eResolutionPolicy as *const _
                as usize
        },
        108usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCEGLViewProtocol),
            "::",
            stringify!(m_eResolutionPolicy)
        )
    );
}
extern "C" {
    #[doc = " @lua NA"]
    #[link_name = "\u{1}?getViewName@CCEGLViewProtocol@cocos2d@@QEAAPEBDXZ"]
    pub fn cocos2d_CCEGLViewProtocol_getViewName(
        this: *mut cocos2d_CCEGLViewProtocol,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Get the opengl view port rectangle."]
    #[link_name = "\u{1}?getViewPortRect@CCEGLViewProtocol@cocos2d@@QEBAAEBVCCRect@2@XZ"]
    pub fn cocos2d_CCEGLViewProtocol_getViewPortRect(
        this: *const cocos2d_CCEGLViewProtocol,
    ) -> *const cocos2d_CCRect;
}
extern "C" {
    #[doc = " Get scale factor of the horizontal direction."]
    #[link_name = "\u{1}?getScaleX@CCEGLViewProtocol@cocos2d@@QEBAMXZ"]
    pub fn cocos2d_CCEGLViewProtocol_getScaleX(this: *const cocos2d_CCEGLViewProtocol) -> f32;
}
extern "C" {
    #[doc = " Get scale factor of the vertical direction."]
    #[link_name = "\u{1}?getScaleY@CCEGLViewProtocol@cocos2d@@QEBAMXZ"]
    pub fn cocos2d_CCEGLViewProtocol_getScaleY(this: *const cocos2d_CCEGLViewProtocol) -> f32;
}
extern "C" {
    #[doc = " @lua NA"]
    #[link_name = "\u{1}??0CCEGLViewProtocol@cocos2d@@QEAA@XZ"]
    pub fn cocos2d_CCEGLViewProtocol_CCEGLViewProtocol(this: *mut cocos2d_CCEGLViewProtocol);
}
impl cocos2d_CCEGLViewProtocol {
    #[inline]
    pub unsafe fn getViewName(&mut self) -> *const ::std::os::raw::c_char {
        cocos2d_CCEGLViewProtocol_getViewName(self)
    }
    #[inline]
    pub unsafe fn getViewPortRect(&self) -> *const cocos2d_CCRect {
        cocos2d_CCEGLViewProtocol_getViewPortRect(self)
    }
    #[inline]
    pub unsafe fn getScaleX(&self) -> f32 {
        cocos2d_CCEGLViewProtocol_getScaleX(self)
    }
    #[inline]
    pub unsafe fn getScaleY(&self) -> f32 {
        cocos2d_CCEGLViewProtocol_getScaleY(self)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cocos2d_CCEGLViewProtocol_CCEGLViewProtocol(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
}
extern "C" {
    #[doc = " @lua NA"]
    #[link_name = "\u{1}??_DCCEGLViewProtocol@cocos2d@@QEAAXXZ"]
    pub fn cocos2d_CCEGLViewProtocol_CCEGLViewProtocol_destructor(
        this: *mut cocos2d_CCEGLViewProtocol,
    );
}
extern "C" {
    #[doc = " Get the frame size of EGL view."]
    #[doc = " In general, it returns the screen size since the EGL view is a fullscreen view."]
    #[link_name = "\u{1}?getFrameSize@CCEGLViewProtocol@cocos2d@@UEBAAEBVCCSize@2@XZ"]
    pub fn cocos2d_CCEGLViewProtocol_getFrameSize(
        this: *mut ::std::os::raw::c_void,
    ) -> *const cocos2d_CCSize;
}
extern "C" {
    #[doc = " Set the frame size of EGL view."]
    #[link_name = "\u{1}?setFrameSize@CCEGLViewProtocol@cocos2d@@UEAAXMM@Z"]
    pub fn cocos2d_CCEGLViewProtocol_setFrameSize(
        this: *mut ::std::os::raw::c_void,
        width: f32,
        height: f32,
    );
}
extern "C" {
    #[doc = " Get the visible area size of opengl viewport."]
    #[link_name = "\u{1}?getVisibleSize@CCEGLViewProtocol@cocos2d@@UEBA?AVCCSize@2@XZ"]
    pub fn cocos2d_CCEGLViewProtocol_getVisibleSize(
        this: *mut ::std::os::raw::c_void,
    ) -> cocos2d_CCSize;
}
extern "C" {
    #[doc = " Get the visible origin point of opengl viewport."]
    #[link_name = "\u{1}?getVisibleOrigin@CCEGLViewProtocol@cocos2d@@UEBA?AVCCPoint@2@XZ"]
    pub fn cocos2d_CCEGLViewProtocol_getVisibleOrigin(
        this: *mut ::std::os::raw::c_void,
    ) -> cocos2d_CCPoint;
}
extern "C" {
    #[doc = " Set the design resolution size."]
    #[doc = " @param width Design resolution width."]
    #[doc = " @param height Design resolution height."]
    #[doc = " @param resolutionPolicy The resolution policy desired, you may choose:"]
    #[doc = "                         [1] kResolutionExactFit Fill screen by stretch-to-fit: if the design resolution ratio of width to height is different from the screen resolution ratio, your game view will be stretched."]
    #[doc = "                         [2] kResolutionNoBorder Full screen without black border: if the design resolution ratio of width to height is different from the screen resolution ratio, two areas of your game view will be cut."]
    #[doc = "                         [3] kResolutionShowAll  Full screen with black border: if the design resolution ratio of width to height is different from the screen resolution ratio, two black borders will be shown."]
    #[link_name = "\u{1}?setDesignResolutionSize@CCEGLViewProtocol@cocos2d@@UEAAXMMW4ResolutionPolicy@@@Z"]
    pub fn cocos2d_CCEGLViewProtocol_setDesignResolutionSize(
        this: *mut ::std::os::raw::c_void,
        width: f32,
        height: f32,
        resolutionPolicy: ResolutionPolicy,
    );
}
extern "C" {
    #[doc = " Get design resolution size."]
    #[doc = "  Default resolution size is the same as 'getFrameSize'."]
    #[link_name = "\u{1}?getDesignResolutionSize@CCEGLViewProtocol@cocos2d@@UEBAAEBVCCSize@2@XZ"]
    pub fn cocos2d_CCEGLViewProtocol_getDesignResolutionSize(
        this: *mut ::std::os::raw::c_void,
    ) -> *const cocos2d_CCSize;
}
extern "C" {
    #[doc = " Set touch delegate"]
    #[link_name = "\u{1}?setTouchDelegate@CCEGLViewProtocol@cocos2d@@UEAAXPEAVEGLTouchDelegate@2@@Z"]
    pub fn cocos2d_CCEGLViewProtocol_setTouchDelegate(
        this: *mut ::std::os::raw::c_void,
        pDelegate: *mut cocos2d_EGLTouchDelegate,
    );
}
extern "C" {
    #[doc = " Set opengl view port rectangle with points."]
    #[link_name = "\u{1}?setViewPortInPoints@CCEGLViewProtocol@cocos2d@@UEAAXMMMM@Z"]
    pub fn cocos2d_CCEGLViewProtocol_setViewPortInPoints(
        this: *mut ::std::os::raw::c_void,
        x: f32,
        y: f32,
        w: f32,
        h: f32,
    );
}
extern "C" {
    #[doc = " Set Scissor rectangle with points."]
    #[link_name = "\u{1}?setScissorInPoints@CCEGLViewProtocol@cocos2d@@UEAAXMMMM@Z"]
    pub fn cocos2d_CCEGLViewProtocol_setScissorInPoints(
        this: *mut ::std::os::raw::c_void,
        x: f32,
        y: f32,
        w: f32,
        h: f32,
    );
}
extern "C" {
    #[doc = " Get whether GL_SCISSOR_TEST is enable"]
    #[doc = " @lua NA"]
    #[link_name = "\u{1}?isScissorEnabled@CCEGLViewProtocol@cocos2d@@UEAA_NXZ"]
    pub fn cocos2d_CCEGLViewProtocol_isScissorEnabled(this: *mut ::std::os::raw::c_void) -> bool;
}
extern "C" {
    #[doc = " Get the current scissor rectangle"]
    #[doc = " @lua NA"]
    #[link_name = "\u{1}?getScissorRect@CCEGLViewProtocol@cocos2d@@UEAA?AVCCRect@2@XZ"]
    pub fn cocos2d_CCEGLViewProtocol_getScissorRect(
        this: *mut ::std::os::raw::c_void,
    ) -> cocos2d_CCRect;
}
extern "C" {
    #[doc = " @lua NA"]
    #[link_name = "\u{1}?setViewName@CCEGLViewProtocol@cocos2d@@UEAAXPEBD@Z"]
    pub fn cocos2d_CCEGLViewProtocol_setViewName(
        this: *mut ::std::os::raw::c_void,
        pszViewName: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    #[doc = " Touch events are handled by default; if you want to customize your handlers, please override these functions:"]
    #[doc = " @lua NA"]
    #[link_name = "\u{1}?handleTouchesBegin@CCEGLViewProtocol@cocos2d@@UEAAXHQEAHQEAM1@Z"]
    pub fn cocos2d_CCEGLViewProtocol_handleTouchesBegin(
        this: *mut ::std::os::raw::c_void,
        num: ::std::os::raw::c_int,
        ids: *mut ::std::os::raw::c_int,
        xs: *mut f32,
        ys: *mut f32,
    );
}
extern "C" {
    #[doc = " @lua NA"]
    #[link_name = "\u{1}?handleTouchesMove@CCEGLViewProtocol@cocos2d@@UEAAXHQEAHQEAM1@Z"]
    pub fn cocos2d_CCEGLViewProtocol_handleTouchesMove(
        this: *mut ::std::os::raw::c_void,
        num: ::std::os::raw::c_int,
        ids: *mut ::std::os::raw::c_int,
        xs: *mut f32,
        ys: *mut f32,
    );
}
extern "C" {
    #[doc = " @lua NA"]
    #[link_name = "\u{1}?handleTouchesEnd@CCEGLViewProtocol@cocos2d@@UEAAXHQEAHQEAM1@Z"]
    pub fn cocos2d_CCEGLViewProtocol_handleTouchesEnd(
        this: *mut ::std::os::raw::c_void,
        num: ::std::os::raw::c_int,
        ids: *mut ::std::os::raw::c_int,
        xs: *mut f32,
        ys: *mut f32,
    );
}
extern "C" {
    #[doc = " @lua NA"]
    #[link_name = "\u{1}?handleTouchesCancel@CCEGLViewProtocol@cocos2d@@UEAAXHQEAHQEAM1@Z"]
    pub fn cocos2d_CCEGLViewProtocol_handleTouchesCancel(
        this: *mut ::std::os::raw::c_void,
        num: ::std::os::raw::c_int,
        ids: *mut ::std::os::raw::c_int,
        xs: *mut f32,
        ys: *mut f32,
    );
}
pub type cocos2d_CUSTOM_WND_PROC = ::std::option::Option<
    unsafe extern "C" fn(
        message: UINT,
        wParam: WPARAM,
        lParam: LPARAM,
        pProcessed: *mut BOOL,
    ) -> LRESULT,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cocos2d_CCEGL {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCEGLView {
    pub _base: cocos2d_CCEGLViewProtocol,
    pub _base_1: cocos2d_CCObject,
    pub m_bCaptured: bool,
    pub m_bSupportTouch: bool,
    pub m_bInRetinaMonitor: bool,
    pub m_bRetinaEnabled: bool,
    pub m_nRetinaFactor: ::std::os::raw::c_int,
    pub m_bCursorHidden: bool,
    pub m_fFrameZoomFactor: f32,
    pub m_pMainWindow: *mut GLFWwindow,
    pub m_pPrimaryMonitor: *mut GLFWmonitor,
    pub m_obWindowedSize: cocos2d_CCSize,
    pub m_fMouseX: f32,
    pub m_fMouseY: f32,
    pub m_bIsFullscreen: bool,
    pub m_bShouldHideCursor: bool,
    pub m_bShouldCallGLFinish: bool,
}
pub type cocos2d_CCEGLView_LPFN_ACCELEROMETER_KEYHOOK =
    ::std::option::Option<unsafe extern "C" fn(message: UINT, wParam: WPARAM, lParam: LPARAM)>;
extern "C" {
    #[link_name = "\u{1}?s_pEglView@CCEGLView@cocos2d@@1PEAV12@EA"]
    pub static mut cocos2d_CCEGLView_s_pEglView: *mut cocos2d_CCEGLView;
}
#[test]
fn bindgen_test_layout_cocos2d_CCEGLView() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCEGLView>(),
        208usize,
        concat!("Size of: ", stringify!(cocos2d_CCEGLView))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCEGLView>(),
        8usize,
        concat!("Alignment of ", stringify!(cocos2d_CCEGLView))
    );
}
extern "C" {
    #[link_name = "\u{1}?setMenuResource@CCEGLView@cocos2d@@QEAAXPEB_W@Z"]
    pub fn cocos2d_CCEGLView_setMenuResource(this: *mut cocos2d_CCEGLView, menu: LPCWSTR);
}
extern "C" {
    #[link_name = "\u{1}?setWndProc@CCEGLView@cocos2d@@QEAAXP6A_JI_K_JPEAH@Z@Z"]
    pub fn cocos2d_CCEGLView_setWndProc(
        this: *mut cocos2d_CCEGLView,
        proc_: cocos2d_CUSTOM_WND_PROC,
    );
}
extern "C" {
    #[link_name = "\u{1}?initGL@CCEGLView@cocos2d@@QEAA_NXZ"]
    pub fn cocos2d_CCEGLView_initGL(this: *mut cocos2d_CCEGLView) -> bool;
}
extern "C" {
    #[link_name = "\u{1}?destroyGL@CCEGLView@cocos2d@@QEAAXXZ"]
    pub fn cocos2d_CCEGLView_destroyGL(this: *mut cocos2d_CCEGLView);
}
extern "C" {
    #[link_name = "\u{1}?setHWnd@CCEGLView@cocos2d@@QEAAXPEAUHWND__@@@Z"]
    pub fn cocos2d_CCEGLView_setHWnd(this: *mut cocos2d_CCEGLView, hWnd: HWND);
}
extern "C" {
    #[link_name = "\u{1}?resizeWindow@CCEGLView@cocos2d@@QEAAXHH@Z"]
    pub fn cocos2d_CCEGLView_resizeWindow(
        this: *mut cocos2d_CCEGLView,
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}?setFrameZoomFactor@CCEGLView@cocos2d@@QEAAXM@Z"]
    pub fn cocos2d_CCEGLView_setFrameZoomFactor(this: *mut cocos2d_CCEGLView, fZoomFactor: f32);
}
extern "C" {
    #[link_name = "\u{1}?getFrameZoomFactor@CCEGLView@cocos2d@@QEAAMXZ"]
    pub fn cocos2d_CCEGLView_getFrameZoomFactor(this: *mut cocos2d_CCEGLView) -> f32;
}
extern "C" {
    #[link_name = "\u{1}?centerWindow@CCEGLView@cocos2d@@QEAAXXZ"]
    pub fn cocos2d_CCEGLView_centerWindow(this: *mut cocos2d_CCEGLView);
}
extern "C" {
    #[link_name = "\u{1}?showCursor@CCEGLView@cocos2d@@QEAAX_N@Z"]
    pub fn cocos2d_CCEGLView_showCursor(this: *mut cocos2d_CCEGLView, state: bool);
}
extern "C" {
    #[link_name = "\u{1}?setAccelerometerKeyHook@CCEGLView@cocos2d@@QEAAXP6AXI_K_J@Z@Z"]
    pub fn cocos2d_CCEGLView_setAccelerometerKeyHook(
        this: *mut cocos2d_CCEGLView,
        lpfnAccelerometerKeyHook: cocos2d_CCEGLView_LPFN_ACCELEROMETER_KEYHOOK,
    );
}
extern "C" {
    #[doc = "@brief    get the shared main open gl window"]
    #[link_name = "\u{1}?sharedOpenGLView@CCEGLView@cocos2d@@SAPEAV12@XZ"]
    pub fn cocos2d_CCEGLView_sharedOpenGLView() -> *mut cocos2d_CCEGLView;
}
extern "C" {
    #[link_name = "\u{1}?create@CCEGLView@cocos2d@@SAPEAV12@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z"]
    pub fn cocos2d_CCEGLView_create(arg1: *const std_string) -> *mut cocos2d_CCEGLView;
}
extern "C" {
    #[link_name = "\u{1}?toggleFullScreen@CCEGLView@cocos2d@@QEAAX_N@Z"]
    pub fn cocos2d_CCEGLView_toggleFullScreen(this: *mut cocos2d_CCEGLView, fullscreen: bool);
}
extern "C" {
    #[link_name = "\u{1}?getWindow@CCEGLView@cocos2d@@QEBAPEAUGLFWwindow@@XZ"]
    pub fn cocos2d_CCEGLView_getWindow(this: *const cocos2d_CCEGLView) -> *mut GLFWwindow;
}
extern "C" {
    #[link_name = "\u{1}??0CCEGLView@cocos2d@@QEAA@XZ"]
    pub fn cocos2d_CCEGLView_CCEGLView(this: *mut cocos2d_CCEGLView);
}
impl cocos2d_CCEGLView {
    #[inline]
    pub unsafe fn setMenuResource(&mut self, menu: LPCWSTR) {
        cocos2d_CCEGLView_setMenuResource(self, menu)
    }
    #[inline]
    pub unsafe fn setWndProc(&mut self, proc_: cocos2d_CUSTOM_WND_PROC) {
        cocos2d_CCEGLView_setWndProc(self, proc_)
    }
    #[inline]
    pub unsafe fn initGL(&mut self) -> bool {
        cocos2d_CCEGLView_initGL(self)
    }
    #[inline]
    pub unsafe fn destroyGL(&mut self) {
        cocos2d_CCEGLView_destroyGL(self)
    }
    #[inline]
    pub unsafe fn setHWnd(&mut self, hWnd: HWND) {
        cocos2d_CCEGLView_setHWnd(self, hWnd)
    }
    #[inline]
    pub unsafe fn resizeWindow(
        &mut self,
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
    ) {
        cocos2d_CCEGLView_resizeWindow(self, width, height)
    }
    #[inline]
    pub unsafe fn setFrameZoomFactor(&mut self, fZoomFactor: f32) {
        cocos2d_CCEGLView_setFrameZoomFactor(self, fZoomFactor)
    }
    #[inline]
    pub unsafe fn getFrameZoomFactor(&mut self) -> f32 {
        cocos2d_CCEGLView_getFrameZoomFactor(self)
    }
    #[inline]
    pub unsafe fn centerWindow(&mut self) {
        cocos2d_CCEGLView_centerWindow(self)
    }
    #[inline]
    pub unsafe fn showCursor(&mut self, state: bool) {
        cocos2d_CCEGLView_showCursor(self, state)
    }
    #[inline]
    pub unsafe fn setAccelerometerKeyHook(
        &mut self,
        lpfnAccelerometerKeyHook: cocos2d_CCEGLView_LPFN_ACCELEROMETER_KEYHOOK,
    ) {
        cocos2d_CCEGLView_setAccelerometerKeyHook(self, lpfnAccelerometerKeyHook)
    }
    #[inline]
    pub unsafe fn sharedOpenGLView() -> *mut cocos2d_CCEGLView {
        cocos2d_CCEGLView_sharedOpenGLView()
    }
    #[inline]
    pub unsafe fn create(arg1: *const std_string) -> *mut cocos2d_CCEGLView {
        cocos2d_CCEGLView_create(arg1)
    }
    #[inline]
    pub unsafe fn toggleFullScreen(&mut self, fullscreen: bool) {
        cocos2d_CCEGLView_toggleFullScreen(self, fullscreen)
    }
    #[inline]
    pub unsafe fn getWindow(&self) -> *mut GLFWwindow {
        cocos2d_CCEGLView_getWindow(self)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cocos2d_CCEGLView_CCEGLView(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
}
extern "C" {
    #[link_name = "\u{1}?isOpenGLReady@CCEGLView@cocos2d@@UEAA_NXZ"]
    pub fn cocos2d_CCEGLView_isOpenGLReady(this: *mut ::std::os::raw::c_void) -> bool;
}
extern "C" {
    #[link_name = "\u{1}?end@CCEGLView@cocos2d@@UEAAXXZ"]
    pub fn cocos2d_CCEGLView_end(this: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[link_name = "\u{1}?swapBuffers@CCEGLView@cocos2d@@UEAAXXZ"]
    pub fn cocos2d_CCEGLView_swapBuffers(this: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[link_name = "\u{1}?setFrameSize@CCEGLView@cocos2d@@UEAAXMM@Z"]
    pub fn cocos2d_CCEGLView_setFrameSize(
        this: *mut ::std::os::raw::c_void,
        width: f32,
        height: f32,
    );
}
extern "C" {
    #[link_name = "\u{1}?setIMEKeyboardState@CCEGLView@cocos2d@@UEAAX_N@Z"]
    pub fn cocos2d_CCEGLView_setIMEKeyboardState(this: *mut ::std::os::raw::c_void, bOpen: bool);
}
extern "C" {
    #[link_name = "\u{1}?setViewPortInPoints@CCEGLView@cocos2d@@UEAAXMMMM@Z"]
    pub fn cocos2d_CCEGLView_setViewPortInPoints(
        this: *mut ::std::os::raw::c_void,
        x: f32,
        y: f32,
        w: f32,
        h: f32,
    );
}
extern "C" {
    #[link_name = "\u{1}?setScissorInPoints@CCEGLView@cocos2d@@UEAAXMMMM@Z"]
    pub fn cocos2d_CCEGLView_setScissorInPoints(
        this: *mut ::std::os::raw::c_void,
        x: f32,
        y: f32,
        w: f32,
        h: f32,
    );
}
#[doc = " CCShaderCache"]
#[doc = "Singleton that stores manages GL shaders"]
#[doc = "@since v2.0"]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCShaderCache {
    pub _base: cocos2d_CCObject,
    pub m_pPrograms: *mut cocos2d_CCDictionary,
}
#[test]
fn bindgen_test_layout_cocos2d_CCShaderCache() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCShaderCache>(),
        48usize,
        concat!("Size of: ", stringify!(cocos2d_CCShaderCache))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCShaderCache>(),
        8usize,
        concat!("Alignment of ", stringify!(cocos2d_CCShaderCache))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cocos2d_CCShaderCache>())).m_pPrograms as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCShaderCache),
            "::",
            stringify!(m_pPrograms)
        )
    );
}
extern "C" {
    #[doc = " returns the shared instance"]
    #[doc = "  @js getInstance"]
    #[link_name = "\u{1}?sharedShaderCache@CCShaderCache@cocos2d@@SAPEAV12@XZ"]
    pub fn cocos2d_CCShaderCache_sharedShaderCache() -> *mut cocos2d_CCShaderCache;
}
extern "C" {
    #[doc = " purges the cache. It releases the retained instance."]
    #[link_name = "\u{1}?purgeSharedShaderCache@CCShaderCache@cocos2d@@SAXXZ"]
    pub fn cocos2d_CCShaderCache_purgeSharedShaderCache();
}
extern "C" {
    #[doc = " loads the default shaders"]
    #[link_name = "\u{1}?loadDefaultShaders@CCShaderCache@cocos2d@@QEAAXXZ"]
    pub fn cocos2d_CCShaderCache_loadDefaultShaders(this: *mut cocos2d_CCShaderCache);
}
extern "C" {
    #[doc = " reload the default shaders"]
    #[link_name = "\u{1}?reloadDefaultShaders@CCShaderCache@cocos2d@@QEAAXXZ"]
    pub fn cocos2d_CCShaderCache_reloadDefaultShaders(this: *mut cocos2d_CCShaderCache);
}
extern "C" {
    #[doc = " returns a GL program for a given key"]
    #[doc = "  @js getProgram"]
    #[link_name = "\u{1}?programForKey@CCShaderCache@cocos2d@@QEAAPEAVCCGLProgram@2@PEBD@Z"]
    pub fn cocos2d_CCShaderCache_programForKey(
        this: *mut cocos2d_CCShaderCache,
        key: *const ::std::os::raw::c_char,
    ) -> *mut cocos2d_CCGLProgram;
}
extern "C" {
    #[doc = " adds a CCGLProgram to the cache for a given name"]
    #[link_name = "\u{1}?addProgram@CCShaderCache@cocos2d@@QEAAXPEAVCCGLProgram@2@PEBD@Z"]
    pub fn cocos2d_CCShaderCache_addProgram(
        this: *mut cocos2d_CCShaderCache,
        program: *mut cocos2d_CCGLProgram,
        key: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    #[doc = " @js ctor"]
    #[link_name = "\u{1}??0CCShaderCache@cocos2d@@QEAA@XZ"]
    pub fn cocos2d_CCShaderCache_CCShaderCache(this: *mut cocos2d_CCShaderCache);
}
impl cocos2d_CCShaderCache {
    #[inline]
    pub unsafe fn sharedShaderCache() -> *mut cocos2d_CCShaderCache {
        cocos2d_CCShaderCache_sharedShaderCache()
    }
    #[inline]
    pub unsafe fn purgeSharedShaderCache() {
        cocos2d_CCShaderCache_purgeSharedShaderCache()
    }
    #[inline]
    pub unsafe fn loadDefaultShaders(&mut self) {
        cocos2d_CCShaderCache_loadDefaultShaders(self)
    }
    #[inline]
    pub unsafe fn reloadDefaultShaders(&mut self) {
        cocos2d_CCShaderCache_reloadDefaultShaders(self)
    }
    #[inline]
    pub unsafe fn programForKey(
        &mut self,
        key: *const ::std::os::raw::c_char,
    ) -> *mut cocos2d_CCGLProgram {
        cocos2d_CCShaderCache_programForKey(self, key)
    }
    #[inline]
    pub unsafe fn addProgram(
        &mut self,
        program: *mut cocos2d_CCGLProgram,
        key: *const ::std::os::raw::c_char,
    ) {
        cocos2d_CCShaderCache_addProgram(self, program, key)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cocos2d_CCShaderCache_CCShaderCache(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
}
extern "C" {
    #[doc = " @js NA"]
    #[doc = " @lua NA"]
    #[link_name = "\u{1}??_DCCShaderCache@cocos2d@@QEAAXXZ"]
    pub fn cocos2d_CCShaderCache_CCShaderCache_destructor(this: *mut cocos2d_CCShaderCache);
}
extern "C" {
    #[doc = " @addtogroup shaders"]
    #[doc = " @{"]
    #[link_name = "\u{1}?ccPosition_uColor_frag@cocos2d@@3PEBDEB"]
    pub static mut cocos2d_ccPosition_uColor_frag: *const GLchar;
}
extern "C" {
    #[link_name = "\u{1}?ccPosition_uColor_vert@cocos2d@@3PEBDEB"]
    pub static mut cocos2d_ccPosition_uColor_vert: *const GLchar;
}
extern "C" {
    #[link_name = "\u{1}?ccPositionColor_frag@cocos2d@@3PEBDEB"]
    pub static mut cocos2d_ccPositionColor_frag: *const GLchar;
}
extern "C" {
    #[link_name = "\u{1}?ccPositionColor_vert@cocos2d@@3PEBDEB"]
    pub static mut cocos2d_ccPositionColor_vert: *const GLchar;
}
extern "C" {
    #[link_name = "\u{1}?ccPositionTexture_frag@cocos2d@@3PEBDEB"]
    pub static mut cocos2d_ccPositionTexture_frag: *const GLchar;
}
extern "C" {
    #[link_name = "\u{1}?ccPositionTexture_vert@cocos2d@@3PEBDEB"]
    pub static mut cocos2d_ccPositionTexture_vert: *const GLchar;
}
extern "C" {
    #[link_name = "\u{1}?ccPositionTextureA8Color_frag@cocos2d@@3PEBDEB"]
    pub static mut cocos2d_ccPositionTextureA8Color_frag: *const GLchar;
}
extern "C" {
    #[link_name = "\u{1}?ccPositionTextureA8Color_vert@cocos2d@@3PEBDEB"]
    pub static mut cocos2d_ccPositionTextureA8Color_vert: *const GLchar;
}
extern "C" {
    #[link_name = "\u{1}?ccPositionTextureColor_frag@cocos2d@@3PEBDEB"]
    pub static mut cocos2d_ccPositionTextureColor_frag: *const GLchar;
}
extern "C" {
    #[link_name = "\u{1}?ccPositionTextureColor_vert@cocos2d@@3PEBDEB"]
    pub static mut cocos2d_ccPositionTextureColor_vert: *const GLchar;
}
extern "C" {
    #[link_name = "\u{1}?ccPositionTextureColorAlphaTest_frag@cocos2d@@3PEBDEB"]
    pub static mut cocos2d_ccPositionTextureColorAlphaTest_frag: *const GLchar;
}
extern "C" {
    #[link_name = "\u{1}?ccPositionTexture_uColor_frag@cocos2d@@3PEBDEB"]
    pub static mut cocos2d_ccPositionTexture_uColor_frag: *const GLchar;
}
extern "C" {
    #[link_name = "\u{1}?ccPositionTexture_uColor_vert@cocos2d@@3PEBDEB"]
    pub static mut cocos2d_ccPositionTexture_uColor_vert: *const GLchar;
}
extern "C" {
    #[link_name = "\u{1}?ccPositionColorLengthTexture_frag@cocos2d@@3PEBDEB"]
    pub static mut cocos2d_ccPositionColorLengthTexture_frag: *const GLchar;
}
extern "C" {
    #[link_name = "\u{1}?ccPositionColorLengthTexture_vert@cocos2d@@3PEBDEB"]
    pub static mut cocos2d_ccPositionColorLengthTexture_vert: *const GLchar;
}
extern "C" {
    #[link_name = "\u{1}?ccExSwitchMask_frag@cocos2d@@3PEBDEB"]
    pub static mut cocos2d_ccExSwitchMask_frag: *const GLchar;
}
#[doc = " Singleton that manages the Animations."]
#[doc = "It saves in a cache the animations. You should use this class if you want to save your animations in a cache."]
#[doc = ""]
#[doc = "Before v0.99.5, the recommend way was to save them on the CCSprite. Since v0.99.5, you should use this class instead."]
#[doc = ""]
#[doc = "@since v0.99.5"]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCAnimationCache {
    pub _base: cocos2d_CCObject,
    pub m_pAnimations: *mut cocos2d_CCDictionary,
}
extern "C" {
    #[link_name = "\u{1}?s_pSharedAnimationCache@CCAnimationCache@cocos2d@@0PEAV12@EA"]
    pub static mut cocos2d_CCAnimationCache_s_pSharedAnimationCache: *mut cocos2d_CCAnimationCache;
}
#[test]
fn bindgen_test_layout_cocos2d_CCAnimationCache() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCAnimationCache>(),
        48usize,
        concat!("Size of: ", stringify!(cocos2d_CCAnimationCache))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCAnimationCache>(),
        8usize,
        concat!("Alignment of ", stringify!(cocos2d_CCAnimationCache))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cocos2d_CCAnimationCache>())).m_pAnimations as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCAnimationCache),
            "::",
            stringify!(m_pAnimations)
        )
    );
}
extern "C" {
    #[doc = " Returns the shared instance of the Animation cache"]
    #[doc = "  @js getInstance"]
    #[link_name = "\u{1}?sharedAnimationCache@CCAnimationCache@cocos2d@@SAPEAV12@XZ"]
    pub fn cocos2d_CCAnimationCache_sharedAnimationCache() -> *mut cocos2d_CCAnimationCache;
}
extern "C" {
    #[doc = " Purges the cache. It releases all the CCAnimation objects and the shared instance."]
    #[link_name = "\u{1}?purgeSharedAnimationCache@CCAnimationCache@cocos2d@@SAXXZ"]
    pub fn cocos2d_CCAnimationCache_purgeSharedAnimationCache();
}
extern "C" {
    #[doc = " Adds a CCAnimation with a name."]
    #[link_name = "\u{1}?addAnimation@CCAnimationCache@cocos2d@@QEAAXPEAVCCAnimation@2@PEBD@Z"]
    pub fn cocos2d_CCAnimationCache_addAnimation(
        this: *mut cocos2d_CCAnimationCache,
        animation: *mut cocos2d_CCAnimation,
        name: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    #[doc = " Deletes a CCAnimation from the cache."]
    #[doc = "@js removeAnimation"]
    #[link_name = "\u{1}?removeAnimationByName@CCAnimationCache@cocos2d@@QEAAXPEBD@Z"]
    pub fn cocos2d_CCAnimationCache_removeAnimationByName(
        this: *mut cocos2d_CCAnimationCache,
        name: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    #[doc = " Returns a CCAnimation that was previously added."]
    #[doc = "If the name is not found it will return nil."]
    #[doc = "You should retain the returned copy if you are going to use it."]
    #[doc = "@js getAnimation"]
    #[link_name = "\u{1}?animationByName@CCAnimationCache@cocos2d@@QEAAPEAVCCAnimation@2@PEBD@Z"]
    pub fn cocos2d_CCAnimationCache_animationByName(
        this: *mut cocos2d_CCAnimationCache,
        name: *const ::std::os::raw::c_char,
    ) -> *mut cocos2d_CCAnimation;
}
extern "C" {
    #[doc = " Adds an animation from an NSDictionary"]
    #[doc = "Make sure that the frames were previously loaded in the CCSpriteFrameCache."]
    #[doc = "@param plist The path of the relative file,it use to find the plist path for load SpriteFrames."]
    #[doc = "@since v1.1"]
    #[link_name = "\u{1}?addAnimationsWithDictionary@CCAnimationCache@cocos2d@@QEAAXPEAVCCDictionary@2@PEBD@Z"]
    pub fn cocos2d_CCAnimationCache_addAnimationsWithDictionary(
        this: *mut cocos2d_CCAnimationCache,
        dictionary: *mut cocos2d_CCDictionary,
        plist: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    #[doc = " Adds an animation from a plist file."]
    #[doc = "Make sure that the frames were previously loaded in the CCSpriteFrameCache."]
    #[doc = "@since v1.1"]
    #[doc = "@js addAnimations"]
    #[link_name = "\u{1}?addAnimationsWithFile@CCAnimationCache@cocos2d@@QEAAXPEBD@Z"]
    pub fn cocos2d_CCAnimationCache_addAnimationsWithFile(
        this: *mut cocos2d_CCAnimationCache,
        plist: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    #[link_name = "\u{1}?init@CCAnimationCache@cocos2d@@QEAA_NXZ"]
    pub fn cocos2d_CCAnimationCache_init(this: *mut cocos2d_CCAnimationCache) -> bool;
}
extern "C" {
    #[doc = " @js ctor"]
    #[link_name = "\u{1}??0CCAnimationCache@cocos2d@@QEAA@XZ"]
    pub fn cocos2d_CCAnimationCache_CCAnimationCache(this: *mut cocos2d_CCAnimationCache);
}
impl cocos2d_CCAnimationCache {
    #[inline]
    pub unsafe fn sharedAnimationCache() -> *mut cocos2d_CCAnimationCache {
        cocos2d_CCAnimationCache_sharedAnimationCache()
    }
    #[inline]
    pub unsafe fn purgeSharedAnimationCache() {
        cocos2d_CCAnimationCache_purgeSharedAnimationCache()
    }
    #[inline]
    pub unsafe fn addAnimation(
        &mut self,
        animation: *mut cocos2d_CCAnimation,
        name: *const ::std::os::raw::c_char,
    ) {
        cocos2d_CCAnimationCache_addAnimation(self, animation, name)
    }
    #[inline]
    pub unsafe fn removeAnimationByName(&mut self, name: *const ::std::os::raw::c_char) {
        cocos2d_CCAnimationCache_removeAnimationByName(self, name)
    }
    #[inline]
    pub unsafe fn animationByName(
        &mut self,
        name: *const ::std::os::raw::c_char,
    ) -> *mut cocos2d_CCAnimation {
        cocos2d_CCAnimationCache_animationByName(self, name)
    }
    #[inline]
    pub unsafe fn addAnimationsWithDictionary(
        &mut self,
        dictionary: *mut cocos2d_CCDictionary,
        plist: *const ::std::os::raw::c_char,
    ) {
        cocos2d_CCAnimationCache_addAnimationsWithDictionary(self, dictionary, plist)
    }
    #[inline]
    pub unsafe fn addAnimationsWithFile(&mut self, plist: *const ::std::os::raw::c_char) {
        cocos2d_CCAnimationCache_addAnimationsWithFile(self, plist)
    }
    #[inline]
    pub unsafe fn init(&mut self) -> bool {
        cocos2d_CCAnimationCache_init(self)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cocos2d_CCAnimationCache_CCAnimationCache(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
}
extern "C" {
    #[doc = " @js NA"]
    #[doc = " @lua NA"]
    #[link_name = "\u{1}??_DCCAnimationCache@cocos2d@@QEAAXXZ"]
    pub fn cocos2d_CCAnimationCache_CCAnimationCache_destructor(
        this: *mut cocos2d_CCAnimationCache,
    );
}
#[doc = " @brief Singleton that handles the loading of the sprite frames."]
#[doc = "It saves in a cache the sprite frames."]
#[doc = "@since v0.9"]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCSpriteFrameCache {
    pub _base: cocos2d_CCObject,
    pub m_pSpriteFrames: *mut cocos2d_CCDictionary,
    pub m_pSpriteFramesAliases: *mut cocos2d_CCDictionary,
    pub m_pLoadedFileNames: *mut u8,
}
#[test]
fn bindgen_test_layout_cocos2d_CCSpriteFrameCache() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCSpriteFrameCache>(),
        64usize,
        concat!("Size of: ", stringify!(cocos2d_CCSpriteFrameCache))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCSpriteFrameCache>(),
        8usize,
        concat!("Alignment of ", stringify!(cocos2d_CCSpriteFrameCache))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cocos2d_CCSpriteFrameCache>())).m_pSpriteFrames as *const _
                as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCSpriteFrameCache),
            "::",
            stringify!(m_pSpriteFrames)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cocos2d_CCSpriteFrameCache>())).m_pSpriteFramesAliases
                as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCSpriteFrameCache),
            "::",
            stringify!(m_pSpriteFramesAliases)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cocos2d_CCSpriteFrameCache>())).m_pLoadedFileNames as *const _
                as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCSpriteFrameCache),
            "::",
            stringify!(m_pLoadedFileNames)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}?init@CCSpriteFrameCache@cocos2d@@QEAA_NXZ"]
    pub fn cocos2d_CCSpriteFrameCache_init(this: *mut cocos2d_CCSpriteFrameCache) -> bool;
}
extern "C" {
    #[doc = " Adds multiple Sprite Frames from a plist file."]
    #[doc = " A texture will be loaded automatically. The texture name will composed by replacing the .plist suffix with .png"]
    #[doc = " If you want to use another texture, you should use the addSpriteFramesWithFile:texture method."]
    #[doc = " @js addSpriteFrames"]
    #[link_name = "\u{1}?addSpriteFramesWithFile@CCSpriteFrameCache@cocos2d@@QEAAXPEBD@Z"]
    pub fn cocos2d_CCSpriteFrameCache_addSpriteFramesWithFile(
        this: *mut cocos2d_CCSpriteFrameCache,
        pszPlist: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    #[doc = " Adds multiple Sprite Frames from a plist file. The texture will be associated with the created sprite frames."]
    #[doc = "@since v0.99.5"]
    #[doc = "@js addSpriteFrames"]
    #[link_name = "\u{1}?addSpriteFramesWithFile@CCSpriteFrameCache@cocos2d@@QEAAXPEBD0@Z"]
    pub fn cocos2d_CCSpriteFrameCache_addSpriteFramesWithFile1(
        this: *mut cocos2d_CCSpriteFrameCache,
        plist: *const ::std::os::raw::c_char,
        textureFileName: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    #[doc = " Adds multiple Sprite Frames from a plist file. The texture will be associated with the created sprite frames."]
    #[doc = " @js addSpriteFrames"]
    #[link_name = "\u{1}?addSpriteFramesWithFile@CCSpriteFrameCache@cocos2d@@QEAAXPEBDPEAVCCTexture2D@2@@Z"]
    pub fn cocos2d_CCSpriteFrameCache_addSpriteFramesWithFile2(
        this: *mut cocos2d_CCSpriteFrameCache,
        pszPlist: *const ::std::os::raw::c_char,
        pobTexture: *mut cocos2d_CCTexture2D,
    );
}
extern "C" {
    #[doc = " Adds an sprite frame with a given name."]
    #[doc = "If the name already exists, then the contents of the old name will be replaced with the new one."]
    #[link_name = "\u{1}?addSpriteFrame@CCSpriteFrameCache@cocos2d@@QEAAXPEAVCCSpriteFrame@2@PEBD@Z"]
    pub fn cocos2d_CCSpriteFrameCache_addSpriteFrame(
        this: *mut cocos2d_CCSpriteFrameCache,
        pobFrame: *mut cocos2d_CCSpriteFrame,
        pszFrameName: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    #[doc = " Purges the dictionary of loaded sprite frames."]
    #[doc = " Call this method if you receive the \"Memory Warning\"."]
    #[doc = " In the short term: it will free some resources preventing your app from being killed."]
    #[doc = " In the medium term: it will allocate more resources."]
    #[doc = " In the long term: it will be the same."]
    #[link_name = "\u{1}?removeSpriteFrames@CCSpriteFrameCache@cocos2d@@QEAAXXZ"]
    pub fn cocos2d_CCSpriteFrameCache_removeSpriteFrames(this: *mut cocos2d_CCSpriteFrameCache);
}
extern "C" {
    #[doc = " Removes unused sprite frames."]
    #[doc = " Sprite Frames that have a retain count of 1 will be deleted."]
    #[doc = " It is convenient to call this method after when starting a new Scene."]
    #[link_name = "\u{1}?removeUnusedSpriteFrames@CCSpriteFrameCache@cocos2d@@QEAAXXZ"]
    pub fn cocos2d_CCSpriteFrameCache_removeUnusedSpriteFrames(
        this: *mut cocos2d_CCSpriteFrameCache,
    );
}
extern "C" {
    #[doc = " Deletes an sprite frame from the sprite frame cache."]
    #[doc = "  @js getSpriteFrame"]
    #[link_name = "\u{1}?removeSpriteFrameByName@CCSpriteFrameCache@cocos2d@@QEAAXPEBD@Z"]
    pub fn cocos2d_CCSpriteFrameCache_removeSpriteFrameByName(
        this: *mut cocos2d_CCSpriteFrameCache,
        pszName: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    #[doc = " Removes multiple Sprite Frames from a plist file."]
    #[doc = " Sprite Frames stored in this file will be removed."]
    #[doc = " It is convenient to call this method when a specific texture needs to be removed."]
    #[doc = " @since v0.99.5"]
    #[link_name = "\u{1}?removeSpriteFramesFromFile@CCSpriteFrameCache@cocos2d@@QEAAXPEBD@Z"]
    pub fn cocos2d_CCSpriteFrameCache_removeSpriteFramesFromFile(
        this: *mut cocos2d_CCSpriteFrameCache,
        plist: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    #[doc = " Removes all Sprite Frames associated with the specified textures."]
    #[doc = " It is convenient to call this method when a specific texture needs to be removed."]
    #[doc = " @since v0.995."]
    #[link_name = "\u{1}?removeSpriteFramesFromTexture@CCSpriteFrameCache@cocos2d@@QEAAXPEAVCCTexture2D@2@@Z"]
    pub fn cocos2d_CCSpriteFrameCache_removeSpriteFramesFromTexture(
        this: *mut cocos2d_CCSpriteFrameCache,
        texture: *mut cocos2d_CCTexture2D,
    );
}
extern "C" {
    #[doc = " Returns an Sprite Frame that was previously added."]
    #[doc = "If the name is not found it will return nil."]
    #[doc = "You should retain the returned copy if you are going to use it."]
    #[doc = "@js getSpriteFrame"]
    #[link_name = "\u{1}?spriteFrameByName@CCSpriteFrameCache@cocos2d@@QEAAPEAVCCSpriteFrame@2@PEBD@Z"]
    pub fn cocos2d_CCSpriteFrameCache_spriteFrameByName(
        this: *mut cocos2d_CCSpriteFrameCache,
        pszName: *const ::std::os::raw::c_char,
    ) -> *mut cocos2d_CCSpriteFrame;
}
extern "C" {
    #[doc = " Returns the shared instance of the Sprite Frame cache"]
    #[doc = "  @js getInstance"]
    #[link_name = "\u{1}?sharedSpriteFrameCache@CCSpriteFrameCache@cocos2d@@SAPEAV12@XZ"]
    pub fn cocos2d_CCSpriteFrameCache_sharedSpriteFrameCache() -> *mut cocos2d_CCSpriteFrameCache;
}
extern "C" {
    #[doc = " Purges the cache. It releases all the Sprite Frames and the retained instance."]
    #[link_name = "\u{1}?purgeSharedSpriteFrameCache@CCSpriteFrameCache@cocos2d@@SAXXZ"]
    pub fn cocos2d_CCSpriteFrameCache_purgeSharedSpriteFrameCache();
}
impl cocos2d_CCSpriteFrameCache {
    #[inline]
    pub unsafe fn init(&mut self) -> bool {
        cocos2d_CCSpriteFrameCache_init(self)
    }
    #[inline]
    pub unsafe fn addSpriteFramesWithFile(&mut self, pszPlist: *const ::std::os::raw::c_char) {
        cocos2d_CCSpriteFrameCache_addSpriteFramesWithFile(self, pszPlist)
    }
    #[inline]
    pub unsafe fn addSpriteFramesWithFile1(
        &mut self,
        plist: *const ::std::os::raw::c_char,
        textureFileName: *const ::std::os::raw::c_char,
    ) {
        cocos2d_CCSpriteFrameCache_addSpriteFramesWithFile1(self, plist, textureFileName)
    }
    #[inline]
    pub unsafe fn addSpriteFramesWithFile2(
        &mut self,
        pszPlist: *const ::std::os::raw::c_char,
        pobTexture: *mut cocos2d_CCTexture2D,
    ) {
        cocos2d_CCSpriteFrameCache_addSpriteFramesWithFile2(self, pszPlist, pobTexture)
    }
    #[inline]
    pub unsafe fn addSpriteFrame(
        &mut self,
        pobFrame: *mut cocos2d_CCSpriteFrame,
        pszFrameName: *const ::std::os::raw::c_char,
    ) {
        cocos2d_CCSpriteFrameCache_addSpriteFrame(self, pobFrame, pszFrameName)
    }
    #[inline]
    pub unsafe fn removeSpriteFrames(&mut self) {
        cocos2d_CCSpriteFrameCache_removeSpriteFrames(self)
    }
    #[inline]
    pub unsafe fn removeUnusedSpriteFrames(&mut self) {
        cocos2d_CCSpriteFrameCache_removeUnusedSpriteFrames(self)
    }
    #[inline]
    pub unsafe fn removeSpriteFrameByName(&mut self, pszName: *const ::std::os::raw::c_char) {
        cocos2d_CCSpriteFrameCache_removeSpriteFrameByName(self, pszName)
    }
    #[inline]
    pub unsafe fn removeSpriteFramesFromFile(&mut self, plist: *const ::std::os::raw::c_char) {
        cocos2d_CCSpriteFrameCache_removeSpriteFramesFromFile(self, plist)
    }
    #[inline]
    pub unsafe fn removeSpriteFramesFromTexture(&mut self, texture: *mut cocos2d_CCTexture2D) {
        cocos2d_CCSpriteFrameCache_removeSpriteFramesFromTexture(self, texture)
    }
    #[inline]
    pub unsafe fn spriteFrameByName(
        &mut self,
        pszName: *const ::std::os::raw::c_char,
    ) -> *mut cocos2d_CCSpriteFrame {
        cocos2d_CCSpriteFrameCache_spriteFrameByName(self, pszName)
    }
    #[inline]
    pub unsafe fn sharedSpriteFrameCache() -> *mut cocos2d_CCSpriteFrameCache {
        cocos2d_CCSpriteFrameCache_sharedSpriteFrameCache()
    }
    #[inline]
    pub unsafe fn purgeSharedSpriteFrameCache() {
        cocos2d_CCSpriteFrameCache_purgeSharedSpriteFrameCache()
    }
}
extern "C" {
    #[doc = " @js NA"]
    #[doc = " @lua NA"]
    #[link_name = "\u{1}??_DCCSpriteFrameCache@cocos2d@@QEAAXXZ"]
    pub fn cocos2d_CCSpriteFrameCache_CCSpriteFrameCache_destructor(
        this: *mut cocos2d_CCSpriteFrameCache,
    );
}
extern "C" {
    #[link_name = "\u{1}?cc_wcslen@cocos2d@@YAHPEBG@Z"]
    pub fn cocos2d_cc_wcslen(str_: *const ::std::os::raw::c_ushort) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}?cc_utf8_trim_ws@cocos2d@@YAXPEAV?$vector@GV?$allocator@G@std@@@std@@@Z"]
    pub fn cocos2d_cc_utf8_trim_ws(str_: *mut u8);
}
extern "C" {
    #[link_name = "\u{1}?isspace_unicode@cocos2d@@YA_NG@Z"]
    pub fn cocos2d_isspace_unicode(ch: ::std::os::raw::c_ushort) -> bool;
}
extern "C" {
    #[link_name = "\u{1}?cc_utf8_strlen@cocos2d@@YAJPEBDH@Z"]
    pub fn cocos2d_cc_utf8_strlen(
        p: *const ::std::os::raw::c_char,
        max: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    #[link_name = "\u{1}?cc_utf8_find_last_not_char@cocos2d@@YAIV?$vector@GV?$allocator@G@std@@@std@@G@Z"]
    pub fn cocos2d_cc_utf8_find_last_not_char(
        str_: u8,
        c: ::std::os::raw::c_ushort,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[link_name = "\u{1}?cc_utf16_vec_from_utf16_str@cocos2d@@YA?AV?$vector@GV?$allocator@G@std@@@std@@PEBG@Z"]
    pub fn cocos2d_cc_utf16_vec_from_utf16_str(str_: *const ::std::os::raw::c_ushort) -> u8;
}
extern "C" {
    #[link_name = "\u{1}?cc_utf8_to_utf16@cocos2d@@YAPEAGPEBDHPEAH@Z"]
    pub fn cocos2d_cc_utf8_to_utf16(
        str_old: *const ::std::os::raw::c_char,
        length: ::std::os::raw::c_int,
        rUtf16Size: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_ushort;
}
extern "C" {
    #[doc = " cc_utf16_to_utf8:"]
    #[doc = " @str: a UTF-16 encoded string"]
    #[doc = " @len: the maximum length of @str to use. If @len < 0, then"]
    #[doc = "       the string is terminated with a 0 character."]
    #[doc = " @items_read: location to store number of words read, or %NULL."]
    #[doc = "              If %NULL, then %G_CONVERT_ERROR_PARTIAL_INPUT will be"]
    #[doc = "              returned in case @str contains a trailing partial"]
    #[doc = "              character. If an error occurs then the index of the"]
    #[doc = "              invalid input is stored here."]
    #[doc = " @items_written: location to store number of bytes written, or %NULL."]
    #[doc = "                 The value stored here does not include the trailing"]
    #[doc = "                 0 byte."]
    #[doc = " @error: location to store the error occuring, or %NULL to ignore"]
    #[doc = "         errors. Any of the errors in #GConvertError other than"]
    #[doc = "         %G_CONVERT_ERROR_NO_CONVERSION may occur."]
    #[doc = ""]
    #[doc = " Convert a string from UTF-16 to UTF-8. The result will be"]
    #[doc = " terminated with a 0 byte."]
    #[doc = ""]
    #[doc = " Return value: a pointer to a newly allocated UTF-8 string."]
    #[doc = "               This value must be freed with free(). If an"]
    #[doc = "               error occurs, %NULL will be returned and"]
    #[doc = "               @error set."]
    #[link_name = "\u{1}?cc_utf16_to_utf8@cocos2d@@YAPEADPEBGJPEAJ1@Z"]
    pub fn cocos2d_cc_utf16_to_utf8(
        str_: *const ::std::os::raw::c_ushort,
        len: ::std::os::raw::c_long,
        items_read: *mut ::std::os::raw::c_long,
        items_written: *mut ::std::os::raw::c_long,
    ) -> *mut ::std::os::raw::c_char;
}
#[doc = " @js NA"]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCNotificationCenter {
    pub _base: cocos2d_CCObject,
    pub m_observers: *mut cocos2d_CCArray,
    pub m_scriptHandler: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_cocos2d_CCNotificationCenter() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCNotificationCenter>(),
        56usize,
        concat!("Size of: ", stringify!(cocos2d_CCNotificationCenter))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCNotificationCenter>(),
        8usize,
        concat!("Alignment of ", stringify!(cocos2d_CCNotificationCenter))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cocos2d_CCNotificationCenter>())).m_observers as *const _
                as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCNotificationCenter),
            "::",
            stringify!(m_observers)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cocos2d_CCNotificationCenter>())).m_scriptHandler as *const _
                as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCNotificationCenter),
            "::",
            stringify!(m_scriptHandler)
        )
    );
}
extern "C" {
    #[doc = " Gets the single instance of CCNotificationCenter."]
    #[link_name = "\u{1}?sharedNotificationCenter@CCNotificationCenter@cocos2d@@SAPEAV12@XZ"]
    pub fn cocos2d_CCNotificationCenter_sharedNotificationCenter(
    ) -> *mut cocos2d_CCNotificationCenter;
}
extern "C" {
    #[doc = " Destroys the single instance of CCNotificationCenter."]
    #[link_name = "\u{1}?purgeNotificationCenter@CCNotificationCenter@cocos2d@@SAXXZ"]
    pub fn cocos2d_CCNotificationCenter_purgeNotificationCenter();
}
extern "C" {
    #[doc = " @brief Adds an observer for the specified target."]
    #[doc = "  @param target The target which wants to observe notification events."]
    #[doc = "  @param selector The callback function which will be invoked when the specified notification event was posted."]
    #[doc = "  @param name The name of this notification."]
    #[doc = "  @param obj The extra parameter which will be passed to the callback function."]
    #[link_name = "\u{1}?addObserver@CCNotificationCenter@cocos2d@@QEAAXPEAVCCObject@2@P832@EAAX0@ZPEBD0@Z"]
    pub fn cocos2d_CCNotificationCenter_addObserver(
        this: *mut cocos2d_CCNotificationCenter,
        target: *mut cocos2d_CCObject,
        selector: cocos2d_SEL_CallFuncO,
        name: *const ::std::os::raw::c_char,
        obj: *mut cocos2d_CCObject,
    );
}
extern "C" {
    #[doc = " @brief Removes the observer by the specified target and name."]
    #[doc = "  @param target The target of this notification."]
    #[doc = "  @param name The name of this notification."]
    #[link_name = "\u{1}?removeObserver@CCNotificationCenter@cocos2d@@QEAAXPEAVCCObject@2@PEBD@Z"]
    pub fn cocos2d_CCNotificationCenter_removeObserver(
        this: *mut cocos2d_CCNotificationCenter,
        target: *mut cocos2d_CCObject,
        name: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    #[doc = " @brief Removes all notifications registered by this target"]
    #[doc = "  @param target The target of this notification."]
    #[doc = "  @returns the number of observers removed"]
    #[link_name = "\u{1}?removeAllObservers@CCNotificationCenter@cocos2d@@QEAAHPEAVCCObject@2@@Z"]
    pub fn cocos2d_CCNotificationCenter_removeAllObservers(
        this: *mut cocos2d_CCNotificationCenter,
        target: *mut cocos2d_CCObject,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Registers one hander for script binding."]
    #[doc = "  @note Only supports Lua Binding now."]
    #[doc = "  @param handler The lua handler."]
    #[link_name = "\u{1}?registerScriptObserver@CCNotificationCenter@cocos2d@@QEAAXPEAVCCObject@2@HPEBD@Z"]
    pub fn cocos2d_CCNotificationCenter_registerScriptObserver(
        this: *mut cocos2d_CCNotificationCenter,
        target: *mut cocos2d_CCObject,
        handler: ::std::os::raw::c_int,
        name: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    #[doc = " Unregisters script observer"]
    #[link_name = "\u{1}?unregisterScriptObserver@CCNotificationCenter@cocos2d@@QEAAXPEAVCCObject@2@PEBD@Z"]
    pub fn cocos2d_CCNotificationCenter_unregisterScriptObserver(
        this: *mut cocos2d_CCNotificationCenter,
        target: *mut cocos2d_CCObject,
        name: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    #[doc = " @brief Posts one notification event by name."]
    #[doc = "  @param name The name of this notification."]
    #[link_name = "\u{1}?postNotification@CCNotificationCenter@cocos2d@@QEAAXPEBD@Z"]
    pub fn cocos2d_CCNotificationCenter_postNotification(
        this: *mut cocos2d_CCNotificationCenter,
        name: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    #[doc = " @brief Posts one notification event by name."]
    #[doc = "  @param name The name of this notification."]
    #[doc = "  @param object The extra parameter."]
    #[link_name = "\u{1}?postNotification@CCNotificationCenter@cocos2d@@QEAAXPEBDPEAVCCObject@2@@Z"]
    pub fn cocos2d_CCNotificationCenter_postNotification1(
        this: *mut cocos2d_CCNotificationCenter,
        name: *const ::std::os::raw::c_char,
        object: *mut cocos2d_CCObject,
    );
}
extern "C" {
    #[doc = " @brief Gets observer script handler."]
    #[doc = "  @param name The name of this notification."]
    #[doc = "  @return The observer script handle."]
    #[link_name = "\u{1}?getObserverHandlerByName@CCNotificationCenter@cocos2d@@QEAAHPEBD@Z"]
    pub fn cocos2d_CCNotificationCenter_getObserverHandlerByName(
        this: *mut cocos2d_CCNotificationCenter,
        name: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " CCNotificationCenter constructor"]
    #[link_name = "\u{1}??0CCNotificationCenter@cocos2d@@QEAA@XZ"]
    pub fn cocos2d_CCNotificationCenter_CCNotificationCenter(
        this: *mut cocos2d_CCNotificationCenter,
    );
}
impl cocos2d_CCNotificationCenter {
    #[inline]
    pub unsafe fn sharedNotificationCenter() -> *mut cocos2d_CCNotificationCenter {
        cocos2d_CCNotificationCenter_sharedNotificationCenter()
    }
    #[inline]
    pub unsafe fn purgeNotificationCenter() {
        cocos2d_CCNotificationCenter_purgeNotificationCenter()
    }
    #[inline]
    pub unsafe fn addObserver(
        &mut self,
        target: *mut cocos2d_CCObject,
        selector: cocos2d_SEL_CallFuncO,
        name: *const ::std::os::raw::c_char,
        obj: *mut cocos2d_CCObject,
    ) {
        cocos2d_CCNotificationCenter_addObserver(self, target, selector, name, obj)
    }
    #[inline]
    pub unsafe fn removeObserver(
        &mut self,
        target: *mut cocos2d_CCObject,
        name: *const ::std::os::raw::c_char,
    ) {
        cocos2d_CCNotificationCenter_removeObserver(self, target, name)
    }
    #[inline]
    pub unsafe fn removeAllObservers(
        &mut self,
        target: *mut cocos2d_CCObject,
    ) -> ::std::os::raw::c_int {
        cocos2d_CCNotificationCenter_removeAllObservers(self, target)
    }
    #[inline]
    pub unsafe fn registerScriptObserver(
        &mut self,
        target: *mut cocos2d_CCObject,
        handler: ::std::os::raw::c_int,
        name: *const ::std::os::raw::c_char,
    ) {
        cocos2d_CCNotificationCenter_registerScriptObserver(self, target, handler, name)
    }
    #[inline]
    pub unsafe fn unregisterScriptObserver(
        &mut self,
        target: *mut cocos2d_CCObject,
        name: *const ::std::os::raw::c_char,
    ) {
        cocos2d_CCNotificationCenter_unregisterScriptObserver(self, target, name)
    }
    #[inline]
    pub unsafe fn postNotification(&mut self, name: *const ::std::os::raw::c_char) {
        cocos2d_CCNotificationCenter_postNotification(self, name)
    }
    #[inline]
    pub unsafe fn postNotification1(
        &mut self,
        name: *const ::std::os::raw::c_char,
        object: *mut cocos2d_CCObject,
    ) {
        cocos2d_CCNotificationCenter_postNotification1(self, name, object)
    }
    #[inline]
    pub unsafe fn getObserverHandlerByName(
        &mut self,
        name: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int {
        cocos2d_CCNotificationCenter_getObserverHandlerByName(self, name)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cocos2d_CCNotificationCenter_CCNotificationCenter(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
}
extern "C" {
    #[doc = " CCNotificationCenter destructor"]
    #[link_name = "\u{1}??_DCCNotificationCenter@cocos2d@@QEAAXXZ"]
    pub fn cocos2d_CCNotificationCenter_CCNotificationCenter_destructor(
        this: *mut cocos2d_CCNotificationCenter,
    );
}
#[doc = " @js NA"]
#[doc = " @lua NA"]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCNotificationObserver {
    pub _base: cocos2d_CCObject,
    pub m_target: *mut cocos2d_CCObject,
    pub m_selector: cocos2d_SEL_CallFuncO,
    pub m_name: *mut ::std::os::raw::c_char,
    pub m_object: *mut cocos2d_CCObject,
    pub m_nHandler: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_cocos2d_CCNotificationObserver() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCNotificationObserver>(),
        80usize,
        concat!("Size of: ", stringify!(cocos2d_CCNotificationObserver))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCNotificationObserver>(),
        8usize,
        concat!("Alignment of ", stringify!(cocos2d_CCNotificationObserver))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cocos2d_CCNotificationObserver>())).m_target as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCNotificationObserver),
            "::",
            stringify!(m_target)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cocos2d_CCNotificationObserver>())).m_selector as *const _
                as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCNotificationObserver),
            "::",
            stringify!(m_selector)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cocos2d_CCNotificationObserver>())).m_name as *const _ as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCNotificationObserver),
            "::",
            stringify!(m_name)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cocos2d_CCNotificationObserver>())).m_object as *const _ as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCNotificationObserver),
            "::",
            stringify!(m_object)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cocos2d_CCNotificationObserver>())).m_nHandler as *const _
                as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCNotificationObserver),
            "::",
            stringify!(m_nHandler)
        )
    );
}
extern "C" {
    #[doc = " Invokes the callback function of this observer"]
    #[link_name = "\u{1}?performSelector@CCNotificationObserver@cocos2d@@QEAAXPEAVCCObject@2@@Z"]
    pub fn cocos2d_CCNotificationObserver_performSelector(
        this: *mut cocos2d_CCNotificationObserver,
        obj: *mut cocos2d_CCObject,
    );
}
extern "C" {
    #[doc = " @brief CCNotificationObserver constructor"]
    #[doc = "  @param target The target which wants to observer notification events."]
    #[doc = "  @param selector The callback function which will be invoked when the specified notification event was posted."]
    #[doc = "  @param name The name of this notification."]
    #[doc = "  @param obj The extra parameter which will be passed to the callback function."]
    #[link_name = "\u{1}??0CCNotificationObserver@cocos2d@@QEAA@PEAVCCObject@1@P821@EAAX0@ZPEBD0@Z"]
    pub fn cocos2d_CCNotificationObserver_CCNotificationObserver(
        this: *mut cocos2d_CCNotificationObserver,
        target: *mut cocos2d_CCObject,
        selector: cocos2d_SEL_CallFuncO,
        name: *const ::std::os::raw::c_char,
        obj: *mut cocos2d_CCObject,
    );
}
impl cocos2d_CCNotificationObserver {
    #[inline]
    pub unsafe fn performSelector(&mut self, obj: *mut cocos2d_CCObject) {
        cocos2d_CCNotificationObserver_performSelector(self, obj)
    }
    #[inline]
    pub unsafe fn new(
        target: *mut cocos2d_CCObject,
        selector: cocos2d_SEL_CallFuncO,
        name: *const ::std::os::raw::c_char,
        obj: *mut cocos2d_CCObject,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cocos2d_CCNotificationObserver_CCNotificationObserver(
            __bindgen_tmp.as_mut_ptr(),
            target,
            selector,
            name,
            obj,
        );
        __bindgen_tmp.assume_init()
    }
}
extern "C" {
    #[doc = " CCNotificationObserver destructor function"]
    #[link_name = "\u{1}??_DCCNotificationObserver@cocos2d@@QEAAXXZ"]
    pub fn cocos2d_CCNotificationObserver_CCNotificationObserver_destructor(
        this: *mut cocos2d_CCNotificationObserver,
    );
}
extern "C" {
    #[link_name = "\u{1}?getTarget@CCNotificationObserver@cocos2d@@UEAAPEAVCCObject@2@XZ"]
    pub fn cocos2d_CCNotificationObserver_getTarget(
        this: *mut ::std::os::raw::c_void,
    ) -> *mut cocos2d_CCObject;
}
extern "C" {
    #[link_name = "\u{1}?getSelector@CCNotificationObserver@cocos2d@@UEAAP8CCObject@2@EAAXPEAV32@@ZXZ"]
    pub fn cocos2d_CCNotificationObserver_getSelector(
        this: *mut ::std::os::raw::c_void,
    ) -> cocos2d_SEL_CallFuncO;
}
extern "C" {
    #[link_name = "\u{1}?getName@CCNotificationObserver@cocos2d@@UEAAPEADXZ"]
    pub fn cocos2d_CCNotificationObserver_getName(
        this: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}?getObject@CCNotificationObserver@cocos2d@@UEAAPEAVCCObject@2@XZ"]
    pub fn cocos2d_CCNotificationObserver_getObject(
        this: *mut ::std::os::raw::c_void,
    ) -> *mut cocos2d_CCObject;
}
extern "C" {
    #[link_name = "\u{1}?getHandler@CCNotificationObserver@cocos2d@@UEAAHXZ"]
    pub fn cocos2d_CCNotificationObserver_getHandler(
        this: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}?setHandler@CCNotificationObserver@cocos2d@@UEAAXH@Z"]
    pub fn cocos2d_CCNotificationObserver_setHandler(
        this: *mut ::std::os::raw::c_void,
        var: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " Calculates distance between point an origin"]
    #[doc = "@return float"]
    #[doc = "@since v0.7.2"]
    #[link_name = "\u{1}?ccpLength@cocos2d@@YAMAEBVCCPoint@1@@Z"]
    pub fn cocos2d_ccpLength(v: *const cocos2d_CCPoint) -> f32;
}
extern "C" {
    #[doc = " Calculates the distance between two points"]
    #[doc = "@return float"]
    #[doc = "@since v0.7.2"]
    #[link_name = "\u{1}?ccpDistance@cocos2d@@YAMAEBVCCPoint@1@0@Z"]
    pub fn cocos2d_ccpDistance(v1: *const cocos2d_CCPoint, v2: *const cocos2d_CCPoint) -> f32;
}
extern "C" {
    #[doc = " Returns point multiplied to a length of 1."]
    #[doc = "@return CCPoint"]
    #[doc = "@since v0.7.2"]
    #[link_name = "\u{1}?ccpNormalize@cocos2d@@YA?AVCCPoint@1@AEBV21@@Z"]
    pub fn cocos2d_ccpNormalize(v: *const cocos2d_CCPoint) -> cocos2d_CCPoint;
}
extern "C" {
    #[doc = " Converts radians to a normalized vector."]
    #[doc = "@return CCPoint"]
    #[doc = "@since v0.7.2"]
    #[link_name = "\u{1}?ccpForAngle@cocos2d@@YA?AVCCPoint@1@M@Z"]
    pub fn cocos2d_ccpForAngle(a: f32) -> cocos2d_CCPoint;
}
extern "C" {
    #[doc = " Converts a vector to radians."]
    #[doc = "@return float"]
    #[doc = "@since v0.7.2"]
    #[link_name = "\u{1}?ccpToAngle@cocos2d@@YAMAEBVCCPoint@1@@Z"]
    pub fn cocos2d_ccpToAngle(v: *const cocos2d_CCPoint) -> f32;
}
extern "C" {
    #[doc = " Clamp a value between from and to."]
    #[doc = "@since v0.99.1"]
    #[link_name = "\u{1}?clampf@cocos2d@@YAMMMM@Z"]
    pub fn cocos2d_clampf(value: f32, min_inclusive: f32, max_inclusive: f32) -> f32;
}
extern "C" {
    #[doc = " Clamp a point between from and to."]
    #[doc = "@since v0.99.1"]
    #[link_name = "\u{1}?ccpClamp@cocos2d@@YA?AVCCPoint@1@AEBV21@00@Z"]
    pub fn cocos2d_ccpClamp(
        p: *const cocos2d_CCPoint,
        from: *const cocos2d_CCPoint,
        to: *const cocos2d_CCPoint,
    ) -> cocos2d_CCPoint;
}
extern "C" {
    #[doc = " Quickly convert CCSize to a CCPoint"]
    #[doc = "@since v0.99.1"]
    #[link_name = "\u{1}?ccpFromSize@cocos2d@@YA?AVCCPoint@1@AEBVCCSize@1@@Z"]
    pub fn cocos2d_ccpFromSize(s: *const cocos2d_CCSize) -> cocos2d_CCPoint;
}
extern "C" {
    #[doc = " Run a math operation function on each point component"]
    #[doc = " absf, fllorf, ceilf, roundf"]
    #[doc = " any function that has the signature: float func(float);"]
    #[doc = " For example: let's try to take the floor of x,y"]
    #[doc = " ccpCompOp(p,floorf);"]
    #[doc = "@since v0.99.1"]
    #[link_name = "\u{1}?ccpCompOp@cocos2d@@YA?AVCCPoint@1@AEBV21@P6AMM@Z@Z"]
    pub fn cocos2d_ccpCompOp(
        p: *const cocos2d_CCPoint,
        opFunc: ::std::option::Option<unsafe extern "C" fn(arg1: f32) -> f32>,
    ) -> cocos2d_CCPoint;
}
extern "C" {
    #[doc = " Linear Interpolation between two points a and b"]
    #[doc = "@returns"]
    #[doc = "alpha == 0 ? a"]
    #[doc = "alpha == 1 ? b"]
    #[doc = "otherwise a value between a..b"]
    #[doc = "@since v0.99.1"]
    #[link_name = "\u{1}?ccpLerp@cocos2d@@YA?AVCCPoint@1@AEBV21@0M@Z"]
    pub fn cocos2d_ccpLerp(
        a: *const cocos2d_CCPoint,
        b: *const cocos2d_CCPoint,
        alpha: f32,
    ) -> cocos2d_CCPoint;
}
extern "C" {
    #[doc = " @returns if points have fuzzy equality which means equal with some degree of variance."]
    #[doc = "@since v0.99.1"]
    #[link_name = "\u{1}?ccpFuzzyEqual@cocos2d@@YA_NAEBVCCPoint@1@0M@Z"]
    pub fn cocos2d_ccpFuzzyEqual(
        a: *const cocos2d_CCPoint,
        b: *const cocos2d_CCPoint,
        variance: f32,
    ) -> bool;
}
extern "C" {
    #[doc = " Multiplies a and b components, a.x*b.x, a.y*b.y"]
    #[doc = "@returns a component-wise multiplication"]
    #[doc = "@since v0.99.1"]
    #[link_name = "\u{1}?ccpCompMult@cocos2d@@YA?AVCCPoint@1@AEBV21@0@Z"]
    pub fn cocos2d_ccpCompMult(
        a: *const cocos2d_CCPoint,
        b: *const cocos2d_CCPoint,
    ) -> cocos2d_CCPoint;
}
extern "C" {
    #[doc = " @returns the signed angle in radians between two vector directions"]
    #[doc = "@since v0.99.1"]
    #[link_name = "\u{1}?ccpAngleSigned@cocos2d@@YAMAEBVCCPoint@1@0@Z"]
    pub fn cocos2d_ccpAngleSigned(a: *const cocos2d_CCPoint, b: *const cocos2d_CCPoint) -> f32;
}
extern "C" {
    #[doc = " @returns the angle in radians between two vector directions"]
    #[doc = "@since v0.99.1"]
    #[link_name = "\u{1}?ccpAngle@cocos2d@@YAMAEBVCCPoint@1@0@Z"]
    pub fn cocos2d_ccpAngle(a: *const cocos2d_CCPoint, b: *const cocos2d_CCPoint) -> f32;
}
extern "C" {
    #[doc = " Rotates a point counter clockwise by the angle around a pivot"]
    #[doc = "@param v is the point to rotate"]
    #[doc = "@param pivot is the pivot, naturally"]
    #[doc = "@param angle is the angle of rotation cw in radians"]
    #[doc = "@returns the rotated point"]
    #[doc = "@since v0.99.1"]
    #[link_name = "\u{1}?ccpRotateByAngle@cocos2d@@YA?AVCCPoint@1@AEBV21@0M@Z"]
    pub fn cocos2d_ccpRotateByAngle(
        v: *const cocos2d_CCPoint,
        pivot: *const cocos2d_CCPoint,
        angle: f32,
    ) -> cocos2d_CCPoint;
}
extern "C" {
    #[doc = " A general line-line intersection test"]
    #[doc = "@param p1"]
    #[doc = "is the startpoint for the first line P1 = (p1 - p2)"]
    #[doc = "@param p2"]
    #[doc = "is the endpoint for the first line P1 = (p1 - p2)"]
    #[doc = "@param p3"]
    #[doc = "is the startpoint for the second line P2 = (p3 - p4)"]
    #[doc = "@param p4"]
    #[doc = "is the endpoint for the second line P2 = (p3 - p4)"]
    #[doc = "@param s"]
    #[doc = "is the range for a hitpoint in P1 (pa = p1 + s*(p2 - p1))"]
    #[doc = "@param t"]
    #[doc = "is the range for a hitpoint in P3 (pa = p2 + t*(p4 - p3))"]
    #[doc = "@return bool"]
    #[doc = "indicating successful intersection of a line"]
    #[doc = "note that to truly test intersection for segments we have to make"]
    #[doc = "sure that s & t lie within [0..1] and for rays, make sure s & t > 0"]
    #[doc = "the hit point is        p3 + t * (p4 - p3);"]
    #[doc = "the hit point also is    p1 + s * (p2 - p1);"]
    #[doc = "@since v0.99.1"]
    #[link_name = "\u{1}?ccpLineIntersect@cocos2d@@YA_NAEBVCCPoint@1@000PEAM1@Z"]
    pub fn cocos2d_ccpLineIntersect(
        p1: *const cocos2d_CCPoint,
        p2: *const cocos2d_CCPoint,
        p3: *const cocos2d_CCPoint,
        p4: *const cocos2d_CCPoint,
        s: *mut f32,
        t: *mut f32,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}?ccpSegmentIntersect@cocos2d@@YA_NAEBVCCPoint@1@000@Z"]
    pub fn cocos2d_ccpSegmentIntersect(
        A: *const cocos2d_CCPoint,
        B: *const cocos2d_CCPoint,
        C: *const cocos2d_CCPoint,
        D: *const cocos2d_CCPoint,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}?ccpIntersectPoint@cocos2d@@YA?AVCCPoint@1@AEBV21@000@Z"]
    pub fn cocos2d_ccpIntersectPoint(
        A: *const cocos2d_CCPoint,
        B: *const cocos2d_CCPoint,
        C: *const cocos2d_CCPoint,
        D: *const cocos2d_CCPoint,
    ) -> cocos2d_CCPoint;
}
#[doc = " CCProfiler"]
#[doc = "cocos2d builtin profiler."]
#[doc = ""]
#[doc = "To use it, enable set the CC_ENABLE_PROFILERS=1 in the ccConfig.h file"]
#[doc = "@js NA"]
#[doc = "@lua NA"]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCProfiler {
    pub _base: cocos2d_CCObject,
    pub m_pActiveTimers: *mut cocos2d_CCDictionary,
}
#[test]
fn bindgen_test_layout_cocos2d_CCProfiler() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCProfiler>(),
        48usize,
        concat!("Size of: ", stringify!(cocos2d_CCProfiler))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCProfiler>(),
        8usize,
        concat!("Alignment of ", stringify!(cocos2d_CCProfiler))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cocos2d_CCProfiler>())).m_pActiveTimers as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCProfiler),
            "::",
            stringify!(m_pActiveTimers)
        )
    );
}
extern "C" {
    #[doc = " display the timers"]
    #[link_name = "\u{1}?displayTimers@CCProfiler@cocos2d@@QEAAXXZ"]
    pub fn cocos2d_CCProfiler_displayTimers(this: *mut cocos2d_CCProfiler);
}
extern "C" {
    #[link_name = "\u{1}?init@CCProfiler@cocos2d@@QEAA_NXZ"]
    pub fn cocos2d_CCProfiler_init(this: *mut cocos2d_CCProfiler) -> bool;
}
extern "C" {
    #[link_name = "\u{1}?sharedProfiler@CCProfiler@cocos2d@@SAPEAV12@XZ"]
    pub fn cocos2d_CCProfiler_sharedProfiler() -> *mut cocos2d_CCProfiler;
}
extern "C" {
    #[doc = " Creates and adds a new timer"]
    #[link_name = "\u{1}?createAndAddTimerWithName@CCProfiler@cocos2d@@QEAAPEAVCCProfilingTimer@2@PEBD@Z"]
    pub fn cocos2d_CCProfiler_createAndAddTimerWithName(
        this: *mut cocos2d_CCProfiler,
        timerName: *const ::std::os::raw::c_char,
    ) -> *mut cocos2d_CCProfilingTimer;
}
extern "C" {
    #[doc = " releases a timer"]
    #[link_name = "\u{1}?releaseTimer@CCProfiler@cocos2d@@QEAAXPEBD@Z"]
    pub fn cocos2d_CCProfiler_releaseTimer(
        this: *mut cocos2d_CCProfiler,
        timerName: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    #[doc = " releases all timers"]
    #[link_name = "\u{1}?releaseAllTimers@CCProfiler@cocos2d@@QEAAXXZ"]
    pub fn cocos2d_CCProfiler_releaseAllTimers(this: *mut cocos2d_CCProfiler);
}
impl cocos2d_CCProfiler {
    #[inline]
    pub unsafe fn displayTimers(&mut self) {
        cocos2d_CCProfiler_displayTimers(self)
    }
    #[inline]
    pub unsafe fn init(&mut self) -> bool {
        cocos2d_CCProfiler_init(self)
    }
    #[inline]
    pub unsafe fn sharedProfiler() -> *mut cocos2d_CCProfiler {
        cocos2d_CCProfiler_sharedProfiler()
    }
    #[inline]
    pub unsafe fn createAndAddTimerWithName(
        &mut self,
        timerName: *const ::std::os::raw::c_char,
    ) -> *mut cocos2d_CCProfilingTimer {
        cocos2d_CCProfiler_createAndAddTimerWithName(self, timerName)
    }
    #[inline]
    pub unsafe fn releaseTimer(&mut self, timerName: *const ::std::os::raw::c_char) {
        cocos2d_CCProfiler_releaseTimer(self, timerName)
    }
    #[inline]
    pub unsafe fn releaseAllTimers(&mut self) {
        cocos2d_CCProfiler_releaseAllTimers(self)
    }
}
extern "C" {
    #[link_name = "\u{1}??_DCCProfiler@cocos2d@@QEAAXXZ"]
    pub fn cocos2d_CCProfiler_CCProfiler_destructor(this: *mut cocos2d_CCProfiler);
}
#[doc = " @addtogroup global"]
#[doc = " @{"]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCProfilingTimer {
    pub _base: cocos2d_CCObject,
    pub m_NameStr: std_string,
    pub numberOfCalls: ::std::os::raw::c_int,
    pub m_dAverageTime1: ::std::os::raw::c_int,
    pub m_dAverageTime2: ::std::os::raw::c_int,
    pub totalTime: ::std::os::raw::c_longlong,
    pub minTime: ::std::os::raw::c_int,
    pub maxTime: ::std::os::raw::c_int,
    pub m_sStartTime: cocos2d_cc_timeval,
}
#[test]
fn bindgen_test_layout_cocos2d_CCProfilingTimer() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCProfilingTimer>(),
        112usize,
        concat!("Size of: ", stringify!(cocos2d_CCProfilingTimer))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCProfilingTimer>(),
        8usize,
        concat!("Alignment of ", stringify!(cocos2d_CCProfilingTimer))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cocos2d_CCProfilingTimer>())).m_NameStr as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCProfilingTimer),
            "::",
            stringify!(m_NameStr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cocos2d_CCProfilingTimer>())).numberOfCalls as *const _ as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCProfilingTimer),
            "::",
            stringify!(numberOfCalls)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cocos2d_CCProfilingTimer>())).m_dAverageTime1 as *const _
                as usize
        },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCProfilingTimer),
            "::",
            stringify!(m_dAverageTime1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cocos2d_CCProfilingTimer>())).m_dAverageTime2 as *const _
                as usize
        },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCProfilingTimer),
            "::",
            stringify!(m_dAverageTime2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cocos2d_CCProfilingTimer>())).totalTime as *const _ as usize
        },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCProfilingTimer),
            "::",
            stringify!(totalTime)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cocos2d_CCProfilingTimer>())).minTime as *const _ as usize
        },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCProfilingTimer),
            "::",
            stringify!(minTime)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cocos2d_CCProfilingTimer>())).maxTime as *const _ as usize
        },
        100usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCProfilingTimer),
            "::",
            stringify!(maxTime)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cocos2d_CCProfilingTimer>())).m_sStartTime as *const _ as usize
        },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCProfilingTimer),
            "::",
            stringify!(m_sStartTime)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}?initWithName@CCProfilingTimer@cocos2d@@QEAA_NPEBD@Z"]
    pub fn cocos2d_CCProfilingTimer_initWithName(
        this: *mut cocos2d_CCProfilingTimer,
        timerName: *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}?description@CCProfilingTimer@cocos2d@@QEAAPEBDXZ"]
    pub fn cocos2d_CCProfilingTimer_description(
        this: *mut cocos2d_CCProfilingTimer,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " resets the timer properties"]
    #[link_name = "\u{1}?reset@CCProfilingTimer@cocos2d@@QEAAXXZ"]
    pub fn cocos2d_CCProfilingTimer_reset(this: *mut cocos2d_CCProfilingTimer);
}
extern "C" {
    #[link_name = "\u{1}??0CCProfilingTimer@cocos2d@@QEAA@XZ"]
    pub fn cocos2d_CCProfilingTimer_CCProfilingTimer(this: *mut cocos2d_CCProfilingTimer);
}
impl cocos2d_CCProfilingTimer {
    #[inline]
    pub unsafe fn initWithName(&mut self, timerName: *const ::std::os::raw::c_char) -> bool {
        cocos2d_CCProfilingTimer_initWithName(self, timerName)
    }
    #[inline]
    pub unsafe fn description(&mut self) -> *const ::std::os::raw::c_char {
        cocos2d_CCProfilingTimer_description(self)
    }
    #[inline]
    pub unsafe fn reset(&mut self) {
        cocos2d_CCProfilingTimer_reset(self)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cocos2d_CCProfilingTimer_CCProfilingTimer(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
}
extern "C" {
    #[link_name = "\u{1}??_DCCProfilingTimer@cocos2d@@QEAAXXZ"]
    pub fn cocos2d_CCProfilingTimer_CCProfilingTimer_destructor(
        this: *mut cocos2d_CCProfilingTimer,
    );
}
extern "C" {
    #[link_name = "\u{1}?CCProfilingBeginTimingBlock@cocos2d@@YAXPEBD@Z"]
    pub fn cocos2d_CCProfilingBeginTimingBlock(timerName: *const ::std::os::raw::c_char);
}
extern "C" {
    #[link_name = "\u{1}?CCProfilingEndTimingBlock@cocos2d@@YAXPEBD@Z"]
    pub fn cocos2d_CCProfilingEndTimingBlock(timerName: *const ::std::os::raw::c_char);
}
extern "C" {
    #[link_name = "\u{1}?CCProfilingResetTimingBlock@cocos2d@@YAXPEBD@Z"]
    pub fn cocos2d_CCProfilingResetTimingBlock(timerName: *const ::std::os::raw::c_char);
}
extern "C" {
    #[link_name = "\u{1}?kCCProfilerCategorySprite@cocos2d@@3_NA"]
    pub static mut cocos2d_kCCProfilerCategorySprite: bool;
}
extern "C" {
    #[link_name = "\u{1}?kCCProfilerCategoryBatchSprite@cocos2d@@3_NA"]
    pub static mut cocos2d_kCCProfilerCategoryBatchSprite: bool;
}
extern "C" {
    #[link_name = "\u{1}?kCCProfilerCategoryParticles@cocos2d@@3_NA"]
    pub static mut cocos2d_kCCProfilerCategoryParticles: bool;
}
#[doc = " CCUserDefault acts as a tiny database. You can save and get base type values by it."]
#[doc = " For example, setBoolForKey(\"played\", true) will add a bool value true into the database."]
#[doc = " Its key is \"played\". You can get the value of the key by getBoolForKey(\"played\")."]
#[doc = ""]
#[doc = " It supports the following base types:"]
#[doc = " bool, int, float, double, string"]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCUserDefault {
    pub _address: u8,
}
extern "C" {
    #[link_name = "\u{1}?m_spUserDefault@CCUserDefault@cocos2d@@0PEAV12@EA"]
    pub static mut cocos2d_CCUserDefault_m_spUserDefault: *mut cocos2d_CCUserDefault;
}
extern "C" {
    #[link_name = "\u{1}?m_sFilePath@CCUserDefault@cocos2d@@0V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A"]
    pub static mut cocos2d_CCUserDefault_m_sFilePath: std_string;
}
extern "C" {
    #[link_name = "\u{1}?m_sbIsFilePathInitialized@CCUserDefault@cocos2d@@0_NA"]
    pub static mut cocos2d_CCUserDefault_m_sbIsFilePathInitialized: bool;
}
#[test]
fn bindgen_test_layout_cocos2d_CCUserDefault() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCUserDefault>(),
        1usize,
        concat!("Size of: ", stringify!(cocos2d_CCUserDefault))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCUserDefault>(),
        1usize,
        concat!("Alignment of ", stringify!(cocos2d_CCUserDefault))
    );
}
extern "C" {
    #[doc = "@brief Get bool value by key, if the key doesn't exist, a default value will return."]
    #[doc = "You can set the default value, or it is false."]
    #[link_name = "\u{1}?getBoolForKey@CCUserDefault@cocos2d@@QEAA_NPEBD@Z"]
    pub fn cocos2d_CCUserDefault_getBoolForKey(
        this: *mut cocos2d_CCUserDefault,
        pKey: *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}?getBoolForKey@CCUserDefault@cocos2d@@QEAA_NPEBD_N@Z"]
    pub fn cocos2d_CCUserDefault_getBoolForKey1(
        this: *mut cocos2d_CCUserDefault,
        pKey: *const ::std::os::raw::c_char,
        defaultValue: bool,
    ) -> bool;
}
extern "C" {
    #[doc = "@brief Get integer value by key, if the key doesn't exist, a default value will return."]
    #[doc = "You can set the default value, or it is 0."]
    #[link_name = "\u{1}?getIntegerForKey@CCUserDefault@cocos2d@@QEAAHPEBD@Z"]
    pub fn cocos2d_CCUserDefault_getIntegerForKey(
        this: *mut cocos2d_CCUserDefault,
        pKey: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}?getIntegerForKey@CCUserDefault@cocos2d@@QEAAHPEBDH@Z"]
    pub fn cocos2d_CCUserDefault_getIntegerForKey1(
        this: *mut cocos2d_CCUserDefault,
        pKey: *const ::std::os::raw::c_char,
        defaultValue: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "@brief Get float value by key, if the key doesn't exist, a default value will return."]
    #[doc = "You can set the default value, or it is 0.0f."]
    #[link_name = "\u{1}?getFloatForKey@CCUserDefault@cocos2d@@QEAAMPEBD@Z"]
    pub fn cocos2d_CCUserDefault_getFloatForKey(
        this: *mut cocos2d_CCUserDefault,
        pKey: *const ::std::os::raw::c_char,
    ) -> f32;
}
extern "C" {
    #[link_name = "\u{1}?getFloatForKey@CCUserDefault@cocos2d@@QEAAMPEBDM@Z"]
    pub fn cocos2d_CCUserDefault_getFloatForKey1(
        this: *mut cocos2d_CCUserDefault,
        pKey: *const ::std::os::raw::c_char,
        defaultValue: f32,
    ) -> f32;
}
extern "C" {
    #[doc = "@brief Get double value by key, if the key doesn't exist, a default value will return."]
    #[doc = "You can set the default value, or it is 0.0."]
    #[link_name = "\u{1}?getDoubleForKey@CCUserDefault@cocos2d@@QEAANPEBD@Z"]
    pub fn cocos2d_CCUserDefault_getDoubleForKey(
        this: *mut cocos2d_CCUserDefault,
        pKey: *const ::std::os::raw::c_char,
    ) -> f64;
}
extern "C" {
    #[link_name = "\u{1}?getDoubleForKey@CCUserDefault@cocos2d@@QEAANPEBDN@Z"]
    pub fn cocos2d_CCUserDefault_getDoubleForKey1(
        this: *mut cocos2d_CCUserDefault,
        pKey: *const ::std::os::raw::c_char,
        defaultValue: f64,
    ) -> f64;
}
extern "C" {
    #[doc = "@brief Get string value by key, if the key doesn't exist, a default value will return."]
    #[doc = "You can set the default value, or it is \"\"."]
    #[link_name = "\u{1}?getStringForKey@CCUserDefault@cocos2d@@QEAA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEBD@Z"]
    pub fn cocos2d_CCUserDefault_getStringForKey(
        this: *mut cocos2d_CCUserDefault,
        pKey: *const ::std::os::raw::c_char,
    ) -> std_string;
}
extern "C" {
    #[link_name = "\u{1}?getStringForKey@CCUserDefault@cocos2d@@QEAA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEBDAEBV34@@Z"]
    pub fn cocos2d_CCUserDefault_getStringForKey1(
        this: *mut cocos2d_CCUserDefault,
        pKey: *const ::std::os::raw::c_char,
        defaultValue: *const std_string,
    ) -> std_string;
}
extern "C" {
    #[doc = "@brief Set bool value by key."]
    #[link_name = "\u{1}?setBoolForKey@CCUserDefault@cocos2d@@QEAAXPEBD_N@Z"]
    pub fn cocos2d_CCUserDefault_setBoolForKey(
        this: *mut cocos2d_CCUserDefault,
        pKey: *const ::std::os::raw::c_char,
        value: bool,
    );
}
extern "C" {
    #[doc = "@brief Set integer value by key."]
    #[link_name = "\u{1}?setIntegerForKey@CCUserDefault@cocos2d@@QEAAXPEBDH@Z"]
    pub fn cocos2d_CCUserDefault_setIntegerForKey(
        this: *mut cocos2d_CCUserDefault,
        pKey: *const ::std::os::raw::c_char,
        value: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = "@brief Set float value by key."]
    #[link_name = "\u{1}?setFloatForKey@CCUserDefault@cocos2d@@QEAAXPEBDM@Z"]
    pub fn cocos2d_CCUserDefault_setFloatForKey(
        this: *mut cocos2d_CCUserDefault,
        pKey: *const ::std::os::raw::c_char,
        value: f32,
    );
}
extern "C" {
    #[doc = "@brief Set double value by key."]
    #[link_name = "\u{1}?setDoubleForKey@CCUserDefault@cocos2d@@QEAAXPEBDN@Z"]
    pub fn cocos2d_CCUserDefault_setDoubleForKey(
        this: *mut cocos2d_CCUserDefault,
        pKey: *const ::std::os::raw::c_char,
        value: f64,
    );
}
extern "C" {
    #[doc = "@brief Set string value by key."]
    #[link_name = "\u{1}?setStringForKey@CCUserDefault@cocos2d@@QEAAXPEBDAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z"]
    pub fn cocos2d_CCUserDefault_setStringForKey(
        this: *mut cocos2d_CCUserDefault,
        pKey: *const ::std::os::raw::c_char,
        value: *const std_string,
    );
}
extern "C" {
    #[doc = "@brief Save content to xml file"]
    #[link_name = "\u{1}?flush@CCUserDefault@cocos2d@@QEAAXXZ"]
    pub fn cocos2d_CCUserDefault_flush(this: *mut cocos2d_CCUserDefault);
}
extern "C" {
    #[link_name = "\u{1}?sharedUserDefault@CCUserDefault@cocos2d@@SAPEAV12@XZ"]
    pub fn cocos2d_CCUserDefault_sharedUserDefault() -> *mut cocos2d_CCUserDefault;
}
extern "C" {
    #[link_name = "\u{1}?purgeSharedUserDefault@CCUserDefault@cocos2d@@SAXXZ"]
    pub fn cocos2d_CCUserDefault_purgeSharedUserDefault();
}
extern "C" {
    #[link_name = "\u{1}?getXMLFilePath@CCUserDefault@cocos2d@@SAAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ"]
    pub fn cocos2d_CCUserDefault_getXMLFilePath() -> *const std_string;
}
extern "C" {
    #[link_name = "\u{1}?isXMLFileExist@CCUserDefault@cocos2d@@SA_NXZ"]
    pub fn cocos2d_CCUserDefault_isXMLFileExist() -> bool;
}
extern "C" {
    #[link_name = "\u{1}??_DCCUserDefault@cocos2d@@QEAAXXZ"]
    pub fn cocos2d_CCUserDefault_CCUserDefault_destructor(this: *mut cocos2d_CCUserDefault);
}
impl cocos2d_CCUserDefault {
    #[inline]
    pub unsafe fn getBoolForKey(&mut self, pKey: *const ::std::os::raw::c_char) -> bool {
        cocos2d_CCUserDefault_getBoolForKey(self, pKey)
    }
    #[inline]
    pub unsafe fn getBoolForKey1(
        &mut self,
        pKey: *const ::std::os::raw::c_char,
        defaultValue: bool,
    ) -> bool {
        cocos2d_CCUserDefault_getBoolForKey1(self, pKey, defaultValue)
    }
    #[inline]
    pub unsafe fn getIntegerForKey(
        &mut self,
        pKey: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int {
        cocos2d_CCUserDefault_getIntegerForKey(self, pKey)
    }
    #[inline]
    pub unsafe fn getIntegerForKey1(
        &mut self,
        pKey: *const ::std::os::raw::c_char,
        defaultValue: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        cocos2d_CCUserDefault_getIntegerForKey1(self, pKey, defaultValue)
    }
    #[inline]
    pub unsafe fn getFloatForKey(&mut self, pKey: *const ::std::os::raw::c_char) -> f32 {
        cocos2d_CCUserDefault_getFloatForKey(self, pKey)
    }
    #[inline]
    pub unsafe fn getFloatForKey1(
        &mut self,
        pKey: *const ::std::os::raw::c_char,
        defaultValue: f32,
    ) -> f32 {
        cocos2d_CCUserDefault_getFloatForKey1(self, pKey, defaultValue)
    }
    #[inline]
    pub unsafe fn getDoubleForKey(&mut self, pKey: *const ::std::os::raw::c_char) -> f64 {
        cocos2d_CCUserDefault_getDoubleForKey(self, pKey)
    }
    #[inline]
    pub unsafe fn getDoubleForKey1(
        &mut self,
        pKey: *const ::std::os::raw::c_char,
        defaultValue: f64,
    ) -> f64 {
        cocos2d_CCUserDefault_getDoubleForKey1(self, pKey, defaultValue)
    }
    #[inline]
    pub unsafe fn getStringForKey(&mut self, pKey: *const ::std::os::raw::c_char) -> std_string {
        cocos2d_CCUserDefault_getStringForKey(self, pKey)
    }
    #[inline]
    pub unsafe fn getStringForKey1(
        &mut self,
        pKey: *const ::std::os::raw::c_char,
        defaultValue: *const std_string,
    ) -> std_string {
        cocos2d_CCUserDefault_getStringForKey1(self, pKey, defaultValue)
    }
    #[inline]
    pub unsafe fn setBoolForKey(&mut self, pKey: *const ::std::os::raw::c_char, value: bool) {
        cocos2d_CCUserDefault_setBoolForKey(self, pKey, value)
    }
    #[inline]
    pub unsafe fn setIntegerForKey(
        &mut self,
        pKey: *const ::std::os::raw::c_char,
        value: ::std::os::raw::c_int,
    ) {
        cocos2d_CCUserDefault_setIntegerForKey(self, pKey, value)
    }
    #[inline]
    pub unsafe fn setFloatForKey(&mut self, pKey: *const ::std::os::raw::c_char, value: f32) {
        cocos2d_CCUserDefault_setFloatForKey(self, pKey, value)
    }
    #[inline]
    pub unsafe fn setDoubleForKey(&mut self, pKey: *const ::std::os::raw::c_char, value: f64) {
        cocos2d_CCUserDefault_setDoubleForKey(self, pKey, value)
    }
    #[inline]
    pub unsafe fn setStringForKey(
        &mut self,
        pKey: *const ::std::os::raw::c_char,
        value: *const std_string,
    ) {
        cocos2d_CCUserDefault_setStringForKey(self, pKey, value)
    }
    #[inline]
    pub unsafe fn flush(&mut self) {
        cocos2d_CCUserDefault_flush(self)
    }
    #[inline]
    pub unsafe fn sharedUserDefault() -> *mut cocos2d_CCUserDefault {
        cocos2d_CCUserDefault_sharedUserDefault()
    }
    #[inline]
    pub unsafe fn purgeSharedUserDefault() {
        cocos2d_CCUserDefault_purgeSharedUserDefault()
    }
    #[inline]
    pub unsafe fn getXMLFilePath() -> *const std_string {
        cocos2d_CCUserDefault_getXMLFilePath()
    }
    #[inline]
    pub unsafe fn isXMLFileExist() -> bool {
        cocos2d_CCUserDefault_isXMLFileExist()
    }
    #[inline]
    pub unsafe fn destruct(&mut self) {
        cocos2d_CCUserDefault_CCUserDefault_destructor(self)
    }
}
extern "C" {
    #[doc = " converts a line to a polygon"]
    #[link_name = "\u{1}?ccVertexLineToPolygon@cocos2d@@YAXPEAVCCPoint@1@MPEAU_ccVertex2F@1@II@Z"]
    pub fn cocos2d_ccVertexLineToPolygon(
        points: *mut cocos2d_CCPoint,
        stroke: f32,
        vertices: *mut cocos2d_ccVertex2F,
        offset: ::std::os::raw::c_uint,
        nuPoints: ::std::os::raw::c_uint,
    );
}
extern "C" {
    #[doc = " returns whether or not the line intersects"]
    #[link_name = "\u{1}?ccVertexLineIntersect@cocos2d@@YA_NMMMMMMMMPEAM@Z"]
    pub fn cocos2d_ccVertexLineIntersect(
        Ax: f32,
        Ay: f32,
        Bx: f32,
        By: f32,
        Cx: f32,
        Cy: f32,
        Dx: f32,
        Dy: f32,
        T: *mut f32,
    ) -> bool;
}
#[doc = " @addtogroup input"]
#[doc = " @{"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cocos2d_CCIMEKeyboardNotificationInfo {
    pub begin: cocos2d_CCRect,
    pub end: cocos2d_CCRect,
    pub duration: f32,
}
#[test]
fn bindgen_test_layout_cocos2d_CCIMEKeyboardNotificationInfo() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCIMEKeyboardNotificationInfo>(),
        36usize,
        concat!(
            "Size of: ",
            stringify!(cocos2d_CCIMEKeyboardNotificationInfo)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCIMEKeyboardNotificationInfo>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(cocos2d_CCIMEKeyboardNotificationInfo)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cocos2d_CCIMEKeyboardNotificationInfo>())).begin as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCIMEKeyboardNotificationInfo),
            "::",
            stringify!(begin)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cocos2d_CCIMEKeyboardNotificationInfo>())).end as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCIMEKeyboardNotificationInfo),
            "::",
            stringify!(end)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cocos2d_CCIMEKeyboardNotificationInfo>())).duration as *const _
                as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCIMEKeyboardNotificationInfo),
            "::",
            stringify!(duration)
        )
    );
}
#[repr(C)]
pub struct cocos2d_CCIMEDelegate__bindgen_vtable(::std::os::raw::c_void);
#[doc = "@brief    Input method editor delegate."]
#[doc = "@js NA"]
#[doc = "@lua NA"]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCIMEDelegate {
    pub vtable_: *const cocos2d_CCIMEDelegate__bindgen_vtable,
}
#[test]
fn bindgen_test_layout_cocos2d_CCIMEDelegate() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCIMEDelegate>(),
        8usize,
        concat!("Size of: ", stringify!(cocos2d_CCIMEDelegate))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCIMEDelegate>(),
        8usize,
        concat!("Alignment of ", stringify!(cocos2d_CCIMEDelegate))
    );
}
extern "C" {
    #[link_name = "\u{1}??0CCIMEDelegate@cocos2d@@IEAA@XZ"]
    pub fn cocos2d_CCIMEDelegate_CCIMEDelegate(this: *mut cocos2d_CCIMEDelegate);
}
impl cocos2d_CCIMEDelegate {
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cocos2d_CCIMEDelegate_CCIMEDelegate(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
}
extern "C" {
    #[link_name = "\u{1}??_DCCIMEDelegate@cocos2d@@QEAAXXZ"]
    pub fn cocos2d_CCIMEDelegate_CCIMEDelegate_destructor(this: *mut cocos2d_CCIMEDelegate);
}
extern "C" {
    #[link_name = "\u{1}?attachWithIME@CCIMEDelegate@cocos2d@@UEAA_NXZ"]
    pub fn cocos2d_CCIMEDelegate_attachWithIME(this: *mut ::std::os::raw::c_void) -> bool;
}
extern "C" {
    #[link_name = "\u{1}?detachWithIME@CCIMEDelegate@cocos2d@@UEAA_NXZ"]
    pub fn cocos2d_CCIMEDelegate_detachWithIME(this: *mut ::std::os::raw::c_void) -> bool;
}
#[doc = "@brief    Input Method Edit Message Dispatcher."]
#[doc = "@js NA"]
#[doc = "@lua NA"]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCIMEDispatcher {
    pub m_pImpl: *mut cocos2d_CCIMEDispatcher_Impl,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cocos2d_CCIMEDispatcher_Impl {
    _unused: [u8; 0],
}
#[test]
fn bindgen_test_layout_cocos2d_CCIMEDispatcher() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCIMEDispatcher>(),
        8usize,
        concat!("Size of: ", stringify!(cocos2d_CCIMEDispatcher))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCIMEDispatcher>(),
        8usize,
        concat!("Alignment of ", stringify!(cocos2d_CCIMEDispatcher))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cocos2d_CCIMEDispatcher>())).m_pImpl as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCIMEDispatcher),
            "::",
            stringify!(m_pImpl)
        )
    );
}
extern "C" {
    #[doc = "@brief Returns the shared CCIMEDispatcher object for the system."]
    #[link_name = "\u{1}?sharedDispatcher@CCIMEDispatcher@cocos2d@@SAPEAV12@XZ"]
    pub fn cocos2d_CCIMEDispatcher_sharedDispatcher() -> *mut cocos2d_CCIMEDispatcher;
}
extern "C" {
    #[doc = "@brief Dispatches the input text from IME."]
    #[link_name = "\u{1}?dispatchInsertText@CCIMEDispatcher@cocos2d@@QEAAXPEBDH@Z"]
    pub fn cocos2d_CCIMEDispatcher_dispatchInsertText(
        this: *mut cocos2d_CCIMEDispatcher,
        pText: *const ::std::os::raw::c_char,
        nLen: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = "@brief Dispatches the delete-backward operation."]
    #[link_name = "\u{1}?dispatchDeleteBackward@CCIMEDispatcher@cocos2d@@QEAAXXZ"]
    pub fn cocos2d_CCIMEDispatcher_dispatchDeleteBackward(this: *mut cocos2d_CCIMEDispatcher);
}
extern "C" {
    #[doc = "@brief Get the content text from CCIMEDelegate, retrieved previously from IME."]
    #[link_name = "\u{1}?getContentText@CCIMEDispatcher@cocos2d@@QEAAPEBDXZ"]
    pub fn cocos2d_CCIMEDispatcher_getContentText(
        this: *mut cocos2d_CCIMEDispatcher,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = ""]
    #[link_name = "\u{1}?dispatchKeyboardWillShow@CCIMEDispatcher@cocos2d@@QEAAXAEAUCCIMEKeyboardNotificationInfo@2@@Z"]
    pub fn cocos2d_CCIMEDispatcher_dispatchKeyboardWillShow(
        this: *mut cocos2d_CCIMEDispatcher,
        info: *mut cocos2d_CCIMEKeyboardNotificationInfo,
    );
}
extern "C" {
    #[link_name = "\u{1}?dispatchKeyboardDidShow@CCIMEDispatcher@cocos2d@@QEAAXAEAUCCIMEKeyboardNotificationInfo@2@@Z"]
    pub fn cocos2d_CCIMEDispatcher_dispatchKeyboardDidShow(
        this: *mut cocos2d_CCIMEDispatcher,
        info: *mut cocos2d_CCIMEKeyboardNotificationInfo,
    );
}
extern "C" {
    #[link_name = "\u{1}?dispatchKeyboardWillHide@CCIMEDispatcher@cocos2d@@QEAAXAEAUCCIMEKeyboardNotificationInfo@2@@Z"]
    pub fn cocos2d_CCIMEDispatcher_dispatchKeyboardWillHide(
        this: *mut cocos2d_CCIMEDispatcher,
        info: *mut cocos2d_CCIMEKeyboardNotificationInfo,
    );
}
extern "C" {
    #[link_name = "\u{1}?dispatchKeyboardDidHide@CCIMEDispatcher@cocos2d@@QEAAXAEAUCCIMEKeyboardNotificationInfo@2@@Z"]
    pub fn cocos2d_CCIMEDispatcher_dispatchKeyboardDidHide(
        this: *mut cocos2d_CCIMEDispatcher,
        info: *mut cocos2d_CCIMEKeyboardNotificationInfo,
    );
}
extern "C" {
    #[doc = "@brief Add delegate to receive IME messages."]
    #[link_name = "\u{1}?addDelegate@CCIMEDispatcher@cocos2d@@IEAAXPEAVCCIMEDelegate@2@@Z"]
    pub fn cocos2d_CCIMEDispatcher_addDelegate(
        this: *mut cocos2d_CCIMEDispatcher,
        pDelegate: *mut cocos2d_CCIMEDelegate,
    );
}
extern "C" {
    #[doc = "@brief Attach the pDelegate to the IME."]
    #[doc = "@return If the old delegate can detach from the IME, and the new delegate"]
    #[doc = "can attach to the IME, return true, otherwise false."]
    #[link_name = "\u{1}?attachDelegateWithIME@CCIMEDispatcher@cocos2d@@IEAA_NPEAVCCIMEDelegate@2@@Z"]
    pub fn cocos2d_CCIMEDispatcher_attachDelegateWithIME(
        this: *mut cocos2d_CCIMEDispatcher,
        pDelegate: *mut cocos2d_CCIMEDelegate,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}?detachDelegateWithIME@CCIMEDispatcher@cocos2d@@IEAA_NPEAVCCIMEDelegate@2@@Z"]
    pub fn cocos2d_CCIMEDispatcher_detachDelegateWithIME(
        this: *mut cocos2d_CCIMEDispatcher,
        pDelegate: *mut cocos2d_CCIMEDelegate,
    ) -> bool;
}
extern "C" {
    #[doc = "@brief Remove the delegate from the delegates which receive IME messages."]
    #[link_name = "\u{1}?removeDelegate@CCIMEDispatcher@cocos2d@@IEAAXPEAVCCIMEDelegate@2@@Z"]
    pub fn cocos2d_CCIMEDispatcher_removeDelegate(
        this: *mut cocos2d_CCIMEDispatcher,
        pDelegate: *mut cocos2d_CCIMEDelegate,
    );
}
extern "C" {
    #[link_name = "\u{1}??_DCCIMEDispatcher@cocos2d@@QEAAXXZ"]
    pub fn cocos2d_CCIMEDispatcher_CCIMEDispatcher_destructor(this: *mut cocos2d_CCIMEDispatcher);
}
impl cocos2d_CCIMEDispatcher {
    #[inline]
    pub unsafe fn sharedDispatcher() -> *mut cocos2d_CCIMEDispatcher {
        cocos2d_CCIMEDispatcher_sharedDispatcher()
    }
    #[inline]
    pub unsafe fn dispatchInsertText(
        &mut self,
        pText: *const ::std::os::raw::c_char,
        nLen: ::std::os::raw::c_int,
    ) {
        cocos2d_CCIMEDispatcher_dispatchInsertText(self, pText, nLen)
    }
    #[inline]
    pub unsafe fn dispatchDeleteBackward(&mut self) {
        cocos2d_CCIMEDispatcher_dispatchDeleteBackward(self)
    }
    #[inline]
    pub unsafe fn getContentText(&mut self) -> *const ::std::os::raw::c_char {
        cocos2d_CCIMEDispatcher_getContentText(self)
    }
    #[inline]
    pub unsafe fn dispatchKeyboardWillShow(
        &mut self,
        info: *mut cocos2d_CCIMEKeyboardNotificationInfo,
    ) {
        cocos2d_CCIMEDispatcher_dispatchKeyboardWillShow(self, info)
    }
    #[inline]
    pub unsafe fn dispatchKeyboardDidShow(
        &mut self,
        info: *mut cocos2d_CCIMEKeyboardNotificationInfo,
    ) {
        cocos2d_CCIMEDispatcher_dispatchKeyboardDidShow(self, info)
    }
    #[inline]
    pub unsafe fn dispatchKeyboardWillHide(
        &mut self,
        info: *mut cocos2d_CCIMEKeyboardNotificationInfo,
    ) {
        cocos2d_CCIMEDispatcher_dispatchKeyboardWillHide(self, info)
    }
    #[inline]
    pub unsafe fn dispatchKeyboardDidHide(
        &mut self,
        info: *mut cocos2d_CCIMEKeyboardNotificationInfo,
    ) {
        cocos2d_CCIMEDispatcher_dispatchKeyboardDidHide(self, info)
    }
    #[inline]
    pub unsafe fn addDelegate(&mut self, pDelegate: *mut cocos2d_CCIMEDelegate) {
        cocos2d_CCIMEDispatcher_addDelegate(self, pDelegate)
    }
    #[inline]
    pub unsafe fn attachDelegateWithIME(&mut self, pDelegate: *mut cocos2d_CCIMEDelegate) -> bool {
        cocos2d_CCIMEDispatcher_attachDelegateWithIME(self, pDelegate)
    }
    #[inline]
    pub unsafe fn detachDelegateWithIME(&mut self, pDelegate: *mut cocos2d_CCIMEDelegate) -> bool {
        cocos2d_CCIMEDispatcher_detachDelegateWithIME(self, pDelegate)
    }
    #[inline]
    pub unsafe fn removeDelegate(&mut self, pDelegate: *mut cocos2d_CCIMEDelegate) {
        cocos2d_CCIMEDispatcher_removeDelegate(self, pDelegate)
    }
    #[inline]
    pub unsafe fn destruct(&mut self) {
        cocos2d_CCIMEDispatcher_CCIMEDispatcher_destructor(self)
    }
}
#[repr(C)]
pub struct cocos2d_CCTextFieldDelegate__bindgen_vtable(::std::os::raw::c_void);
#[doc = " @addtogroup input"]
#[doc = " @{"]
#[doc = " @js NA"]
#[doc = " @lua NA"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cocos2d_CCTextFieldDelegate {
    pub vtable_: *const cocos2d_CCTextFieldDelegate__bindgen_vtable,
}
#[test]
fn bindgen_test_layout_cocos2d_CCTextFieldDelegate() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCTextFieldDelegate>(),
        8usize,
        concat!("Size of: ", stringify!(cocos2d_CCTextFieldDelegate))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCTextFieldDelegate>(),
        8usize,
        concat!("Alignment of ", stringify!(cocos2d_CCTextFieldDelegate))
    );
}
#[doc = "@brief    A simple text input field with TTF font."]
#[doc = "@js NA"]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCTextFieldTTF {
    pub _base: cocos2d_CCLabelTTF,
    pub _base_1: cocos2d_CCIMEDelegate,
    pub m_pDelegate: *mut cocos2d_CCTextFieldDelegate,
    pub m_nCharCount: ::std::os::raw::c_int,
    pub m_pInputText: *mut std_string,
    pub m_pPlaceHolder: *mut std_string,
    pub m_ColorSpaceHolder: cocos2d_ccColor3B,
    pub m_bSecureTextEntry: bool,
    pub m_pLens: *mut cocos2d_CCTextFieldTTF_LengthStack,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cocos2d_CCTextFieldTTF_LengthStack {
    _unused: [u8; 0],
}
#[test]
fn bindgen_test_layout_cocos2d_CCTextFieldTTF() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCTextFieldTTF>(),
        736usize,
        concat!("Size of: ", stringify!(cocos2d_CCTextFieldTTF))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCTextFieldTTF>(),
        8usize,
        concat!("Alignment of ", stringify!(cocos2d_CCTextFieldTTF))
    );
}
extern "C" {
    #[doc = " creates a CCTextFieldTTF from a fontname, alignment, dimension and font size"]
    #[link_name = "\u{1}?textFieldWithPlaceHolder@CCTextFieldTTF@cocos2d@@SAPEAV12@PEBDAEBVCCSize@2@W4CCTextAlignment@2@0M@Z"]
    pub fn cocos2d_CCTextFieldTTF_textFieldWithPlaceHolder(
        placeholder: *const ::std::os::raw::c_char,
        dimensions: *const cocos2d_CCSize,
        alignment: cocos2d_CCTextAlignment,
        fontName: *const ::std::os::raw::c_char,
        fontSize: f32,
    ) -> *mut cocos2d_CCTextFieldTTF;
}
extern "C" {
    #[doc = " creates a CCLabelTTF from a fontname and font size"]
    #[link_name = "\u{1}?textFieldWithPlaceHolder@CCTextFieldTTF@cocos2d@@SAPEAV12@PEBD0M@Z"]
    pub fn cocos2d_CCTextFieldTTF_textFieldWithPlaceHolder1(
        placeholder: *const ::std::os::raw::c_char,
        fontName: *const ::std::os::raw::c_char,
        fontSize: f32,
    ) -> *mut cocos2d_CCTextFieldTTF;
}
extern "C" {
    #[doc = " initializes the CCTextFieldTTF with a font name, alignment, dimension and font size"]
    #[link_name = "\u{1}?initWithPlaceHolder@CCTextFieldTTF@cocos2d@@QEAA_NPEBDAEBVCCSize@2@W4CCTextAlignment@2@0M@Z"]
    pub fn cocos2d_CCTextFieldTTF_initWithPlaceHolder(
        this: *mut cocos2d_CCTextFieldTTF,
        placeholder: *const ::std::os::raw::c_char,
        dimensions: *const cocos2d_CCSize,
        alignment: cocos2d_CCTextAlignment,
        fontName: *const ::std::os::raw::c_char,
        fontSize: f32,
    ) -> bool;
}
extern "C" {
    #[doc = " initializes the CCTextFieldTTF with a font name and font size"]
    #[link_name = "\u{1}?initWithPlaceHolder@CCTextFieldTTF@cocos2d@@QEAA_NPEBD0M@Z"]
    pub fn cocos2d_CCTextFieldTTF_initWithPlaceHolder1(
        this: *mut cocos2d_CCTextFieldTTF,
        placeholder: *const ::std::os::raw::c_char,
        fontName: *const ::std::os::raw::c_char,
        fontSize: f32,
    ) -> bool;
}
extern "C" {
    #[doc = "  @lua NA"]
    #[link_name = "\u{1}??0CCTextFieldTTF@cocos2d@@QEAA@XZ"]
    pub fn cocos2d_CCTextFieldTTF_CCTextFieldTTF(this: *mut cocos2d_CCTextFieldTTF);
}
impl cocos2d_CCTextFieldTTF {
    #[inline]
    pub unsafe fn textFieldWithPlaceHolder(
        placeholder: *const ::std::os::raw::c_char,
        dimensions: *const cocos2d_CCSize,
        alignment: cocos2d_CCTextAlignment,
        fontName: *const ::std::os::raw::c_char,
        fontSize: f32,
    ) -> *mut cocos2d_CCTextFieldTTF {
        cocos2d_CCTextFieldTTF_textFieldWithPlaceHolder(
            placeholder,
            dimensions,
            alignment,
            fontName,
            fontSize,
        )
    }
    #[inline]
    pub unsafe fn textFieldWithPlaceHolder1(
        placeholder: *const ::std::os::raw::c_char,
        fontName: *const ::std::os::raw::c_char,
        fontSize: f32,
    ) -> *mut cocos2d_CCTextFieldTTF {
        cocos2d_CCTextFieldTTF_textFieldWithPlaceHolder1(placeholder, fontName, fontSize)
    }
    #[inline]
    pub unsafe fn initWithPlaceHolder(
        &mut self,
        placeholder: *const ::std::os::raw::c_char,
        dimensions: *const cocos2d_CCSize,
        alignment: cocos2d_CCTextAlignment,
        fontName: *const ::std::os::raw::c_char,
        fontSize: f32,
    ) -> bool {
        cocos2d_CCTextFieldTTF_initWithPlaceHolder(
            self,
            placeholder,
            dimensions,
            alignment,
            fontName,
            fontSize,
        )
    }
    #[inline]
    pub unsafe fn initWithPlaceHolder1(
        &mut self,
        placeholder: *const ::std::os::raw::c_char,
        fontName: *const ::std::os::raw::c_char,
        fontSize: f32,
    ) -> bool {
        cocos2d_CCTextFieldTTF_initWithPlaceHolder1(self, placeholder, fontName, fontSize)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cocos2d_CCTextFieldTTF_CCTextFieldTTF(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
}
extern "C" {
    #[doc = "  @lua NA"]
    #[link_name = "\u{1}??_DCCTextFieldTTF@cocos2d@@QEAAXXZ"]
    pub fn cocos2d_CCTextFieldTTF_CCTextFieldTTF_destructor(this: *mut cocos2d_CCTextFieldTTF);
}
extern "C" {
    #[doc = "@brief    Open keyboard and receive input text."]
    #[link_name = "\u{1}?attachWithIME@CCTextFieldTTF@cocos2d@@UEAA_NXZ"]
    pub fn cocos2d_CCTextFieldTTF_attachWithIME(this: *mut ::std::os::raw::c_void) -> bool;
}
extern "C" {
    #[doc = "@brief    End text input and close keyboard."]
    #[link_name = "\u{1}?detachWithIME@CCTextFieldTTF@cocos2d@@UEAA_NXZ"]
    pub fn cocos2d_CCTextFieldTTF_detachWithIME(this: *mut ::std::os::raw::c_void) -> bool;
}
extern "C" {
    #[link_name = "\u{1}?getColorSpaceHolder@CCTextFieldTTF@cocos2d@@UEAAAEBU_ccColor3B@2@XZ"]
    pub fn cocos2d_CCTextFieldTTF_getColorSpaceHolder(
        this: *mut ::std::os::raw::c_void,
    ) -> *const cocos2d_ccColor3B;
}
extern "C" {
    #[link_name = "\u{1}?setColorSpaceHolder@CCTextFieldTTF@cocos2d@@UEAAXAEBU_ccColor3B@2@@Z"]
    pub fn cocos2d_CCTextFieldTTF_setColorSpaceHolder(
        this: *mut ::std::os::raw::c_void,
        color: *const cocos2d_ccColor3B,
    );
}
extern "C" {
    #[link_name = "\u{1}?setString@CCTextFieldTTF@cocos2d@@UEAAXPEBD@Z"]
    pub fn cocos2d_CCTextFieldTTF_setString(
        this: *mut ::std::os::raw::c_void,
        text: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    #[link_name = "\u{1}?getString@CCTextFieldTTF@cocos2d@@UEAAPEBDXZ"]
    pub fn cocos2d_CCTextFieldTTF_getString(
        this: *mut ::std::os::raw::c_void,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}?setPlaceHolder@CCTextFieldTTF@cocos2d@@UEAAXPEBD@Z"]
    pub fn cocos2d_CCTextFieldTTF_setPlaceHolder(
        this: *mut ::std::os::raw::c_void,
        text: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    #[link_name = "\u{1}?getPlaceHolder@CCTextFieldTTF@cocos2d@@UEAAPEBDXZ"]
    pub fn cocos2d_CCTextFieldTTF_getPlaceHolder(
        this: *mut ::std::os::raw::c_void,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}?setSecureTextEntry@CCTextFieldTTF@cocos2d@@UEAAX_N@Z"]
    pub fn cocos2d_CCTextFieldTTF_setSecureTextEntry(
        this: *mut ::std::os::raw::c_void,
        value: bool,
    );
}
extern "C" {
    #[link_name = "\u{1}?isSecureTextEntry@CCTextFieldTTF@cocos2d@@UEAA_NXZ"]
    pub fn cocos2d_CCTextFieldTTF_isSecureTextEntry(this: *mut ::std::os::raw::c_void) -> bool;
}
extern "C" {
    #[link_name = "\u{1}?draw@CCTextFieldTTF@cocos2d@@MEAAXXZ"]
    pub fn cocos2d_CCTextFieldTTF_draw(this: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[doc = ""]
    #[link_name = "\u{1}?canAttachWithIME@CCTextFieldTTF@cocos2d@@MEAA_NXZ"]
    pub fn cocos2d_CCTextFieldTTF_canAttachWithIME(this: *mut ::std::os::raw::c_void) -> bool;
}
extern "C" {
    #[link_name = "\u{1}?canDetachWithIME@CCTextFieldTTF@cocos2d@@MEAA_NXZ"]
    pub fn cocos2d_CCTextFieldTTF_canDetachWithIME(this: *mut ::std::os::raw::c_void) -> bool;
}
extern "C" {
    #[link_name = "\u{1}?insertText@CCTextFieldTTF@cocos2d@@MEAAXPEBDH@Z"]
    pub fn cocos2d_CCTextFieldTTF_insertText(
        this: *mut ::std::os::raw::c_void,
        text: *const ::std::os::raw::c_char,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}?deleteBackward@CCTextFieldTTF@cocos2d@@MEAAXXZ"]
    pub fn cocos2d_CCTextFieldTTF_deleteBackward(this: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[link_name = "\u{1}?getContentText@CCTextFieldTTF@cocos2d@@MEAAPEBDXZ"]
    pub fn cocos2d_CCTextFieldTTF_getContentText(
        this: *mut ::std::os::raw::c_void,
    ) -> *const ::std::os::raw::c_char;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cocos2d_CCLock {
    _unused: [u8; 0],
}
#[doc = " @brief Singleton that handles the loading of textures"]
#[doc = " Once the texture is loaded, the next time it will return"]
#[doc = " a reference of the previously loaded texture reducing GPU & CPU memory"]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCTextureCache {
    pub _base: cocos2d_CCObject,
    pub m_pTextures: *mut cocos2d_CCDictionary,
}
#[test]
fn bindgen_test_layout_cocos2d_CCTextureCache() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCTextureCache>(),
        48usize,
        concat!("Size of: ", stringify!(cocos2d_CCTextureCache))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCTextureCache>(),
        8usize,
        concat!("Alignment of ", stringify!(cocos2d_CCTextureCache))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cocos2d_CCTextureCache>())).m_pTextures as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCTextureCache),
            "::",
            stringify!(m_pTextures)
        )
    );
}
extern "C" {
    #[doc = "  @js NA"]
    #[doc = "  @lua NA"]
    #[link_name = "\u{1}?description@CCTextureCache@cocos2d@@QEAAPEBDXZ"]
    pub fn cocos2d_CCTextureCache_description(
        this: *mut cocos2d_CCTextureCache,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = "  @js NA"]
    #[link_name = "\u{1}?snapshotTextures@CCTextureCache@cocos2d@@QEAAPEAVCCDictionary@2@XZ"]
    pub fn cocos2d_CCTextureCache_snapshotTextures(
        this: *mut cocos2d_CCTextureCache,
    ) -> *mut cocos2d_CCDictionary;
}
extern "C" {
    #[doc = " Returns the shared instance of the cache"]
    #[doc = "  @js getInstance"]
    #[link_name = "\u{1}?sharedTextureCache@CCTextureCache@cocos2d@@SAPEAV12@XZ"]
    pub fn cocos2d_CCTextureCache_sharedTextureCache() -> *mut cocos2d_CCTextureCache;
}
extern "C" {
    #[doc = " purges the cache. It releases the retained instance."]
    #[doc = "@since v0.99.0"]
    #[link_name = "\u{1}?purgeSharedTextureCache@CCTextureCache@cocos2d@@SAXXZ"]
    pub fn cocos2d_CCTextureCache_purgeSharedTextureCache();
}
extern "C" {
    #[doc = " Returns a Texture2D object given an file image"]
    #[doc = " If the file image was not previously loaded, it will create a new CCTexture2D"]
    #[doc = "  object and it will return it. It will use the filename as a key."]
    #[doc = " Otherwise it will return a reference of a previously loaded image."]
    #[doc = " Supported image extensions: .png, .bmp, .tiff, .jpeg, .pvr, .gif"]
    #[link_name = "\u{1}?addImage@CCTextureCache@cocos2d@@QEAAPEAVCCTexture2D@2@PEBD@Z"]
    pub fn cocos2d_CCTextureCache_addImage(
        this: *mut cocos2d_CCTextureCache,
        fileimage: *const ::std::os::raw::c_char,
    ) -> *mut cocos2d_CCTexture2D;
}
extern "C" {
    #[link_name = "\u{1}?addImageAsync@CCTextureCache@cocos2d@@QEAAXPEBDPEAVCCObject@2@P832@EAAX1@Z@Z"]
    pub fn cocos2d_CCTextureCache_addImageAsync(
        this: *mut cocos2d_CCTextureCache,
        path: *const ::std::os::raw::c_char,
        target: *mut cocos2d_CCObject,
        selector: cocos2d_SEL_CallFuncO,
    );
}
extern "C" {
    #[doc = " Returns a Texture2D object given an UIImage image"]
    #[doc = " If the image was not previously loaded, it will create a new CCTexture2D object and it will return it."]
    #[doc = " Otherwise it will return a reference of a previously loaded image"]
    #[doc = " The \"key\" parameter will be used as the \"key\" for the cache."]
    #[doc = " If \"key\" is nil, then a new texture will be created each time."]
    #[link_name = "\u{1}?addUIImage@CCTextureCache@cocos2d@@QEAAPEAVCCTexture2D@2@PEAVCCImage@2@PEBD@Z"]
    pub fn cocos2d_CCTextureCache_addUIImage(
        this: *mut cocos2d_CCTextureCache,
        image: *mut cocos2d_CCImage,
        key: *const ::std::os::raw::c_char,
    ) -> *mut cocos2d_CCTexture2D;
}
extern "C" {
    #[doc = " Returns an already created texture. Returns nil if the texture doesn't exist."]
    #[doc = "@since v0.99.5"]
    #[link_name = "\u{1}?textureForKey@CCTextureCache@cocos2d@@QEAAPEAVCCTexture2D@2@PEBD@Z"]
    pub fn cocos2d_CCTextureCache_textureForKey(
        this: *mut cocos2d_CCTextureCache,
        key: *const ::std::os::raw::c_char,
    ) -> *mut cocos2d_CCTexture2D;
}
extern "C" {
    #[doc = " Reload texture from the image file"]
    #[doc = " If the file image hasn't loaded before, load it."]
    #[doc = " Otherwise the texture will be reloaded from the file image."]
    #[doc = " The \"filenName\" parameter is the related/absolute path of the file image."]
    #[doc = " Return true if the reloading is succeed, otherwise return false."]
    #[link_name = "\u{1}?reloadTexture@CCTextureCache@cocos2d@@QEAA_NPEBD@Z"]
    pub fn cocos2d_CCTextureCache_reloadTexture(
        this: *mut cocos2d_CCTextureCache,
        fileName: *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    #[doc = " Purges the dictionary of loaded textures."]
    #[doc = " Call this method if you receive the \"Memory Warning\""]
    #[doc = " In the short term: it will free some resources preventing your app from being killed"]
    #[doc = " In the medium term: it will allocate more resources"]
    #[doc = " In the long term: it will be the same"]
    #[link_name = "\u{1}?removeAllTextures@CCTextureCache@cocos2d@@QEAAXXZ"]
    pub fn cocos2d_CCTextureCache_removeAllTextures(this: *mut cocos2d_CCTextureCache);
}
extern "C" {
    #[doc = " Removes unused textures"]
    #[doc = " Textures that have a retain count of 1 will be deleted"]
    #[doc = " It is convenient to call this method after when starting a new Scene"]
    #[doc = " @since v0.8"]
    #[link_name = "\u{1}?removeUnusedTextures@CCTextureCache@cocos2d@@QEAAXXZ"]
    pub fn cocos2d_CCTextureCache_removeUnusedTextures(this: *mut cocos2d_CCTextureCache);
}
extern "C" {
    #[doc = " Deletes a texture from the cache given a texture"]
    #[link_name = "\u{1}?removeTexture@CCTextureCache@cocos2d@@QEAAXPEAVCCTexture2D@2@@Z"]
    pub fn cocos2d_CCTextureCache_removeTexture(
        this: *mut cocos2d_CCTextureCache,
        texture: *mut cocos2d_CCTexture2D,
    );
}
extern "C" {
    #[doc = " Deletes a texture from the cache given a its key name"]
    #[doc = "@since v0.99.4"]
    #[link_name = "\u{1}?removeTextureForKey@CCTextureCache@cocos2d@@QEAAXPEBD@Z"]
    pub fn cocos2d_CCTextureCache_removeTextureForKey(
        this: *mut cocos2d_CCTextureCache,
        textureKeyName: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    #[doc = " Output to CCLOG the current contents of this CCTextureCache"]
    #[doc = " This will attempt to calculate the size of each texture, and the total texture memory in use"]
    #[doc = ""]
    #[doc = " @since v1.0"]
    #[link_name = "\u{1}?dumpCachedTextureInfo@CCTextureCache@cocos2d@@QEAAXXZ"]
    pub fn cocos2d_CCTextureCache_dumpCachedTextureInfo(this: *mut cocos2d_CCTextureCache);
}
extern "C" {
    #[doc = " Returns a Texture2D object given an PVR filename"]
    #[doc = " If the file image was not previously loaded, it will create a new CCTexture2D"]
    #[doc = "  object and it will return it. Otherwise it will return a reference of a previously loaded image"]
    #[link_name = "\u{1}?addPVRImage@CCTextureCache@cocos2d@@QEAAPEAVCCTexture2D@2@PEBD@Z"]
    pub fn cocos2d_CCTextureCache_addPVRImage(
        this: *mut cocos2d_CCTextureCache,
        filename: *const ::std::os::raw::c_char,
    ) -> *mut cocos2d_CCTexture2D;
}
extern "C" {
    #[doc = " Returns a Texture2D object given an ETC filename"]
    #[doc = " If the file image was not previously loaded, it will create a new CCTexture2D"]
    #[doc = "  object and it will return it. Otherwise it will return a reference of a previously loaded image"]
    #[doc = "  @lua NA"]
    #[link_name = "\u{1}?addETCImage@CCTextureCache@cocos2d@@QEAAPEAVCCTexture2D@2@PEBD@Z"]
    pub fn cocos2d_CCTextureCache_addETCImage(
        this: *mut cocos2d_CCTextureCache,
        filename: *const ::std::os::raw::c_char,
    ) -> *mut cocos2d_CCTexture2D;
}
extern "C" {
    #[doc = " Reload all textures"]
    #[doc = "It's only useful when the value of CC_ENABLE_CACHE_TEXTURE_DATA is 1"]
    #[link_name = "\u{1}?reloadAllTextures@CCTextureCache@cocos2d@@SAXXZ"]
    pub fn cocos2d_CCTextureCache_reloadAllTextures();
}
extern "C" {
    #[doc = "  @js ctor"]
    #[doc = "  @lua NA"]
    #[link_name = "\u{1}??0CCTextureCache@cocos2d@@QEAA@XZ"]
    pub fn cocos2d_CCTextureCache_CCTextureCache(this: *mut cocos2d_CCTextureCache);
}
impl cocos2d_CCTextureCache {
    #[inline]
    pub unsafe fn description(&mut self) -> *const ::std::os::raw::c_char {
        cocos2d_CCTextureCache_description(self)
    }
    #[inline]
    pub unsafe fn snapshotTextures(&mut self) -> *mut cocos2d_CCDictionary {
        cocos2d_CCTextureCache_snapshotTextures(self)
    }
    #[inline]
    pub unsafe fn sharedTextureCache() -> *mut cocos2d_CCTextureCache {
        cocos2d_CCTextureCache_sharedTextureCache()
    }
    #[inline]
    pub unsafe fn purgeSharedTextureCache() {
        cocos2d_CCTextureCache_purgeSharedTextureCache()
    }
    #[inline]
    pub unsafe fn addImage(
        &mut self,
        fileimage: *const ::std::os::raw::c_char,
    ) -> *mut cocos2d_CCTexture2D {
        cocos2d_CCTextureCache_addImage(self, fileimage)
    }
    #[inline]
    pub unsafe fn addImageAsync(
        &mut self,
        path: *const ::std::os::raw::c_char,
        target: *mut cocos2d_CCObject,
        selector: cocos2d_SEL_CallFuncO,
    ) {
        cocos2d_CCTextureCache_addImageAsync(self, path, target, selector)
    }
    #[inline]
    pub unsafe fn addUIImage(
        &mut self,
        image: *mut cocos2d_CCImage,
        key: *const ::std::os::raw::c_char,
    ) -> *mut cocos2d_CCTexture2D {
        cocos2d_CCTextureCache_addUIImage(self, image, key)
    }
    #[inline]
    pub unsafe fn textureForKey(
        &mut self,
        key: *const ::std::os::raw::c_char,
    ) -> *mut cocos2d_CCTexture2D {
        cocos2d_CCTextureCache_textureForKey(self, key)
    }
    #[inline]
    pub unsafe fn reloadTexture(&mut self, fileName: *const ::std::os::raw::c_char) -> bool {
        cocos2d_CCTextureCache_reloadTexture(self, fileName)
    }
    #[inline]
    pub unsafe fn removeAllTextures(&mut self) {
        cocos2d_CCTextureCache_removeAllTextures(self)
    }
    #[inline]
    pub unsafe fn removeUnusedTextures(&mut self) {
        cocos2d_CCTextureCache_removeUnusedTextures(self)
    }
    #[inline]
    pub unsafe fn removeTexture(&mut self, texture: *mut cocos2d_CCTexture2D) {
        cocos2d_CCTextureCache_removeTexture(self, texture)
    }
    #[inline]
    pub unsafe fn removeTextureForKey(&mut self, textureKeyName: *const ::std::os::raw::c_char) {
        cocos2d_CCTextureCache_removeTextureForKey(self, textureKeyName)
    }
    #[inline]
    pub unsafe fn dumpCachedTextureInfo(&mut self) {
        cocos2d_CCTextureCache_dumpCachedTextureInfo(self)
    }
    #[inline]
    pub unsafe fn addPVRImage(
        &mut self,
        filename: *const ::std::os::raw::c_char,
    ) -> *mut cocos2d_CCTexture2D {
        cocos2d_CCTextureCache_addPVRImage(self, filename)
    }
    #[inline]
    pub unsafe fn addETCImage(
        &mut self,
        filename: *const ::std::os::raw::c_char,
    ) -> *mut cocos2d_CCTexture2D {
        cocos2d_CCTextureCache_addETCImage(self, filename)
    }
    #[inline]
    pub unsafe fn reloadAllTextures() {
        cocos2d_CCTextureCache_reloadAllTextures()
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cocos2d_CCTextureCache_CCTextureCache(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
}
extern "C" {
    #[doc = "  @js NA"]
    #[doc = "  @lua NA"]
    #[link_name = "\u{1}??_DCCTextureCache@cocos2d@@QEAAXXZ"]
    pub fn cocos2d_CCTextureCache_CCTextureCache_destructor(this: *mut cocos2d_CCTextureCache);
}
#[doc = "@brief Structure which can tell where mipmap begins and how long is it"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cocos2d_CCPVRMipmap {
    pub address: *mut ::std::os::raw::c_uchar,
    pub len: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_cocos2d_CCPVRMipmap() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCPVRMipmap>(),
        16usize,
        concat!("Size of: ", stringify!(cocos2d_CCPVRMipmap))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCPVRMipmap>(),
        8usize,
        concat!("Alignment of ", stringify!(cocos2d_CCPVRMipmap))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cocos2d_CCPVRMipmap>())).address as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCPVRMipmap),
            "::",
            stringify!(address)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cocos2d_CCPVRMipmap>())).len as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCPVRMipmap),
            "::",
            stringify!(len)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cocos2d__ccPVRTexturePixelFormatInfo {
    pub internalFormat: GLenum,
    pub format: GLenum,
    pub type_: GLenum,
    pub bpp: u32,
    pub compressed: bool,
    pub alpha: bool,
    pub ccPixelFormat: cocos2d_CCTexture2DPixelFormat,
}
#[test]
fn bindgen_test_layout_cocos2d__ccPVRTexturePixelFormatInfo() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d__ccPVRTexturePixelFormatInfo>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(cocos2d__ccPVRTexturePixelFormatInfo)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d__ccPVRTexturePixelFormatInfo>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(cocos2d__ccPVRTexturePixelFormatInfo)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cocos2d__ccPVRTexturePixelFormatInfo>())).internalFormat
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d__ccPVRTexturePixelFormatInfo),
            "::",
            stringify!(internalFormat)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cocos2d__ccPVRTexturePixelFormatInfo>())).format as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d__ccPVRTexturePixelFormatInfo),
            "::",
            stringify!(format)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cocos2d__ccPVRTexturePixelFormatInfo>())).type_ as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d__ccPVRTexturePixelFormatInfo),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cocos2d__ccPVRTexturePixelFormatInfo>())).bpp as *const _
                as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d__ccPVRTexturePixelFormatInfo),
            "::",
            stringify!(bpp)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cocos2d__ccPVRTexturePixelFormatInfo>())).compressed as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d__ccPVRTexturePixelFormatInfo),
            "::",
            stringify!(compressed)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cocos2d__ccPVRTexturePixelFormatInfo>())).alpha as *const _
                as usize
        },
        17usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d__ccPVRTexturePixelFormatInfo),
            "::",
            stringify!(alpha)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cocos2d__ccPVRTexturePixelFormatInfo>())).ccPixelFormat
                as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d__ccPVRTexturePixelFormatInfo),
            "::",
            stringify!(ccPixelFormat)
        )
    );
}
pub type cocos2d_ccPVRTexturePixelFormatInfo = cocos2d__ccPVRTexturePixelFormatInfo;
pub const CC_PVRMIPMAP_MAX: ::std::os::raw::c_int = 16;
#[doc = "@brief Determine how many mipmaps can we have."]
#[doc = "Its same as define but it respects namespaces"]
pub type cocos2d__bindgen_ty_12 = ::std::os::raw::c_int;
#[doc = " CCTexturePVR"]
#[doc = ""]
#[doc = "Object that loads PVR images."]
#[doc = ""]
#[doc = "Supported PVR formats:"]
#[doc = "- RGBA8888"]
#[doc = "- BGRA8888"]
#[doc = "- RGBA4444"]
#[doc = "- RGBA5551"]
#[doc = "- RGB565"]
#[doc = "- A8"]
#[doc = "- I8"]
#[doc = "- AI88"]
#[doc = "- PVRTC 4BPP"]
#[doc = "- PVRTC 2BPP"]
#[doc = ""]
#[doc = "Limitations:"]
#[doc = "Pre-generated mipmaps, such as PVR textures with mipmap levels embedded in file,"]
#[doc = "are only supported if all individual sprites are of _square_ size."]
#[doc = "To use mipmaps with non-square textures, instead call CCTexture2D#generateMipmap on the sheet texture itself"]
#[doc = "(and to save space, save the PVR sprite sheet without mip maps included)."]
#[doc = "@js NA"]
#[doc = "@lua NA"]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCTexturePVR {
    pub _base: cocos2d_CCObject,
    pub m_asMipmaps: [cocos2d_CCPVRMipmap; 16usize],
    pub m_uNumberOfMipmaps: ::std::os::raw::c_uint,
    pub m_uWidth: ::std::os::raw::c_uint,
    pub m_uHeight: ::std::os::raw::c_uint,
    pub m_uName: GLuint,
    pub m_bHasAlpha: bool,
    pub m_bHasPremultipliedAlpha: bool,
    pub m_bForcePremultipliedAlpha: bool,
    pub m_bRetainName: bool,
    pub m_eFormat: cocos2d_CCTexture2DPixelFormat,
    pub m_pPixelFormatInfo: *const cocos2d_ccPVRTexturePixelFormatInfo,
}
#[test]
fn bindgen_test_layout_cocos2d_CCTexturePVR() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCTexturePVR>(),
        328usize,
        concat!("Size of: ", stringify!(cocos2d_CCTexturePVR))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCTexturePVR>(),
        8usize,
        concat!("Alignment of ", stringify!(cocos2d_CCTexturePVR))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cocos2d_CCTexturePVR>())).m_asMipmaps as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCTexturePVR),
            "::",
            stringify!(m_asMipmaps)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cocos2d_CCTexturePVR>())).m_uNumberOfMipmaps as *const _ as usize
        },
        296usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCTexturePVR),
            "::",
            stringify!(m_uNumberOfMipmaps)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cocos2d_CCTexturePVR>())).m_uWidth as *const _ as usize },
        300usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCTexturePVR),
            "::",
            stringify!(m_uWidth)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cocos2d_CCTexturePVR>())).m_uHeight as *const _ as usize },
        304usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCTexturePVR),
            "::",
            stringify!(m_uHeight)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cocos2d_CCTexturePVR>())).m_uName as *const _ as usize },
        308usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCTexturePVR),
            "::",
            stringify!(m_uName)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cocos2d_CCTexturePVR>())).m_bHasAlpha as *const _ as usize
        },
        312usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCTexturePVR),
            "::",
            stringify!(m_bHasAlpha)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cocos2d_CCTexturePVR>())).m_bHasPremultipliedAlpha as *const _
                as usize
        },
        313usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCTexturePVR),
            "::",
            stringify!(m_bHasPremultipliedAlpha)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cocos2d_CCTexturePVR>())).m_bForcePremultipliedAlpha as *const _
                as usize
        },
        314usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCTexturePVR),
            "::",
            stringify!(m_bForcePremultipliedAlpha)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cocos2d_CCTexturePVR>())).m_bRetainName as *const _ as usize
        },
        315usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCTexturePVR),
            "::",
            stringify!(m_bRetainName)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cocos2d_CCTexturePVR>())).m_eFormat as *const _ as usize },
        316usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCTexturePVR),
            "::",
            stringify!(m_eFormat)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cocos2d_CCTexturePVR>())).m_pPixelFormatInfo as *const _ as usize
        },
        320usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCTexturePVR),
            "::",
            stringify!(m_pPixelFormatInfo)
        )
    );
}
extern "C" {
    #[doc = " initializes a CCTexturePVR with a path"]
    #[link_name = "\u{1}?initWithContentsOfFile@CCTexturePVR@cocos2d@@QEAA_NPEBD@Z"]
    pub fn cocos2d_CCTexturePVR_initWithContentsOfFile(
        this: *mut cocos2d_CCTexturePVR,
        path: *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    #[doc = " creates and initializes a CCTexturePVR with a path"]
    #[link_name = "\u{1}?create@CCTexturePVR@cocos2d@@SAPEAV12@PEBD@Z"]
    pub fn cocos2d_CCTexturePVR_create(
        path: *const ::std::os::raw::c_char,
    ) -> *mut cocos2d_CCTexturePVR;
}
extern "C" {
    #[link_name = "\u{1}??0CCTexturePVR@cocos2d@@QEAA@XZ"]
    pub fn cocos2d_CCTexturePVR_CCTexturePVR(this: *mut cocos2d_CCTexturePVR);
}
impl cocos2d_CCTexturePVR {
    #[inline]
    pub unsafe fn initWithContentsOfFile(&mut self, path: *const ::std::os::raw::c_char) -> bool {
        cocos2d_CCTexturePVR_initWithContentsOfFile(self, path)
    }
    #[inline]
    pub unsafe fn create(path: *const ::std::os::raw::c_char) -> *mut cocos2d_CCTexturePVR {
        cocos2d_CCTexturePVR_create(path)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cocos2d_CCTexturePVR_CCTexturePVR(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
}
extern "C" {
    #[link_name = "\u{1}??_DCCTexturePVR@cocos2d@@QEAAXXZ"]
    pub fn cocos2d_CCTexturePVR_CCTexturePVR_destructor(this: *mut cocos2d_CCTexturePVR);
}
#[doc = " @brief CCParallaxNode: A node that simulates a parallax scroller"]
#[doc = ""]
#[doc = "The children will be moved faster / slower than the parent according the the parallax ratio."]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCParallaxNode {
    pub _base: cocos2d_CCNode,
    pub m_pParallaxArray: *mut cocos2d__ccArray,
    pub m_tLastPosition: cocos2d_CCPoint,
}
#[test]
fn bindgen_test_layout_cocos2d_CCParallaxNode() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCParallaxNode>(),
        312usize,
        concat!("Size of: ", stringify!(cocos2d_CCParallaxNode))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCParallaxNode>(),
        8usize,
        concat!("Alignment of ", stringify!(cocos2d_CCParallaxNode))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cocos2d_CCParallaxNode>())).m_pParallaxArray as *const _ as usize
        },
        296usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCParallaxNode),
            "::",
            stringify!(m_pParallaxArray)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cocos2d_CCParallaxNode>())).m_tLastPosition as *const _ as usize
        },
        304usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCParallaxNode),
            "::",
            stringify!(m_tLastPosition)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}?create@CCParallaxNode@cocos2d@@SAPEAV12@XZ"]
    pub fn cocos2d_CCParallaxNode_create() -> *mut cocos2d_CCParallaxNode;
}
extern "C" {
    #[doc = " Adds a child to the container with a z-order, a parallax ratio and a position offset"]
    #[doc = "It returns self, so you can chain several addChilds."]
    #[doc = "@since v0.8"]
    #[doc = "@js ctor"]
    #[link_name = "\u{1}??0CCParallaxNode@cocos2d@@QEAA@XZ"]
    pub fn cocos2d_CCParallaxNode_CCParallaxNode(this: *mut cocos2d_CCParallaxNode);
}
impl cocos2d_CCParallaxNode {
    #[inline]
    pub unsafe fn create() -> *mut cocos2d_CCParallaxNode {
        cocos2d_CCParallaxNode_create()
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cocos2d_CCParallaxNode_CCParallaxNode(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
}
extern "C" {
    #[doc = " @js NA"]
    #[doc = " @lua NA"]
    #[link_name = "\u{1}??_DCCParallaxNode@cocos2d@@QEAAXXZ"]
    pub fn cocos2d_CCParallaxNode_CCParallaxNode_destructor(this: *mut cocos2d_CCParallaxNode);
}
extern "C" {
    #[link_name = "\u{1}?addChild@CCParallaxNode@cocos2d@@UEAAXPEAVCCNode@2@IAEBVCCPoint@2@1@Z"]
    pub fn cocos2d_CCParallaxNode_addChild(
        this: *mut ::std::os::raw::c_void,
        child: *mut cocos2d_CCNode,
        z: ::std::os::raw::c_uint,
        parallaxRatio: *const cocos2d_CCPoint,
        positionOffset: *const cocos2d_CCPoint,
    );
}
extern "C" {
    #[link_name = "\u{1}?addChild@CCParallaxNode@cocos2d@@UEAAXPEAVCCNode@2@IH@Z"]
    pub fn cocos2d_CCParallaxNode_addChild1(
        this: *mut ::std::os::raw::c_void,
        child: *mut cocos2d_CCNode,
        zOrder: ::std::os::raw::c_uint,
        tag: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}?removeChild@CCParallaxNode@cocos2d@@UEAAXPEAVCCNode@2@_N@Z"]
    pub fn cocos2d_CCParallaxNode_removeChild(
        this: *mut ::std::os::raw::c_void,
        child: *mut cocos2d_CCNode,
        cleanup: bool,
    );
}
extern "C" {
    #[link_name = "\u{1}?removeAllChildrenWithCleanup@CCParallaxNode@cocos2d@@UEAAX_N@Z"]
    pub fn cocos2d_CCParallaxNode_removeAllChildrenWithCleanup(
        this: *mut ::std::os::raw::c_void,
        cleanup: bool,
    );
}
extern "C" {
    #[link_name = "\u{1}?visit@CCParallaxNode@cocos2d@@UEAAXXZ"]
    pub fn cocos2d_CCParallaxNode_visit(this: *mut ::std::os::raw::c_void);
}
#[doc = " @brief CCTMXObjectGroup represents the TMX object group."]
#[doc = "@since v0.99.0"]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCTMXObjectGroup {
    pub _base: cocos2d_CCObject,
    pub m_tPositionOffset: cocos2d_CCPoint,
    pub m_pProperties: *mut cocos2d_CCDictionary,
    pub m_pObjects: *mut cocos2d_CCArray,
    #[doc = " name of the group"]
    pub m_sGroupName: std_string,
}
#[test]
fn bindgen_test_layout_cocos2d_CCTMXObjectGroup() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCTMXObjectGroup>(),
        96usize,
        concat!("Size of: ", stringify!(cocos2d_CCTMXObjectGroup))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCTMXObjectGroup>(),
        8usize,
        concat!("Alignment of ", stringify!(cocos2d_CCTMXObjectGroup))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cocos2d_CCTMXObjectGroup>())).m_tPositionOffset as *const _
                as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCTMXObjectGroup),
            "::",
            stringify!(m_tPositionOffset)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cocos2d_CCTMXObjectGroup>())).m_pProperties as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCTMXObjectGroup),
            "::",
            stringify!(m_pProperties)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cocos2d_CCTMXObjectGroup>())).m_pObjects as *const _ as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCTMXObjectGroup),
            "::",
            stringify!(m_pObjects)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cocos2d_CCTMXObjectGroup>())).m_sGroupName as *const _ as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCTMXObjectGroup),
            "::",
            stringify!(m_sGroupName)
        )
    );
}
extern "C" {
    #[doc = " return the value for the specific property name"]
    #[link_name = "\u{1}?propertyNamed@CCTMXObjectGroup@cocos2d@@QEAAPEAVCCString@2@PEBD@Z"]
    pub fn cocos2d_CCTMXObjectGroup_propertyNamed(
        this: *mut cocos2d_CCTMXObjectGroup,
        propertyName: *const ::std::os::raw::c_char,
    ) -> *mut cocos2d_CCString;
}
extern "C" {
    #[doc = " return the dictionary for the specific object name."]
    #[doc = "It will return the 1st object found on the array for the given name."]
    #[link_name = "\u{1}?objectNamed@CCTMXObjectGroup@cocos2d@@QEAAPEAVCCDictionary@2@PEBD@Z"]
    pub fn cocos2d_CCTMXObjectGroup_objectNamed(
        this: *mut cocos2d_CCTMXObjectGroup,
        objectName: *const ::std::os::raw::c_char,
    ) -> *mut cocos2d_CCDictionary;
}
extern "C" {
    #[doc = " @js ctor"]
    #[link_name = "\u{1}??0CCTMXObjectGroup@cocos2d@@QEAA@XZ"]
    pub fn cocos2d_CCTMXObjectGroup_CCTMXObjectGroup(this: *mut cocos2d_CCTMXObjectGroup);
}
impl cocos2d_CCTMXObjectGroup {
    #[inline]
    pub unsafe fn propertyNamed(
        &mut self,
        propertyName: *const ::std::os::raw::c_char,
    ) -> *mut cocos2d_CCString {
        cocos2d_CCTMXObjectGroup_propertyNamed(self, propertyName)
    }
    #[inline]
    pub unsafe fn objectNamed(
        &mut self,
        objectName: *const ::std::os::raw::c_char,
    ) -> *mut cocos2d_CCDictionary {
        cocos2d_CCTMXObjectGroup_objectNamed(self, objectName)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cocos2d_CCTMXObjectGroup_CCTMXObjectGroup(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
}
extern "C" {
    #[link_name = "\u{1}?getProperties@CCTMXObjectGroup@cocos2d@@UEAAPEAVCCDictionary@2@XZ"]
    pub fn cocos2d_CCTMXObjectGroup_getProperties(
        this: *mut ::std::os::raw::c_void,
    ) -> *mut cocos2d_CCDictionary;
}
extern "C" {
    #[link_name = "\u{1}?setProperties@CCTMXObjectGroup@cocos2d@@UEAAXPEAVCCDictionary@2@@Z"]
    pub fn cocos2d_CCTMXObjectGroup_setProperties(
        this: *mut ::std::os::raw::c_void,
        var: *mut cocos2d_CCDictionary,
    );
}
extern "C" {
    #[link_name = "\u{1}?getObjects@CCTMXObjectGroup@cocos2d@@UEAAPEAVCCArray@2@XZ"]
    pub fn cocos2d_CCTMXObjectGroup_getObjects(
        this: *mut ::std::os::raw::c_void,
    ) -> *mut cocos2d_CCArray;
}
extern "C" {
    #[link_name = "\u{1}?setObjects@CCTMXObjectGroup@cocos2d@@UEAAXPEAVCCArray@2@@Z"]
    pub fn cocos2d_CCTMXObjectGroup_setObjects(
        this: *mut ::std::os::raw::c_void,
        var: *mut cocos2d_CCArray,
    );
}
extern "C" {
    #[doc = " @js NA"]
    #[doc = " @lua NA"]
    #[link_name = "\u{1}??_DCCTMXObjectGroup@cocos2d@@QEAAXXZ"]
    pub fn cocos2d_CCTMXObjectGroup_CCTMXObjectGroup_destructor(
        this: *mut cocos2d_CCTMXObjectGroup,
    );
}
pub const TMXLayerAttribNone: ::std::os::raw::c_int = 1;
pub const TMXLayerAttribBase64: ::std::os::raw::c_int = 2;
pub const TMXLayerAttribGzip: ::std::os::raw::c_int = 4;
pub const TMXLayerAttribZlib: ::std::os::raw::c_int = 8;
#[doc = " @addtogroup tilemap_parallax_nodes"]
#[doc = " @{"]
pub type cocos2d__bindgen_ty_13 = ::std::os::raw::c_int;
pub const TMXPropertyNone: ::std::os::raw::c_int = 0;
pub const TMXPropertyMap: ::std::os::raw::c_int = 1;
pub const TMXPropertyLayer: ::std::os::raw::c_int = 2;
pub const TMXPropertyObjectGroup: ::std::os::raw::c_int = 3;
pub const TMXPropertyObject: ::std::os::raw::c_int = 4;
pub const TMXPropertyTile: ::std::os::raw::c_int = 5;
pub type cocos2d__bindgen_ty_14 = ::std::os::raw::c_int;
pub const cocos2d_ccTMXTileFlags__kCCTMXTileHorizontalFlag: cocos2d_ccTMXTileFlags_ = -2147483648;
pub const cocos2d_ccTMXTileFlags__kCCTMXTileVerticalFlag: cocos2d_ccTMXTileFlags_ = 1073741824;
pub const cocos2d_ccTMXTileFlags__kCCTMXTileDiagonalFlag: cocos2d_ccTMXTileFlags_ = 536870912;
pub const cocos2d_ccTMXTileFlags__kCCFlipedAll: cocos2d_ccTMXTileFlags_ = -536870912;
pub const cocos2d_ccTMXTileFlags__kCCFlippedMask: cocos2d_ccTMXTileFlags_ = 536870911;
pub type cocos2d_ccTMXTileFlags_ = ::std::os::raw::c_int;
pub use self::cocos2d_ccTMXTileFlags_ as cocos2d_ccTMXTileFlags;
#[doc = " @brief CCTMXLayerInfo contains the information about the layers like:"]
#[doc = "- Layer name"]
#[doc = "- Layer size"]
#[doc = "- Layer opacity at creation time (it can be modified at runtime)"]
#[doc = "- Whether the layer is visible (if it's not visible, then the CocosNode won't be created)"]
#[doc = ""]
#[doc = "This information is obtained from the TMX file."]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCTMXLayerInfo {
    pub _base: cocos2d_CCObject,
    pub m_pProperties: *mut cocos2d_CCDictionary,
    pub m_sName: std_string,
    pub m_tLayerSize: cocos2d_CCSize,
    pub m_pTiles: *mut ::std::os::raw::c_uint,
    pub m_bVisible: bool,
    pub m_cOpacity: ::std::os::raw::c_uchar,
    pub m_bOwnTiles: bool,
    pub m_uMinGID: ::std::os::raw::c_uint,
    pub m_uMaxGID: ::std::os::raw::c_uint,
    pub m_tOffset: cocos2d_CCPoint,
}
#[test]
fn bindgen_test_layout_cocos2d_CCTMXLayerInfo() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCTMXLayerInfo>(),
        120usize,
        concat!("Size of: ", stringify!(cocos2d_CCTMXLayerInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCTMXLayerInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(cocos2d_CCTMXLayerInfo))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cocos2d_CCTMXLayerInfo>())).m_pProperties as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCTMXLayerInfo),
            "::",
            stringify!(m_pProperties)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cocos2d_CCTMXLayerInfo>())).m_sName as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCTMXLayerInfo),
            "::",
            stringify!(m_sName)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cocos2d_CCTMXLayerInfo>())).m_tLayerSize as *const _ as usize
        },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCTMXLayerInfo),
            "::",
            stringify!(m_tLayerSize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cocos2d_CCTMXLayerInfo>())).m_pTiles as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCTMXLayerInfo),
            "::",
            stringify!(m_pTiles)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cocos2d_CCTMXLayerInfo>())).m_bVisible as *const _ as usize
        },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCTMXLayerInfo),
            "::",
            stringify!(m_bVisible)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cocos2d_CCTMXLayerInfo>())).m_cOpacity as *const _ as usize
        },
        97usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCTMXLayerInfo),
            "::",
            stringify!(m_cOpacity)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cocos2d_CCTMXLayerInfo>())).m_bOwnTiles as *const _ as usize
        },
        98usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCTMXLayerInfo),
            "::",
            stringify!(m_bOwnTiles)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cocos2d_CCTMXLayerInfo>())).m_uMinGID as *const _ as usize
        },
        100usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCTMXLayerInfo),
            "::",
            stringify!(m_uMinGID)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cocos2d_CCTMXLayerInfo>())).m_uMaxGID as *const _ as usize
        },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCTMXLayerInfo),
            "::",
            stringify!(m_uMaxGID)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cocos2d_CCTMXLayerInfo>())).m_tOffset as *const _ as usize
        },
        108usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCTMXLayerInfo),
            "::",
            stringify!(m_tOffset)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}??0CCTMXLayerInfo@cocos2d@@QEAA@XZ"]
    pub fn cocos2d_CCTMXLayerInfo_CCTMXLayerInfo(this: *mut cocos2d_CCTMXLayerInfo);
}
impl cocos2d_CCTMXLayerInfo {
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cocos2d_CCTMXLayerInfo_CCTMXLayerInfo(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
}
extern "C" {
    #[link_name = "\u{1}?getProperties@CCTMXLayerInfo@cocos2d@@UEAAPEAVCCDictionary@2@XZ"]
    pub fn cocos2d_CCTMXLayerInfo_getProperties(
        this: *mut ::std::os::raw::c_void,
    ) -> *mut cocos2d_CCDictionary;
}
extern "C" {
    #[link_name = "\u{1}?setProperties@CCTMXLayerInfo@cocos2d@@UEAAXPEAVCCDictionary@2@@Z"]
    pub fn cocos2d_CCTMXLayerInfo_setProperties(
        this: *mut ::std::os::raw::c_void,
        var: *mut cocos2d_CCDictionary,
    );
}
extern "C" {
    #[link_name = "\u{1}??_DCCTMXLayerInfo@cocos2d@@QEAAXXZ"]
    pub fn cocos2d_CCTMXLayerInfo_CCTMXLayerInfo_destructor(this: *mut cocos2d_CCTMXLayerInfo);
}
#[doc = " @brief CCTMXTilesetInfo contains the information about the tilesets like:"]
#[doc = "- Tileset name"]
#[doc = "- Tileset spacing"]
#[doc = "- Tileset margin"]
#[doc = "- size of the tiles"]
#[doc = "- Image used for the tiles"]
#[doc = "- Image size"]
#[doc = ""]
#[doc = "This information is obtained from the TMX file."]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCTMXTilesetInfo {
    pub _base: cocos2d_CCObject,
    pub m_sName: std_string,
    pub m_uFirstGid: ::std::os::raw::c_uint,
    pub m_tTileSize: cocos2d_CCSize,
    pub m_uSpacing: ::std::os::raw::c_uint,
    pub m_uMargin: ::std::os::raw::c_uint,
    #[doc = "! filename containing the tiles (should be spritesheet / texture atlas)"]
    pub m_sSourceImage: std_string,
    #[doc = "! size in pixels of the image"]
    pub m_tImageSize: cocos2d_CCSize,
}
#[test]
fn bindgen_test_layout_cocos2d_CCTMXTilesetInfo() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCTMXTilesetInfo>(),
        136usize,
        concat!("Size of: ", stringify!(cocos2d_CCTMXTilesetInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCTMXTilesetInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(cocos2d_CCTMXTilesetInfo))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cocos2d_CCTMXTilesetInfo>())).m_sName as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCTMXTilesetInfo),
            "::",
            stringify!(m_sName)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cocos2d_CCTMXTilesetInfo>())).m_uFirstGid as *const _ as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCTMXTilesetInfo),
            "::",
            stringify!(m_uFirstGid)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cocos2d_CCTMXTilesetInfo>())).m_tTileSize as *const _ as usize
        },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCTMXTilesetInfo),
            "::",
            stringify!(m_tTileSize)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cocos2d_CCTMXTilesetInfo>())).m_uSpacing as *const _ as usize
        },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCTMXTilesetInfo),
            "::",
            stringify!(m_uSpacing)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cocos2d_CCTMXTilesetInfo>())).m_uMargin as *const _ as usize
        },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCTMXTilesetInfo),
            "::",
            stringify!(m_uMargin)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cocos2d_CCTMXTilesetInfo>())).m_sSourceImage as *const _ as usize
        },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCTMXTilesetInfo),
            "::",
            stringify!(m_sSourceImage)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cocos2d_CCTMXTilesetInfo>())).m_tImageSize as *const _ as usize
        },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCTMXTilesetInfo),
            "::",
            stringify!(m_tImageSize)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}?rectForGID@CCTMXTilesetInfo@cocos2d@@QEAA?AVCCRect@2@I@Z"]
    pub fn cocos2d_CCTMXTilesetInfo_rectForGID(
        this: *mut cocos2d_CCTMXTilesetInfo,
        gid: ::std::os::raw::c_uint,
    ) -> cocos2d_CCRect;
}
extern "C" {
    #[link_name = "\u{1}??0CCTMXTilesetInfo@cocos2d@@QEAA@XZ"]
    pub fn cocos2d_CCTMXTilesetInfo_CCTMXTilesetInfo(this: *mut cocos2d_CCTMXTilesetInfo);
}
impl cocos2d_CCTMXTilesetInfo {
    #[inline]
    pub unsafe fn rectForGID(&mut self, gid: ::std::os::raw::c_uint) -> cocos2d_CCRect {
        cocos2d_CCTMXTilesetInfo_rectForGID(self, gid)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cocos2d_CCTMXTilesetInfo_CCTMXTilesetInfo(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
}
extern "C" {
    #[link_name = "\u{1}??_DCCTMXTilesetInfo@cocos2d@@QEAAXXZ"]
    pub fn cocos2d_CCTMXTilesetInfo_CCTMXTilesetInfo_destructor(
        this: *mut cocos2d_CCTMXTilesetInfo,
    );
}
#[doc = " @brief CCTMXMapInfo contains the information about the map like:"]
#[doc = "- Map orientation (hexagonal, isometric or orthogonal)"]
#[doc = "- Tile size"]
#[doc = "- Map size"]
#[doc = ""]
#[doc = "And it also contains:"]
#[doc = "- Layers (an array of TMXLayerInfo objects)"]
#[doc = "- Tilesets (an array of TMXTilesetInfo objects)"]
#[doc = "- ObjectGroups (an array of TMXObjectGroupInfo objects)"]
#[doc = ""]
#[doc = "This information is obtained from the TMX file."]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCTMXMapInfo {
    pub _base: cocos2d_CCObject,
    pub _base_1: cocos2d_CCSAXDelegator,
    pub m_nOrientation: ::std::os::raw::c_int,
    pub m_tMapSize: cocos2d_CCSize,
    pub m_tTileSize: cocos2d_CCSize,
    pub m_pLayers: *mut cocos2d_CCArray,
    pub m_pTilesets: *mut cocos2d_CCArray,
    pub m_pObjectGroups: *mut cocos2d_CCArray,
    pub m_nParentElement: ::std::os::raw::c_int,
    pub m_uParentGID: ::std::os::raw::c_uint,
    pub m_nLayerAttribs: ::std::os::raw::c_int,
    pub m_bStoringCharacters: bool,
    pub m_pProperties: *mut cocos2d_CCDictionary,
    #[doc = "! tmx filename"]
    pub m_sTMXFileName: std_string,
    pub m_sResources: std_string,
    #[doc = "! current string"]
    pub m_sCurrentString: std_string,
    #[doc = "! tile properties"]
    pub m_pTileProperties: *mut cocos2d_CCDictionary,
    pub m_uCurrentFirstGID: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_cocos2d_CCTMXMapInfo() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCTMXMapInfo>(),
        232usize,
        concat!("Size of: ", stringify!(cocos2d_CCTMXMapInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCTMXMapInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(cocos2d_CCTMXMapInfo))
    );
}
extern "C" {
    #[doc = " creates a TMX Format with a tmx file"]
    #[link_name = "\u{1}?formatWithTMXFile@CCTMXMapInfo@cocos2d@@SAPEAV12@PEBD@Z"]
    pub fn cocos2d_CCTMXMapInfo_formatWithTMXFile(
        tmxFile: *const ::std::os::raw::c_char,
    ) -> *mut cocos2d_CCTMXMapInfo;
}
extern "C" {
    #[doc = " creates a TMX Format with an XML string and a TMX resource path"]
    #[link_name = "\u{1}?formatWithXML@CCTMXMapInfo@cocos2d@@SAPEAV12@PEBD0@Z"]
    pub fn cocos2d_CCTMXMapInfo_formatWithXML(
        tmxString: *const ::std::os::raw::c_char,
        resourcePath: *const ::std::os::raw::c_char,
    ) -> *mut cocos2d_CCTMXMapInfo;
}
extern "C" {
    #[doc = " initializes a TMX format with a  tmx file"]
    #[doc = " @lua NA"]
    #[link_name = "\u{1}?initWithTMXFile@CCTMXMapInfo@cocos2d@@QEAA_NPEBD@Z"]
    pub fn cocos2d_CCTMXMapInfo_initWithTMXFile(
        this: *mut cocos2d_CCTMXMapInfo,
        tmxFile: *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    #[doc = " initializes a TMX format with an XML string and a TMX resource path"]
    #[doc = " @lua NA"]
    #[link_name = "\u{1}?initWithXML@CCTMXMapInfo@cocos2d@@QEAA_NPEBD0@Z"]
    pub fn cocos2d_CCTMXMapInfo_initWithXML(
        this: *mut cocos2d_CCTMXMapInfo,
        tmxString: *const ::std::os::raw::c_char,
        resourcePath: *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    #[doc = " initializes parsing of an XML file, either a tmx (Map) file or tsx (Tileset) file"]
    #[link_name = "\u{1}?parseXMLFile@CCTMXMapInfo@cocos2d@@QEAA_NPEBD@Z"]
    pub fn cocos2d_CCTMXMapInfo_parseXMLFile(
        this: *mut cocos2d_CCTMXMapInfo,
        xmlFilename: *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}?parseXMLString@CCTMXMapInfo@cocos2d@@QEAA_NPEBD@Z"]
    pub fn cocos2d_CCTMXMapInfo_parseXMLString(
        this: *mut cocos2d_CCTMXMapInfo,
        xmlString: *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}?getTileProperties@CCTMXMapInfo@cocos2d@@QEAAPEAVCCDictionary@2@XZ"]
    pub fn cocos2d_CCTMXMapInfo_getTileProperties(
        this: *mut cocos2d_CCTMXMapInfo,
    ) -> *mut cocos2d_CCDictionary;
}
extern "C" {
    #[link_name = "\u{1}?setTileProperties@CCTMXMapInfo@cocos2d@@QEAAXPEAVCCDictionary@2@@Z"]
    pub fn cocos2d_CCTMXMapInfo_setTileProperties(
        this: *mut cocos2d_CCTMXMapInfo,
        tileProperties: *mut cocos2d_CCDictionary,
    );
}
extern "C" {
    #[doc = " @js  ctor"]
    #[doc = " @lua NA"]
    #[link_name = "\u{1}??0CCTMXMapInfo@cocos2d@@QEAA@XZ"]
    pub fn cocos2d_CCTMXMapInfo_CCTMXMapInfo(this: *mut cocos2d_CCTMXMapInfo);
}
impl cocos2d_CCTMXMapInfo {
    #[inline]
    pub unsafe fn formatWithTMXFile(
        tmxFile: *const ::std::os::raw::c_char,
    ) -> *mut cocos2d_CCTMXMapInfo {
        cocos2d_CCTMXMapInfo_formatWithTMXFile(tmxFile)
    }
    #[inline]
    pub unsafe fn formatWithXML(
        tmxString: *const ::std::os::raw::c_char,
        resourcePath: *const ::std::os::raw::c_char,
    ) -> *mut cocos2d_CCTMXMapInfo {
        cocos2d_CCTMXMapInfo_formatWithXML(tmxString, resourcePath)
    }
    #[inline]
    pub unsafe fn initWithTMXFile(&mut self, tmxFile: *const ::std::os::raw::c_char) -> bool {
        cocos2d_CCTMXMapInfo_initWithTMXFile(self, tmxFile)
    }
    #[inline]
    pub unsafe fn initWithXML(
        &mut self,
        tmxString: *const ::std::os::raw::c_char,
        resourcePath: *const ::std::os::raw::c_char,
    ) -> bool {
        cocos2d_CCTMXMapInfo_initWithXML(self, tmxString, resourcePath)
    }
    #[inline]
    pub unsafe fn parseXMLFile(&mut self, xmlFilename: *const ::std::os::raw::c_char) -> bool {
        cocos2d_CCTMXMapInfo_parseXMLFile(self, xmlFilename)
    }
    #[inline]
    pub unsafe fn parseXMLString(&mut self, xmlString: *const ::std::os::raw::c_char) -> bool {
        cocos2d_CCTMXMapInfo_parseXMLString(self, xmlString)
    }
    #[inline]
    pub unsafe fn getTileProperties(&mut self) -> *mut cocos2d_CCDictionary {
        cocos2d_CCTMXMapInfo_getTileProperties(self)
    }
    #[inline]
    pub unsafe fn setTileProperties(&mut self, tileProperties: *mut cocos2d_CCDictionary) {
        cocos2d_CCTMXMapInfo_setTileProperties(self, tileProperties)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cocos2d_CCTMXMapInfo_CCTMXMapInfo(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
}
extern "C" {
    #[link_name = "\u{1}?getLayers@CCTMXMapInfo@cocos2d@@UEAAPEAVCCArray@2@XZ"]
    pub fn cocos2d_CCTMXMapInfo_getLayers(
        this: *mut ::std::os::raw::c_void,
    ) -> *mut cocos2d_CCArray;
}
extern "C" {
    #[link_name = "\u{1}?setLayers@CCTMXMapInfo@cocos2d@@UEAAXPEAVCCArray@2@@Z"]
    pub fn cocos2d_CCTMXMapInfo_setLayers(
        this: *mut ::std::os::raw::c_void,
        var: *mut cocos2d_CCArray,
    );
}
extern "C" {
    #[link_name = "\u{1}?getTilesets@CCTMXMapInfo@cocos2d@@UEAAPEAVCCArray@2@XZ"]
    pub fn cocos2d_CCTMXMapInfo_getTilesets(
        this: *mut ::std::os::raw::c_void,
    ) -> *mut cocos2d_CCArray;
}
extern "C" {
    #[link_name = "\u{1}?setTilesets@CCTMXMapInfo@cocos2d@@UEAAXPEAVCCArray@2@@Z"]
    pub fn cocos2d_CCTMXMapInfo_setTilesets(
        this: *mut ::std::os::raw::c_void,
        var: *mut cocos2d_CCArray,
    );
}
extern "C" {
    #[link_name = "\u{1}?getObjectGroups@CCTMXMapInfo@cocos2d@@UEAAPEAVCCArray@2@XZ"]
    pub fn cocos2d_CCTMXMapInfo_getObjectGroups(
        this: *mut ::std::os::raw::c_void,
    ) -> *mut cocos2d_CCArray;
}
extern "C" {
    #[link_name = "\u{1}?setObjectGroups@CCTMXMapInfo@cocos2d@@UEAAXPEAVCCArray@2@@Z"]
    pub fn cocos2d_CCTMXMapInfo_setObjectGroups(
        this: *mut ::std::os::raw::c_void,
        var: *mut cocos2d_CCArray,
    );
}
extern "C" {
    #[link_name = "\u{1}?getProperties@CCTMXMapInfo@cocos2d@@UEAAPEAVCCDictionary@2@XZ"]
    pub fn cocos2d_CCTMXMapInfo_getProperties(
        this: *mut ::std::os::raw::c_void,
    ) -> *mut cocos2d_CCDictionary;
}
extern "C" {
    #[link_name = "\u{1}?setProperties@CCTMXMapInfo@cocos2d@@UEAAXPEAVCCDictionary@2@@Z"]
    pub fn cocos2d_CCTMXMapInfo_setProperties(
        this: *mut ::std::os::raw::c_void,
        var: *mut cocos2d_CCDictionary,
    );
}
extern "C" {
    #[doc = " @js NA"]
    #[doc = " @lua NA"]
    #[link_name = "\u{1}??_DCCTMXMapInfo@cocos2d@@QEAAXXZ"]
    pub fn cocos2d_CCTMXMapInfo_CCTMXMapInfo_destructor(this: *mut cocos2d_CCTMXMapInfo);
}
extern "C" {
    #[doc = " implement pure virtual methods of CCSAXDelegator"]
    #[doc = "  @js NA"]
    #[link_name = "\u{1}?startElement@CCTMXMapInfo@cocos2d@@UEAAXPEAXPEBDPEAPEBD@Z"]
    pub fn cocos2d_CCTMXMapInfo_startElement(
        this: *mut ::std::os::raw::c_void,
        ctx: *mut ::std::os::raw::c_void,
        name: *const ::std::os::raw::c_char,
        atts: *mut *const ::std::os::raw::c_char,
    );
}
extern "C" {
    #[doc = "  @js NA"]
    #[link_name = "\u{1}?endElement@CCTMXMapInfo@cocos2d@@UEAAXPEAXPEBD@Z"]
    pub fn cocos2d_CCTMXMapInfo_endElement(
        this: *mut ::std::os::raw::c_void,
        ctx: *mut ::std::os::raw::c_void,
        name: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    #[doc = " @js NA"]
    #[link_name = "\u{1}?textHandler@CCTMXMapInfo@cocos2d@@UEAAXPEAXPEBDH@Z"]
    pub fn cocos2d_CCTMXMapInfo_textHandler(
        this: *mut ::std::os::raw::c_void,
        ctx: *mut ::std::os::raw::c_void,
        ch: *const ::std::os::raw::c_char,
        len: ::std::os::raw::c_int,
    );
}
#[doc = " @brief CCTMXLayer represents the TMX layer."]
#[doc = ""]
#[doc = "It is a subclass of CCSpriteBatchNode. By default the tiles are rendered using a CCTextureAtlas."]
#[doc = "If you modify a tile on runtime, then, that tile will become a CCSprite, otherwise no CCSprite objects are created."]
#[doc = "The benefits of using CCSprite objects as tiles are:"]
#[doc = "- tiles (CCSprite) can be rotated/scaled/moved with a nice API"]
#[doc = ""]
#[doc = "If the layer contains a property named \"cc_vertexz\" with an integer (in can be positive or negative),"]
#[doc = "then all the tiles belonging to the layer will use that value as their OpenGL vertex Z for depth."]
#[doc = ""]
#[doc = "On the other hand, if the \"cc_vertexz\" property has the \"automatic\" value, then the tiles will use an automatic vertex Z value."]
#[doc = "Also before drawing the tiles, GL_ALPHA_TEST will be enabled, and disabled after drawing them. The used alpha func will be:"]
#[doc = ""]
#[doc = "glAlphaFunc( GL_GREATER, value )"]
#[doc = ""]
#[doc = "\"value\" by default is 0, but you can change it from Tiled by adding the \"cc_alpha_func\" property to the layer."]
#[doc = "The value 0 should work for most cases, but if you have tiles that are semi-transparent, then you might want to use a different"]
#[doc = "value, like 0.5."]
#[doc = ""]
#[doc = "For further information, please see the programming guide:"]
#[doc = ""]
#[doc = "http://www.cocos2d-iphone.org/wiki/doku.php/prog_guide:tiled_maps"]
#[doc = ""]
#[doc = "@since v0.8.1"]
#[doc = "Tiles can have tile flags for additional properties. At the moment only flip horizontal and flip vertical are used. These bit flags are defined in CCTMXXMLParser.h."]
#[doc = ""]
#[doc = "@since 1.1"]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCTMXLayer {
    pub _base: cocos2d_CCSpriteBatchNode,
    pub m_tLayerSize: cocos2d_CCSize,
    pub m_tMapTileSize: cocos2d_CCSize,
    pub m_pTiles: *mut ::std::os::raw::c_uint,
    pub m_pTileSet: *mut cocos2d_CCTMXTilesetInfo,
    pub m_uLayerOrientation: ::std::os::raw::c_uint,
    pub m_pProperties: *mut cocos2d_CCDictionary,
    #[doc = "! name of the layer"]
    pub m_sLayerName: std_string,
    #[doc = "! TMX Layer supports opacity"]
    pub m_cOpacity: ::std::os::raw::c_uchar,
    pub m_uMinGID: ::std::os::raw::c_uint,
    pub m_uMaxGID: ::std::os::raw::c_uint,
    #[doc = "! Only used when vertexZ is used"]
    pub m_nVertexZvalue: ::std::os::raw::c_int,
    pub m_bUseAutomaticVertexZ: bool,
    #[doc = "! used for optimization"]
    pub m_pReusedTile: *mut cocos2d_CCSprite,
    pub m_pAtlasIndexArray: *mut cocos2d_ccCArray,
    pub m_fContentScaleFactor: f32,
}
#[test]
fn bindgen_test_layout_cocos2d_CCTMXLayer() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCTMXLayer>(),
        464usize,
        concat!("Size of: ", stringify!(cocos2d_CCTMXLayer))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCTMXLayer>(),
        8usize,
        concat!("Alignment of ", stringify!(cocos2d_CCTMXLayer))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cocos2d_CCTMXLayer>())).m_tLayerSize as *const _ as usize },
        336usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCTMXLayer),
            "::",
            stringify!(m_tLayerSize)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cocos2d_CCTMXLayer>())).m_tMapTileSize as *const _ as usize
        },
        344usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCTMXLayer),
            "::",
            stringify!(m_tMapTileSize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cocos2d_CCTMXLayer>())).m_pTiles as *const _ as usize },
        352usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCTMXLayer),
            "::",
            stringify!(m_pTiles)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cocos2d_CCTMXLayer>())).m_pTileSet as *const _ as usize },
        360usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCTMXLayer),
            "::",
            stringify!(m_pTileSet)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cocos2d_CCTMXLayer>())).m_uLayerOrientation as *const _ as usize
        },
        368usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCTMXLayer),
            "::",
            stringify!(m_uLayerOrientation)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cocos2d_CCTMXLayer>())).m_pProperties as *const _ as usize
        },
        376usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCTMXLayer),
            "::",
            stringify!(m_pProperties)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cocos2d_CCTMXLayer>())).m_sLayerName as *const _ as usize },
        384usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCTMXLayer),
            "::",
            stringify!(m_sLayerName)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cocos2d_CCTMXLayer>())).m_cOpacity as *const _ as usize },
        416usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCTMXLayer),
            "::",
            stringify!(m_cOpacity)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cocos2d_CCTMXLayer>())).m_uMinGID as *const _ as usize },
        420usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCTMXLayer),
            "::",
            stringify!(m_uMinGID)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cocos2d_CCTMXLayer>())).m_uMaxGID as *const _ as usize },
        424usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCTMXLayer),
            "::",
            stringify!(m_uMaxGID)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cocos2d_CCTMXLayer>())).m_nVertexZvalue as *const _ as usize
        },
        428usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCTMXLayer),
            "::",
            stringify!(m_nVertexZvalue)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cocos2d_CCTMXLayer>())).m_bUseAutomaticVertexZ as *const _
                as usize
        },
        432usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCTMXLayer),
            "::",
            stringify!(m_bUseAutomaticVertexZ)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cocos2d_CCTMXLayer>())).m_pReusedTile as *const _ as usize
        },
        440usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCTMXLayer),
            "::",
            stringify!(m_pReusedTile)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cocos2d_CCTMXLayer>())).m_pAtlasIndexArray as *const _ as usize
        },
        448usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCTMXLayer),
            "::",
            stringify!(m_pAtlasIndexArray)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cocos2d_CCTMXLayer>())).m_fContentScaleFactor as *const _
                as usize
        },
        456usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCTMXLayer),
            "::",
            stringify!(m_fContentScaleFactor)
        )
    );
}
extern "C" {
    #[doc = " creates a CCTMXLayer with an tileset info, a layer info and a map info"]
    #[link_name = "\u{1}?create@CCTMXLayer@cocos2d@@SAPEAV12@PEAVCCTMXTilesetInfo@2@PEAVCCTMXLayerInfo@2@PEAVCCTMXMapInfo@2@@Z"]
    pub fn cocos2d_CCTMXLayer_create(
        tilesetInfo: *mut cocos2d_CCTMXTilesetInfo,
        layerInfo: *mut cocos2d_CCTMXLayerInfo,
        mapInfo: *mut cocos2d_CCTMXMapInfo,
    ) -> *mut cocos2d_CCTMXLayer;
}
extern "C" {
    #[doc = " initializes a CCTMXLayer with a tileset info, a layer info and a map info"]
    #[doc = " @lua NA"]
    #[link_name = "\u{1}?initWithTilesetInfo@CCTMXLayer@cocos2d@@QEAA_NPEAVCCTMXTilesetInfo@2@PEAVCCTMXLayerInfo@2@PEAVCCTMXMapInfo@2@@Z"]
    pub fn cocos2d_CCTMXLayer_initWithTilesetInfo(
        this: *mut cocos2d_CCTMXLayer,
        tilesetInfo: *mut cocos2d_CCTMXTilesetInfo,
        layerInfo: *mut cocos2d_CCTMXLayerInfo,
        mapInfo: *mut cocos2d_CCTMXMapInfo,
    ) -> bool;
}
extern "C" {
    #[doc = " dealloc the map that contains the tile position from memory."]
    #[doc = "Unless you want to know at runtime the tiles positions, you can safely call this method."]
    #[doc = "If you are going to call layer->tileGIDAt() then, don't release the map"]
    #[link_name = "\u{1}?releaseMap@CCTMXLayer@cocos2d@@QEAAXXZ"]
    pub fn cocos2d_CCTMXLayer_releaseMap(this: *mut cocos2d_CCTMXLayer);
}
extern "C" {
    #[doc = " returns the tile (CCSprite) at a given a tile coordinate."]
    #[doc = "The returned CCSprite will be already added to the CCTMXLayer. Don't add it again."]
    #[doc = "The CCSprite can be treated like any other CCSprite: rotated, scaled, translated, opacity, color, etc."]
    #[doc = "You can remove either by calling:"]
    #[doc = "- layer->removeChild(sprite, cleanup);"]
    #[doc = "- or layer->removeTileAt(ccp(x,y));"]
    #[doc = "@js getTileGIDAt"]
    #[link_name = "\u{1}?tileAt@CCTMXLayer@cocos2d@@QEAAPEAVCCSprite@2@AEBVCCPoint@2@@Z"]
    pub fn cocos2d_CCTMXLayer_tileAt(
        this: *mut cocos2d_CCTMXLayer,
        tileCoordinate: *const cocos2d_CCPoint,
    ) -> *mut cocos2d_CCSprite;
}
extern "C" {
    #[doc = " returns the tile gid at a given tile coordinate."]
    #[doc = "if it returns 0, it means that the tile is empty."]
    #[doc = "This method requires the the tile map has not been previously released (eg. don't call layer->releaseMap())"]
    #[doc = "@js tileGIDAt"]
    #[link_name = "\u{1}?tileGIDAt@CCTMXLayer@cocos2d@@QEAAIAEBVCCPoint@2@@Z"]
    pub fn cocos2d_CCTMXLayer_tileGIDAt(
        this: *mut cocos2d_CCTMXLayer,
        tileCoordinate: *const cocos2d_CCPoint,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " returns the tile gid at a given tile coordinate. It also returns the tile flags."]
    #[doc = "This method requires the the tile map has not been previously released (eg. don't call [layer releaseMap])"]
    #[doc = "@js tileGIDAt"]
    #[doc = "@lua NA"]
    #[link_name = "\u{1}?tileGIDAt@CCTMXLayer@cocos2d@@QEAAIAEBVCCPoint@2@PEAW4ccTMXTileFlags_@2@@Z"]
    pub fn cocos2d_CCTMXLayer_tileGIDAt1(
        this: *mut cocos2d_CCTMXLayer,
        tileCoordinate: *const cocos2d_CCPoint,
        flags: *mut cocos2d_ccTMXTileFlags,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " sets the tile gid (gid = tile global id) at a given tile coordinate."]
    #[doc = "The Tile GID can be obtained by using the method \"tileGIDAt\" or by using the TMX editor -> Tileset Mgr +1."]
    #[doc = "If a tile is already placed at that position, then it will be removed."]
    #[link_name = "\u{1}?setTileGID@CCTMXLayer@cocos2d@@QEAAXIAEBVCCPoint@2@@Z"]
    pub fn cocos2d_CCTMXLayer_setTileGID(
        this: *mut cocos2d_CCTMXLayer,
        gid: ::std::os::raw::c_uint,
        tileCoordinate: *const cocos2d_CCPoint,
    );
}
extern "C" {
    #[doc = " sets the tile gid (gid = tile global id) at a given tile coordinate."]
    #[doc = "The Tile GID can be obtained by using the method \"tileGIDAt\" or by using the TMX editor -> Tileset Mgr +1."]
    #[doc = "If a tile is already placed at that position, then it will be removed."]
    #[doc = ""]
    #[doc = "Use withFlags if the tile flags need to be changed as well"]
    #[link_name = "\u{1}?setTileGID@CCTMXLayer@cocos2d@@QEAAXIAEBVCCPoint@2@W4ccTMXTileFlags_@2@@Z"]
    pub fn cocos2d_CCTMXLayer_setTileGID1(
        this: *mut cocos2d_CCTMXLayer,
        gid: ::std::os::raw::c_uint,
        tileCoordinate: *const cocos2d_CCPoint,
        flags: cocos2d_ccTMXTileFlags,
    );
}
extern "C" {
    #[doc = " removes a tile at given tile coordinate"]
    #[link_name = "\u{1}?removeTileAt@CCTMXLayer@cocos2d@@QEAAXAEBVCCPoint@2@@Z"]
    pub fn cocos2d_CCTMXLayer_removeTileAt(
        this: *mut cocos2d_CCTMXLayer,
        tileCoordinate: *const cocos2d_CCPoint,
    );
}
extern "C" {
    #[doc = " returns the position in points of a given tile coordinate"]
    #[doc = " @js getPositionAt"]
    #[link_name = "\u{1}?positionAt@CCTMXLayer@cocos2d@@QEAA?AVCCPoint@2@AEBV32@@Z"]
    pub fn cocos2d_CCTMXLayer_positionAt(
        this: *mut cocos2d_CCTMXLayer,
        tileCoordinate: *const cocos2d_CCPoint,
    ) -> cocos2d_CCPoint;
}
extern "C" {
    #[doc = " return the value for the specific property name"]
    #[doc = "  @js getProperty"]
    #[link_name = "\u{1}?propertyNamed@CCTMXLayer@cocos2d@@QEAAPEAVCCString@2@PEBD@Z"]
    pub fn cocos2d_CCTMXLayer_propertyNamed(
        this: *mut cocos2d_CCTMXLayer,
        propertyName: *const ::std::os::raw::c_char,
    ) -> *mut cocos2d_CCString;
}
extern "C" {
    #[doc = " Creates the tiles"]
    #[link_name = "\u{1}?setupTiles@CCTMXLayer@cocos2d@@QEAAXXZ"]
    pub fn cocos2d_CCTMXLayer_setupTiles(this: *mut cocos2d_CCTMXLayer);
}
extern "C" {
    #[doc = " @js ctor"]
    #[doc = " @lua NA"]
    #[link_name = "\u{1}??0CCTMXLayer@cocos2d@@QEAA@XZ"]
    pub fn cocos2d_CCTMXLayer_CCTMXLayer(this: *mut cocos2d_CCTMXLayer);
}
impl cocos2d_CCTMXLayer {
    #[inline]
    pub unsafe fn create(
        tilesetInfo: *mut cocos2d_CCTMXTilesetInfo,
        layerInfo: *mut cocos2d_CCTMXLayerInfo,
        mapInfo: *mut cocos2d_CCTMXMapInfo,
    ) -> *mut cocos2d_CCTMXLayer {
        cocos2d_CCTMXLayer_create(tilesetInfo, layerInfo, mapInfo)
    }
    #[inline]
    pub unsafe fn initWithTilesetInfo(
        &mut self,
        tilesetInfo: *mut cocos2d_CCTMXTilesetInfo,
        layerInfo: *mut cocos2d_CCTMXLayerInfo,
        mapInfo: *mut cocos2d_CCTMXMapInfo,
    ) -> bool {
        cocos2d_CCTMXLayer_initWithTilesetInfo(self, tilesetInfo, layerInfo, mapInfo)
    }
    #[inline]
    pub unsafe fn releaseMap(&mut self) {
        cocos2d_CCTMXLayer_releaseMap(self)
    }
    #[inline]
    pub unsafe fn tileAt(
        &mut self,
        tileCoordinate: *const cocos2d_CCPoint,
    ) -> *mut cocos2d_CCSprite {
        cocos2d_CCTMXLayer_tileAt(self, tileCoordinate)
    }
    #[inline]
    pub unsafe fn tileGIDAt(
        &mut self,
        tileCoordinate: *const cocos2d_CCPoint,
    ) -> ::std::os::raw::c_uint {
        cocos2d_CCTMXLayer_tileGIDAt(self, tileCoordinate)
    }
    #[inline]
    pub unsafe fn tileGIDAt1(
        &mut self,
        tileCoordinate: *const cocos2d_CCPoint,
        flags: *mut cocos2d_ccTMXTileFlags,
    ) -> ::std::os::raw::c_uint {
        cocos2d_CCTMXLayer_tileGIDAt1(self, tileCoordinate, flags)
    }
    #[inline]
    pub unsafe fn setTileGID(
        &mut self,
        gid: ::std::os::raw::c_uint,
        tileCoordinate: *const cocos2d_CCPoint,
    ) {
        cocos2d_CCTMXLayer_setTileGID(self, gid, tileCoordinate)
    }
    #[inline]
    pub unsafe fn setTileGID1(
        &mut self,
        gid: ::std::os::raw::c_uint,
        tileCoordinate: *const cocos2d_CCPoint,
        flags: cocos2d_ccTMXTileFlags,
    ) {
        cocos2d_CCTMXLayer_setTileGID1(self, gid, tileCoordinate, flags)
    }
    #[inline]
    pub unsafe fn removeTileAt(&mut self, tileCoordinate: *const cocos2d_CCPoint) {
        cocos2d_CCTMXLayer_removeTileAt(self, tileCoordinate)
    }
    #[inline]
    pub unsafe fn positionAt(&mut self, tileCoordinate: *const cocos2d_CCPoint) -> cocos2d_CCPoint {
        cocos2d_CCTMXLayer_positionAt(self, tileCoordinate)
    }
    #[inline]
    pub unsafe fn propertyNamed(
        &mut self,
        propertyName: *const ::std::os::raw::c_char,
    ) -> *mut cocos2d_CCString {
        cocos2d_CCTMXLayer_propertyNamed(self, propertyName)
    }
    #[inline]
    pub unsafe fn setupTiles(&mut self) {
        cocos2d_CCTMXLayer_setupTiles(self)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cocos2d_CCTMXLayer_CCTMXLayer(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
}
extern "C" {
    #[link_name = "\u{1}?getTileSet@CCTMXLayer@cocos2d@@UEAAPEAVCCTMXTilesetInfo@2@XZ"]
    pub fn cocos2d_CCTMXLayer_getTileSet(
        this: *mut ::std::os::raw::c_void,
    ) -> *mut cocos2d_CCTMXTilesetInfo;
}
extern "C" {
    #[link_name = "\u{1}?setTileSet@CCTMXLayer@cocos2d@@UEAAXPEAVCCTMXTilesetInfo@2@@Z"]
    pub fn cocos2d_CCTMXLayer_setTileSet(
        this: *mut ::std::os::raw::c_void,
        var: *mut cocos2d_CCTMXTilesetInfo,
    );
}
extern "C" {
    #[link_name = "\u{1}?getProperties@CCTMXLayer@cocos2d@@UEAAPEAVCCDictionary@2@XZ"]
    pub fn cocos2d_CCTMXLayer_getProperties(
        this: *mut ::std::os::raw::c_void,
    ) -> *mut cocos2d_CCDictionary;
}
extern "C" {
    #[link_name = "\u{1}?setProperties@CCTMXLayer@cocos2d@@UEAAXPEAVCCDictionary@2@@Z"]
    pub fn cocos2d_CCTMXLayer_setProperties(
        this: *mut ::std::os::raw::c_void,
        var: *mut cocos2d_CCDictionary,
    );
}
extern "C" {
    #[doc = " @js NA"]
    #[doc = " @lua NA"]
    #[link_name = "\u{1}??_DCCTMXLayer@cocos2d@@QEAAXXZ"]
    pub fn cocos2d_CCTMXLayer_CCTMXLayer_destructor(this: *mut cocos2d_CCTMXLayer);
}
extern "C" {
    #[doc = " CCTMXLayer doesn't support adding a CCSprite manually."]
    #[doc = "  @warning addchild(z, tag); is not supported on CCTMXLayer. Instead of setTileGID."]
    #[doc = "  @lua NA"]
    #[link_name = "\u{1}?addChild@CCTMXLayer@cocos2d@@UEAAXPEAVCCNode@2@HH@Z"]
    pub fn cocos2d_CCTMXLayer_addChild(
        this: *mut ::std::os::raw::c_void,
        child: *mut cocos2d_CCNode,
        zOrder: ::std::os::raw::c_int,
        tag: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " super method"]
    #[doc = "  @lua NA"]
    #[link_name = "\u{1}?removeChild@CCTMXLayer@cocos2d@@UEAAXPEAVCCNode@2@_N@Z"]
    pub fn cocos2d_CCTMXLayer_removeChild(
        this: *mut ::std::os::raw::c_void,
        child: *mut cocos2d_CCNode,
        cleanup: bool,
    );
}
#[doc = " Orthogonal orientation"]
pub const CCTMXOrientationOrtho: ::std::os::raw::c_int = 0;
#[doc = " Hexagonal orientation"]
pub const CCTMXOrientationHex: ::std::os::raw::c_int = 1;
#[doc = " Isometric orientation"]
pub const CCTMXOrientationIso: ::std::os::raw::c_int = 2;
#[doc = " Possible orientations of the TMX map"]
pub type cocos2d__bindgen_ty_15 = ::std::os::raw::c_int;
#[doc = " @brief CCTMXTiledMap knows how to parse and render a TMX map."]
#[doc = ""]
#[doc = "It adds support for the TMX tiled map format used by http://www.mapeditor.org"]
#[doc = "It supports isometric, hexagonal and orthogonal tiles."]
#[doc = "It also supports object groups, objects, and properties."]
#[doc = ""]
#[doc = "Features:"]
#[doc = "- Each tile will be treated as an CCSprite"]
#[doc = "- The sprites are created on demand. They will be created only when you call \"layer->tileAt(position)\""]
#[doc = "- Each tile can be rotated / moved / scaled / tinted / \"opaqued\", since each tile is a CCSprite"]
#[doc = "- Tiles can be added/removed in runtime"]
#[doc = "- The z-order of the tiles can be modified in runtime"]
#[doc = "- Each tile has an anchorPoint of (0,0)"]
#[doc = "- The anchorPoint of the TMXTileMap is (0,0)"]
#[doc = "- The TMX layers will be added as a child"]
#[doc = "- The TMX layers will be aliased by default"]
#[doc = "- The tileset image will be loaded using the CCTextureCache"]
#[doc = "- Each tile will have a unique tag"]
#[doc = "- Each tile will have a unique z value. top-left: z=1, bottom-right: z=max z"]
#[doc = "- Each object group will be treated as an CCMutableArray"]
#[doc = "- Object class which will contain all the properties in a dictionary"]
#[doc = "- Properties can be assigned to the Map, Layer, Object Group, and Object"]
#[doc = ""]
#[doc = "Limitations:"]
#[doc = "- It only supports one tileset per layer."]
#[doc = "- Embedded images are not supported"]
#[doc = "- It only supports the XML format (the JSON format is not supported)"]
#[doc = ""]
#[doc = "Technical description:"]
#[doc = "Each layer is created using an CCTMXLayer (subclass of CCSpriteBatchNode). If you have 5 layers, then 5 CCTMXLayer will be created,"]
#[doc = "unless the layer visibility is off. In that case, the layer won't be created at all."]
#[doc = "You can obtain the layers (CCTMXLayer objects) at runtime by:"]
#[doc = "- map->getChildByTag(tag_number);  // 0=1st layer, 1=2nd layer, 2=3rd layer, etc..."]
#[doc = "- map->layerNamed(name_of_the_layer);"]
#[doc = ""]
#[doc = "Each object group is created using a CCTMXObjectGroup which is a subclass of CCMutableArray."]
#[doc = "You can obtain the object groups at runtime by:"]
#[doc = "- map->objectGroupNamed(name_of_the_object_group);"]
#[doc = ""]
#[doc = "Each object is a CCTMXObject."]
#[doc = ""]
#[doc = "Each property is stored as a key-value pair in an CCMutableDictionary."]
#[doc = "You can obtain the properties at runtime by:"]
#[doc = ""]
#[doc = "map->propertyNamed(name_of_the_property);"]
#[doc = "layer->propertyNamed(name_of_the_property);"]
#[doc = "objectGroup->propertyNamed(name_of_the_property);"]
#[doc = "object->propertyNamed(name_of_the_property);"]
#[doc = ""]
#[doc = "@since v0.8.1"]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCTMXTiledMap {
    pub _base: cocos2d_CCNode,
    pub m_tMapSize: cocos2d_CCSize,
    pub m_tTileSize: cocos2d_CCSize,
    pub m_nMapOrientation: ::std::os::raw::c_int,
    pub m_pObjectGroups: *mut cocos2d_CCArray,
    pub m_pProperties: *mut cocos2d_CCDictionary,
    #[doc = "! tile properties"]
    pub m_pTileProperties: *mut cocos2d_CCDictionary,
}
#[test]
fn bindgen_test_layout_cocos2d_CCTMXTiledMap() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCTMXTiledMap>(),
        344usize,
        concat!("Size of: ", stringify!(cocos2d_CCTMXTiledMap))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCTMXTiledMap>(),
        8usize,
        concat!("Alignment of ", stringify!(cocos2d_CCTMXTiledMap))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cocos2d_CCTMXTiledMap>())).m_tMapSize as *const _ as usize
        },
        296usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCTMXTiledMap),
            "::",
            stringify!(m_tMapSize)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cocos2d_CCTMXTiledMap>())).m_tTileSize as *const _ as usize
        },
        304usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCTMXTiledMap),
            "::",
            stringify!(m_tTileSize)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cocos2d_CCTMXTiledMap>())).m_nMapOrientation as *const _ as usize
        },
        312usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCTMXTiledMap),
            "::",
            stringify!(m_nMapOrientation)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cocos2d_CCTMXTiledMap>())).m_pObjectGroups as *const _ as usize
        },
        320usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCTMXTiledMap),
            "::",
            stringify!(m_pObjectGroups)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cocos2d_CCTMXTiledMap>())).m_pProperties as *const _ as usize
        },
        328usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCTMXTiledMap),
            "::",
            stringify!(m_pProperties)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cocos2d_CCTMXTiledMap>())).m_pTileProperties as *const _ as usize
        },
        336usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCTMXTiledMap),
            "::",
            stringify!(m_pTileProperties)
        )
    );
}
extern "C" {
    #[doc = " creates a TMX Tiled Map with a TMX file."]
    #[link_name = "\u{1}?create@CCTMXTiledMap@cocos2d@@SAPEAV12@PEBD@Z"]
    pub fn cocos2d_CCTMXTiledMap_create(
        tmxFile: *const ::std::os::raw::c_char,
    ) -> *mut cocos2d_CCTMXTiledMap;
}
extern "C" {
    #[doc = " initializes a TMX Tiled Map with a TMX formatted XML string and a path to TMX resources"]
    #[link_name = "\u{1}?createWithXML@CCTMXTiledMap@cocos2d@@SAPEAV12@PEBD0@Z"]
    pub fn cocos2d_CCTMXTiledMap_createWithXML(
        tmxString: *const ::std::os::raw::c_char,
        resourcePath: *const ::std::os::raw::c_char,
    ) -> *mut cocos2d_CCTMXTiledMap;
}
extern "C" {
    #[doc = " initializes a TMX Tiled Map with a TMX file"]
    #[link_name = "\u{1}?initWithTMXFile@CCTMXTiledMap@cocos2d@@QEAA_NPEBD@Z"]
    pub fn cocos2d_CCTMXTiledMap_initWithTMXFile(
        this: *mut cocos2d_CCTMXTiledMap,
        tmxFile: *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    #[doc = " initializes a TMX Tiled Map with a TMX formatted XML string and a path to TMX resources"]
    #[link_name = "\u{1}?initWithXML@CCTMXTiledMap@cocos2d@@QEAA_NPEBD0@Z"]
    pub fn cocos2d_CCTMXTiledMap_initWithXML(
        this: *mut cocos2d_CCTMXTiledMap,
        tmxString: *const ::std::os::raw::c_char,
        resourcePath: *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    #[doc = " return the TMXLayer for the specific layer"]
    #[doc = "  @js getLayer"]
    #[link_name = "\u{1}?layerNamed@CCTMXTiledMap@cocos2d@@QEAAPEAVCCTMXLayer@2@PEBD@Z"]
    pub fn cocos2d_CCTMXTiledMap_layerNamed(
        this: *mut cocos2d_CCTMXTiledMap,
        layerName: *const ::std::os::raw::c_char,
    ) -> *mut cocos2d_CCTMXLayer;
}
extern "C" {
    #[doc = " return the TMXObjectGroup for the specific group"]
    #[doc = "  @js getObjectGroup"]
    #[link_name = "\u{1}?objectGroupNamed@CCTMXTiledMap@cocos2d@@QEAAPEAVCCTMXObjectGroup@2@PEBD@Z"]
    pub fn cocos2d_CCTMXTiledMap_objectGroupNamed(
        this: *mut cocos2d_CCTMXTiledMap,
        groupName: *const ::std::os::raw::c_char,
    ) -> *mut cocos2d_CCTMXObjectGroup;
}
extern "C" {
    #[doc = " return the value for the specific property name"]
    #[doc = "  @js getProperty"]
    #[link_name = "\u{1}?propertyNamed@CCTMXTiledMap@cocos2d@@QEAAPEAVCCString@2@PEBD@Z"]
    pub fn cocos2d_CCTMXTiledMap_propertyNamed(
        this: *mut cocos2d_CCTMXTiledMap,
        propertyName: *const ::std::os::raw::c_char,
    ) -> *mut cocos2d_CCString;
}
extern "C" {
    #[doc = " return properties dictionary for tile GID"]
    #[link_name = "\u{1}?propertiesForGID@CCTMXTiledMap@cocos2d@@QEAAPEAVCCDictionary@2@H@Z"]
    pub fn cocos2d_CCTMXTiledMap_propertiesForGID(
        this: *mut cocos2d_CCTMXTiledMap,
        GID: ::std::os::raw::c_int,
    ) -> *mut cocos2d_CCDictionary;
}
extern "C" {
    #[doc = " @js ctor"]
    #[link_name = "\u{1}??0CCTMXTiledMap@cocos2d@@QEAA@XZ"]
    pub fn cocos2d_CCTMXTiledMap_CCTMXTiledMap(this: *mut cocos2d_CCTMXTiledMap);
}
impl cocos2d_CCTMXTiledMap {
    #[inline]
    pub unsafe fn create(tmxFile: *const ::std::os::raw::c_char) -> *mut cocos2d_CCTMXTiledMap {
        cocos2d_CCTMXTiledMap_create(tmxFile)
    }
    #[inline]
    pub unsafe fn createWithXML(
        tmxString: *const ::std::os::raw::c_char,
        resourcePath: *const ::std::os::raw::c_char,
    ) -> *mut cocos2d_CCTMXTiledMap {
        cocos2d_CCTMXTiledMap_createWithXML(tmxString, resourcePath)
    }
    #[inline]
    pub unsafe fn initWithTMXFile(&mut self, tmxFile: *const ::std::os::raw::c_char) -> bool {
        cocos2d_CCTMXTiledMap_initWithTMXFile(self, tmxFile)
    }
    #[inline]
    pub unsafe fn initWithXML(
        &mut self,
        tmxString: *const ::std::os::raw::c_char,
        resourcePath: *const ::std::os::raw::c_char,
    ) -> bool {
        cocos2d_CCTMXTiledMap_initWithXML(self, tmxString, resourcePath)
    }
    #[inline]
    pub unsafe fn layerNamed(
        &mut self,
        layerName: *const ::std::os::raw::c_char,
    ) -> *mut cocos2d_CCTMXLayer {
        cocos2d_CCTMXTiledMap_layerNamed(self, layerName)
    }
    #[inline]
    pub unsafe fn objectGroupNamed(
        &mut self,
        groupName: *const ::std::os::raw::c_char,
    ) -> *mut cocos2d_CCTMXObjectGroup {
        cocos2d_CCTMXTiledMap_objectGroupNamed(self, groupName)
    }
    #[inline]
    pub unsafe fn propertyNamed(
        &mut self,
        propertyName: *const ::std::os::raw::c_char,
    ) -> *mut cocos2d_CCString {
        cocos2d_CCTMXTiledMap_propertyNamed(self, propertyName)
    }
    #[inline]
    pub unsafe fn propertiesForGID(
        &mut self,
        GID: ::std::os::raw::c_int,
    ) -> *mut cocos2d_CCDictionary {
        cocos2d_CCTMXTiledMap_propertiesForGID(self, GID)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cocos2d_CCTMXTiledMap_CCTMXTiledMap(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
}
extern "C" {
    #[link_name = "\u{1}?getObjectGroups@CCTMXTiledMap@cocos2d@@UEAAPEAVCCArray@2@XZ"]
    pub fn cocos2d_CCTMXTiledMap_getObjectGroups(
        this: *mut ::std::os::raw::c_void,
    ) -> *mut cocos2d_CCArray;
}
extern "C" {
    #[link_name = "\u{1}?setObjectGroups@CCTMXTiledMap@cocos2d@@UEAAXPEAVCCArray@2@@Z"]
    pub fn cocos2d_CCTMXTiledMap_setObjectGroups(
        this: *mut ::std::os::raw::c_void,
        var: *mut cocos2d_CCArray,
    );
}
extern "C" {
    #[link_name = "\u{1}?getProperties@CCTMXTiledMap@cocos2d@@UEAAPEAVCCDictionary@2@XZ"]
    pub fn cocos2d_CCTMXTiledMap_getProperties(
        this: *mut ::std::os::raw::c_void,
    ) -> *mut cocos2d_CCDictionary;
}
extern "C" {
    #[link_name = "\u{1}?setProperties@CCTMXTiledMap@cocos2d@@UEAAXPEAVCCDictionary@2@@Z"]
    pub fn cocos2d_CCTMXTiledMap_setProperties(
        this: *mut ::std::os::raw::c_void,
        var: *mut cocos2d_CCDictionary,
    );
}
extern "C" {
    #[doc = " @js NA"]
    #[doc = " @lua NA"]
    #[link_name = "\u{1}??_DCCTMXTiledMap@cocos2d@@QEAAXXZ"]
    pub fn cocos2d_CCTMXTiledMap_CCTMXTiledMap_destructor(this: *mut cocos2d_CCTMXTiledMap);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cocos2d_sImageTGA {
    _unused: [u8; 0],
}
#[doc = " @brief CCTileMapAtlas is a subclass of CCAtlasNode."]
#[doc = ""]
#[doc = "It knows how to render a map based of tiles."]
#[doc = "The tiles must be in a .PNG format while the map must be a .TGA file."]
#[doc = ""]
#[doc = "For more information regarding the format, please see this post:"]
#[doc = "http://www.cocos2d-iphone.org/archives/27"]
#[doc = ""]
#[doc = "All features from CCAtlasNode are valid in CCTileMapAtlas"]
#[doc = ""]
#[doc = "IMPORTANT:"]
#[doc = "This class is deprecated. It is maintained for compatibility reasons only."]
#[doc = "You SHOULD not use this class."]
#[doc = "Instead, use the newer TMX file format: CCTMXTiledMap"]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCTileMapAtlas {
    pub _base: cocos2d_CCAtlasNode,
    pub m_pTGAInfo: *mut cocos2d_sImageTGA,
    #[doc = "! x,y to atlas dictionary"]
    pub m_pPosToAtlasIndex: *mut cocos2d_CCDictionary,
    #[doc = "! numbers of tiles to render"]
    pub m_nItemsToRender: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_cocos2d_CCTileMapAtlas() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCTileMapAtlas>(),
        408usize,
        concat!("Size of: ", stringify!(cocos2d_CCTileMapAtlas))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCTileMapAtlas>(),
        8usize,
        concat!("Alignment of ", stringify!(cocos2d_CCTileMapAtlas))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cocos2d_CCTileMapAtlas>())).m_pTGAInfo as *const _ as usize
        },
        384usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCTileMapAtlas),
            "::",
            stringify!(m_pTGAInfo)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cocos2d_CCTileMapAtlas>())).m_pPosToAtlasIndex as *const _
                as usize
        },
        392usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCTileMapAtlas),
            "::",
            stringify!(m_pPosToAtlasIndex)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cocos2d_CCTileMapAtlas>())).m_nItemsToRender as *const _ as usize
        },
        400usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCTileMapAtlas),
            "::",
            stringify!(m_nItemsToRender)
        )
    );
}
extern "C" {
    #[doc = " creates a CCTileMap with a tile file (atlas) with a map file and the width and height of each tile in points."]
    #[doc = "The tile file will be loaded using the TextureMgr."]
    #[link_name = "\u{1}?create@CCTileMapAtlas@cocos2d@@SAPEAV12@PEBD0HH@Z"]
    pub fn cocos2d_CCTileMapAtlas_create(
        tile: *const ::std::os::raw::c_char,
        mapFile: *const ::std::os::raw::c_char,
        tileWidth: ::std::os::raw::c_int,
        tileHeight: ::std::os::raw::c_int,
    ) -> *mut cocos2d_CCTileMapAtlas;
}
extern "C" {
    #[doc = " initializes a CCTileMap with a tile file (atlas) with a map file and the width and height of each tile in points."]
    #[doc = "The file will be loaded using the TextureMgr."]
    #[link_name = "\u{1}?initWithTileFile@CCTileMapAtlas@cocos2d@@QEAA_NPEBD0HH@Z"]
    pub fn cocos2d_CCTileMapAtlas_initWithTileFile(
        this: *mut cocos2d_CCTileMapAtlas,
        tile: *const ::std::os::raw::c_char,
        mapFile: *const ::std::os::raw::c_char,
        tileWidth: ::std::os::raw::c_int,
        tileHeight: ::std::os::raw::c_int,
    ) -> bool;
}
extern "C" {
    #[doc = " returns a tile from position x,y."]
    #[doc = "For the moment only channel R is used"]
    #[doc = "@js getTileAt"]
    #[link_name = "\u{1}?tileAt@CCTileMapAtlas@cocos2d@@QEAA?AU_ccColor3B@2@AEBVCCPoint@2@@Z"]
    pub fn cocos2d_CCTileMapAtlas_tileAt(
        this: *mut cocos2d_CCTileMapAtlas,
        position: *const cocos2d_CCPoint,
    ) -> cocos2d_ccColor3B;
}
extern "C" {
    #[doc = " sets a tile at position x,y."]
    #[doc = "For the moment only channel R is used"]
    #[link_name = "\u{1}?setTile@CCTileMapAtlas@cocos2d@@QEAAXAEBU_ccColor3B@2@AEBVCCPoint@2@@Z"]
    pub fn cocos2d_CCTileMapAtlas_setTile(
        this: *mut cocos2d_CCTileMapAtlas,
        tile: *const cocos2d_ccColor3B,
        position: *const cocos2d_CCPoint,
    );
}
extern "C" {
    #[doc = " dealloc the map from memory"]
    #[link_name = "\u{1}?releaseMap@CCTileMapAtlas@cocos2d@@QEAAXXZ"]
    pub fn cocos2d_CCTileMapAtlas_releaseMap(this: *mut cocos2d_CCTileMapAtlas);
}
extern "C" {
    #[doc = " @js ctor"]
    #[link_name = "\u{1}??0CCTileMapAtlas@cocos2d@@QEAA@XZ"]
    pub fn cocos2d_CCTileMapAtlas_CCTileMapAtlas(this: *mut cocos2d_CCTileMapAtlas);
}
impl cocos2d_CCTileMapAtlas {
    #[inline]
    pub unsafe fn create(
        tile: *const ::std::os::raw::c_char,
        mapFile: *const ::std::os::raw::c_char,
        tileWidth: ::std::os::raw::c_int,
        tileHeight: ::std::os::raw::c_int,
    ) -> *mut cocos2d_CCTileMapAtlas {
        cocos2d_CCTileMapAtlas_create(tile, mapFile, tileWidth, tileHeight)
    }
    #[inline]
    pub unsafe fn initWithTileFile(
        &mut self,
        tile: *const ::std::os::raw::c_char,
        mapFile: *const ::std::os::raw::c_char,
        tileWidth: ::std::os::raw::c_int,
        tileHeight: ::std::os::raw::c_int,
    ) -> bool {
        cocos2d_CCTileMapAtlas_initWithTileFile(self, tile, mapFile, tileWidth, tileHeight)
    }
    #[inline]
    pub unsafe fn tileAt(&mut self, position: *const cocos2d_CCPoint) -> cocos2d_ccColor3B {
        cocos2d_CCTileMapAtlas_tileAt(self, position)
    }
    #[inline]
    pub unsafe fn setTile(
        &mut self,
        tile: *const cocos2d_ccColor3B,
        position: *const cocos2d_CCPoint,
    ) {
        cocos2d_CCTileMapAtlas_setTile(self, tile, position)
    }
    #[inline]
    pub unsafe fn releaseMap(&mut self) {
        cocos2d_CCTileMapAtlas_releaseMap(self)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cocos2d_CCTileMapAtlas_CCTileMapAtlas(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
}
extern "C" {
    #[link_name = "\u{1}?getTGAInfo@CCTileMapAtlas@cocos2d@@UEAAPEAUsImageTGA@2@XZ"]
    pub fn cocos2d_CCTileMapAtlas_getTGAInfo(
        this: *mut ::std::os::raw::c_void,
    ) -> *mut cocos2d_sImageTGA;
}
extern "C" {
    #[link_name = "\u{1}?setTGAInfo@CCTileMapAtlas@cocos2d@@UEAAXPEAUsImageTGA@2@@Z"]
    pub fn cocos2d_CCTileMapAtlas_setTGAInfo(
        this: *mut ::std::os::raw::c_void,
        var: *mut cocos2d_sImageTGA,
    );
}
extern "C" {
    #[doc = " @js NA"]
    #[doc = " @lua NA"]
    #[link_name = "\u{1}??_DCCTileMapAtlas@cocos2d@@QEAAXXZ"]
    pub fn cocos2d_CCTileMapAtlas_CCTileMapAtlas_destructor(this: *mut cocos2d_CCTileMapAtlas);
}
pub const cocos2d_ccTouchSelectorFlag_ccTouchSelectorBeganBit: cocos2d_ccTouchSelectorFlag = 1;
pub const cocos2d_ccTouchSelectorFlag_ccTouchSelectorMovedBit: cocos2d_ccTouchSelectorFlag = 2;
pub const cocos2d_ccTouchSelectorFlag_ccTouchSelectorEndedBit: cocos2d_ccTouchSelectorFlag = 4;
pub const cocos2d_ccTouchSelectorFlag_ccTouchSelectorCancelledBit: cocos2d_ccTouchSelectorFlag = 8;
pub const cocos2d_ccTouchSelectorFlag_ccTouchSelectorAllBits: cocos2d_ccTouchSelectorFlag = 15;
#[doc = " @addtogroup input"]
#[doc = " @{"]
pub type cocos2d_ccTouchSelectorFlag = ::std::os::raw::c_int;
pub const CCTOUCHBEGAN: ::std::os::raw::c_int = 0;
pub const CCTOUCHMOVED: ::std::os::raw::c_int = 1;
pub const CCTOUCHENDED: ::std::os::raw::c_int = 2;
pub const CCTOUCHCANCELLED: ::std::os::raw::c_int = 3;
pub const ccTouchMax: ::std::os::raw::c_int = 4;
pub type cocos2d__bindgen_ty_16 = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cocos2d_ccTouchHandlerHelperData {
    pub m_type: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_cocos2d_ccTouchHandlerHelperData() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d_ccTouchHandlerHelperData>(),
        4usize,
        concat!("Size of: ", stringify!(cocos2d_ccTouchHandlerHelperData))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_ccTouchHandlerHelperData>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(cocos2d_ccTouchHandlerHelperData)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cocos2d_ccTouchHandlerHelperData>())).m_type as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_ccTouchHandlerHelperData),
            "::",
            stringify!(m_type)
        )
    );
}
#[repr(C)]
pub struct cocos2d_EGLTouchDelegate__bindgen_vtable(::std::os::raw::c_void);
#[doc = " @js NA"]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_EGLTouchDelegate {
    pub vtable_: *const cocos2d_EGLTouchDelegate__bindgen_vtable,
}
#[test]
fn bindgen_test_layout_cocos2d_EGLTouchDelegate() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d_EGLTouchDelegate>(),
        8usize,
        concat!("Size of: ", stringify!(cocos2d_EGLTouchDelegate))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_EGLTouchDelegate>(),
        8usize,
        concat!("Alignment of ", stringify!(cocos2d_EGLTouchDelegate))
    );
}
#[doc = " @brief CCTouchDispatcher."]
#[doc = "Singleton that handles all the touch events."]
#[doc = "The dispatcher dispatches events to the registered TouchHandlers."]
#[doc = "There are 2 different type of touch handlers:"]
#[doc = "- Standard Touch Handlers"]
#[doc = "- Targeted Touch Handlers"]
#[doc = ""]
#[doc = "The Standard Touch Handlers work like the CocoaTouch touch handler: a set of touches is passed to the delegate."]
#[doc = "On the other hand, the Targeted Touch Handlers only receive 1 touch at the time, and they can \"swallow\" touches (avoid the propagation of the event)."]
#[doc = ""]
#[doc = "Firstly, the dispatcher sends the received touches to the targeted touches."]
#[doc = "These touches can be swallowed by the Targeted Touch Handlers. If there are still remaining touches, then the remaining touches will be sent"]
#[doc = "to the Standard Touch Handlers."]
#[doc = ""]
#[doc = "@since v0.8.0"]
#[doc = "@js NA"]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCTouchDispatcher {
    pub _base: cocos2d_CCObject,
    pub _base_1: cocos2d_EGLTouchDelegate,
    pub m_pTargetedHandlers: *mut cocos2d_CCArray,
    pub m_pStandardHandlers: *mut cocos2d_CCArray,
    pub m_bLocked: bool,
    pub m_bToAdd: bool,
    pub m_bToRemove: bool,
    pub m_pHandlersToAdd: *mut cocos2d_CCArray,
    pub m_pHandlersToRemove: *mut cocos2d__ccCArray,
    pub m_bToQuit: bool,
    pub m_bDispatchEvents: bool,
    pub m_sHandlerHelperData: [cocos2d_ccTouchHandlerHelperData; 4usize],
    pub m_bForcePrio: bool,
    pub m_nTargetPrio: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_cocos2d_CCTouchDispatcher() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCTouchDispatcher>(),
        120usize,
        concat!("Size of: ", stringify!(cocos2d_CCTouchDispatcher))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCTouchDispatcher>(),
        8usize,
        concat!("Alignment of ", stringify!(cocos2d_CCTouchDispatcher))
    );
}
extern "C" {
    #[doc = " @lua NA"]
    #[link_name = "\u{1}?init@CCTouchDispatcher@cocos2d@@QEAA_NXZ"]
    pub fn cocos2d_CCTouchDispatcher_init(this: *mut cocos2d_CCTouchDispatcher) -> bool;
}
extern "C" {
    #[doc = " Whether or not the events are going to be dispatched. Default: true"]
    #[link_name = "\u{1}?isDispatchEvents@CCTouchDispatcher@cocos2d@@QEAA_NXZ"]
    pub fn cocos2d_CCTouchDispatcher_isDispatchEvents(this: *mut cocos2d_CCTouchDispatcher)
        -> bool;
}
extern "C" {
    #[link_name = "\u{1}?setDispatchEvents@CCTouchDispatcher@cocos2d@@QEAAX_N@Z"]
    pub fn cocos2d_CCTouchDispatcher_setDispatchEvents(
        this: *mut cocos2d_CCTouchDispatcher,
        bDispatchEvents: bool,
    );
}
extern "C" {
    #[doc = " Adds a standard touch delegate to the dispatcher's list."]
    #[doc = " See StandardTouchDelegate description."]
    #[doc = " IMPORTANT: The delegate will be retained."]
    #[doc = " @lua NA"]
    #[link_name = "\u{1}?addStandardDelegate@CCTouchDispatcher@cocos2d@@QEAAXPEAVCCTouchDelegate@2@H@Z"]
    pub fn cocos2d_CCTouchDispatcher_addStandardDelegate(
        this: *mut cocos2d_CCTouchDispatcher,
        pDelegate: *mut cocos2d_CCTouchDelegate,
        nPriority: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " Adds a targeted touch delegate to the dispatcher's list."]
    #[doc = " See TargetedTouchDelegate description."]
    #[doc = " IMPORTANT: The delegate will be retained."]
    #[doc = " @lua NA"]
    #[link_name = "\u{1}?addTargetedDelegate@CCTouchDispatcher@cocos2d@@QEAAXPEAVCCTouchDelegate@2@H_N@Z"]
    pub fn cocos2d_CCTouchDispatcher_addTargetedDelegate(
        this: *mut cocos2d_CCTouchDispatcher,
        pDelegate: *mut cocos2d_CCTouchDelegate,
        nPriority: ::std::os::raw::c_int,
        bSwallowsTouches: bool,
    );
}
extern "C" {
    #[doc = " Removes a touch delegate."]
    #[doc = " The delegate will be released"]
    #[doc = " @lua NA"]
    #[link_name = "\u{1}?removeDelegate@CCTouchDispatcher@cocos2d@@QEAAXPEAVCCTouchDelegate@2@@Z"]
    pub fn cocos2d_CCTouchDispatcher_removeDelegate(
        this: *mut cocos2d_CCTouchDispatcher,
        pDelegate: *mut cocos2d_CCTouchDelegate,
    );
}
extern "C" {
    #[doc = " Removes all touch delegates, releasing all the delegates"]
    #[doc = " @lua NA"]
    #[link_name = "\u{1}?removeAllDelegates@CCTouchDispatcher@cocos2d@@QEAAXXZ"]
    pub fn cocos2d_CCTouchDispatcher_removeAllDelegates(this: *mut cocos2d_CCTouchDispatcher);
}
extern "C" {
    #[doc = " Changes the priority of a previously added delegate. The lower the number,"]
    #[doc = " the higher the priority"]
    #[doc = " @lua NA"]
    #[link_name = "\u{1}?setPriority@CCTouchDispatcher@cocos2d@@QEAAXHPEAVCCTouchDelegate@2@@Z"]
    pub fn cocos2d_CCTouchDispatcher_setPriority(
        this: *mut cocos2d_CCTouchDispatcher,
        nPriority: ::std::os::raw::c_int,
        pDelegate: *mut cocos2d_CCTouchDelegate,
    );
}
extern "C" {
    #[doc = " @lua NA"]
    #[link_name = "\u{1}?touches@CCTouchDispatcher@cocos2d@@QEAAXPEAVCCSet@2@PEAVCCEvent@2@I@Z"]
    pub fn cocos2d_CCTouchDispatcher_touches(
        this: *mut cocos2d_CCTouchDispatcher,
        pTouches: *mut cocos2d_CCSet,
        pEvent: *mut cocos2d_CCEvent,
        uIndex: ::std::os::raw::c_uint,
    );
}
extern "C" {
    #[doc = " @lua NA"]
    #[link_name = "\u{1}?findHandler@CCTouchDispatcher@cocos2d@@QEAAPEAVCCTouchHandler@2@PEAVCCTouchDelegate@2@@Z"]
    pub fn cocos2d_CCTouchDispatcher_findHandler(
        this: *mut cocos2d_CCTouchDispatcher,
        pDelegate: *mut cocos2d_CCTouchDelegate,
    ) -> *mut cocos2d_CCTouchHandler;
}
extern "C" {
    #[link_name = "\u{1}?incrementForcePrio@CCTouchDispatcher@cocos2d@@QEAAXH@Z"]
    pub fn cocos2d_CCTouchDispatcher_incrementForcePrio(
        this: *mut cocos2d_CCTouchDispatcher,
        priority: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}?forceRemoveDelegate@CCTouchDispatcher@cocos2d@@IEAAXPEAVCCTouchDelegate@2@@Z"]
    pub fn cocos2d_CCTouchDispatcher_forceRemoveDelegate(
        this: *mut cocos2d_CCTouchDispatcher,
        pDelegate: *mut cocos2d_CCTouchDelegate,
    );
}
extern "C" {
    #[link_name = "\u{1}?forceAddHandler@CCTouchDispatcher@cocos2d@@IEAAXPEAVCCTouchHandler@2@PEAVCCArray@2@@Z"]
    pub fn cocos2d_CCTouchDispatcher_forceAddHandler(
        this: *mut cocos2d_CCTouchDispatcher,
        pHandler: *mut cocos2d_CCTouchHandler,
        pArray: *mut cocos2d_CCArray,
    );
}
extern "C" {
    #[link_name = "\u{1}?forceRemoveAllDelegates@CCTouchDispatcher@cocos2d@@IEAAXXZ"]
    pub fn cocos2d_CCTouchDispatcher_forceRemoveAllDelegates(this: *mut cocos2d_CCTouchDispatcher);
}
extern "C" {
    #[link_name = "\u{1}?rearrangeHandlers@CCTouchDispatcher@cocos2d@@IEAAXPEAVCCArray@2@@Z"]
    pub fn cocos2d_CCTouchDispatcher_rearrangeHandlers(
        this: *mut cocos2d_CCTouchDispatcher,
        pArray: *mut cocos2d_CCArray,
    );
}
extern "C" {
    #[link_name = "\u{1}?findHandler@CCTouchDispatcher@cocos2d@@IEAAPEAVCCTouchHandler@2@PEAVCCArray@2@PEAVCCTouchDelegate@2@@Z"]
    pub fn cocos2d_CCTouchDispatcher_findHandler1(
        this: *mut cocos2d_CCTouchDispatcher,
        pArray: *mut cocos2d_CCArray,
        pDelegate: *mut cocos2d_CCTouchDelegate,
    ) -> *mut cocos2d_CCTouchHandler;
}
impl cocos2d_CCTouchDispatcher {
    #[inline]
    pub unsafe fn init(&mut self) -> bool {
        cocos2d_CCTouchDispatcher_init(self)
    }
    #[inline]
    pub unsafe fn isDispatchEvents(&mut self) -> bool {
        cocos2d_CCTouchDispatcher_isDispatchEvents(self)
    }
    #[inline]
    pub unsafe fn setDispatchEvents(&mut self, bDispatchEvents: bool) {
        cocos2d_CCTouchDispatcher_setDispatchEvents(self, bDispatchEvents)
    }
    #[inline]
    pub unsafe fn addStandardDelegate(
        &mut self,
        pDelegate: *mut cocos2d_CCTouchDelegate,
        nPriority: ::std::os::raw::c_int,
    ) {
        cocos2d_CCTouchDispatcher_addStandardDelegate(self, pDelegate, nPriority)
    }
    #[inline]
    pub unsafe fn addTargetedDelegate(
        &mut self,
        pDelegate: *mut cocos2d_CCTouchDelegate,
        nPriority: ::std::os::raw::c_int,
        bSwallowsTouches: bool,
    ) {
        cocos2d_CCTouchDispatcher_addTargetedDelegate(self, pDelegate, nPriority, bSwallowsTouches)
    }
    #[inline]
    pub unsafe fn removeDelegate(&mut self, pDelegate: *mut cocos2d_CCTouchDelegate) {
        cocos2d_CCTouchDispatcher_removeDelegate(self, pDelegate)
    }
    #[inline]
    pub unsafe fn removeAllDelegates(&mut self) {
        cocos2d_CCTouchDispatcher_removeAllDelegates(self)
    }
    #[inline]
    pub unsafe fn setPriority(
        &mut self,
        nPriority: ::std::os::raw::c_int,
        pDelegate: *mut cocos2d_CCTouchDelegate,
    ) {
        cocos2d_CCTouchDispatcher_setPriority(self, nPriority, pDelegate)
    }
    #[inline]
    pub unsafe fn touches(
        &mut self,
        pTouches: *mut cocos2d_CCSet,
        pEvent: *mut cocos2d_CCEvent,
        uIndex: ::std::os::raw::c_uint,
    ) {
        cocos2d_CCTouchDispatcher_touches(self, pTouches, pEvent, uIndex)
    }
    #[inline]
    pub unsafe fn findHandler(
        &mut self,
        pDelegate: *mut cocos2d_CCTouchDelegate,
    ) -> *mut cocos2d_CCTouchHandler {
        cocos2d_CCTouchDispatcher_findHandler(self, pDelegate)
    }
    #[inline]
    pub unsafe fn incrementForcePrio(&mut self, priority: ::std::os::raw::c_int) {
        cocos2d_CCTouchDispatcher_incrementForcePrio(self, priority)
    }
    #[inline]
    pub unsafe fn forceRemoveDelegate(&mut self, pDelegate: *mut cocos2d_CCTouchDelegate) {
        cocos2d_CCTouchDispatcher_forceRemoveDelegate(self, pDelegate)
    }
    #[inline]
    pub unsafe fn forceAddHandler(
        &mut self,
        pHandler: *mut cocos2d_CCTouchHandler,
        pArray: *mut cocos2d_CCArray,
    ) {
        cocos2d_CCTouchDispatcher_forceAddHandler(self, pHandler, pArray)
    }
    #[inline]
    pub unsafe fn forceRemoveAllDelegates(&mut self) {
        cocos2d_CCTouchDispatcher_forceRemoveAllDelegates(self)
    }
    #[inline]
    pub unsafe fn rearrangeHandlers(&mut self, pArray: *mut cocos2d_CCArray) {
        cocos2d_CCTouchDispatcher_rearrangeHandlers(self, pArray)
    }
    #[inline]
    pub unsafe fn findHandler1(
        &mut self,
        pArray: *mut cocos2d_CCArray,
        pDelegate: *mut cocos2d_CCTouchDelegate,
    ) -> *mut cocos2d_CCTouchHandler {
        cocos2d_CCTouchDispatcher_findHandler1(self, pArray, pDelegate)
    }
}
extern "C" {
    #[doc = " @lua NA"]
    #[link_name = "\u{1}??_DCCTouchDispatcher@cocos2d@@QEAAXXZ"]
    pub fn cocos2d_CCTouchDispatcher_CCTouchDispatcher_destructor(
        this: *mut cocos2d_CCTouchDispatcher,
    );
}
extern "C" {
    #[doc = " @lua NA"]
    #[link_name = "\u{1}?touchesBegan@CCTouchDispatcher@cocos2d@@UEAAXPEAVCCSet@2@PEAVCCEvent@2@@Z"]
    pub fn cocos2d_CCTouchDispatcher_touchesBegan(
        this: *mut ::std::os::raw::c_void,
        touches: *mut cocos2d_CCSet,
        pEvent: *mut cocos2d_CCEvent,
    );
}
extern "C" {
    #[doc = " @lua NA"]
    #[link_name = "\u{1}?touchesMoved@CCTouchDispatcher@cocos2d@@UEAAXPEAVCCSet@2@PEAVCCEvent@2@@Z"]
    pub fn cocos2d_CCTouchDispatcher_touchesMoved(
        this: *mut ::std::os::raw::c_void,
        touches: *mut cocos2d_CCSet,
        pEvent: *mut cocos2d_CCEvent,
    );
}
extern "C" {
    #[doc = " @lua NA"]
    #[link_name = "\u{1}?touchesEnded@CCTouchDispatcher@cocos2d@@UEAAXPEAVCCSet@2@PEAVCCEvent@2@@Z"]
    pub fn cocos2d_CCTouchDispatcher_touchesEnded(
        this: *mut ::std::os::raw::c_void,
        touches: *mut cocos2d_CCSet,
        pEvent: *mut cocos2d_CCEvent,
    );
}
extern "C" {
    #[doc = " @lua NA"]
    #[link_name = "\u{1}?touchesCancelled@CCTouchDispatcher@cocos2d@@UEAAXPEAVCCSet@2@PEAVCCEvent@2@@Z"]
    pub fn cocos2d_CCTouchDispatcher_touchesCancelled(
        this: *mut ::std::os::raw::c_void,
        touches: *mut cocos2d_CCSet,
        pEvent: *mut cocos2d_CCEvent,
    );
}
#[doc = "CCTouchHandler"]
#[doc = "Object than contains the delegate and priority of the event handler."]
#[doc = "@js NA"]
#[doc = "@lua NA"]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCTouchHandler {
    pub _base: cocos2d_CCObject,
    pub m_pDelegate: *mut cocos2d_CCTouchDelegate,
    pub m_nPriority: ::std::os::raw::c_int,
    pub m_nEnabledSelectors: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_cocos2d_CCTouchHandler() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCTouchHandler>(),
        56usize,
        concat!("Size of: ", stringify!(cocos2d_CCTouchHandler))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCTouchHandler>(),
        8usize,
        concat!("Alignment of ", stringify!(cocos2d_CCTouchHandler))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cocos2d_CCTouchHandler>())).m_pDelegate as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCTouchHandler),
            "::",
            stringify!(m_pDelegate)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cocos2d_CCTouchHandler>())).m_nPriority as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCTouchHandler),
            "::",
            stringify!(m_nPriority)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cocos2d_CCTouchHandler>())).m_nEnabledSelectors as *const _
                as usize
        },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCTouchHandler),
            "::",
            stringify!(m_nEnabledSelectors)
        )
    );
}
extern "C" {
    #[doc = " delegate"]
    #[link_name = "\u{1}?getDelegate@CCTouchHandler@cocos2d@@QEAAPEAVCCTouchDelegate@2@XZ"]
    pub fn cocos2d_CCTouchHandler_getDelegate(
        this: *mut cocos2d_CCTouchHandler,
    ) -> *mut cocos2d_CCTouchDelegate;
}
extern "C" {
    #[link_name = "\u{1}?setDelegate@CCTouchHandler@cocos2d@@QEAAXPEAVCCTouchDelegate@2@@Z"]
    pub fn cocos2d_CCTouchHandler_setDelegate(
        this: *mut cocos2d_CCTouchHandler,
        pDelegate: *mut cocos2d_CCTouchDelegate,
    );
}
extern "C" {
    #[doc = " priority"]
    #[link_name = "\u{1}?getPriority@CCTouchHandler@cocos2d@@QEAAHXZ"]
    pub fn cocos2d_CCTouchHandler_getPriority(
        this: *mut cocos2d_CCTouchHandler,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}?setPriority@CCTouchHandler@cocos2d@@QEAAXH@Z"]
    pub fn cocos2d_CCTouchHandler_setPriority(
        this: *mut cocos2d_CCTouchHandler,
        nPriority: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " enabled selectors"]
    #[link_name = "\u{1}?getEnabledSelectors@CCTouchHandler@cocos2d@@QEAAHXZ"]
    pub fn cocos2d_CCTouchHandler_getEnabledSelectors(
        this: *mut cocos2d_CCTouchHandler,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}?setEnalbedSelectors@CCTouchHandler@cocos2d@@QEAAXH@Z"]
    pub fn cocos2d_CCTouchHandler_setEnalbedSelectors(
        this: *mut cocos2d_CCTouchHandler,
        nValue: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " allocates a TouchHandler with a delegate and a priority"]
    #[link_name = "\u{1}?handlerWithDelegate@CCTouchHandler@cocos2d@@SAPEAV12@PEAVCCTouchDelegate@2@H@Z"]
    pub fn cocos2d_CCTouchHandler_handlerWithDelegate(
        pDelegate: *mut cocos2d_CCTouchDelegate,
        nPriority: ::std::os::raw::c_int,
    ) -> *mut cocos2d_CCTouchHandler;
}
impl cocos2d_CCTouchHandler {
    #[inline]
    pub unsafe fn getDelegate(&mut self) -> *mut cocos2d_CCTouchDelegate {
        cocos2d_CCTouchHandler_getDelegate(self)
    }
    #[inline]
    pub unsafe fn setDelegate(&mut self, pDelegate: *mut cocos2d_CCTouchDelegate) {
        cocos2d_CCTouchHandler_setDelegate(self, pDelegate)
    }
    #[inline]
    pub unsafe fn getPriority(&mut self) -> ::std::os::raw::c_int {
        cocos2d_CCTouchHandler_getPriority(self)
    }
    #[inline]
    pub unsafe fn setPriority(&mut self, nPriority: ::std::os::raw::c_int) {
        cocos2d_CCTouchHandler_setPriority(self, nPriority)
    }
    #[inline]
    pub unsafe fn getEnabledSelectors(&mut self) -> ::std::os::raw::c_int {
        cocos2d_CCTouchHandler_getEnabledSelectors(self)
    }
    #[inline]
    pub unsafe fn setEnalbedSelectors(&mut self, nValue: ::std::os::raw::c_int) {
        cocos2d_CCTouchHandler_setEnalbedSelectors(self, nValue)
    }
    #[inline]
    pub unsafe fn handlerWithDelegate(
        pDelegate: *mut cocos2d_CCTouchDelegate,
        nPriority: ::std::os::raw::c_int,
    ) -> *mut cocos2d_CCTouchHandler {
        cocos2d_CCTouchHandler_handlerWithDelegate(pDelegate, nPriority)
    }
}
extern "C" {
    #[link_name = "\u{1}??_DCCTouchHandler@cocos2d@@QEAAXXZ"]
    pub fn cocos2d_CCTouchHandler_CCTouchHandler_destructor(this: *mut cocos2d_CCTouchHandler);
}
extern "C" {
    #[doc = " initializes a TouchHandler with a delegate and a priority"]
    #[link_name = "\u{1}?initWithDelegate@CCTouchHandler@cocos2d@@UEAA_NPEAVCCTouchDelegate@2@H@Z"]
    pub fn cocos2d_CCTouchHandler_initWithDelegate(
        this: *mut ::std::os::raw::c_void,
        pDelegate: *mut cocos2d_CCTouchDelegate,
        nPriority: ::std::os::raw::c_int,
    ) -> bool;
}
#[doc = " CCStandardTouchHandler"]
#[doc = "It forwards each event to the delegate."]
#[doc = "@js NA"]
#[doc = "@lua NA"]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCStandardTouchHandler {
    pub _base: cocos2d_CCTouchHandler,
}
#[test]
fn bindgen_test_layout_cocos2d_CCStandardTouchHandler() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCStandardTouchHandler>(),
        56usize,
        concat!("Size of: ", stringify!(cocos2d_CCStandardTouchHandler))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCStandardTouchHandler>(),
        8usize,
        concat!("Alignment of ", stringify!(cocos2d_CCStandardTouchHandler))
    );
}
extern "C" {
    #[doc = " allocates a TouchHandler with a delegate and a priority"]
    #[link_name = "\u{1}?handlerWithDelegate@CCStandardTouchHandler@cocos2d@@SAPEAV12@PEAVCCTouchDelegate@2@H@Z"]
    pub fn cocos2d_CCStandardTouchHandler_handlerWithDelegate(
        pDelegate: *mut cocos2d_CCTouchDelegate,
        nPriority: ::std::os::raw::c_int,
    ) -> *mut cocos2d_CCStandardTouchHandler;
}
impl cocos2d_CCStandardTouchHandler {
    #[inline]
    pub unsafe fn handlerWithDelegate(
        pDelegate: *mut cocos2d_CCTouchDelegate,
        nPriority: ::std::os::raw::c_int,
    ) -> *mut cocos2d_CCStandardTouchHandler {
        cocos2d_CCStandardTouchHandler_handlerWithDelegate(pDelegate, nPriority)
    }
}
extern "C" {
    #[doc = " initializes a TouchHandler with a delegate and a priority"]
    #[link_name = "\u{1}?initWithDelegate@CCStandardTouchHandler@cocos2d@@UEAA_NPEAVCCTouchDelegate@2@H@Z"]
    pub fn cocos2d_CCStandardTouchHandler_initWithDelegate(
        this: *mut ::std::os::raw::c_void,
        pDelegate: *mut cocos2d_CCTouchDelegate,
        nPriority: ::std::os::raw::c_int,
    ) -> bool;
}
#[doc = "CCTargetedTouchHandler"]
#[doc = "Object than contains the claimed touches and if it swallows touches."]
#[doc = "Used internally by TouchDispatcher"]
#[doc = "@js NA"]
#[doc = "@lua NA"]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCTargetedTouchHandler {
    pub _base: cocos2d_CCTouchHandler,
    pub m_bSwallowsTouches: bool,
    pub m_pClaimedTouches: *mut cocos2d_CCSet,
}
#[test]
fn bindgen_test_layout_cocos2d_CCTargetedTouchHandler() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCTargetedTouchHandler>(),
        72usize,
        concat!("Size of: ", stringify!(cocos2d_CCTargetedTouchHandler))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCTargetedTouchHandler>(),
        8usize,
        concat!("Alignment of ", stringify!(cocos2d_CCTargetedTouchHandler))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cocos2d_CCTargetedTouchHandler>())).m_bSwallowsTouches
                as *const _ as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCTargetedTouchHandler),
            "::",
            stringify!(m_bSwallowsTouches)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cocos2d_CCTargetedTouchHandler>())).m_pClaimedTouches as *const _
                as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCTargetedTouchHandler),
            "::",
            stringify!(m_pClaimedTouches)
        )
    );
}
extern "C" {
    #[doc = " whether or not the touches are swallowed"]
    #[link_name = "\u{1}?isSwallowsTouches@CCTargetedTouchHandler@cocos2d@@QEAA_NXZ"]
    pub fn cocos2d_CCTargetedTouchHandler_isSwallowsTouches(
        this: *mut cocos2d_CCTargetedTouchHandler,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}?setSwallowsTouches@CCTargetedTouchHandler@cocos2d@@QEAAX_N@Z"]
    pub fn cocos2d_CCTargetedTouchHandler_setSwallowsTouches(
        this: *mut cocos2d_CCTargetedTouchHandler,
        bSwallowsTouches: bool,
    );
}
extern "C" {
    #[doc = " MutableSet that contains the claimed touches"]
    #[link_name = "\u{1}?getClaimedTouches@CCTargetedTouchHandler@cocos2d@@QEAAPEAVCCSet@2@XZ"]
    pub fn cocos2d_CCTargetedTouchHandler_getClaimedTouches(
        this: *mut cocos2d_CCTargetedTouchHandler,
    ) -> *mut cocos2d_CCSet;
}
extern "C" {
    #[doc = " initializes a TargetedTouchHandler with a delegate, a priority and whether or not it swallows touches or not"]
    #[link_name = "\u{1}?initWithDelegate@CCTargetedTouchHandler@cocos2d@@QEAA_NPEAVCCTouchDelegate@2@H_N@Z"]
    pub fn cocos2d_CCTargetedTouchHandler_initWithDelegate(
        this: *mut cocos2d_CCTargetedTouchHandler,
        pDelegate: *mut cocos2d_CCTouchDelegate,
        nPriority: ::std::os::raw::c_int,
        bSwallow: bool,
    ) -> bool;
}
extern "C" {
    #[doc = " allocates a TargetedTouchHandler with a delegate, a priority and whether or not it swallows touches or not"]
    #[link_name = "\u{1}?handlerWithDelegate@CCTargetedTouchHandler@cocos2d@@SAPEAV12@PEAVCCTouchDelegate@2@H_N@Z"]
    pub fn cocos2d_CCTargetedTouchHandler_handlerWithDelegate(
        pDelegate: *mut cocos2d_CCTouchDelegate,
        nPriority: ::std::os::raw::c_int,
        bSwallow: bool,
    ) -> *mut cocos2d_CCTargetedTouchHandler;
}
impl cocos2d_CCTargetedTouchHandler {
    #[inline]
    pub unsafe fn isSwallowsTouches(&mut self) -> bool {
        cocos2d_CCTargetedTouchHandler_isSwallowsTouches(self)
    }
    #[inline]
    pub unsafe fn setSwallowsTouches(&mut self, bSwallowsTouches: bool) {
        cocos2d_CCTargetedTouchHandler_setSwallowsTouches(self, bSwallowsTouches)
    }
    #[inline]
    pub unsafe fn getClaimedTouches(&mut self) -> *mut cocos2d_CCSet {
        cocos2d_CCTargetedTouchHandler_getClaimedTouches(self)
    }
    #[inline]
    pub unsafe fn initWithDelegate(
        &mut self,
        pDelegate: *mut cocos2d_CCTouchDelegate,
        nPriority: ::std::os::raw::c_int,
        bSwallow: bool,
    ) -> bool {
        cocos2d_CCTargetedTouchHandler_initWithDelegate(self, pDelegate, nPriority, bSwallow)
    }
    #[inline]
    pub unsafe fn handlerWithDelegate(
        pDelegate: *mut cocos2d_CCTouchDelegate,
        nPriority: ::std::os::raw::c_int,
        bSwallow: bool,
    ) -> *mut cocos2d_CCTargetedTouchHandler {
        cocos2d_CCTargetedTouchHandler_handlerWithDelegate(pDelegate, nPriority, bSwallow)
    }
}
extern "C" {
    #[link_name = "\u{1}??_DCCTargetedTouchHandler@cocos2d@@QEAAXXZ"]
    pub fn cocos2d_CCTargetedTouchHandler_CCTargetedTouchHandler_destructor(
        this: *mut cocos2d_CCTargetedTouchHandler,
    );
}
#[doc = " @brief Light-weight timer"]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCTimer {
    pub _base: cocos2d_CCObject,
    pub m_pTarget: *mut cocos2d_CCObject,
    pub m_fElapsed: f32,
    pub m_bRunForever: bool,
    pub m_bUseDelay: bool,
    pub m_uTimesExecuted: ::std::os::raw::c_uint,
    pub m_uRepeat: ::std::os::raw::c_uint,
    pub m_fDelay: f32,
    pub m_fInterval: f32,
    pub m_pfnSelector: cocos2d_SEL_SCHEDULE,
    pub m_nScriptHandler: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_cocos2d_CCTimer() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCTimer>(),
        88usize,
        concat!("Size of: ", stringify!(cocos2d_CCTimer))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCTimer>(),
        8usize,
        concat!("Alignment of ", stringify!(cocos2d_CCTimer))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cocos2d_CCTimer>())).m_pTarget as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCTimer),
            "::",
            stringify!(m_pTarget)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cocos2d_CCTimer>())).m_fElapsed as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCTimer),
            "::",
            stringify!(m_fElapsed)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cocos2d_CCTimer>())).m_bRunForever as *const _ as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCTimer),
            "::",
            stringify!(m_bRunForever)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cocos2d_CCTimer>())).m_bUseDelay as *const _ as usize },
        53usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCTimer),
            "::",
            stringify!(m_bUseDelay)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cocos2d_CCTimer>())).m_uTimesExecuted as *const _ as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCTimer),
            "::",
            stringify!(m_uTimesExecuted)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cocos2d_CCTimer>())).m_uRepeat as *const _ as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCTimer),
            "::",
            stringify!(m_uRepeat)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cocos2d_CCTimer>())).m_fDelay as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCTimer),
            "::",
            stringify!(m_fDelay)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cocos2d_CCTimer>())).m_fInterval as *const _ as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCTimer),
            "::",
            stringify!(m_fInterval)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cocos2d_CCTimer>())).m_pfnSelector as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCTimer),
            "::",
            stringify!(m_pfnSelector)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cocos2d_CCTimer>())).m_nScriptHandler as *const _ as usize
        },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCTimer),
            "::",
            stringify!(m_nScriptHandler)
        )
    );
}
extern "C" {
    #[doc = " get interval in seconds"]
    #[link_name = "\u{1}?getInterval@CCTimer@cocos2d@@QEBAMXZ"]
    pub fn cocos2d_CCTimer_getInterval(this: *const cocos2d_CCTimer) -> f32;
}
extern "C" {
    #[doc = " set interval in seconds"]
    #[link_name = "\u{1}?setInterval@CCTimer@cocos2d@@QEAAXM@Z"]
    pub fn cocos2d_CCTimer_setInterval(this: *mut cocos2d_CCTimer, fInterval: f32);
}
extern "C" {
    #[doc = "  @lua NA"]
    #[link_name = "\u{1}?getSelector@CCTimer@cocos2d@@QEBAP8CCObject@2@EAAXM@ZXZ"]
    pub fn cocos2d_CCTimer_getSelector(this: *const cocos2d_CCTimer) -> cocos2d_SEL_SCHEDULE;
}
extern "C" {
    #[doc = " Initializes a timer with a target and a selector."]
    #[doc = "  @lua NA"]
    #[link_name = "\u{1}?initWithTarget@CCTimer@cocos2d@@QEAA_NPEAVCCObject@2@P832@EAAXM@Z@Z"]
    pub fn cocos2d_CCTimer_initWithTarget(
        this: *mut cocos2d_CCTimer,
        pTarget: *mut cocos2d_CCObject,
        pfnSelector: cocos2d_SEL_SCHEDULE,
    ) -> bool;
}
extern "C" {
    #[doc = " Initializes a timer with a target, a selector and an interval in seconds, repeat in number of times to repeat, delay in seconds."]
    #[doc = "  @lua NA"]
    #[link_name = "\u{1}?initWithTarget@CCTimer@cocos2d@@QEAA_NPEAVCCObject@2@P832@EAAXM@ZMIM@Z"]
    pub fn cocos2d_CCTimer_initWithTarget1(
        this: *mut cocos2d_CCTimer,
        pTarget: *mut cocos2d_CCObject,
        pfnSelector: cocos2d_SEL_SCHEDULE,
        fSeconds: f32,
        nRepeat: ::std::os::raw::c_uint,
        fDelay: f32,
    ) -> bool;
}
extern "C" {
    #[doc = " Initializes a timer with a script callback function and an interval in seconds."]
    #[link_name = "\u{1}?initWithScriptHandler@CCTimer@cocos2d@@QEAA_NHM@Z"]
    pub fn cocos2d_CCTimer_initWithScriptHandler(
        this: *mut cocos2d_CCTimer,
        nHandler: ::std::os::raw::c_int,
        fSeconds: f32,
    ) -> bool;
}
extern "C" {
    #[doc = " Allocates a timer with a target and a selector."]
    #[doc = "  @lua NA"]
    #[link_name = "\u{1}?timerWithTarget@CCTimer@cocos2d@@SAPEAV12@PEAVCCObject@2@P832@EAAXM@Z@Z"]
    pub fn cocos2d_CCTimer_timerWithTarget(
        pTarget: *mut cocos2d_CCObject,
        pfnSelector: cocos2d_SEL_SCHEDULE,
    ) -> *mut cocos2d_CCTimer;
}
extern "C" {
    #[doc = " Allocates a timer with a target, a selector and an interval in seconds."]
    #[doc = "  @lua NA"]
    #[link_name = "\u{1}?timerWithTarget@CCTimer@cocos2d@@SAPEAV12@PEAVCCObject@2@P832@EAAXM@ZM@Z"]
    pub fn cocos2d_CCTimer_timerWithTarget1(
        pTarget: *mut cocos2d_CCObject,
        pfnSelector: cocos2d_SEL_SCHEDULE,
        fSeconds: f32,
    ) -> *mut cocos2d_CCTimer;
}
extern "C" {
    #[doc = " Allocates a timer with a script callback function and an interval in seconds."]
    #[link_name = "\u{1}?timerWithScriptHandler@CCTimer@cocos2d@@SAPEAV12@HM@Z"]
    pub fn cocos2d_CCTimer_timerWithScriptHandler(
        nHandler: ::std::os::raw::c_int,
        fSeconds: f32,
    ) -> *mut cocos2d_CCTimer;
}
extern "C" {
    #[doc = "  @js  ctor"]
    #[doc = "  @lua NA"]
    #[link_name = "\u{1}??0CCTimer@cocos2d@@QEAA@XZ"]
    pub fn cocos2d_CCTimer_CCTimer(this: *mut cocos2d_CCTimer);
}
impl cocos2d_CCTimer {
    #[inline]
    pub unsafe fn getInterval(&self) -> f32 {
        cocos2d_CCTimer_getInterval(self)
    }
    #[inline]
    pub unsafe fn setInterval(&mut self, fInterval: f32) {
        cocos2d_CCTimer_setInterval(self, fInterval)
    }
    #[inline]
    pub unsafe fn getSelector(&self) -> cocos2d_SEL_SCHEDULE {
        cocos2d_CCTimer_getSelector(self)
    }
    #[inline]
    pub unsafe fn initWithTarget(
        &mut self,
        pTarget: *mut cocos2d_CCObject,
        pfnSelector: cocos2d_SEL_SCHEDULE,
    ) -> bool {
        cocos2d_CCTimer_initWithTarget(self, pTarget, pfnSelector)
    }
    #[inline]
    pub unsafe fn initWithTarget1(
        &mut self,
        pTarget: *mut cocos2d_CCObject,
        pfnSelector: cocos2d_SEL_SCHEDULE,
        fSeconds: f32,
        nRepeat: ::std::os::raw::c_uint,
        fDelay: f32,
    ) -> bool {
        cocos2d_CCTimer_initWithTarget1(self, pTarget, pfnSelector, fSeconds, nRepeat, fDelay)
    }
    #[inline]
    pub unsafe fn initWithScriptHandler(
        &mut self,
        nHandler: ::std::os::raw::c_int,
        fSeconds: f32,
    ) -> bool {
        cocos2d_CCTimer_initWithScriptHandler(self, nHandler, fSeconds)
    }
    #[inline]
    pub unsafe fn timerWithTarget(
        pTarget: *mut cocos2d_CCObject,
        pfnSelector: cocos2d_SEL_SCHEDULE,
    ) -> *mut cocos2d_CCTimer {
        cocos2d_CCTimer_timerWithTarget(pTarget, pfnSelector)
    }
    #[inline]
    pub unsafe fn timerWithTarget1(
        pTarget: *mut cocos2d_CCObject,
        pfnSelector: cocos2d_SEL_SCHEDULE,
        fSeconds: f32,
    ) -> *mut cocos2d_CCTimer {
        cocos2d_CCTimer_timerWithTarget1(pTarget, pfnSelector, fSeconds)
    }
    #[inline]
    pub unsafe fn timerWithScriptHandler(
        nHandler: ::std::os::raw::c_int,
        fSeconds: f32,
    ) -> *mut cocos2d_CCTimer {
        cocos2d_CCTimer_timerWithScriptHandler(nHandler, fSeconds)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cocos2d_CCTimer_CCTimer(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
}
extern "C" {
    #[doc = " triggers the timer"]
    #[link_name = "\u{1}?update@CCTimer@cocos2d@@UEAAXM@Z"]
    pub fn cocos2d_CCTimer_update(this: *mut ::std::os::raw::c_void, dt: f32);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cocos2d__listEntry {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cocos2d__hashSelectorEntry {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cocos2d__hashUpdateEntry {
    _unused: [u8; 0],
}
#[doc = " @brief Scheduler is responsible for triggering the scheduled callbacks."]
#[doc = "You should not use NSTimer. Instead use this class."]
#[doc = ""]
#[doc = "There are 2 different types of callbacks (selectors):"]
#[doc = ""]
#[doc = "- update selector: the 'update' selector will be called every frame. You can customize the priority."]
#[doc = "- custom selector: A custom selector will be called every frame, or with a custom interval of time"]
#[doc = ""]
#[doc = "The 'custom selectors' should be avoided when possible. It is faster, and consumes less memory to use the 'update selector'."]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCScheduler {
    pub _base: cocos2d_CCObject,
    pub m_fTimeScale: f32,
    pub m_pUpdatesNegList: *mut cocos2d__listEntry,
    pub m_pUpdates0List: *mut cocos2d__listEntry,
    pub m_pUpdatesPosList: *mut cocos2d__listEntry,
    pub m_pHashForUpdates: *mut cocos2d__hashUpdateEntry,
    pub m_pHashForTimers: *mut cocos2d__hashSelectorEntry,
    pub m_pCurrentTarget: *mut cocos2d__hashSelectorEntry,
    pub m_bCurrentTargetSalvaged: bool,
    pub m_bUpdateHashLocked: bool,
    pub m_pScriptHandlerEntries: *mut cocos2d_CCArray,
}
#[test]
fn bindgen_test_layout_cocos2d_CCScheduler() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCScheduler>(),
        112usize,
        concat!("Size of: ", stringify!(cocos2d_CCScheduler))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCScheduler>(),
        8usize,
        concat!("Alignment of ", stringify!(cocos2d_CCScheduler))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cocos2d_CCScheduler>())).m_fTimeScale as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCScheduler),
            "::",
            stringify!(m_fTimeScale)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cocos2d_CCScheduler>())).m_pUpdatesNegList as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCScheduler),
            "::",
            stringify!(m_pUpdatesNegList)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cocos2d_CCScheduler>())).m_pUpdates0List as *const _ as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCScheduler),
            "::",
            stringify!(m_pUpdates0List)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cocos2d_CCScheduler>())).m_pUpdatesPosList as *const _ as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCScheduler),
            "::",
            stringify!(m_pUpdatesPosList)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cocos2d_CCScheduler>())).m_pHashForUpdates as *const _ as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCScheduler),
            "::",
            stringify!(m_pHashForUpdates)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cocos2d_CCScheduler>())).m_pHashForTimers as *const _ as usize
        },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCScheduler),
            "::",
            stringify!(m_pHashForTimers)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cocos2d_CCScheduler>())).m_pCurrentTarget as *const _ as usize
        },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCScheduler),
            "::",
            stringify!(m_pCurrentTarget)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cocos2d_CCScheduler>())).m_bCurrentTargetSalvaged as *const _
                as usize
        },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCScheduler),
            "::",
            stringify!(m_bCurrentTargetSalvaged)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cocos2d_CCScheduler>())).m_bUpdateHashLocked as *const _ as usize
        },
        97usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCScheduler),
            "::",
            stringify!(m_bUpdateHashLocked)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cocos2d_CCScheduler>())).m_pScriptHandlerEntries as *const _
                as usize
        },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCScheduler),
            "::",
            stringify!(m_pScriptHandlerEntries)
        )
    );
}
extern "C" {
    #[doc = " The scheduled method will be called every 'interval' seconds."]
    #[doc = "If paused is YES, then it won't be called until it is resumed."]
    #[doc = "If 'interval' is 0, it will be called every frame, but if so, it's recommended to use 'scheduleUpdateForTarget:' instead."]
    #[doc = "If the selector is already scheduled, then only the interval parameter will be updated without re-scheduling it again."]
    #[doc = "repeat let the action be repeated repeat + 1 times, use kCCRepeatForever to let the action run continuously"]
    #[doc = "delay is the amount of time the action will wait before it'll start"]
    #[doc = ""]
    #[doc = "@since v0.99.3, repeat and delay added in v1.1"]
    #[doc = "@js  NA"]
    #[doc = "@lua NA"]
    #[link_name = "\u{1}?scheduleSelector@CCScheduler@cocos2d@@QEAAXP8CCObject@2@EAAXM@ZPEAV32@MIM_N@Z"]
    pub fn cocos2d_CCScheduler_scheduleSelector(
        this: *mut cocos2d_CCScheduler,
        pfnSelector: cocos2d_SEL_SCHEDULE,
        pTarget: *mut cocos2d_CCObject,
        fInterval: f32,
        repeat: ::std::os::raw::c_uint,
        delay: f32,
        bPaused: bool,
    );
}
extern "C" {
    #[doc = " calls scheduleSelector with kCCRepeatForever and a 0 delay"]
    #[doc = "  @js NA"]
    #[doc = "  @lua NA"]
    #[link_name = "\u{1}?scheduleSelector@CCScheduler@cocos2d@@QEAAXP8CCObject@2@EAAXM@ZPEAV32@M_N@Z"]
    pub fn cocos2d_CCScheduler_scheduleSelector1(
        this: *mut cocos2d_CCScheduler,
        pfnSelector: cocos2d_SEL_SCHEDULE,
        pTarget: *mut cocos2d_CCObject,
        fInterval: f32,
        bPaused: bool,
    );
}
extern "C" {
    #[doc = " Schedules the 'update' selector for a given target with a given priority."]
    #[doc = "The 'update' selector will be called every frame."]
    #[doc = "The lower the priority, the earlier it is called."]
    #[doc = "@since v0.99.3"]
    #[doc = "@lua NA"]
    #[link_name = "\u{1}?scheduleUpdateForTarget@CCScheduler@cocos2d@@QEAAXPEAVCCObject@2@H_N@Z"]
    pub fn cocos2d_CCScheduler_scheduleUpdateForTarget(
        this: *mut cocos2d_CCScheduler,
        pTarget: *mut cocos2d_CCObject,
        nPriority: ::std::os::raw::c_int,
        bPaused: bool,
    );
}
extern "C" {
    #[doc = " Unschedule a selector for a given target."]
    #[doc = "If you want to unschedule the \"update\", use unscheudleUpdateForTarget."]
    #[doc = "@since v0.99.3"]
    #[doc = "@lua NA"]
    #[link_name = "\u{1}?unscheduleSelector@CCScheduler@cocos2d@@QEAAXP8CCObject@2@EAAXM@ZPEAV32@@Z"]
    pub fn cocos2d_CCScheduler_unscheduleSelector(
        this: *mut cocos2d_CCScheduler,
        pfnSelector: cocos2d_SEL_SCHEDULE,
        pTarget: *mut cocos2d_CCObject,
    );
}
extern "C" {
    #[doc = " Unschedules the update selector for a given target"]
    #[doc = "@since v0.99.3"]
    #[doc = "@lua NA"]
    #[link_name = "\u{1}?unscheduleUpdateForTarget@CCScheduler@cocos2d@@QEAAXPEBVCCObject@2@@Z"]
    pub fn cocos2d_CCScheduler_unscheduleUpdateForTarget(
        this: *mut cocos2d_CCScheduler,
        pTarget: *const cocos2d_CCObject,
    );
}
extern "C" {
    #[doc = " Unschedules all selectors for a given target."]
    #[doc = "This also includes the \"update\" selector."]
    #[doc = "@since v0.99.3"]
    #[doc = "@js  unscheduleCallbackForTarget"]
    #[doc = "@lua NA"]
    #[link_name = "\u{1}?unscheduleAllForTarget@CCScheduler@cocos2d@@QEAAXPEAVCCObject@2@@Z"]
    pub fn cocos2d_CCScheduler_unscheduleAllForTarget(
        this: *mut cocos2d_CCScheduler,
        pTarget: *mut cocos2d_CCObject,
    );
}
extern "C" {
    #[doc = " Unschedules all selectors from all targets."]
    #[doc = "You should NEVER call this method, unless you know what you are doing."]
    #[doc = ""]
    #[doc = "@since v0.99.3"]
    #[doc = "@js unscheduleAllCallbacks"]
    #[doc = "@lua NA"]
    #[link_name = "\u{1}?unscheduleAll@CCScheduler@cocos2d@@QEAAXXZ"]
    pub fn cocos2d_CCScheduler_unscheduleAll(this: *mut cocos2d_CCScheduler);
}
extern "C" {
    #[doc = " Unschedules all selectors from all targets with a minimum priority."]
    #[doc = "You should only call this with kCCPriorityNonSystemMin or higher."]
    #[doc = "@since v2.0.0"]
    #[doc = "@js unscheduleAllCallbacksWithMinPriority"]
    #[doc = "@lua NA"]
    #[link_name = "\u{1}?unscheduleAllWithMinPriority@CCScheduler@cocos2d@@QEAAXH@Z"]
    pub fn cocos2d_CCScheduler_unscheduleAllWithMinPriority(
        this: *mut cocos2d_CCScheduler,
        nMinPriority: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " The scheduled script callback will be called every 'interval' seconds."]
    #[doc = "If paused is YES, then it won't be called until it is resumed."]
    #[doc = "If 'interval' is 0, it will be called every frame."]
    #[doc = "return schedule script entry ID, used for unscheduleScriptFunc()."]
    #[doc = "@js NA"]
    #[link_name = "\u{1}?scheduleScriptFunc@CCScheduler@cocos2d@@QEAAIIM_N@Z"]
    pub fn cocos2d_CCScheduler_scheduleScriptFunc(
        this: *mut cocos2d_CCScheduler,
        nHandler: ::std::os::raw::c_uint,
        fInterval: f32,
        bPaused: bool,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " Unschedule a script entry."]
    #[doc = "  @js NA"]
    #[link_name = "\u{1}?unscheduleScriptEntry@CCScheduler@cocos2d@@QEAAXI@Z"]
    pub fn cocos2d_CCScheduler_unscheduleScriptEntry(
        this: *mut cocos2d_CCScheduler,
        uScheduleScriptEntryID: ::std::os::raw::c_uint,
    );
}
extern "C" {
    #[doc = " Pauses the target."]
    #[doc = "All scheduled selectors/update for a given target won't be 'ticked' until the target is resumed."]
    #[doc = "If the target is not present, nothing happens."]
    #[doc = "@since v0.99.3"]
    #[doc = "@lua NA"]
    #[link_name = "\u{1}?pauseTarget@CCScheduler@cocos2d@@QEAAXPEAVCCObject@2@@Z"]
    pub fn cocos2d_CCScheduler_pauseTarget(
        this: *mut cocos2d_CCScheduler,
        pTarget: *mut cocos2d_CCObject,
    );
}
extern "C" {
    #[doc = " Resumes the target."]
    #[doc = "The 'target' will be unpaused, so all schedule selectors/update will be 'ticked' again."]
    #[doc = "If the target is not present, nothing happens."]
    #[doc = "@since v0.99.3"]
    #[doc = "@lua NA"]
    #[link_name = "\u{1}?resumeTarget@CCScheduler@cocos2d@@QEAAXPEAVCCObject@2@@Z"]
    pub fn cocos2d_CCScheduler_resumeTarget(
        this: *mut cocos2d_CCScheduler,
        pTarget: *mut cocos2d_CCObject,
    );
}
extern "C" {
    #[doc = " Returns whether or not the target is paused"]
    #[doc = "@since v1.0.0"]
    #[doc = "@lua NA"]
    #[link_name = "\u{1}?isTargetPaused@CCScheduler@cocos2d@@QEAA_NPEAVCCObject@2@@Z"]
    pub fn cocos2d_CCScheduler_isTargetPaused(
        this: *mut cocos2d_CCScheduler,
        pTarget: *mut cocos2d_CCObject,
    ) -> bool;
}
extern "C" {
    #[doc = " Pause all selectors from all targets."]
    #[doc = "You should NEVER call this method, unless you know what you are doing."]
    #[doc = "@since v2.0.0"]
    #[doc = "@lua NA"]
    #[link_name = "\u{1}?pauseAllTargets@CCScheduler@cocos2d@@QEAAPEAVCCSet@2@XZ"]
    pub fn cocos2d_CCScheduler_pauseAllTargets(
        this: *mut cocos2d_CCScheduler,
    ) -> *mut cocos2d_CCSet;
}
extern "C" {
    #[doc = " Pause all selectors from all targets with a minimum priority."]
    #[doc = "You should only call this with kCCPriorityNonSystemMin or higher."]
    #[doc = "@since v2.0.0"]
    #[doc = "@lua NA"]
    #[link_name = "\u{1}?pauseAllTargetsWithMinPriority@CCScheduler@cocos2d@@QEAAPEAVCCSet@2@H@Z"]
    pub fn cocos2d_CCScheduler_pauseAllTargetsWithMinPriority(
        this: *mut cocos2d_CCScheduler,
        nMinPriority: ::std::os::raw::c_int,
    ) -> *mut cocos2d_CCSet;
}
extern "C" {
    #[doc = " Resume selectors on a set of targets."]
    #[doc = "This can be useful for undoing a call to pauseAllSelectors."]
    #[doc = "@since v2.0.0"]
    #[doc = "@lua NA"]
    #[link_name = "\u{1}?resumeTargets@CCScheduler@cocos2d@@QEAAXPEAVCCSet@2@@Z"]
    pub fn cocos2d_CCScheduler_resumeTargets(
        this: *mut cocos2d_CCScheduler,
        targetsToResume: *mut cocos2d_CCSet,
    );
}
extern "C" {
    #[link_name = "\u{1}??0CCScheduler@cocos2d@@QEAA@XZ"]
    pub fn cocos2d_CCScheduler_CCScheduler(this: *mut cocos2d_CCScheduler);
}
impl cocos2d_CCScheduler {
    #[inline]
    pub unsafe fn scheduleSelector(
        &mut self,
        pfnSelector: cocos2d_SEL_SCHEDULE,
        pTarget: *mut cocos2d_CCObject,
        fInterval: f32,
        repeat: ::std::os::raw::c_uint,
        delay: f32,
        bPaused: bool,
    ) {
        cocos2d_CCScheduler_scheduleSelector(
            self,
            pfnSelector,
            pTarget,
            fInterval,
            repeat,
            delay,
            bPaused,
        )
    }
    #[inline]
    pub unsafe fn scheduleSelector1(
        &mut self,
        pfnSelector: cocos2d_SEL_SCHEDULE,
        pTarget: *mut cocos2d_CCObject,
        fInterval: f32,
        bPaused: bool,
    ) {
        cocos2d_CCScheduler_scheduleSelector1(self, pfnSelector, pTarget, fInterval, bPaused)
    }
    #[inline]
    pub unsafe fn scheduleUpdateForTarget(
        &mut self,
        pTarget: *mut cocos2d_CCObject,
        nPriority: ::std::os::raw::c_int,
        bPaused: bool,
    ) {
        cocos2d_CCScheduler_scheduleUpdateForTarget(self, pTarget, nPriority, bPaused)
    }
    #[inline]
    pub unsafe fn unscheduleSelector(
        &mut self,
        pfnSelector: cocos2d_SEL_SCHEDULE,
        pTarget: *mut cocos2d_CCObject,
    ) {
        cocos2d_CCScheduler_unscheduleSelector(self, pfnSelector, pTarget)
    }
    #[inline]
    pub unsafe fn unscheduleUpdateForTarget(&mut self, pTarget: *const cocos2d_CCObject) {
        cocos2d_CCScheduler_unscheduleUpdateForTarget(self, pTarget)
    }
    #[inline]
    pub unsafe fn unscheduleAllForTarget(&mut self, pTarget: *mut cocos2d_CCObject) {
        cocos2d_CCScheduler_unscheduleAllForTarget(self, pTarget)
    }
    #[inline]
    pub unsafe fn unscheduleAll(&mut self) {
        cocos2d_CCScheduler_unscheduleAll(self)
    }
    #[inline]
    pub unsafe fn unscheduleAllWithMinPriority(&mut self, nMinPriority: ::std::os::raw::c_int) {
        cocos2d_CCScheduler_unscheduleAllWithMinPriority(self, nMinPriority)
    }
    #[inline]
    pub unsafe fn scheduleScriptFunc(
        &mut self,
        nHandler: ::std::os::raw::c_uint,
        fInterval: f32,
        bPaused: bool,
    ) -> ::std::os::raw::c_uint {
        cocos2d_CCScheduler_scheduleScriptFunc(self, nHandler, fInterval, bPaused)
    }
    #[inline]
    pub unsafe fn unscheduleScriptEntry(&mut self, uScheduleScriptEntryID: ::std::os::raw::c_uint) {
        cocos2d_CCScheduler_unscheduleScriptEntry(self, uScheduleScriptEntryID)
    }
    #[inline]
    pub unsafe fn pauseTarget(&mut self, pTarget: *mut cocos2d_CCObject) {
        cocos2d_CCScheduler_pauseTarget(self, pTarget)
    }
    #[inline]
    pub unsafe fn resumeTarget(&mut self, pTarget: *mut cocos2d_CCObject) {
        cocos2d_CCScheduler_resumeTarget(self, pTarget)
    }
    #[inline]
    pub unsafe fn isTargetPaused(&mut self, pTarget: *mut cocos2d_CCObject) -> bool {
        cocos2d_CCScheduler_isTargetPaused(self, pTarget)
    }
    #[inline]
    pub unsafe fn pauseAllTargets(&mut self) -> *mut cocos2d_CCSet {
        cocos2d_CCScheduler_pauseAllTargets(self)
    }
    #[inline]
    pub unsafe fn pauseAllTargetsWithMinPriority(
        &mut self,
        nMinPriority: ::std::os::raw::c_int,
    ) -> *mut cocos2d_CCSet {
        cocos2d_CCScheduler_pauseAllTargetsWithMinPriority(self, nMinPriority)
    }
    #[inline]
    pub unsafe fn resumeTargets(&mut self, targetsToResume: *mut cocos2d_CCSet) {
        cocos2d_CCScheduler_resumeTargets(self, targetsToResume)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cocos2d_CCScheduler_CCScheduler(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
}
extern "C" {
    #[doc = "  @js NA"]
    #[doc = "  @lua NA"]
    #[link_name = "\u{1}??_DCCScheduler@cocos2d@@QEAAXXZ"]
    pub fn cocos2d_CCScheduler_CCScheduler_destructor(this: *mut cocos2d_CCScheduler);
}
extern "C" {
    #[doc = " 'update' the scheduler."]
    #[doc = "  You should NEVER call this method, unless you know what you are doing."]
    #[doc = "  @js NA"]
    #[doc = "  @lua NA"]
    #[link_name = "\u{1}?update@CCScheduler@cocos2d@@UEAAXM@Z"]
    pub fn cocos2d_CCScheduler_update(this: *mut ::std::os::raw::c_void, dt: f32);
}
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCComponent {
    pub _base: cocos2d_CCObject,
    pub m_pOwner: *mut cocos2d_CCNode,
    pub m_strName: std_string,
    pub m_bEnabled: bool,
}
#[test]
fn bindgen_test_layout_cocos2d_CCComponent() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCComponent>(),
        88usize,
        concat!("Size of: ", stringify!(cocos2d_CCComponent))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCComponent>(),
        8usize,
        concat!("Alignment of ", stringify!(cocos2d_CCComponent))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cocos2d_CCComponent>())).m_pOwner as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCComponent),
            "::",
            stringify!(m_pOwner)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cocos2d_CCComponent>())).m_strName as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCComponent),
            "::",
            stringify!(m_strName)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cocos2d_CCComponent>())).m_bEnabled as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCComponent),
            "::",
            stringify!(m_bEnabled)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}?create@CCComponent@cocos2d@@SAPEAV12@XZ"]
    pub fn cocos2d_CCComponent_create() -> *mut cocos2d_CCComponent;
}
extern "C" {
    #[link_name = "\u{1}?getName@CCComponent@cocos2d@@QEBAPEBDXZ"]
    pub fn cocos2d_CCComponent_getName(
        this: *const cocos2d_CCComponent,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}?setName@CCComponent@cocos2d@@QEAAXPEBD@Z"]
    pub fn cocos2d_CCComponent_setName(
        this: *mut cocos2d_CCComponent,
        pName: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    #[link_name = "\u{1}?setOwner@CCComponent@cocos2d@@QEAAXPEAVCCNode@2@@Z"]
    pub fn cocos2d_CCComponent_setOwner(
        this: *mut cocos2d_CCComponent,
        pOwner: *mut cocos2d_CCNode,
    );
}
extern "C" {
    #[link_name = "\u{1}?getOwner@CCComponent@cocos2d@@QEBAPEAVCCNode@2@XZ"]
    pub fn cocos2d_CCComponent_getOwner(this: *const cocos2d_CCComponent) -> *mut cocos2d_CCNode;
}
extern "C" {
    #[link_name = "\u{1}??0CCComponent@cocos2d@@IEAA@XZ"]
    pub fn cocos2d_CCComponent_CCComponent(this: *mut cocos2d_CCComponent);
}
impl cocos2d_CCComponent {
    #[inline]
    pub unsafe fn create() -> *mut cocos2d_CCComponent {
        cocos2d_CCComponent_create()
    }
    #[inline]
    pub unsafe fn getName(&self) -> *const ::std::os::raw::c_char {
        cocos2d_CCComponent_getName(self)
    }
    #[inline]
    pub unsafe fn setName(&mut self, pName: *const ::std::os::raw::c_char) {
        cocos2d_CCComponent_setName(self, pName)
    }
    #[inline]
    pub unsafe fn setOwner(&mut self, pOwner: *mut cocos2d_CCNode) {
        cocos2d_CCComponent_setOwner(self, pOwner)
    }
    #[inline]
    pub unsafe fn getOwner(&self) -> *mut cocos2d_CCNode {
        cocos2d_CCComponent_getOwner(self)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cocos2d_CCComponent_CCComponent(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
}
extern "C" {
    #[doc = "  @js NA"]
    #[doc = "  @lua NA"]
    #[link_name = "\u{1}??_DCCComponent@cocos2d@@QEAAXXZ"]
    pub fn cocos2d_CCComponent_CCComponent_destructor(this: *mut cocos2d_CCComponent);
}
extern "C" {
    #[link_name = "\u{1}?init@CCComponent@cocos2d@@UEAA_NXZ"]
    pub fn cocos2d_CCComponent_init(this: *mut ::std::os::raw::c_void) -> bool;
}
extern "C" {
    #[doc = "  @js NA"]
    #[doc = "  @lua NA"]
    #[link_name = "\u{1}?onEnter@CCComponent@cocos2d@@UEAAXXZ"]
    pub fn cocos2d_CCComponent_onEnter(this: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[doc = "  @js NA"]
    #[doc = "  @lua NA"]
    #[link_name = "\u{1}?onExit@CCComponent@cocos2d@@UEAAXXZ"]
    pub fn cocos2d_CCComponent_onExit(this: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[link_name = "\u{1}?update@CCComponent@cocos2d@@UEAAXM@Z"]
    pub fn cocos2d_CCComponent_update(this: *mut ::std::os::raw::c_void, delta: f32);
}
extern "C" {
    #[link_name = "\u{1}?serialize@CCComponent@cocos2d@@UEAA_NPEAX@Z"]
    pub fn cocos2d_CCComponent_serialize(
        this: *mut ::std::os::raw::c_void,
        r: *mut ::std::os::raw::c_void,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}?isEnabled@CCComponent@cocos2d@@UEBA_NXZ"]
    pub fn cocos2d_CCComponent_isEnabled(this: *mut ::std::os::raw::c_void) -> bool;
}
extern "C" {
    #[link_name = "\u{1}?setEnabled@CCComponent@cocos2d@@UEAAX_N@Z"]
    pub fn cocos2d_CCComponent_setEnabled(this: *mut ::std::os::raw::c_void, b: bool);
}
#[repr(C)]
pub struct cocos2d_CCComponentContainer__bindgen_vtable(::std::os::raw::c_void);
#[doc = "  @js NA"]
#[doc = "  @lua NA"]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCComponentContainer {
    pub vtable_: *const cocos2d_CCComponentContainer__bindgen_vtable,
    #[doc = "< Dictionary of components"]
    pub m_pComponents: *mut cocos2d_CCDictionary,
    pub m_pOwner: *mut cocos2d_CCNode,
}
#[test]
fn bindgen_test_layout_cocos2d_CCComponentContainer() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCComponentContainer>(),
        24usize,
        concat!("Size of: ", stringify!(cocos2d_CCComponentContainer))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCComponentContainer>(),
        8usize,
        concat!("Alignment of ", stringify!(cocos2d_CCComponentContainer))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cocos2d_CCComponentContainer>())).m_pComponents as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCComponentContainer),
            "::",
            stringify!(m_pComponents)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cocos2d_CCComponentContainer>())).m_pOwner as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCComponentContainer),
            "::",
            stringify!(m_pOwner)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}?isEmpty@CCComponentContainer@cocos2d@@QEBA_NXZ"]
    pub fn cocos2d_CCComponentContainer_isEmpty(this: *const cocos2d_CCComponentContainer) -> bool;
}
extern "C" {
    #[link_name = "\u{1}??0CCComponentContainer@cocos2d@@IEAA@PEAVCCNode@1@@Z"]
    pub fn cocos2d_CCComponentContainer_CCComponentContainer(
        this: *mut cocos2d_CCComponentContainer,
        pNode: *mut cocos2d_CCNode,
    );
}
impl cocos2d_CCComponentContainer {
    #[inline]
    pub unsafe fn isEmpty(&self) -> bool {
        cocos2d_CCComponentContainer_isEmpty(self)
    }
    #[inline]
    pub unsafe fn new(pNode: *mut cocos2d_CCNode) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cocos2d_CCComponentContainer_CCComponentContainer(__bindgen_tmp.as_mut_ptr(), pNode);
        __bindgen_tmp.assume_init()
    }
}
extern "C" {
    #[link_name = "\u{1}??_DCCComponentContainer@cocos2d@@QEAAXXZ"]
    pub fn cocos2d_CCComponentContainer_CCComponentContainer_destructor(
        this: *mut cocos2d_CCComponentContainer,
    );
}
extern "C" {
    #[link_name = "\u{1}?get@CCComponentContainer@cocos2d@@UEBAPEAVCCComponent@2@PEBD@Z"]
    pub fn cocos2d_CCComponentContainer_get(
        this: *mut ::std::os::raw::c_void,
        pName: *const ::std::os::raw::c_char,
    ) -> *mut cocos2d_CCComponent;
}
extern "C" {
    #[link_name = "\u{1}?add@CCComponentContainer@cocos2d@@UEAA_NPEAVCCComponent@2@@Z"]
    pub fn cocos2d_CCComponentContainer_add(
        this: *mut ::std::os::raw::c_void,
        pCom: *mut cocos2d_CCComponent,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}?remove@CCComponentContainer@cocos2d@@UEAA_NPEBD@Z"]
    pub fn cocos2d_CCComponentContainer_remove(
        this: *mut ::std::os::raw::c_void,
        pName: *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}?remove@CCComponentContainer@cocos2d@@UEAA_NPEAVCCComponent@2@@Z"]
    pub fn cocos2d_CCComponentContainer_remove1(
        this: *mut ::std::os::raw::c_void,
        pCom: *mut cocos2d_CCComponent,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}?removeAll@CCComponentContainer@cocos2d@@UEAAXXZ"]
    pub fn cocos2d_CCComponentContainer_removeAll(this: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[link_name = "\u{1}?visit@CCComponentContainer@cocos2d@@UEAAXM@Z"]
    pub fn cocos2d_CCComponentContainer_visit(this: *mut ::std::os::raw::c_void, fDelta: f32);
}
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCKeyboardDispatcher {
    pub _base: cocos2d_CCObject,
    pub m_pDelegates: *mut cocos2d_CCArray,
}
#[test]
fn bindgen_test_layout_cocos2d_CCKeyboardDispatcher() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCKeyboardDispatcher>(),
        48usize,
        concat!("Size of: ", stringify!(cocos2d_CCKeyboardDispatcher))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCKeyboardDispatcher>(),
        8usize,
        concat!("Alignment of ", stringify!(cocos2d_CCKeyboardDispatcher))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cocos2d_CCKeyboardDispatcher>())).m_pDelegates as *const _
                as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCKeyboardDispatcher),
            "::",
            stringify!(m_pDelegates)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}?addDelegate@CCKeyboardDispatcher@cocos2d@@QEAAXPEAVCCKeyboardDelegate@2@@Z"]
    pub fn cocos2d_CCKeyboardDispatcher_addDelegate(
        this: *mut cocos2d_CCKeyboardDispatcher,
        pDelegate: *mut cocos2d_CCKeyboardDelegate,
    );
}
extern "C" {
    #[link_name = "\u{1}?removeDelegate@CCKeyboardDispatcher@cocos2d@@QEAAXPEAVCCKeyboardDelegate@2@@Z"]
    pub fn cocos2d_CCKeyboardDispatcher_removeDelegate(
        this: *mut cocos2d_CCKeyboardDispatcher,
        pDelegate: *mut cocos2d_CCKeyboardDelegate,
    );
}
extern "C" {
    #[link_name = "\u{1}?forceAddDelegate@CCKeyboardDispatcher@cocos2d@@QEAAXPEAVCCKeyboardDelegate@2@@Z"]
    pub fn cocos2d_CCKeyboardDispatcher_forceAddDelegate(
        this: *mut cocos2d_CCKeyboardDispatcher,
        pDelegate: *mut cocos2d_CCKeyboardDelegate,
    );
}
extern "C" {
    #[link_name = "\u{1}?forceRemoveDelegate@CCKeyboardDispatcher@cocos2d@@QEAAXPEAVCCKeyboardDelegate@2@@Z"]
    pub fn cocos2d_CCKeyboardDispatcher_forceRemoveDelegate(
        this: *mut cocos2d_CCKeyboardDispatcher,
        pDelegate: *mut cocos2d_CCKeyboardDelegate,
    );
}
extern "C" {
    #[link_name = "\u{1}?convertKeyCode@CCKeyboardDispatcher@cocos2d@@QEAA?AW4enumKeyCodes@2@W432@@Z"]
    pub fn cocos2d_CCKeyboardDispatcher_convertKeyCode(
        this: *mut cocos2d_CCKeyboardDispatcher,
        key: cocos2d_enumKeyCodes,
    ) -> cocos2d_enumKeyCodes;
}
extern "C" {
    #[link_name = "\u{1}?dispatchKeyboardMSG@CCKeyboardDispatcher@cocos2d@@QEAA_NW4enumKeyCodes@2@_N@Z"]
    pub fn cocos2d_CCKeyboardDispatcher_dispatchKeyboardMSG(
        this: *mut cocos2d_CCKeyboardDispatcher,
        key: cocos2d_enumKeyCodes,
        arg1: bool,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}?getAltKeyPressed@CCKeyboardDispatcher@cocos2d@@QEBA_NXZ"]
    pub fn cocos2d_CCKeyboardDispatcher_getAltKeyPressed(
        this: *const cocos2d_CCKeyboardDispatcher,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}?getCommandKeyPressed@CCKeyboardDispatcher@cocos2d@@QEBA_NXZ"]
    pub fn cocos2d_CCKeyboardDispatcher_getCommandKeyPressed(
        this: *const cocos2d_CCKeyboardDispatcher,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}?getControlKeyPressed@CCKeyboardDispatcher@cocos2d@@QEBA_NXZ"]
    pub fn cocos2d_CCKeyboardDispatcher_getControlKeyPressed(
        this: *const cocos2d_CCKeyboardDispatcher,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}?getShiftKeyPressed@CCKeyboardDispatcher@cocos2d@@QEBA_NXZ"]
    pub fn cocos2d_CCKeyboardDispatcher_getShiftKeyPressed(
        this: *const cocos2d_CCKeyboardDispatcher,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}?keyToString@CCKeyboardDispatcher@cocos2d@@QEAAPEBDW4enumKeyCodes@2@@Z"]
    pub fn cocos2d_CCKeyboardDispatcher_keyToString(
        this: *mut cocos2d_CCKeyboardDispatcher,
        key: cocos2d_enumKeyCodes,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}?updateModifierKeys@CCKeyboardDispatcher@cocos2d@@QEAAX_N000@Z"]
    pub fn cocos2d_CCKeyboardDispatcher_updateModifierKeys(
        this: *mut cocos2d_CCKeyboardDispatcher,
        arg1: bool,
        arg2: bool,
        arg3: bool,
        arg4: bool,
    );
}
extern "C" {
    #[link_name = "\u{1}??0CCKeyboardDispatcher@cocos2d@@QEAA@XZ"]
    pub fn cocos2d_CCKeyboardDispatcher_CCKeyboardDispatcher(
        this: *mut cocos2d_CCKeyboardDispatcher,
    );
}
extern "C" {
    #[link_name = "\u{1}??0CCKeyboardDispatcher@cocos2d@@QEAA@AEBV01@@Z"]
    pub fn cocos2d_CCKeyboardDispatcher_CCKeyboardDispatcher1(
        this: *mut cocos2d_CCKeyboardDispatcher,
        arg1: *const cocos2d_CCKeyboardDispatcher,
    );
}
impl cocos2d_CCKeyboardDispatcher {
    #[inline]
    pub unsafe fn addDelegate(&mut self, pDelegate: *mut cocos2d_CCKeyboardDelegate) {
        cocos2d_CCKeyboardDispatcher_addDelegate(self, pDelegate)
    }
    #[inline]
    pub unsafe fn removeDelegate(&mut self, pDelegate: *mut cocos2d_CCKeyboardDelegate) {
        cocos2d_CCKeyboardDispatcher_removeDelegate(self, pDelegate)
    }
    #[inline]
    pub unsafe fn forceAddDelegate(&mut self, pDelegate: *mut cocos2d_CCKeyboardDelegate) {
        cocos2d_CCKeyboardDispatcher_forceAddDelegate(self, pDelegate)
    }
    #[inline]
    pub unsafe fn forceRemoveDelegate(&mut self, pDelegate: *mut cocos2d_CCKeyboardDelegate) {
        cocos2d_CCKeyboardDispatcher_forceRemoveDelegate(self, pDelegate)
    }
    #[inline]
    pub unsafe fn convertKeyCode(&mut self, key: cocos2d_enumKeyCodes) -> cocos2d_enumKeyCodes {
        cocos2d_CCKeyboardDispatcher_convertKeyCode(self, key)
    }
    #[inline]
    pub unsafe fn dispatchKeyboardMSG(&mut self, key: cocos2d_enumKeyCodes, arg1: bool) -> bool {
        cocos2d_CCKeyboardDispatcher_dispatchKeyboardMSG(self, key, arg1)
    }
    #[inline]
    pub unsafe fn getAltKeyPressed(&self) -> bool {
        cocos2d_CCKeyboardDispatcher_getAltKeyPressed(self)
    }
    #[inline]
    pub unsafe fn getCommandKeyPressed(&self) -> bool {
        cocos2d_CCKeyboardDispatcher_getCommandKeyPressed(self)
    }
    #[inline]
    pub unsafe fn getControlKeyPressed(&self) -> bool {
        cocos2d_CCKeyboardDispatcher_getControlKeyPressed(self)
    }
    #[inline]
    pub unsafe fn getShiftKeyPressed(&self) -> bool {
        cocos2d_CCKeyboardDispatcher_getShiftKeyPressed(self)
    }
    #[inline]
    pub unsafe fn keyToString(
        &mut self,
        key: cocos2d_enumKeyCodes,
    ) -> *const ::std::os::raw::c_char {
        cocos2d_CCKeyboardDispatcher_keyToString(self, key)
    }
    #[inline]
    pub unsafe fn updateModifierKeys(&mut self, arg1: bool, arg2: bool, arg3: bool, arg4: bool) {
        cocos2d_CCKeyboardDispatcher_updateModifierKeys(self, arg1, arg2, arg3, arg4)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cocos2d_CCKeyboardDispatcher_CCKeyboardDispatcher(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new1(arg1: *const cocos2d_CCKeyboardDispatcher) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cocos2d_CCKeyboardDispatcher_CCKeyboardDispatcher1(__bindgen_tmp.as_mut_ptr(), arg1);
        __bindgen_tmp.assume_init()
    }
}
extern "C" {
    #[link_name = "\u{1}??_DCCKeyboardDispatcher@cocos2d@@QEAAXXZ"]
    pub fn cocos2d_CCKeyboardDispatcher_CCKeyboardDispatcher_destructor(
        this: *mut cocos2d_CCKeyboardDispatcher,
    );
}
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCMouseDispatcher {
    pub _base: cocos2d_CCObject,
    pub m_pDelegates: *mut cocos2d_CCArray,
}
#[test]
fn bindgen_test_layout_cocos2d_CCMouseDispatcher() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCMouseDispatcher>(),
        48usize,
        concat!("Size of: ", stringify!(cocos2d_CCMouseDispatcher))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCMouseDispatcher>(),
        8usize,
        concat!("Alignment of ", stringify!(cocos2d_CCMouseDispatcher))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cocos2d_CCMouseDispatcher>())).m_pDelegates as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCMouseDispatcher),
            "::",
            stringify!(m_pDelegates)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}?addDelegate@CCMouseDispatcher@cocos2d@@QEAAXPEAVCCMouseDelegate@2@@Z"]
    pub fn cocos2d_CCMouseDispatcher_addDelegate(
        this: *mut cocos2d_CCMouseDispatcher,
        pDelegate: *mut cocos2d_CCMouseDelegate,
    );
}
extern "C" {
    #[link_name = "\u{1}?removeDelegate@CCMouseDispatcher@cocos2d@@QEAAXPEAVCCMouseDelegate@2@@Z"]
    pub fn cocos2d_CCMouseDispatcher_removeDelegate(
        this: *mut cocos2d_CCMouseDispatcher,
        pDelegate: *mut cocos2d_CCMouseDelegate,
    );
}
extern "C" {
    #[link_name = "\u{1}?forceAddDelegate@CCMouseDispatcher@cocos2d@@QEAAXPEAVCCMouseDelegate@2@@Z"]
    pub fn cocos2d_CCMouseDispatcher_forceAddDelegate(
        this: *mut cocos2d_CCMouseDispatcher,
        pDelegate: *mut cocos2d_CCMouseDelegate,
    );
}
extern "C" {
    #[link_name = "\u{1}?forceRemoveDelegate@CCMouseDispatcher@cocos2d@@QEAAXPEAVCCMouseDelegate@2@@Z"]
    pub fn cocos2d_CCMouseDispatcher_forceRemoveDelegate(
        this: *mut cocos2d_CCMouseDispatcher,
        pDelegate: *mut cocos2d_CCMouseDelegate,
    );
}
extern "C" {
    #[link_name = "\u{1}?dispatchScrollMSG@CCMouseDispatcher@cocos2d@@QEAA_NMM@Z"]
    pub fn cocos2d_CCMouseDispatcher_dispatchScrollMSG(
        this: *mut cocos2d_CCMouseDispatcher,
        x: f32,
        y: f32,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}??0CCMouseDispatcher@cocos2d@@QEAA@XZ"]
    pub fn cocos2d_CCMouseDispatcher_CCMouseDispatcher(this: *mut cocos2d_CCMouseDispatcher);
}
extern "C" {
    #[link_name = "\u{1}??0CCMouseDispatcher@cocos2d@@QEAA@AEBV01@@Z"]
    pub fn cocos2d_CCMouseDispatcher_CCMouseDispatcher1(
        this: *mut cocos2d_CCMouseDispatcher,
        arg1: *const cocos2d_CCMouseDispatcher,
    );
}
impl cocos2d_CCMouseDispatcher {
    #[inline]
    pub unsafe fn addDelegate(&mut self, pDelegate: *mut cocos2d_CCMouseDelegate) {
        cocos2d_CCMouseDispatcher_addDelegate(self, pDelegate)
    }
    #[inline]
    pub unsafe fn removeDelegate(&mut self, pDelegate: *mut cocos2d_CCMouseDelegate) {
        cocos2d_CCMouseDispatcher_removeDelegate(self, pDelegate)
    }
    #[inline]
    pub unsafe fn forceAddDelegate(&mut self, pDelegate: *mut cocos2d_CCMouseDelegate) {
        cocos2d_CCMouseDispatcher_forceAddDelegate(self, pDelegate)
    }
    #[inline]
    pub unsafe fn forceRemoveDelegate(&mut self, pDelegate: *mut cocos2d_CCMouseDelegate) {
        cocos2d_CCMouseDispatcher_forceRemoveDelegate(self, pDelegate)
    }
    #[inline]
    pub unsafe fn dispatchScrollMSG(&mut self, x: f32, y: f32) -> bool {
        cocos2d_CCMouseDispatcher_dispatchScrollMSG(self, x, y)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cocos2d_CCMouseDispatcher_CCMouseDispatcher(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new1(arg1: *const cocos2d_CCMouseDispatcher) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cocos2d_CCMouseDispatcher_CCMouseDispatcher1(__bindgen_tmp.as_mut_ptr(), arg1);
        __bindgen_tmp.assume_init()
    }
}
extern "C" {
    #[link_name = "\u{1}??_DCCMouseDispatcher@cocos2d@@QEAAXXZ"]
    pub fn cocos2d_CCMouseDispatcher_CCMouseDispatcher_destructor(
        this: *mut cocos2d_CCMouseDispatcher,
    );
}
#[repr(C)]
pub struct cocos2d_CCSceneTransitionDelegate__bindgen_vtable(::std::os::raw::c_void);
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cocos2d_CCSceneTransitionDelegate {
    pub vtable_: *const cocos2d_CCSceneTransitionDelegate__bindgen_vtable,
}
#[test]
fn bindgen_test_layout_cocos2d_CCSceneTransitionDelegate() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCSceneTransitionDelegate>(),
        8usize,
        concat!("Size of: ", stringify!(cocos2d_CCSceneTransitionDelegate))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCSceneTransitionDelegate>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(cocos2d_CCSceneTransitionDelegate)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}?cocos2dVersion@cocos2d@@YAPEBDXZ"]
    pub fn cocos2d_cocos2dVersion() -> *const ::std::os::raw::c_char;
}
pub type DWORD = ::std::os::raw::c_ulong;
pub type BOOL = ::std::os::raw::c_int;
pub type UINT = ::std::os::raw::c_uint;
pub type UINT_PTR = ::std::os::raw::c_ulonglong;
pub type LONG_PTR = ::std::os::raw::c_longlong;
pub type LONG = ::std::os::raw::c_long;
pub type WCHAR = u16;
pub type LPCWSTR = *const WCHAR;
pub type LONGLONG = ::std::os::raw::c_longlong;
#[repr(C)]
#[derive(Copy, Clone)]
pub union _LARGE_INTEGER {
    pub __bindgen_anon_1: _LARGE_INTEGER__bindgen_ty_1,
    pub u: _LARGE_INTEGER__bindgen_ty_2,
    pub QuadPart: LONGLONG,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _LARGE_INTEGER__bindgen_ty_1 {
    pub LowPart: DWORD,
    pub HighPart: LONG,
}
#[test]
fn bindgen_test_layout__LARGE_INTEGER__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<_LARGE_INTEGER__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(_LARGE_INTEGER__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<_LARGE_INTEGER__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(_LARGE_INTEGER__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_LARGE_INTEGER__bindgen_ty_1>())).LowPart as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_LARGE_INTEGER__bindgen_ty_1),
            "::",
            stringify!(LowPart)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_LARGE_INTEGER__bindgen_ty_1>())).HighPart as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_LARGE_INTEGER__bindgen_ty_1),
            "::",
            stringify!(HighPart)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _LARGE_INTEGER__bindgen_ty_2 {
    pub LowPart: DWORD,
    pub HighPart: LONG,
}
#[test]
fn bindgen_test_layout__LARGE_INTEGER__bindgen_ty_2() {
    assert_eq!(
        ::std::mem::size_of::<_LARGE_INTEGER__bindgen_ty_2>(),
        8usize,
        concat!("Size of: ", stringify!(_LARGE_INTEGER__bindgen_ty_2))
    );
    assert_eq!(
        ::std::mem::align_of::<_LARGE_INTEGER__bindgen_ty_2>(),
        4usize,
        concat!("Alignment of ", stringify!(_LARGE_INTEGER__bindgen_ty_2))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_LARGE_INTEGER__bindgen_ty_2>())).LowPart as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_LARGE_INTEGER__bindgen_ty_2),
            "::",
            stringify!(LowPart)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_LARGE_INTEGER__bindgen_ty_2>())).HighPart as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_LARGE_INTEGER__bindgen_ty_2),
            "::",
            stringify!(HighPart)
        )
    );
}
#[test]
fn bindgen_test_layout__LARGE_INTEGER() {
    assert_eq!(
        ::std::mem::size_of::<_LARGE_INTEGER>(),
        8usize,
        concat!("Size of: ", stringify!(_LARGE_INTEGER))
    );
    assert_eq!(
        ::std::mem::align_of::<_LARGE_INTEGER>(),
        8usize,
        concat!("Alignment of ", stringify!(_LARGE_INTEGER))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_LARGE_INTEGER>())).u as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_LARGE_INTEGER),
            "::",
            stringify!(u)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_LARGE_INTEGER>())).QuadPart as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_LARGE_INTEGER),
            "::",
            stringify!(QuadPart)
        )
    );
}
pub type LARGE_INTEGER = _LARGE_INTEGER;
pub type WPARAM = UINT_PTR;
pub type LPARAM = LONG_PTR;
pub type LRESULT = LONG_PTR;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HINSTANCE__ {
    pub unused: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_HINSTANCE__() {
    assert_eq!(
        ::std::mem::size_of::<HINSTANCE__>(),
        4usize,
        concat!("Size of: ", stringify!(HINSTANCE__))
    );
    assert_eq!(
        ::std::mem::align_of::<HINSTANCE__>(),
        4usize,
        concat!("Alignment of ", stringify!(HINSTANCE__))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<HINSTANCE__>())).unused as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(HINSTANCE__),
            "::",
            stringify!(unused)
        )
    );
}
pub type HINSTANCE = *mut HINSTANCE__;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HWND__ {
    pub unused: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_HWND__() {
    assert_eq!(
        ::std::mem::size_of::<HWND__>(),
        4usize,
        concat!("Size of: ", stringify!(HWND__))
    );
    assert_eq!(
        ::std::mem::align_of::<HWND__>(),
        4usize,
        concat!("Alignment of ", stringify!(HWND__))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<HWND__>())).unused as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(HWND__),
            "::",
            stringify!(unused)
        )
    );
}
pub type HWND = *mut HWND__;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HACCEL__ {
    pub unused: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_HACCEL__() {
    assert_eq!(
        ::std::mem::size_of::<HACCEL__>(),
        4usize,
        concat!("Size of: ", stringify!(HACCEL__))
    );
    assert_eq!(
        ::std::mem::align_of::<HACCEL__>(),
        4usize,
        concat!("Alignment of ", stringify!(HACCEL__))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<HACCEL__>())).unused as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(HACCEL__),
            "::",
            stringify!(unused)
        )
    );
}
pub type HACCEL = *mut HACCEL__;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timeval {
    pub tv_sec: ::std::os::raw::c_long,
    pub tv_usec: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_timeval() {
    assert_eq!(
        ::std::mem::size_of::<timeval>(),
        8usize,
        concat!("Size of: ", stringify!(timeval))
    );
    assert_eq!(
        ::std::mem::align_of::<timeval>(),
        4usize,
        concat!("Alignment of ", stringify!(timeval))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<timeval>())).tv_sec as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(timeval),
            "::",
            stringify!(tv_sec)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<timeval>())).tv_usec as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(timeval),
            "::",
            stringify!(tv_usec)
        )
    );
}
pub type GLenum = ::std::os::raw::c_uint;
pub type GLbitfield = ::std::os::raw::c_uint;
pub type GLuint = ::std::os::raw::c_uint;
pub type GLint = ::std::os::raw::c_int;
pub type GLsizei = ::std::os::raw::c_int;
pub type GLshort = ::std::os::raw::c_short;
pub type GLubyte = ::std::os::raw::c_uchar;
pub type GLushort = ::std::os::raw::c_ushort;
pub type GLfloat = f32;
pub type GLclampf = f32;
pub type GLvoid = ::std::os::raw::c_void;
pub type GLchar = ::std::os::raw::c_char;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct kmMat4 {
    pub mat: [f32; 16usize],
}
#[test]
fn bindgen_test_layout_kmMat4() {
    assert_eq!(
        ::std::mem::size_of::<kmMat4>(),
        64usize,
        concat!("Size of: ", stringify!(kmMat4))
    );
    assert_eq!(
        ::std::mem::align_of::<kmMat4>(),
        4usize,
        concat!("Alignment of ", stringify!(kmMat4))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<kmMat4>())).mat as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(kmMat4),
            "::",
            stringify!(mat)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct UT_hash_bucket {
    pub hh_head: *mut UT_hash_handle,
    pub count: ::std::os::raw::c_uint,
    pub expand_mult: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_UT_hash_bucket() {
    assert_eq!(
        ::std::mem::size_of::<UT_hash_bucket>(),
        16usize,
        concat!("Size of: ", stringify!(UT_hash_bucket))
    );
    assert_eq!(
        ::std::mem::align_of::<UT_hash_bucket>(),
        8usize,
        concat!("Alignment of ", stringify!(UT_hash_bucket))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<UT_hash_bucket>())).hh_head as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(UT_hash_bucket),
            "::",
            stringify!(hh_head)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<UT_hash_bucket>())).count as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(UT_hash_bucket),
            "::",
            stringify!(count)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<UT_hash_bucket>())).expand_mult as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(UT_hash_bucket),
            "::",
            stringify!(expand_mult)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct UT_hash_table {
    pub buckets: *mut UT_hash_bucket,
    pub num_buckets: ::std::os::raw::c_uint,
    pub log2_num_buckets: ::std::os::raw::c_uint,
    pub num_items: ::std::os::raw::c_uint,
    pub tail: *mut UT_hash_handle,
    pub hho: isize,
    pub ideal_chain_maxlen: ::std::os::raw::c_uint,
    pub nonideal_items: ::std::os::raw::c_uint,
    pub ineff_expands: ::std::os::raw::c_uint,
    pub noexpand: ::std::os::raw::c_uint,
    pub signature: u32,
}
#[test]
fn bindgen_test_layout_UT_hash_table() {
    assert_eq!(
        ::std::mem::size_of::<UT_hash_table>(),
        64usize,
        concat!("Size of: ", stringify!(UT_hash_table))
    );
    assert_eq!(
        ::std::mem::align_of::<UT_hash_table>(),
        8usize,
        concat!("Alignment of ", stringify!(UT_hash_table))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<UT_hash_table>())).buckets as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(UT_hash_table),
            "::",
            stringify!(buckets)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<UT_hash_table>())).num_buckets as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(UT_hash_table),
            "::",
            stringify!(num_buckets)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<UT_hash_table>())).log2_num_buckets as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(UT_hash_table),
            "::",
            stringify!(log2_num_buckets)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<UT_hash_table>())).num_items as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(UT_hash_table),
            "::",
            stringify!(num_items)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<UT_hash_table>())).tail as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(UT_hash_table),
            "::",
            stringify!(tail)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<UT_hash_table>())).hho as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(UT_hash_table),
            "::",
            stringify!(hho)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<UT_hash_table>())).ideal_chain_maxlen as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(UT_hash_table),
            "::",
            stringify!(ideal_chain_maxlen)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<UT_hash_table>())).nonideal_items as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(UT_hash_table),
            "::",
            stringify!(nonideal_items)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<UT_hash_table>())).ineff_expands as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(UT_hash_table),
            "::",
            stringify!(ineff_expands)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<UT_hash_table>())).noexpand as *const _ as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(UT_hash_table),
            "::",
            stringify!(noexpand)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<UT_hash_table>())).signature as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(UT_hash_table),
            "::",
            stringify!(signature)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct UT_hash_handle {
    pub tbl: *mut UT_hash_table,
    pub prev: *mut ::std::os::raw::c_void,
    pub next: *mut ::std::os::raw::c_void,
    pub hh_prev: *mut UT_hash_handle,
    pub hh_next: *mut UT_hash_handle,
    pub key: *mut ::std::os::raw::c_void,
    pub keylen: ::std::os::raw::c_uint,
    pub hashv: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_UT_hash_handle() {
    assert_eq!(
        ::std::mem::size_of::<UT_hash_handle>(),
        56usize,
        concat!("Size of: ", stringify!(UT_hash_handle))
    );
    assert_eq!(
        ::std::mem::align_of::<UT_hash_handle>(),
        8usize,
        concat!("Alignment of ", stringify!(UT_hash_handle))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<UT_hash_handle>())).tbl as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(UT_hash_handle),
            "::",
            stringify!(tbl)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<UT_hash_handle>())).prev as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(UT_hash_handle),
            "::",
            stringify!(prev)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<UT_hash_handle>())).next as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(UT_hash_handle),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<UT_hash_handle>())).hh_prev as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(UT_hash_handle),
            "::",
            stringify!(hh_prev)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<UT_hash_handle>())).hh_next as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(UT_hash_handle),
            "::",
            stringify!(hh_next)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<UT_hash_handle>())).key as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(UT_hash_handle),
            "::",
            stringify!(key)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<UT_hash_handle>())).keylen as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(UT_hash_handle),
            "::",
            stringify!(keylen)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<UT_hash_handle>())).hashv as *const _ as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(UT_hash_handle),
            "::",
            stringify!(hashv)
        )
    );
}
pub const ResolutionPolicy_kResolutionExactFit: ResolutionPolicy = 0;
pub const ResolutionPolicy_kResolutionNoBorder: ResolutionPolicy = 1;
pub const ResolutionPolicy_kResolutionShowAll: ResolutionPolicy = 2;
pub const ResolutionPolicy_kResolutionFixedHeight: ResolutionPolicy = 3;
pub const ResolutionPolicy_kResolutionFixedWidth: ResolutionPolicy = 4;
pub const ResolutionPolicy_kResolutionUnKnown: ResolutionPolicy = 5;
pub type ResolutionPolicy = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GLFWmonitor {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GLFWwindow {
    _unused: [u8; 0],
}
pub type pugi_char_t = ::std::os::raw::c_char;
pub type pugi_string_t = [u64; 4usize];
pub const pugi_xml_node_type_node_null: pugi_xml_node_type = 0;
pub const pugi_xml_node_type_node_document: pugi_xml_node_type = 1;
pub const pugi_xml_node_type_node_element: pugi_xml_node_type = 2;
pub const pugi_xml_node_type_node_pcdata: pugi_xml_node_type = 3;
pub const pugi_xml_node_type_node_cdata: pugi_xml_node_type = 4;
pub const pugi_xml_node_type_node_comment: pugi_xml_node_type = 5;
pub const pugi_xml_node_type_node_pi: pugi_xml_node_type = 6;
pub const pugi_xml_node_type_node_declaration: pugi_xml_node_type = 7;
pub const pugi_xml_node_type_node_doctype: pugi_xml_node_type = 8;
pub type pugi_xml_node_type = ::std::os::raw::c_int;
pub const pugi_xml_encoding_encoding_auto: pugi_xml_encoding = 0;
pub const pugi_xml_encoding_encoding_utf8: pugi_xml_encoding = 1;
pub const pugi_xml_encoding_encoding_utf16_le: pugi_xml_encoding = 2;
pub const pugi_xml_encoding_encoding_utf16_be: pugi_xml_encoding = 3;
pub const pugi_xml_encoding_encoding_utf16: pugi_xml_encoding = 4;
pub const pugi_xml_encoding_encoding_utf32_le: pugi_xml_encoding = 5;
pub const pugi_xml_encoding_encoding_utf32_be: pugi_xml_encoding = 6;
pub const pugi_xml_encoding_encoding_utf32: pugi_xml_encoding = 7;
pub const pugi_xml_encoding_encoding_wchar: pugi_xml_encoding = 8;
pub const pugi_xml_encoding_encoding_latin1: pugi_xml_encoding = 9;
pub type pugi_xml_encoding = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pugi_xml_attribute_struct {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pugi_xml_node_struct {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pugi_xml_object_range<It> {
    pub _begin: It,
    pub _end: It,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<It>>,
}
pub type pugi_xml_object_range_const_iterator<It> = It;
#[repr(C)]
pub struct pugi_xml_writer__bindgen_vtable(::std::os::raw::c_void);
#[repr(C)]
#[derive(Debug)]
pub struct pugi_xml_writer {
    pub vtable_: *const pugi_xml_writer__bindgen_vtable,
}
#[test]
fn bindgen_test_layout_pugi_xml_writer() {
    assert_eq!(
        ::std::mem::size_of::<pugi_xml_writer>(),
        8usize,
        concat!("Size of: ", stringify!(pugi_xml_writer))
    );
    assert_eq!(
        ::std::mem::align_of::<pugi_xml_writer>(),
        8usize,
        concat!("Alignment of ", stringify!(pugi_xml_writer))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pugi_xml_attribute {
    pub _attr: *mut pugi_xml_attribute_struct,
}
pub type pugi_xml_attribute_unspecified_bool_type =
    ::std::option::Option<unsafe extern "C" fn(arg1: *mut *mut *mut pugi_xml_attribute)>;
#[test]
fn bindgen_test_layout_pugi_xml_attribute() {
    assert_eq!(
        ::std::mem::size_of::<pugi_xml_attribute>(),
        8usize,
        concat!("Size of: ", stringify!(pugi_xml_attribute))
    );
    assert_eq!(
        ::std::mem::align_of::<pugi_xml_attribute>(),
        8usize,
        concat!("Alignment of ", stringify!(pugi_xml_attribute))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pugi_xml_attribute>()))._attr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pugi_xml_attribute),
            "::",
            stringify!(_attr)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}?empty@xml_attribute@pugi@@QEBA_NXZ"]
    pub fn pugi_xml_attribute_empty(this: *const pugi_xml_attribute) -> bool;
}
extern "C" {
    #[link_name = "\u{1}?name@xml_attribute@pugi@@QEBAPEBDXZ"]
    pub fn pugi_xml_attribute_name(this: *const pugi_xml_attribute) -> *const pugi_char_t;
}
extern "C" {
    #[link_name = "\u{1}?value@xml_attribute@pugi@@QEBAPEBDXZ"]
    pub fn pugi_xml_attribute_value(this: *const pugi_xml_attribute) -> *const pugi_char_t;
}
extern "C" {
    #[link_name = "\u{1}?as_string@xml_attribute@pugi@@QEBAPEBDPEBD@Z"]
    pub fn pugi_xml_attribute_as_string(
        this: *const pugi_xml_attribute,
        def: *const pugi_char_t,
    ) -> *const pugi_char_t;
}
extern "C" {
    #[link_name = "\u{1}?as_int@xml_attribute@pugi@@QEBAHH@Z"]
    pub fn pugi_xml_attribute_as_int(
        this: *const pugi_xml_attribute,
        def: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}?as_uint@xml_attribute@pugi@@QEBAII@Z"]
    pub fn pugi_xml_attribute_as_uint(
        this: *const pugi_xml_attribute,
        def: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[link_name = "\u{1}?as_double@xml_attribute@pugi@@QEBANN@Z"]
    pub fn pugi_xml_attribute_as_double(this: *const pugi_xml_attribute, def: f64) -> f64;
}
extern "C" {
    #[link_name = "\u{1}?as_float@xml_attribute@pugi@@QEBAMM@Z"]
    pub fn pugi_xml_attribute_as_float(this: *const pugi_xml_attribute, def: f32) -> f32;
}
extern "C" {
    #[link_name = "\u{1}?as_bool@xml_attribute@pugi@@QEBA_N_N@Z"]
    pub fn pugi_xml_attribute_as_bool(this: *const pugi_xml_attribute, def: bool) -> bool;
}
extern "C" {
    #[link_name = "\u{1}?set_name@xml_attribute@pugi@@QEAA_NPEBD@Z"]
    pub fn pugi_xml_attribute_set_name(
        this: *mut pugi_xml_attribute,
        rhs: *const pugi_char_t,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}?set_value@xml_attribute@pugi@@QEAA_NPEBD@Z"]
    pub fn pugi_xml_attribute_set_value(
        this: *mut pugi_xml_attribute,
        rhs: *const pugi_char_t,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}?set_value@xml_attribute@pugi@@QEAA_NH@Z"]
    pub fn pugi_xml_attribute_set_value1(
        this: *mut pugi_xml_attribute,
        rhs: ::std::os::raw::c_int,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}?set_value@xml_attribute@pugi@@QEAA_NI@Z"]
    pub fn pugi_xml_attribute_set_value2(
        this: *mut pugi_xml_attribute,
        rhs: ::std::os::raw::c_uint,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}?set_value@xml_attribute@pugi@@QEAA_NN@Z"]
    pub fn pugi_xml_attribute_set_value3(this: *mut pugi_xml_attribute, rhs: f64) -> bool;
}
extern "C" {
    #[link_name = "\u{1}?set_value@xml_attribute@pugi@@QEAA_N_N@Z"]
    pub fn pugi_xml_attribute_set_value4(this: *mut pugi_xml_attribute, rhs: bool) -> bool;
}
extern "C" {
    #[link_name = "\u{1}?next_attribute@xml_attribute@pugi@@QEBA?AV12@XZ"]
    pub fn pugi_xml_attribute_next_attribute(this: *const pugi_xml_attribute)
        -> pugi_xml_attribute;
}
extern "C" {
    #[link_name = "\u{1}?previous_attribute@xml_attribute@pugi@@QEBA?AV12@XZ"]
    pub fn pugi_xml_attribute_previous_attribute(
        this: *const pugi_xml_attribute,
    ) -> pugi_xml_attribute;
}
extern "C" {
    #[link_name = "\u{1}?hash_value@xml_attribute@pugi@@QEBA_KXZ"]
    pub fn pugi_xml_attribute_hash_value(this: *const pugi_xml_attribute) -> size_t;
}
extern "C" {
    #[link_name = "\u{1}?internal_object@xml_attribute@pugi@@QEBAPEAUxml_attribute_struct@2@XZ"]
    pub fn pugi_xml_attribute_internal_object(
        this: *const pugi_xml_attribute,
    ) -> *mut pugi_xml_attribute_struct;
}
extern "C" {
    #[link_name = "\u{1}??0xml_attribute@pugi@@QEAA@XZ"]
    pub fn pugi_xml_attribute_xml_attribute(this: *mut pugi_xml_attribute);
}
extern "C" {
    #[link_name = "\u{1}??0xml_attribute@pugi@@QEAA@PEAUxml_attribute_struct@1@@Z"]
    pub fn pugi_xml_attribute_xml_attribute1(
        this: *mut pugi_xml_attribute,
        attr: *mut pugi_xml_attribute_struct,
    );
}
impl pugi_xml_attribute {
    #[inline]
    pub unsafe fn empty(&self) -> bool {
        pugi_xml_attribute_empty(self)
    }
    #[inline]
    pub unsafe fn name(&self) -> *const pugi_char_t {
        pugi_xml_attribute_name(self)
    }
    #[inline]
    pub unsafe fn value(&self) -> *const pugi_char_t {
        pugi_xml_attribute_value(self)
    }
    #[inline]
    pub unsafe fn as_string(&self, def: *const pugi_char_t) -> *const pugi_char_t {
        pugi_xml_attribute_as_string(self, def)
    }
    #[inline]
    pub unsafe fn as_int(&self, def: ::std::os::raw::c_int) -> ::std::os::raw::c_int {
        pugi_xml_attribute_as_int(self, def)
    }
    #[inline]
    pub unsafe fn as_uint(&self, def: ::std::os::raw::c_uint) -> ::std::os::raw::c_uint {
        pugi_xml_attribute_as_uint(self, def)
    }
    #[inline]
    pub unsafe fn as_double(&self, def: f64) -> f64 {
        pugi_xml_attribute_as_double(self, def)
    }
    #[inline]
    pub unsafe fn as_float(&self, def: f32) -> f32 {
        pugi_xml_attribute_as_float(self, def)
    }
    #[inline]
    pub unsafe fn as_bool(&self, def: bool) -> bool {
        pugi_xml_attribute_as_bool(self, def)
    }
    #[inline]
    pub unsafe fn set_name(&mut self, rhs: *const pugi_char_t) -> bool {
        pugi_xml_attribute_set_name(self, rhs)
    }
    #[inline]
    pub unsafe fn set_value(&mut self, rhs: *const pugi_char_t) -> bool {
        pugi_xml_attribute_set_value(self, rhs)
    }
    #[inline]
    pub unsafe fn set_value1(&mut self, rhs: ::std::os::raw::c_int) -> bool {
        pugi_xml_attribute_set_value1(self, rhs)
    }
    #[inline]
    pub unsafe fn set_value2(&mut self, rhs: ::std::os::raw::c_uint) -> bool {
        pugi_xml_attribute_set_value2(self, rhs)
    }
    #[inline]
    pub unsafe fn set_value3(&mut self, rhs: f64) -> bool {
        pugi_xml_attribute_set_value3(self, rhs)
    }
    #[inline]
    pub unsafe fn set_value4(&mut self, rhs: bool) -> bool {
        pugi_xml_attribute_set_value4(self, rhs)
    }
    #[inline]
    pub unsafe fn next_attribute(&self) -> pugi_xml_attribute {
        pugi_xml_attribute_next_attribute(self)
    }
    #[inline]
    pub unsafe fn previous_attribute(&self) -> pugi_xml_attribute {
        pugi_xml_attribute_previous_attribute(self)
    }
    #[inline]
    pub unsafe fn hash_value(&self) -> size_t {
        pugi_xml_attribute_hash_value(self)
    }
    #[inline]
    pub unsafe fn internal_object(&self) -> *mut pugi_xml_attribute_struct {
        pugi_xml_attribute_internal_object(self)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        pugi_xml_attribute_xml_attribute(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new1(attr: *mut pugi_xml_attribute_struct) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        pugi_xml_attribute_xml_attribute1(__bindgen_tmp.as_mut_ptr(), attr);
        __bindgen_tmp.assume_init()
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pugi_xml_node {
    pub _root: *mut pugi_xml_node_struct,
}
pub type pugi_xml_node_unspecified_bool_type =
    ::std::option::Option<unsafe extern "C" fn(arg1: *mut *mut *mut pugi_xml_node)>;
pub type pugi_xml_node_attribute_iterator = pugi_xml_attribute_iterator;
#[test]
fn bindgen_test_layout_pugi_xml_node() {
    assert_eq!(
        ::std::mem::size_of::<pugi_xml_node>(),
        8usize,
        concat!("Size of: ", stringify!(pugi_xml_node))
    );
    assert_eq!(
        ::std::mem::align_of::<pugi_xml_node>(),
        8usize,
        concat!("Alignment of ", stringify!(pugi_xml_node))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pugi_xml_node>()))._root as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pugi_xml_node),
            "::",
            stringify!(_root)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}?empty@xml_node@pugi@@QEBA_NXZ"]
    pub fn pugi_xml_node_empty(this: *const pugi_xml_node) -> bool;
}
extern "C" {
    #[link_name = "\u{1}?type@xml_node@pugi@@QEBA?AW4xml_node_type@2@XZ"]
    pub fn pugi_xml_node_type(this: *const pugi_xml_node) -> pugi_xml_node_type;
}
extern "C" {
    #[link_name = "\u{1}?name@xml_node@pugi@@QEBAPEBDXZ"]
    pub fn pugi_xml_node_name(this: *const pugi_xml_node) -> *const pugi_char_t;
}
extern "C" {
    #[link_name = "\u{1}?value@xml_node@pugi@@QEBAPEBDXZ"]
    pub fn pugi_xml_node_value(this: *const pugi_xml_node) -> *const pugi_char_t;
}
extern "C" {
    #[link_name = "\u{1}?first_attribute@xml_node@pugi@@QEBA?AVxml_attribute@2@XZ"]
    pub fn pugi_xml_node_first_attribute(this: *const pugi_xml_node) -> pugi_xml_attribute;
}
extern "C" {
    #[link_name = "\u{1}?last_attribute@xml_node@pugi@@QEBA?AVxml_attribute@2@XZ"]
    pub fn pugi_xml_node_last_attribute(this: *const pugi_xml_node) -> pugi_xml_attribute;
}
extern "C" {
    #[link_name = "\u{1}?first_child@xml_node@pugi@@QEBA?AV12@XZ"]
    pub fn pugi_xml_node_first_child(this: *const pugi_xml_node) -> pugi_xml_node;
}
extern "C" {
    #[link_name = "\u{1}?last_child@xml_node@pugi@@QEBA?AV12@XZ"]
    pub fn pugi_xml_node_last_child(this: *const pugi_xml_node) -> pugi_xml_node;
}
extern "C" {
    #[link_name = "\u{1}?next_sibling@xml_node@pugi@@QEBA?AV12@XZ"]
    pub fn pugi_xml_node_next_sibling(this: *const pugi_xml_node) -> pugi_xml_node;
}
extern "C" {
    #[link_name = "\u{1}?previous_sibling@xml_node@pugi@@QEBA?AV12@XZ"]
    pub fn pugi_xml_node_previous_sibling(this: *const pugi_xml_node) -> pugi_xml_node;
}
extern "C" {
    #[link_name = "\u{1}?parent@xml_node@pugi@@QEBA?AV12@XZ"]
    pub fn pugi_xml_node_parent(this: *const pugi_xml_node) -> pugi_xml_node;
}
extern "C" {
    #[link_name = "\u{1}?root@xml_node@pugi@@QEBA?AV12@XZ"]
    pub fn pugi_xml_node_root(this: *const pugi_xml_node) -> pugi_xml_node;
}
extern "C" {
    #[link_name = "\u{1}?text@xml_node@pugi@@QEBA?AVxml_text@2@XZ"]
    pub fn pugi_xml_node_text(this: *const pugi_xml_node) -> pugi_xml_text;
}
extern "C" {
    #[link_name = "\u{1}?child@xml_node@pugi@@QEBA?AV12@PEBD@Z"]
    pub fn pugi_xml_node_child(
        this: *const pugi_xml_node,
        name: *const pugi_char_t,
    ) -> pugi_xml_node;
}
extern "C" {
    #[link_name = "\u{1}?attribute@xml_node@pugi@@QEBA?AVxml_attribute@2@PEBD@Z"]
    pub fn pugi_xml_node_attribute(
        this: *const pugi_xml_node,
        name: *const pugi_char_t,
    ) -> pugi_xml_attribute;
}
extern "C" {
    #[link_name = "\u{1}?next_sibling@xml_node@pugi@@QEBA?AV12@PEBD@Z"]
    pub fn pugi_xml_node_next_sibling1(
        this: *const pugi_xml_node,
        name: *const pugi_char_t,
    ) -> pugi_xml_node;
}
extern "C" {
    #[link_name = "\u{1}?previous_sibling@xml_node@pugi@@QEBA?AV12@PEBD@Z"]
    pub fn pugi_xml_node_previous_sibling1(
        this: *const pugi_xml_node,
        name: *const pugi_char_t,
    ) -> pugi_xml_node;
}
extern "C" {
    #[link_name = "\u{1}?child_value@xml_node@pugi@@QEBAPEBDXZ"]
    pub fn pugi_xml_node_child_value(this: *const pugi_xml_node) -> *const pugi_char_t;
}
extern "C" {
    #[link_name = "\u{1}?child_value@xml_node@pugi@@QEBAPEBDPEBD@Z"]
    pub fn pugi_xml_node_child_value1(
        this: *const pugi_xml_node,
        name: *const pugi_char_t,
    ) -> *const pugi_char_t;
}
extern "C" {
    #[link_name = "\u{1}?set_name@xml_node@pugi@@QEAA_NPEBD@Z"]
    pub fn pugi_xml_node_set_name(this: *mut pugi_xml_node, rhs: *const pugi_char_t) -> bool;
}
extern "C" {
    #[link_name = "\u{1}?set_value@xml_node@pugi@@QEAA_NPEBD@Z"]
    pub fn pugi_xml_node_set_value(this: *mut pugi_xml_node, rhs: *const pugi_char_t) -> bool;
}
extern "C" {
    #[link_name = "\u{1}?append_attribute@xml_node@pugi@@QEAA?AVxml_attribute@2@PEBD@Z"]
    pub fn pugi_xml_node_append_attribute(
        this: *mut pugi_xml_node,
        name: *const pugi_char_t,
    ) -> pugi_xml_attribute;
}
extern "C" {
    #[link_name = "\u{1}?prepend_attribute@xml_node@pugi@@QEAA?AVxml_attribute@2@PEBD@Z"]
    pub fn pugi_xml_node_prepend_attribute(
        this: *mut pugi_xml_node,
        name: *const pugi_char_t,
    ) -> pugi_xml_attribute;
}
extern "C" {
    #[link_name = "\u{1}?insert_attribute_after@xml_node@pugi@@QEAA?AVxml_attribute@2@PEBDAEBV32@@Z"]
    pub fn pugi_xml_node_insert_attribute_after(
        this: *mut pugi_xml_node,
        name: *const pugi_char_t,
        attr: *const pugi_xml_attribute,
    ) -> pugi_xml_attribute;
}
extern "C" {
    #[link_name = "\u{1}?insert_attribute_before@xml_node@pugi@@QEAA?AVxml_attribute@2@PEBDAEBV32@@Z"]
    pub fn pugi_xml_node_insert_attribute_before(
        this: *mut pugi_xml_node,
        name: *const pugi_char_t,
        attr: *const pugi_xml_attribute,
    ) -> pugi_xml_attribute;
}
extern "C" {
    #[link_name = "\u{1}?append_copy@xml_node@pugi@@QEAA?AVxml_attribute@2@AEBV32@@Z"]
    pub fn pugi_xml_node_append_copy(
        this: *mut pugi_xml_node,
        proto: *const pugi_xml_attribute,
    ) -> pugi_xml_attribute;
}
extern "C" {
    #[link_name = "\u{1}?prepend_copy@xml_node@pugi@@QEAA?AVxml_attribute@2@AEBV32@@Z"]
    pub fn pugi_xml_node_prepend_copy(
        this: *mut pugi_xml_node,
        proto: *const pugi_xml_attribute,
    ) -> pugi_xml_attribute;
}
extern "C" {
    #[link_name = "\u{1}?insert_copy_after@xml_node@pugi@@QEAA?AVxml_attribute@2@AEBV32@0@Z"]
    pub fn pugi_xml_node_insert_copy_after(
        this: *mut pugi_xml_node,
        proto: *const pugi_xml_attribute,
        attr: *const pugi_xml_attribute,
    ) -> pugi_xml_attribute;
}
extern "C" {
    #[link_name = "\u{1}?insert_copy_before@xml_node@pugi@@QEAA?AVxml_attribute@2@AEBV32@0@Z"]
    pub fn pugi_xml_node_insert_copy_before(
        this: *mut pugi_xml_node,
        proto: *const pugi_xml_attribute,
        attr: *const pugi_xml_attribute,
    ) -> pugi_xml_attribute;
}
extern "C" {
    #[link_name = "\u{1}?append_child@xml_node@pugi@@QEAA?AV12@W4xml_node_type@2@@Z"]
    pub fn pugi_xml_node_append_child(
        this: *mut pugi_xml_node,
        type_: pugi_xml_node_type,
    ) -> pugi_xml_node;
}
extern "C" {
    #[link_name = "\u{1}?prepend_child@xml_node@pugi@@QEAA?AV12@W4xml_node_type@2@@Z"]
    pub fn pugi_xml_node_prepend_child(
        this: *mut pugi_xml_node,
        type_: pugi_xml_node_type,
    ) -> pugi_xml_node;
}
extern "C" {
    #[link_name = "\u{1}?insert_child_after@xml_node@pugi@@QEAA?AV12@W4xml_node_type@2@AEBV12@@Z"]
    pub fn pugi_xml_node_insert_child_after(
        this: *mut pugi_xml_node,
        type_: pugi_xml_node_type,
        node: *const pugi_xml_node,
    ) -> pugi_xml_node;
}
extern "C" {
    #[link_name = "\u{1}?insert_child_before@xml_node@pugi@@QEAA?AV12@W4xml_node_type@2@AEBV12@@Z"]
    pub fn pugi_xml_node_insert_child_before(
        this: *mut pugi_xml_node,
        type_: pugi_xml_node_type,
        node: *const pugi_xml_node,
    ) -> pugi_xml_node;
}
extern "C" {
    #[link_name = "\u{1}?append_child@xml_node@pugi@@QEAA?AV12@PEBD@Z"]
    pub fn pugi_xml_node_append_child1(
        this: *mut pugi_xml_node,
        name: *const pugi_char_t,
    ) -> pugi_xml_node;
}
extern "C" {
    #[link_name = "\u{1}?prepend_child@xml_node@pugi@@QEAA?AV12@PEBD@Z"]
    pub fn pugi_xml_node_prepend_child1(
        this: *mut pugi_xml_node,
        name: *const pugi_char_t,
    ) -> pugi_xml_node;
}
extern "C" {
    #[link_name = "\u{1}?insert_child_after@xml_node@pugi@@QEAA?AV12@PEBDAEBV12@@Z"]
    pub fn pugi_xml_node_insert_child_after1(
        this: *mut pugi_xml_node,
        name: *const pugi_char_t,
        node: *const pugi_xml_node,
    ) -> pugi_xml_node;
}
extern "C" {
    #[link_name = "\u{1}?insert_child_before@xml_node@pugi@@QEAA?AV12@PEBDAEBV12@@Z"]
    pub fn pugi_xml_node_insert_child_before1(
        this: *mut pugi_xml_node,
        name: *const pugi_char_t,
        node: *const pugi_xml_node,
    ) -> pugi_xml_node;
}
extern "C" {
    #[link_name = "\u{1}?append_copy@xml_node@pugi@@QEAA?AV12@AEBV12@@Z"]
    pub fn pugi_xml_node_append_copy1(
        this: *mut pugi_xml_node,
        proto: *const pugi_xml_node,
    ) -> pugi_xml_node;
}
extern "C" {
    #[link_name = "\u{1}?prepend_copy@xml_node@pugi@@QEAA?AV12@AEBV12@@Z"]
    pub fn pugi_xml_node_prepend_copy1(
        this: *mut pugi_xml_node,
        proto: *const pugi_xml_node,
    ) -> pugi_xml_node;
}
extern "C" {
    #[link_name = "\u{1}?insert_copy_after@xml_node@pugi@@QEAA?AV12@AEBV12@0@Z"]
    pub fn pugi_xml_node_insert_copy_after1(
        this: *mut pugi_xml_node,
        proto: *const pugi_xml_node,
        node: *const pugi_xml_node,
    ) -> pugi_xml_node;
}
extern "C" {
    #[link_name = "\u{1}?insert_copy_before@xml_node@pugi@@QEAA?AV12@AEBV12@0@Z"]
    pub fn pugi_xml_node_insert_copy_before1(
        this: *mut pugi_xml_node,
        proto: *const pugi_xml_node,
        node: *const pugi_xml_node,
    ) -> pugi_xml_node;
}
extern "C" {
    #[link_name = "\u{1}?remove_attribute@xml_node@pugi@@QEAA_NAEBVxml_attribute@2@@Z"]
    pub fn pugi_xml_node_remove_attribute(
        this: *mut pugi_xml_node,
        a: *const pugi_xml_attribute,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}?remove_attribute@xml_node@pugi@@QEAA_NPEBD@Z"]
    pub fn pugi_xml_node_remove_attribute1(
        this: *mut pugi_xml_node,
        name: *const pugi_char_t,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}?remove_child@xml_node@pugi@@QEAA_NAEBV12@@Z"]
    pub fn pugi_xml_node_remove_child(this: *mut pugi_xml_node, n: *const pugi_xml_node) -> bool;
}
extern "C" {
    #[link_name = "\u{1}?remove_child@xml_node@pugi@@QEAA_NPEBD@Z"]
    pub fn pugi_xml_node_remove_child1(this: *mut pugi_xml_node, name: *const pugi_char_t) -> bool;
}
extern "C" {
    #[link_name = "\u{1}?find_child_by_attribute@xml_node@pugi@@QEBA?AV12@PEBD00@Z"]
    pub fn pugi_xml_node_find_child_by_attribute(
        this: *const pugi_xml_node,
        name: *const pugi_char_t,
        attr_name: *const pugi_char_t,
        attr_value: *const pugi_char_t,
    ) -> pugi_xml_node;
}
extern "C" {
    #[link_name = "\u{1}?find_child_by_attribute@xml_node@pugi@@QEBA?AV12@PEBD0@Z"]
    pub fn pugi_xml_node_find_child_by_attribute1(
        this: *const pugi_xml_node,
        attr_name: *const pugi_char_t,
        attr_value: *const pugi_char_t,
    ) -> pugi_xml_node;
}
extern "C" {
    #[link_name = "\u{1}?path@xml_node@pugi@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@D@Z"]
    pub fn pugi_xml_node_path(this: *const pugi_xml_node, delimiter: pugi_char_t) -> pugi_string_t;
}
extern "C" {
    #[link_name = "\u{1}?first_element_by_path@xml_node@pugi@@QEBA?AV12@PEBDD@Z"]
    pub fn pugi_xml_node_first_element_by_path(
        this: *const pugi_xml_node,
        path: *const pugi_char_t,
        delimiter: pugi_char_t,
    ) -> pugi_xml_node;
}
extern "C" {
    #[link_name = "\u{1}?traverse@xml_node@pugi@@QEAA_NAEAVxml_tree_walker@2@@Z"]
    pub fn pugi_xml_node_traverse(
        this: *mut pugi_xml_node,
        walker: *mut pugi_xml_tree_walker,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}?select_single_node@xml_node@pugi@@QEBA?AVxpath_node@2@PEBDPEAVxpath_variable_set@2@@Z"]
    pub fn pugi_xml_node_select_single_node(
        this: *const pugi_xml_node,
        query: *const pugi_char_t,
        variables: *mut pugi_xpath_variable_set,
    ) -> pugi_xpath_node;
}
extern "C" {
    #[link_name = "\u{1}?select_single_node@xml_node@pugi@@QEBA?AVxpath_node@2@AEBVxpath_query@2@@Z"]
    pub fn pugi_xml_node_select_single_node1(
        this: *const pugi_xml_node,
        query: *const pugi_xpath_query,
    ) -> pugi_xpath_node;
}
extern "C" {
    #[link_name = "\u{1}?select_nodes@xml_node@pugi@@QEBA?AVxpath_node_set@2@PEBDPEAVxpath_variable_set@2@@Z"]
    pub fn pugi_xml_node_select_nodes(
        this: *const pugi_xml_node,
        query: *const pugi_char_t,
        variables: *mut pugi_xpath_variable_set,
    ) -> pugi_xpath_node_set;
}
extern "C" {
    #[link_name = "\u{1}?select_nodes@xml_node@pugi@@QEBA?AVxpath_node_set@2@AEBVxpath_query@2@@Z"]
    pub fn pugi_xml_node_select_nodes1(
        this: *const pugi_xml_node,
        query: *const pugi_xpath_query,
    ) -> pugi_xpath_node_set;
}
extern "C" {
    #[link_name = "\u{1}?print@xml_node@pugi@@QEBAXAEAVxml_writer@2@PEBDIW4xml_encoding@2@I@Z"]
    pub fn pugi_xml_node_print(
        this: *const pugi_xml_node,
        writer: *mut pugi_xml_writer,
        indent: *const pugi_char_t,
        flags: ::std::os::raw::c_uint,
        encoding: pugi_xml_encoding,
        depth: ::std::os::raw::c_uint,
    );
}
extern "C" {
    #[link_name = "\u{1}?print@xml_node@pugi@@QEBAXAEAV?$basic_ostream@DU?$char_traits@D@std@@@std@@PEBDIW4xml_encoding@2@I@Z"]
    pub fn pugi_xml_node_print1(
        this: *const pugi_xml_node,
        os: *mut u8,
        indent: *const pugi_char_t,
        flags: ::std::os::raw::c_uint,
        encoding: pugi_xml_encoding,
        depth: ::std::os::raw::c_uint,
    );
}
extern "C" {
    #[link_name = "\u{1}?print@xml_node@pugi@@QEBAXAEAV?$basic_ostream@_WU?$char_traits@_W@std@@@std@@PEBDII@Z"]
    pub fn pugi_xml_node_print2(
        this: *const pugi_xml_node,
        os: *mut u8,
        indent: *const pugi_char_t,
        flags: ::std::os::raw::c_uint,
        depth: ::std::os::raw::c_uint,
    );
}
extern "C" {
    #[link_name = "\u{1}?begin@xml_node@pugi@@QEBA?AVxml_node_iterator@2@XZ"]
    pub fn pugi_xml_node_begin(this: *const pugi_xml_node) -> pugi_xml_node_iterator;
}
extern "C" {
    #[link_name = "\u{1}?end@xml_node@pugi@@QEBA?AVxml_node_iterator@2@XZ"]
    pub fn pugi_xml_node_end(this: *const pugi_xml_node) -> pugi_xml_node_iterator;
}
extern "C" {
    #[link_name = "\u{1}?attributes_begin@xml_node@pugi@@QEBA?AVxml_attribute_iterator@2@XZ"]
    pub fn pugi_xml_node_attributes_begin(
        this: *const pugi_xml_node,
    ) -> pugi_xml_node_attribute_iterator;
}
extern "C" {
    #[link_name = "\u{1}?attributes_end@xml_node@pugi@@QEBA?AVxml_attribute_iterator@2@XZ"]
    pub fn pugi_xml_node_attributes_end(
        this: *const pugi_xml_node,
    ) -> pugi_xml_node_attribute_iterator;
}
extern "C" {
    #[link_name = "\u{1}?children@xml_node@pugi@@QEBA?AV?$xml_object_range@Vxml_node_iterator@pugi@@@2@XZ"]
    pub fn pugi_xml_node_children(
        this: *const pugi_xml_node,
    ) -> pugi_xml_object_range<pugi_xml_node_iterator>;
}
extern "C" {
    #[link_name = "\u{1}?children@xml_node@pugi@@QEBA?AV?$xml_object_range@Vxml_named_node_iterator@pugi@@@2@PEBD@Z"]
    pub fn pugi_xml_node_children1(
        this: *const pugi_xml_node,
        name: *const pugi_char_t,
    ) -> pugi_xml_object_range<pugi_xml_named_node_iterator>;
}
extern "C" {
    #[link_name = "\u{1}?attributes@xml_node@pugi@@QEBA?AV?$xml_object_range@Vxml_attribute_iterator@pugi@@@2@XZ"]
    pub fn pugi_xml_node_attributes(
        this: *const pugi_xml_node,
    ) -> pugi_xml_object_range<pugi_xml_attribute_iterator>;
}
extern "C" {
    #[link_name = "\u{1}?offset_debug@xml_node@pugi@@QEBA_JXZ"]
    pub fn pugi_xml_node_offset_debug(this: *const pugi_xml_node) -> isize;
}
extern "C" {
    #[link_name = "\u{1}?hash_value@xml_node@pugi@@QEBA_KXZ"]
    pub fn pugi_xml_node_hash_value(this: *const pugi_xml_node) -> size_t;
}
extern "C" {
    #[link_name = "\u{1}?internal_object@xml_node@pugi@@QEBAPEAUxml_node_struct@2@XZ"]
    pub fn pugi_xml_node_internal_object(this: *const pugi_xml_node) -> *mut pugi_xml_node_struct;
}
extern "C" {
    #[link_name = "\u{1}??0xml_node@pugi@@QEAA@XZ"]
    pub fn pugi_xml_node_xml_node(this: *mut pugi_xml_node);
}
extern "C" {
    #[link_name = "\u{1}??0xml_node@pugi@@QEAA@PEAUxml_node_struct@1@@Z"]
    pub fn pugi_xml_node_xml_node1(this: *mut pugi_xml_node, p: *mut pugi_xml_node_struct);
}
impl pugi_xml_node {
    #[inline]
    pub unsafe fn empty(&self) -> bool {
        pugi_xml_node_empty(self)
    }
    #[inline]
    pub unsafe fn type_(&self) -> pugi_xml_node_type {
        pugi_xml_node_type(self)
    }
    #[inline]
    pub unsafe fn name(&self) -> *const pugi_char_t {
        pugi_xml_node_name(self)
    }
    #[inline]
    pub unsafe fn value(&self) -> *const pugi_char_t {
        pugi_xml_node_value(self)
    }
    #[inline]
    pub unsafe fn first_attribute(&self) -> pugi_xml_attribute {
        pugi_xml_node_first_attribute(self)
    }
    #[inline]
    pub unsafe fn last_attribute(&self) -> pugi_xml_attribute {
        pugi_xml_node_last_attribute(self)
    }
    #[inline]
    pub unsafe fn first_child(&self) -> pugi_xml_node {
        pugi_xml_node_first_child(self)
    }
    #[inline]
    pub unsafe fn last_child(&self) -> pugi_xml_node {
        pugi_xml_node_last_child(self)
    }
    #[inline]
    pub unsafe fn next_sibling(&self) -> pugi_xml_node {
        pugi_xml_node_next_sibling(self)
    }
    #[inline]
    pub unsafe fn previous_sibling(&self) -> pugi_xml_node {
        pugi_xml_node_previous_sibling(self)
    }
    #[inline]
    pub unsafe fn parent(&self) -> pugi_xml_node {
        pugi_xml_node_parent(self)
    }
    #[inline]
    pub unsafe fn root(&self) -> pugi_xml_node {
        pugi_xml_node_root(self)
    }
    #[inline]
    pub unsafe fn text(&self) -> pugi_xml_text {
        pugi_xml_node_text(self)
    }
    #[inline]
    pub unsafe fn child(&self, name: *const pugi_char_t) -> pugi_xml_node {
        pugi_xml_node_child(self, name)
    }
    #[inline]
    pub unsafe fn attribute(&self, name: *const pugi_char_t) -> pugi_xml_attribute {
        pugi_xml_node_attribute(self, name)
    }
    #[inline]
    pub unsafe fn next_sibling1(&self, name: *const pugi_char_t) -> pugi_xml_node {
        pugi_xml_node_next_sibling1(self, name)
    }
    #[inline]
    pub unsafe fn previous_sibling1(&self, name: *const pugi_char_t) -> pugi_xml_node {
        pugi_xml_node_previous_sibling1(self, name)
    }
    #[inline]
    pub unsafe fn child_value(&self) -> *const pugi_char_t {
        pugi_xml_node_child_value(self)
    }
    #[inline]
    pub unsafe fn child_value1(&self, name: *const pugi_char_t) -> *const pugi_char_t {
        pugi_xml_node_child_value1(self, name)
    }
    #[inline]
    pub unsafe fn set_name(&mut self, rhs: *const pugi_char_t) -> bool {
        pugi_xml_node_set_name(self, rhs)
    }
    #[inline]
    pub unsafe fn set_value(&mut self, rhs: *const pugi_char_t) -> bool {
        pugi_xml_node_set_value(self, rhs)
    }
    #[inline]
    pub unsafe fn append_attribute(&mut self, name: *const pugi_char_t) -> pugi_xml_attribute {
        pugi_xml_node_append_attribute(self, name)
    }
    #[inline]
    pub unsafe fn prepend_attribute(&mut self, name: *const pugi_char_t) -> pugi_xml_attribute {
        pugi_xml_node_prepend_attribute(self, name)
    }
    #[inline]
    pub unsafe fn insert_attribute_after(
        &mut self,
        name: *const pugi_char_t,
        attr: *const pugi_xml_attribute,
    ) -> pugi_xml_attribute {
        pugi_xml_node_insert_attribute_after(self, name, attr)
    }
    #[inline]
    pub unsafe fn insert_attribute_before(
        &mut self,
        name: *const pugi_char_t,
        attr: *const pugi_xml_attribute,
    ) -> pugi_xml_attribute {
        pugi_xml_node_insert_attribute_before(self, name, attr)
    }
    #[inline]
    pub unsafe fn append_copy(&mut self, proto: *const pugi_xml_attribute) -> pugi_xml_attribute {
        pugi_xml_node_append_copy(self, proto)
    }
    #[inline]
    pub unsafe fn prepend_copy(&mut self, proto: *const pugi_xml_attribute) -> pugi_xml_attribute {
        pugi_xml_node_prepend_copy(self, proto)
    }
    #[inline]
    pub unsafe fn insert_copy_after(
        &mut self,
        proto: *const pugi_xml_attribute,
        attr: *const pugi_xml_attribute,
    ) -> pugi_xml_attribute {
        pugi_xml_node_insert_copy_after(self, proto, attr)
    }
    #[inline]
    pub unsafe fn insert_copy_before(
        &mut self,
        proto: *const pugi_xml_attribute,
        attr: *const pugi_xml_attribute,
    ) -> pugi_xml_attribute {
        pugi_xml_node_insert_copy_before(self, proto, attr)
    }
    #[inline]
    pub unsafe fn append_child(&mut self, type_: pugi_xml_node_type) -> pugi_xml_node {
        pugi_xml_node_append_child(self, type_)
    }
    #[inline]
    pub unsafe fn prepend_child(&mut self, type_: pugi_xml_node_type) -> pugi_xml_node {
        pugi_xml_node_prepend_child(self, type_)
    }
    #[inline]
    pub unsafe fn insert_child_after(
        &mut self,
        type_: pugi_xml_node_type,
        node: *const pugi_xml_node,
    ) -> pugi_xml_node {
        pugi_xml_node_insert_child_after(self, type_, node)
    }
    #[inline]
    pub unsafe fn insert_child_before(
        &mut self,
        type_: pugi_xml_node_type,
        node: *const pugi_xml_node,
    ) -> pugi_xml_node {
        pugi_xml_node_insert_child_before(self, type_, node)
    }
    #[inline]
    pub unsafe fn append_child1(&mut self, name: *const pugi_char_t) -> pugi_xml_node {
        pugi_xml_node_append_child1(self, name)
    }
    #[inline]
    pub unsafe fn prepend_child1(&mut self, name: *const pugi_char_t) -> pugi_xml_node {
        pugi_xml_node_prepend_child1(self, name)
    }
    #[inline]
    pub unsafe fn insert_child_after1(
        &mut self,
        name: *const pugi_char_t,
        node: *const pugi_xml_node,
    ) -> pugi_xml_node {
        pugi_xml_node_insert_child_after1(self, name, node)
    }
    #[inline]
    pub unsafe fn insert_child_before1(
        &mut self,
        name: *const pugi_char_t,
        node: *const pugi_xml_node,
    ) -> pugi_xml_node {
        pugi_xml_node_insert_child_before1(self, name, node)
    }
    #[inline]
    pub unsafe fn append_copy1(&mut self, proto: *const pugi_xml_node) -> pugi_xml_node {
        pugi_xml_node_append_copy1(self, proto)
    }
    #[inline]
    pub unsafe fn prepend_copy1(&mut self, proto: *const pugi_xml_node) -> pugi_xml_node {
        pugi_xml_node_prepend_copy1(self, proto)
    }
    #[inline]
    pub unsafe fn insert_copy_after1(
        &mut self,
        proto: *const pugi_xml_node,
        node: *const pugi_xml_node,
    ) -> pugi_xml_node {
        pugi_xml_node_insert_copy_after1(self, proto, node)
    }
    #[inline]
    pub unsafe fn insert_copy_before1(
        &mut self,
        proto: *const pugi_xml_node,
        node: *const pugi_xml_node,
    ) -> pugi_xml_node {
        pugi_xml_node_insert_copy_before1(self, proto, node)
    }
    #[inline]
    pub unsafe fn remove_attribute(&mut self, a: *const pugi_xml_attribute) -> bool {
        pugi_xml_node_remove_attribute(self, a)
    }
    #[inline]
    pub unsafe fn remove_attribute1(&mut self, name: *const pugi_char_t) -> bool {
        pugi_xml_node_remove_attribute1(self, name)
    }
    #[inline]
    pub unsafe fn remove_child(&mut self, n: *const pugi_xml_node) -> bool {
        pugi_xml_node_remove_child(self, n)
    }
    #[inline]
    pub unsafe fn remove_child1(&mut self, name: *const pugi_char_t) -> bool {
        pugi_xml_node_remove_child1(self, name)
    }
    #[inline]
    pub unsafe fn find_child_by_attribute(
        &self,
        name: *const pugi_char_t,
        attr_name: *const pugi_char_t,
        attr_value: *const pugi_char_t,
    ) -> pugi_xml_node {
        pugi_xml_node_find_child_by_attribute(self, name, attr_name, attr_value)
    }
    #[inline]
    pub unsafe fn find_child_by_attribute1(
        &self,
        attr_name: *const pugi_char_t,
        attr_value: *const pugi_char_t,
    ) -> pugi_xml_node {
        pugi_xml_node_find_child_by_attribute1(self, attr_name, attr_value)
    }
    #[inline]
    pub unsafe fn path(&self, delimiter: pugi_char_t) -> pugi_string_t {
        pugi_xml_node_path(self, delimiter)
    }
    #[inline]
    pub unsafe fn first_element_by_path(
        &self,
        path: *const pugi_char_t,
        delimiter: pugi_char_t,
    ) -> pugi_xml_node {
        pugi_xml_node_first_element_by_path(self, path, delimiter)
    }
    #[inline]
    pub unsafe fn traverse(&mut self, walker: *mut pugi_xml_tree_walker) -> bool {
        pugi_xml_node_traverse(self, walker)
    }
    #[inline]
    pub unsafe fn select_single_node(
        &self,
        query: *const pugi_char_t,
        variables: *mut pugi_xpath_variable_set,
    ) -> pugi_xpath_node {
        pugi_xml_node_select_single_node(self, query, variables)
    }
    #[inline]
    pub unsafe fn select_single_node1(&self, query: *const pugi_xpath_query) -> pugi_xpath_node {
        pugi_xml_node_select_single_node1(self, query)
    }
    #[inline]
    pub unsafe fn select_nodes(
        &self,
        query: *const pugi_char_t,
        variables: *mut pugi_xpath_variable_set,
    ) -> pugi_xpath_node_set {
        pugi_xml_node_select_nodes(self, query, variables)
    }
    #[inline]
    pub unsafe fn select_nodes1(&self, query: *const pugi_xpath_query) -> pugi_xpath_node_set {
        pugi_xml_node_select_nodes1(self, query)
    }
    #[inline]
    pub unsafe fn print(
        &self,
        writer: *mut pugi_xml_writer,
        indent: *const pugi_char_t,
        flags: ::std::os::raw::c_uint,
        encoding: pugi_xml_encoding,
        depth: ::std::os::raw::c_uint,
    ) {
        pugi_xml_node_print(self, writer, indent, flags, encoding, depth)
    }
    #[inline]
    pub unsafe fn print1(
        &self,
        os: *mut u8,
        indent: *const pugi_char_t,
        flags: ::std::os::raw::c_uint,
        encoding: pugi_xml_encoding,
        depth: ::std::os::raw::c_uint,
    ) {
        pugi_xml_node_print1(self, os, indent, flags, encoding, depth)
    }
    #[inline]
    pub unsafe fn print2(
        &self,
        os: *mut u8,
        indent: *const pugi_char_t,
        flags: ::std::os::raw::c_uint,
        depth: ::std::os::raw::c_uint,
    ) {
        pugi_xml_node_print2(self, os, indent, flags, depth)
    }
    #[inline]
    pub unsafe fn begin(&self) -> pugi_xml_node_iterator {
        pugi_xml_node_begin(self)
    }
    #[inline]
    pub unsafe fn end(&self) -> pugi_xml_node_iterator {
        pugi_xml_node_end(self)
    }
    #[inline]
    pub unsafe fn attributes_begin(&self) -> pugi_xml_node_attribute_iterator {
        pugi_xml_node_attributes_begin(self)
    }
    #[inline]
    pub unsafe fn attributes_end(&self) -> pugi_xml_node_attribute_iterator {
        pugi_xml_node_attributes_end(self)
    }
    #[inline]
    pub unsafe fn children(&self) -> pugi_xml_object_range<pugi_xml_node_iterator> {
        pugi_xml_node_children(self)
    }
    #[inline]
    pub unsafe fn children1(
        &self,
        name: *const pugi_char_t,
    ) -> pugi_xml_object_range<pugi_xml_named_node_iterator> {
        pugi_xml_node_children1(self, name)
    }
    #[inline]
    pub unsafe fn attributes(&self) -> pugi_xml_object_range<pugi_xml_attribute_iterator> {
        pugi_xml_node_attributes(self)
    }
    #[inline]
    pub unsafe fn offset_debug(&self) -> isize {
        pugi_xml_node_offset_debug(self)
    }
    #[inline]
    pub unsafe fn hash_value(&self) -> size_t {
        pugi_xml_node_hash_value(self)
    }
    #[inline]
    pub unsafe fn internal_object(&self) -> *mut pugi_xml_node_struct {
        pugi_xml_node_internal_object(self)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        pugi_xml_node_xml_node(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new1(p: *mut pugi_xml_node_struct) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        pugi_xml_node_xml_node1(__bindgen_tmp.as_mut_ptr(), p);
        __bindgen_tmp.assume_init()
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pugi_xml_text {
    pub _root: *mut pugi_xml_node_struct,
}
pub type pugi_xml_text_unspecified_bool_type =
    ::std::option::Option<unsafe extern "C" fn(arg1: *mut *mut *mut pugi_xml_text)>;
#[test]
fn bindgen_test_layout_pugi_xml_text() {
    assert_eq!(
        ::std::mem::size_of::<pugi_xml_text>(),
        8usize,
        concat!("Size of: ", stringify!(pugi_xml_text))
    );
    assert_eq!(
        ::std::mem::align_of::<pugi_xml_text>(),
        8usize,
        concat!("Alignment of ", stringify!(pugi_xml_text))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pugi_xml_text>()))._root as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pugi_xml_text),
            "::",
            stringify!(_root)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}?empty@xml_text@pugi@@QEBA_NXZ"]
    pub fn pugi_xml_text_empty(this: *const pugi_xml_text) -> bool;
}
extern "C" {
    #[link_name = "\u{1}?get@xml_text@pugi@@QEBAPEBDXZ"]
    pub fn pugi_xml_text_get(this: *const pugi_xml_text) -> *const pugi_char_t;
}
extern "C" {
    #[link_name = "\u{1}?as_string@xml_text@pugi@@QEBAPEBDPEBD@Z"]
    pub fn pugi_xml_text_as_string(
        this: *const pugi_xml_text,
        def: *const pugi_char_t,
    ) -> *const pugi_char_t;
}
extern "C" {
    #[link_name = "\u{1}?as_int@xml_text@pugi@@QEBAHH@Z"]
    pub fn pugi_xml_text_as_int(
        this: *const pugi_xml_text,
        def: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}?as_uint@xml_text@pugi@@QEBAII@Z"]
    pub fn pugi_xml_text_as_uint(
        this: *const pugi_xml_text,
        def: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[link_name = "\u{1}?as_double@xml_text@pugi@@QEBANN@Z"]
    pub fn pugi_xml_text_as_double(this: *const pugi_xml_text, def: f64) -> f64;
}
extern "C" {
    #[link_name = "\u{1}?as_float@xml_text@pugi@@QEBAMM@Z"]
    pub fn pugi_xml_text_as_float(this: *const pugi_xml_text, def: f32) -> f32;
}
extern "C" {
    #[link_name = "\u{1}?as_bool@xml_text@pugi@@QEBA_N_N@Z"]
    pub fn pugi_xml_text_as_bool(this: *const pugi_xml_text, def: bool) -> bool;
}
extern "C" {
    #[link_name = "\u{1}?set@xml_text@pugi@@QEAA_NPEBD@Z"]
    pub fn pugi_xml_text_set(this: *mut pugi_xml_text, rhs: *const pugi_char_t) -> bool;
}
extern "C" {
    #[link_name = "\u{1}?set@xml_text@pugi@@QEAA_NH@Z"]
    pub fn pugi_xml_text_set1(this: *mut pugi_xml_text, rhs: ::std::os::raw::c_int) -> bool;
}
extern "C" {
    #[link_name = "\u{1}?set@xml_text@pugi@@QEAA_NI@Z"]
    pub fn pugi_xml_text_set2(this: *mut pugi_xml_text, rhs: ::std::os::raw::c_uint) -> bool;
}
extern "C" {
    #[link_name = "\u{1}?set@xml_text@pugi@@QEAA_NN@Z"]
    pub fn pugi_xml_text_set3(this: *mut pugi_xml_text, rhs: f64) -> bool;
}
extern "C" {
    #[link_name = "\u{1}?set@xml_text@pugi@@QEAA_N_N@Z"]
    pub fn pugi_xml_text_set4(this: *mut pugi_xml_text, rhs: bool) -> bool;
}
extern "C" {
    #[link_name = "\u{1}?data@xml_text@pugi@@QEBA?AVxml_node@2@XZ"]
    pub fn pugi_xml_text_data(this: *const pugi_xml_text) -> pugi_xml_node;
}
extern "C" {
    #[link_name = "\u{1}??0xml_text@pugi@@QEAA@XZ"]
    pub fn pugi_xml_text_xml_text(this: *mut pugi_xml_text);
}
impl pugi_xml_text {
    #[inline]
    pub unsafe fn empty(&self) -> bool {
        pugi_xml_text_empty(self)
    }
    #[inline]
    pub unsafe fn get(&self) -> *const pugi_char_t {
        pugi_xml_text_get(self)
    }
    #[inline]
    pub unsafe fn as_string(&self, def: *const pugi_char_t) -> *const pugi_char_t {
        pugi_xml_text_as_string(self, def)
    }
    #[inline]
    pub unsafe fn as_int(&self, def: ::std::os::raw::c_int) -> ::std::os::raw::c_int {
        pugi_xml_text_as_int(self, def)
    }
    #[inline]
    pub unsafe fn as_uint(&self, def: ::std::os::raw::c_uint) -> ::std::os::raw::c_uint {
        pugi_xml_text_as_uint(self, def)
    }
    #[inline]
    pub unsafe fn as_double(&self, def: f64) -> f64 {
        pugi_xml_text_as_double(self, def)
    }
    #[inline]
    pub unsafe fn as_float(&self, def: f32) -> f32 {
        pugi_xml_text_as_float(self, def)
    }
    #[inline]
    pub unsafe fn as_bool(&self, def: bool) -> bool {
        pugi_xml_text_as_bool(self, def)
    }
    #[inline]
    pub unsafe fn set(&mut self, rhs: *const pugi_char_t) -> bool {
        pugi_xml_text_set(self, rhs)
    }
    #[inline]
    pub unsafe fn set1(&mut self, rhs: ::std::os::raw::c_int) -> bool {
        pugi_xml_text_set1(self, rhs)
    }
    #[inline]
    pub unsafe fn set2(&mut self, rhs: ::std::os::raw::c_uint) -> bool {
        pugi_xml_text_set2(self, rhs)
    }
    #[inline]
    pub unsafe fn set3(&mut self, rhs: f64) -> bool {
        pugi_xml_text_set3(self, rhs)
    }
    #[inline]
    pub unsafe fn set4(&mut self, rhs: bool) -> bool {
        pugi_xml_text_set4(self, rhs)
    }
    #[inline]
    pub unsafe fn data(&self) -> pugi_xml_node {
        pugi_xml_text_data(self)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        pugi_xml_text_xml_text(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pugi_xml_node_iterator {
    pub _wrap: pugi_xml_node,
    pub _parent: pugi_xml_node,
}
pub type pugi_xml_node_iterator_difference_type = isize;
pub type pugi_xml_node_iterator_value_type = pugi_xml_node;
pub type pugi_xml_node_iterator_pointer = *mut pugi_xml_node;
pub type pugi_xml_node_iterator_reference = *mut pugi_xml_node;
pub type pugi_xml_node_iterator_iterator_category = std_bidirectional_iterator_tag;
#[test]
fn bindgen_test_layout_pugi_xml_node_iterator() {
    assert_eq!(
        ::std::mem::size_of::<pugi_xml_node_iterator>(),
        16usize,
        concat!("Size of: ", stringify!(pugi_xml_node_iterator))
    );
    assert_eq!(
        ::std::mem::align_of::<pugi_xml_node_iterator>(),
        8usize,
        concat!("Alignment of ", stringify!(pugi_xml_node_iterator))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pugi_xml_node_iterator>()))._wrap as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pugi_xml_node_iterator),
            "::",
            stringify!(_wrap)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pugi_xml_node_iterator>()))._parent as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(pugi_xml_node_iterator),
            "::",
            stringify!(_parent)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}??0xml_node_iterator@pugi@@QEAA@XZ"]
    pub fn pugi_xml_node_iterator_xml_node_iterator(this: *mut pugi_xml_node_iterator);
}
extern "C" {
    #[link_name = "\u{1}??0xml_node_iterator@pugi@@QEAA@AEBVxml_node@1@@Z"]
    pub fn pugi_xml_node_iterator_xml_node_iterator1(
        this: *mut pugi_xml_node_iterator,
        node: *const pugi_xml_node,
    );
}
impl pugi_xml_node_iterator {
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        pugi_xml_node_iterator_xml_node_iterator(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new1(node: *const pugi_xml_node) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        pugi_xml_node_iterator_xml_node_iterator1(__bindgen_tmp.as_mut_ptr(), node);
        __bindgen_tmp.assume_init()
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pugi_xml_attribute_iterator {
    pub _wrap: pugi_xml_attribute,
    pub _parent: pugi_xml_node,
}
pub type pugi_xml_attribute_iterator_difference_type = isize;
pub type pugi_xml_attribute_iterator_value_type = pugi_xml_attribute;
pub type pugi_xml_attribute_iterator_pointer = *mut pugi_xml_attribute;
pub type pugi_xml_attribute_iterator_reference = *mut pugi_xml_attribute;
pub type pugi_xml_attribute_iterator_iterator_category = std_bidirectional_iterator_tag;
#[test]
fn bindgen_test_layout_pugi_xml_attribute_iterator() {
    assert_eq!(
        ::std::mem::size_of::<pugi_xml_attribute_iterator>(),
        16usize,
        concat!("Size of: ", stringify!(pugi_xml_attribute_iterator))
    );
    assert_eq!(
        ::std::mem::align_of::<pugi_xml_attribute_iterator>(),
        8usize,
        concat!("Alignment of ", stringify!(pugi_xml_attribute_iterator))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<pugi_xml_attribute_iterator>()))._wrap as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pugi_xml_attribute_iterator),
            "::",
            stringify!(_wrap)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<pugi_xml_attribute_iterator>()))._parent as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(pugi_xml_attribute_iterator),
            "::",
            stringify!(_parent)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}??0xml_attribute_iterator@pugi@@QEAA@XZ"]
    pub fn pugi_xml_attribute_iterator_xml_attribute_iterator(
        this: *mut pugi_xml_attribute_iterator,
    );
}
extern "C" {
    #[link_name = "\u{1}??0xml_attribute_iterator@pugi@@QEAA@AEBVxml_attribute@1@AEBVxml_node@1@@Z"]
    pub fn pugi_xml_attribute_iterator_xml_attribute_iterator1(
        this: *mut pugi_xml_attribute_iterator,
        attr: *const pugi_xml_attribute,
        parent: *const pugi_xml_node,
    );
}
impl pugi_xml_attribute_iterator {
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        pugi_xml_attribute_iterator_xml_attribute_iterator(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new1(attr: *const pugi_xml_attribute, parent: *const pugi_xml_node) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        pugi_xml_attribute_iterator_xml_attribute_iterator1(
            __bindgen_tmp.as_mut_ptr(),
            attr,
            parent,
        );
        __bindgen_tmp.assume_init()
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pugi_xml_named_node_iterator {
    pub _node: pugi_xml_node,
    pub _name: *const pugi_char_t,
}
pub type pugi_xml_named_node_iterator_difference_type = isize;
pub type pugi_xml_named_node_iterator_value_type = pugi_xml_node;
pub type pugi_xml_named_node_iterator_pointer = *mut pugi_xml_node;
pub type pugi_xml_named_node_iterator_reference = *mut pugi_xml_node;
pub type pugi_xml_named_node_iterator_iterator_category = std_forward_iterator_tag;
#[test]
fn bindgen_test_layout_pugi_xml_named_node_iterator() {
    assert_eq!(
        ::std::mem::size_of::<pugi_xml_named_node_iterator>(),
        16usize,
        concat!("Size of: ", stringify!(pugi_xml_named_node_iterator))
    );
    assert_eq!(
        ::std::mem::align_of::<pugi_xml_named_node_iterator>(),
        8usize,
        concat!("Alignment of ", stringify!(pugi_xml_named_node_iterator))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<pugi_xml_named_node_iterator>()))._node as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pugi_xml_named_node_iterator),
            "::",
            stringify!(_node)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<pugi_xml_named_node_iterator>()))._name as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(pugi_xml_named_node_iterator),
            "::",
            stringify!(_name)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}??0xml_named_node_iterator@pugi@@QEAA@XZ"]
    pub fn pugi_xml_named_node_iterator_xml_named_node_iterator(
        this: *mut pugi_xml_named_node_iterator,
    );
}
extern "C" {
    #[link_name = "\u{1}??0xml_named_node_iterator@pugi@@QEAA@AEBVxml_node@1@PEBD@Z"]
    pub fn pugi_xml_named_node_iterator_xml_named_node_iterator1(
        this: *mut pugi_xml_named_node_iterator,
        node: *const pugi_xml_node,
        name: *const pugi_char_t,
    );
}
impl pugi_xml_named_node_iterator {
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        pugi_xml_named_node_iterator_xml_named_node_iterator(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new1(node: *const pugi_xml_node, name: *const pugi_char_t) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        pugi_xml_named_node_iterator_xml_named_node_iterator1(
            __bindgen_tmp.as_mut_ptr(),
            node,
            name,
        );
        __bindgen_tmp.assume_init()
    }
}
#[repr(C)]
pub struct pugi_xml_tree_walker__bindgen_vtable(::std::os::raw::c_void);
#[repr(C)]
#[derive(Debug)]
pub struct pugi_xml_tree_walker {
    pub vtable_: *const pugi_xml_tree_walker__bindgen_vtable,
    pub _depth: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_pugi_xml_tree_walker() {
    assert_eq!(
        ::std::mem::size_of::<pugi_xml_tree_walker>(),
        16usize,
        concat!("Size of: ", stringify!(pugi_xml_tree_walker))
    );
    assert_eq!(
        ::std::mem::align_of::<pugi_xml_tree_walker>(),
        8usize,
        concat!("Alignment of ", stringify!(pugi_xml_tree_walker))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pugi_xml_tree_walker>()))._depth as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(pugi_xml_tree_walker),
            "::",
            stringify!(_depth)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}?depth@xml_tree_walker@pugi@@IEBAHXZ"]
    pub fn pugi_xml_tree_walker_depth(this: *const pugi_xml_tree_walker) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}??0xml_tree_walker@pugi@@QEAA@XZ"]
    pub fn pugi_xml_tree_walker_xml_tree_walker(this: *mut pugi_xml_tree_walker);
}
impl pugi_xml_tree_walker {
    #[inline]
    pub unsafe fn depth(&self) -> ::std::os::raw::c_int {
        pugi_xml_tree_walker_depth(self)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        pugi_xml_tree_walker_xml_tree_walker(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
}
extern "C" {
    #[link_name = "\u{1}??_Dxml_tree_walker@pugi@@QEAAXXZ"]
    pub fn pugi_xml_tree_walker_xml_tree_walker_destructor(this: *mut pugi_xml_tree_walker);
}
extern "C" {
    #[link_name = "\u{1}?begin@xml_tree_walker@pugi@@UEAA_NAEAVxml_node@2@@Z"]
    pub fn pugi_xml_tree_walker_begin(
        this: *mut ::std::os::raw::c_void,
        node: *mut pugi_xml_node,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}?end@xml_tree_walker@pugi@@UEAA_NAEAVxml_node@2@@Z"]
    pub fn pugi_xml_tree_walker_end(
        this: *mut ::std::os::raw::c_void,
        node: *mut pugi_xml_node,
    ) -> bool;
}
pub const pugi_xml_parse_status_status_ok: pugi_xml_parse_status = 0;
pub const pugi_xml_parse_status_status_file_not_found: pugi_xml_parse_status = 1;
pub const pugi_xml_parse_status_status_io_error: pugi_xml_parse_status = 2;
pub const pugi_xml_parse_status_status_out_of_memory: pugi_xml_parse_status = 3;
pub const pugi_xml_parse_status_status_internal_error: pugi_xml_parse_status = 4;
pub const pugi_xml_parse_status_status_unrecognized_tag: pugi_xml_parse_status = 5;
pub const pugi_xml_parse_status_status_bad_pi: pugi_xml_parse_status = 6;
pub const pugi_xml_parse_status_status_bad_comment: pugi_xml_parse_status = 7;
pub const pugi_xml_parse_status_status_bad_cdata: pugi_xml_parse_status = 8;
pub const pugi_xml_parse_status_status_bad_doctype: pugi_xml_parse_status = 9;
pub const pugi_xml_parse_status_status_bad_pcdata: pugi_xml_parse_status = 10;
pub const pugi_xml_parse_status_status_bad_start_element: pugi_xml_parse_status = 11;
pub const pugi_xml_parse_status_status_bad_attribute: pugi_xml_parse_status = 12;
pub const pugi_xml_parse_status_status_bad_end_element: pugi_xml_parse_status = 13;
pub const pugi_xml_parse_status_status_end_element_mismatch: pugi_xml_parse_status = 14;
pub type pugi_xml_parse_status = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pugi_xml_parse_result {
    pub status: pugi_xml_parse_status,
    pub offset: isize,
    pub encoding: pugi_xml_encoding,
}
#[test]
fn bindgen_test_layout_pugi_xml_parse_result() {
    assert_eq!(
        ::std::mem::size_of::<pugi_xml_parse_result>(),
        24usize,
        concat!("Size of: ", stringify!(pugi_xml_parse_result))
    );
    assert_eq!(
        ::std::mem::align_of::<pugi_xml_parse_result>(),
        8usize,
        concat!("Alignment of ", stringify!(pugi_xml_parse_result))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pugi_xml_parse_result>())).status as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pugi_xml_parse_result),
            "::",
            stringify!(status)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pugi_xml_parse_result>())).offset as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(pugi_xml_parse_result),
            "::",
            stringify!(offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pugi_xml_parse_result>())).encoding as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(pugi_xml_parse_result),
            "::",
            stringify!(encoding)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}?description@xml_parse_result@pugi@@QEBAPEBDXZ"]
    pub fn pugi_xml_parse_result_description(
        this: *const pugi_xml_parse_result,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}??0xml_parse_result@pugi@@QEAA@XZ"]
    pub fn pugi_xml_parse_result_xml_parse_result(this: *mut pugi_xml_parse_result);
}
impl pugi_xml_parse_result {
    #[inline]
    pub unsafe fn description(&self) -> *const ::std::os::raw::c_char {
        pugi_xml_parse_result_description(self)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        pugi_xml_parse_result_xml_parse_result(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct pugi_xml_document {
    pub _base: pugi_xml_node,
    pub _buffer: *mut pugi_char_t,
    pub _memory: [::std::os::raw::c_char; 192usize],
}
#[test]
fn bindgen_test_layout_pugi_xml_document() {
    assert_eq!(
        ::std::mem::size_of::<pugi_xml_document>(),
        208usize,
        concat!("Size of: ", stringify!(pugi_xml_document))
    );
    assert_eq!(
        ::std::mem::align_of::<pugi_xml_document>(),
        8usize,
        concat!("Alignment of ", stringify!(pugi_xml_document))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pugi_xml_document>()))._buffer as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(pugi_xml_document),
            "::",
            stringify!(_buffer)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pugi_xml_document>()))._memory as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(pugi_xml_document),
            "::",
            stringify!(_memory)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}?reset@xml_document@pugi@@QEAAXXZ"]
    pub fn pugi_xml_document_reset(this: *mut pugi_xml_document);
}
extern "C" {
    #[link_name = "\u{1}?reset@xml_document@pugi@@QEAAXAEBV12@@Z"]
    pub fn pugi_xml_document_reset1(this: *mut pugi_xml_document, proto: *const pugi_xml_document);
}
extern "C" {
    #[link_name = "\u{1}?load@xml_document@pugi@@QEAA?AUxml_parse_result@2@AEAV?$basic_istream@DU?$char_traits@D@std@@@std@@IW4xml_encoding@2@@Z"]
    pub fn pugi_xml_document_load(
        this: *mut pugi_xml_document,
        stream: *mut u8,
        options: ::std::os::raw::c_uint,
        encoding: pugi_xml_encoding,
    ) -> pugi_xml_parse_result;
}
extern "C" {
    #[link_name = "\u{1}?load@xml_document@pugi@@QEAA?AUxml_parse_result@2@AEAV?$basic_istream@_WU?$char_traits@_W@std@@@std@@I@Z"]
    pub fn pugi_xml_document_load1(
        this: *mut pugi_xml_document,
        stream: *mut u8,
        options: ::std::os::raw::c_uint,
    ) -> pugi_xml_parse_result;
}
extern "C" {
    #[link_name = "\u{1}?load@xml_document@pugi@@QEAA?AUxml_parse_result@2@PEBDI@Z"]
    pub fn pugi_xml_document_load2(
        this: *mut pugi_xml_document,
        contents: *const pugi_char_t,
        options: ::std::os::raw::c_uint,
    ) -> pugi_xml_parse_result;
}
extern "C" {
    #[link_name = "\u{1}?load_file@xml_document@pugi@@QEAA?AUxml_parse_result@2@PEBDIW4xml_encoding@2@@Z"]
    pub fn pugi_xml_document_load_file(
        this: *mut pugi_xml_document,
        path: *const ::std::os::raw::c_char,
        options: ::std::os::raw::c_uint,
        encoding: pugi_xml_encoding,
    ) -> pugi_xml_parse_result;
}
extern "C" {
    #[link_name = "\u{1}?load_file@xml_document@pugi@@QEAA?AUxml_parse_result@2@PEB_WIW4xml_encoding@2@@Z"]
    pub fn pugi_xml_document_load_file1(
        this: *mut pugi_xml_document,
        path: *const u16,
        options: ::std::os::raw::c_uint,
        encoding: pugi_xml_encoding,
    ) -> pugi_xml_parse_result;
}
extern "C" {
    #[link_name = "\u{1}?load_buffer@xml_document@pugi@@QEAA?AUxml_parse_result@2@PEBX_KIW4xml_encoding@2@@Z"]
    pub fn pugi_xml_document_load_buffer(
        this: *mut pugi_xml_document,
        contents: *const ::std::os::raw::c_void,
        size: size_t,
        options: ::std::os::raw::c_uint,
        encoding: pugi_xml_encoding,
    ) -> pugi_xml_parse_result;
}
extern "C" {
    #[link_name = "\u{1}?load_buffer_inplace@xml_document@pugi@@QEAA?AUxml_parse_result@2@PEAX_KIW4xml_encoding@2@@Z"]
    pub fn pugi_xml_document_load_buffer_inplace(
        this: *mut pugi_xml_document,
        contents: *mut ::std::os::raw::c_void,
        size: size_t,
        options: ::std::os::raw::c_uint,
        encoding: pugi_xml_encoding,
    ) -> pugi_xml_parse_result;
}
extern "C" {
    #[link_name = "\u{1}?load_buffer_inplace_own@xml_document@pugi@@QEAA?AUxml_parse_result@2@PEAX_KIW4xml_encoding@2@@Z"]
    pub fn pugi_xml_document_load_buffer_inplace_own(
        this: *mut pugi_xml_document,
        contents: *mut ::std::os::raw::c_void,
        size: size_t,
        options: ::std::os::raw::c_uint,
        encoding: pugi_xml_encoding,
    ) -> pugi_xml_parse_result;
}
extern "C" {
    #[link_name = "\u{1}?save@xml_document@pugi@@QEBAXAEAVxml_writer@2@PEBDIW4xml_encoding@2@@Z"]
    pub fn pugi_xml_document_save(
        this: *const pugi_xml_document,
        writer: *mut pugi_xml_writer,
        indent: *const pugi_char_t,
        flags: ::std::os::raw::c_uint,
        encoding: pugi_xml_encoding,
    );
}
extern "C" {
    #[link_name = "\u{1}?save@xml_document@pugi@@QEBAXAEAV?$basic_ostream@DU?$char_traits@D@std@@@std@@PEBDIW4xml_encoding@2@@Z"]
    pub fn pugi_xml_document_save1(
        this: *const pugi_xml_document,
        stream: *mut u8,
        indent: *const pugi_char_t,
        flags: ::std::os::raw::c_uint,
        encoding: pugi_xml_encoding,
    );
}
extern "C" {
    #[link_name = "\u{1}?save@xml_document@pugi@@QEBAXAEAV?$basic_ostream@_WU?$char_traits@_W@std@@@std@@PEBDI@Z"]
    pub fn pugi_xml_document_save2(
        this: *const pugi_xml_document,
        stream: *mut u8,
        indent: *const pugi_char_t,
        flags: ::std::os::raw::c_uint,
    );
}
extern "C" {
    #[link_name = "\u{1}?save_file@xml_document@pugi@@QEBA_NPEBD0IW4xml_encoding@2@@Z"]
    pub fn pugi_xml_document_save_file(
        this: *const pugi_xml_document,
        path: *const ::std::os::raw::c_char,
        indent: *const pugi_char_t,
        flags: ::std::os::raw::c_uint,
        encoding: pugi_xml_encoding,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}?save_file@xml_document@pugi@@QEBA_NPEB_WPEBDIW4xml_encoding@2@@Z"]
    pub fn pugi_xml_document_save_file1(
        this: *const pugi_xml_document,
        path: *const u16,
        indent: *const pugi_char_t,
        flags: ::std::os::raw::c_uint,
        encoding: pugi_xml_encoding,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}?document_element@xml_document@pugi@@QEBA?AVxml_node@2@XZ"]
    pub fn pugi_xml_document_document_element(this: *const pugi_xml_document) -> pugi_xml_node;
}
extern "C" {
    #[link_name = "\u{1}??0xml_document@pugi@@QEAA@XZ"]
    pub fn pugi_xml_document_xml_document(this: *mut pugi_xml_document);
}
extern "C" {
    #[link_name = "\u{1}??_Dxml_document@pugi@@QEAAXXZ"]
    pub fn pugi_xml_document_xml_document_destructor(this: *mut pugi_xml_document);
}
impl pugi_xml_document {
    #[inline]
    pub unsafe fn reset(&mut self) {
        pugi_xml_document_reset(self)
    }
    #[inline]
    pub unsafe fn reset1(&mut self, proto: *const pugi_xml_document) {
        pugi_xml_document_reset1(self, proto)
    }
    #[inline]
    pub unsafe fn load(
        &mut self,
        stream: *mut u8,
        options: ::std::os::raw::c_uint,
        encoding: pugi_xml_encoding,
    ) -> pugi_xml_parse_result {
        pugi_xml_document_load(self, stream, options, encoding)
    }
    #[inline]
    pub unsafe fn load1(
        &mut self,
        stream: *mut u8,
        options: ::std::os::raw::c_uint,
    ) -> pugi_xml_parse_result {
        pugi_xml_document_load1(self, stream, options)
    }
    #[inline]
    pub unsafe fn load2(
        &mut self,
        contents: *const pugi_char_t,
        options: ::std::os::raw::c_uint,
    ) -> pugi_xml_parse_result {
        pugi_xml_document_load2(self, contents, options)
    }
    #[inline]
    pub unsafe fn load_file(
        &mut self,
        path: *const ::std::os::raw::c_char,
        options: ::std::os::raw::c_uint,
        encoding: pugi_xml_encoding,
    ) -> pugi_xml_parse_result {
        pugi_xml_document_load_file(self, path, options, encoding)
    }
    #[inline]
    pub unsafe fn load_file1(
        &mut self,
        path: *const u16,
        options: ::std::os::raw::c_uint,
        encoding: pugi_xml_encoding,
    ) -> pugi_xml_parse_result {
        pugi_xml_document_load_file1(self, path, options, encoding)
    }
    #[inline]
    pub unsafe fn load_buffer(
        &mut self,
        contents: *const ::std::os::raw::c_void,
        size: size_t,
        options: ::std::os::raw::c_uint,
        encoding: pugi_xml_encoding,
    ) -> pugi_xml_parse_result {
        pugi_xml_document_load_buffer(self, contents, size, options, encoding)
    }
    #[inline]
    pub unsafe fn load_buffer_inplace(
        &mut self,
        contents: *mut ::std::os::raw::c_void,
        size: size_t,
        options: ::std::os::raw::c_uint,
        encoding: pugi_xml_encoding,
    ) -> pugi_xml_parse_result {
        pugi_xml_document_load_buffer_inplace(self, contents, size, options, encoding)
    }
    #[inline]
    pub unsafe fn load_buffer_inplace_own(
        &mut self,
        contents: *mut ::std::os::raw::c_void,
        size: size_t,
        options: ::std::os::raw::c_uint,
        encoding: pugi_xml_encoding,
    ) -> pugi_xml_parse_result {
        pugi_xml_document_load_buffer_inplace_own(self, contents, size, options, encoding)
    }
    #[inline]
    pub unsafe fn save(
        &self,
        writer: *mut pugi_xml_writer,
        indent: *const pugi_char_t,
        flags: ::std::os::raw::c_uint,
        encoding: pugi_xml_encoding,
    ) {
        pugi_xml_document_save(self, writer, indent, flags, encoding)
    }
    #[inline]
    pub unsafe fn save1(
        &self,
        stream: *mut u8,
        indent: *const pugi_char_t,
        flags: ::std::os::raw::c_uint,
        encoding: pugi_xml_encoding,
    ) {
        pugi_xml_document_save1(self, stream, indent, flags, encoding)
    }
    #[inline]
    pub unsafe fn save2(
        &self,
        stream: *mut u8,
        indent: *const pugi_char_t,
        flags: ::std::os::raw::c_uint,
    ) {
        pugi_xml_document_save2(self, stream, indent, flags)
    }
    #[inline]
    pub unsafe fn save_file(
        &self,
        path: *const ::std::os::raw::c_char,
        indent: *const pugi_char_t,
        flags: ::std::os::raw::c_uint,
        encoding: pugi_xml_encoding,
    ) -> bool {
        pugi_xml_document_save_file(self, path, indent, flags, encoding)
    }
    #[inline]
    pub unsafe fn save_file1(
        &self,
        path: *const u16,
        indent: *const pugi_char_t,
        flags: ::std::os::raw::c_uint,
        encoding: pugi_xml_encoding,
    ) -> bool {
        pugi_xml_document_save_file1(self, path, indent, flags, encoding)
    }
    #[inline]
    pub unsafe fn document_element(&self) -> pugi_xml_node {
        pugi_xml_document_document_element(self)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        pugi_xml_document_xml_document(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn destruct(&mut self) {
        pugi_xml_document_xml_document_destructor(self)
    }
}
pub const pugi_xpath_value_type_xpath_type_none: pugi_xpath_value_type = 0;
pub const pugi_xpath_value_type_xpath_type_node_set: pugi_xpath_value_type = 1;
pub const pugi_xpath_value_type_xpath_type_number: pugi_xpath_value_type = 2;
pub const pugi_xpath_value_type_xpath_type_string: pugi_xpath_value_type = 3;
pub const pugi_xpath_value_type_xpath_type_boolean: pugi_xpath_value_type = 4;
pub type pugi_xpath_value_type = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pugi_xpath_parse_result {
    pub error: *const ::std::os::raw::c_char,
    pub offset: isize,
}
#[test]
fn bindgen_test_layout_pugi_xpath_parse_result() {
    assert_eq!(
        ::std::mem::size_of::<pugi_xpath_parse_result>(),
        16usize,
        concat!("Size of: ", stringify!(pugi_xpath_parse_result))
    );
    assert_eq!(
        ::std::mem::align_of::<pugi_xpath_parse_result>(),
        8usize,
        concat!("Alignment of ", stringify!(pugi_xpath_parse_result))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pugi_xpath_parse_result>())).error as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pugi_xpath_parse_result),
            "::",
            stringify!(error)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pugi_xpath_parse_result>())).offset as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(pugi_xpath_parse_result),
            "::",
            stringify!(offset)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}?description@xpath_parse_result@pugi@@QEBAPEBDXZ"]
    pub fn pugi_xpath_parse_result_description(
        this: *const pugi_xpath_parse_result,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}??0xpath_parse_result@pugi@@QEAA@XZ"]
    pub fn pugi_xpath_parse_result_xpath_parse_result(this: *mut pugi_xpath_parse_result);
}
impl pugi_xpath_parse_result {
    #[inline]
    pub unsafe fn description(&self) -> *const ::std::os::raw::c_char {
        pugi_xpath_parse_result_description(self)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        pugi_xpath_parse_result_xpath_parse_result(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pugi_xpath_variable {
    pub _type: pugi_xpath_value_type,
    pub _next: *mut pugi_xpath_variable,
}
#[test]
fn bindgen_test_layout_pugi_xpath_variable() {
    assert_eq!(
        ::std::mem::size_of::<pugi_xpath_variable>(),
        16usize,
        concat!("Size of: ", stringify!(pugi_xpath_variable))
    );
    assert_eq!(
        ::std::mem::align_of::<pugi_xpath_variable>(),
        8usize,
        concat!("Alignment of ", stringify!(pugi_xpath_variable))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pugi_xpath_variable>()))._type as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pugi_xpath_variable),
            "::",
            stringify!(_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pugi_xpath_variable>()))._next as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(pugi_xpath_variable),
            "::",
            stringify!(_next)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}?name@xpath_variable@pugi@@QEBAPEBDXZ"]
    pub fn pugi_xpath_variable_name(this: *const pugi_xpath_variable) -> *const pugi_char_t;
}
extern "C" {
    #[link_name = "\u{1}?type@xpath_variable@pugi@@QEBA?AW4xpath_value_type@2@XZ"]
    pub fn pugi_xpath_variable_type(this: *const pugi_xpath_variable) -> pugi_xpath_value_type;
}
extern "C" {
    #[link_name = "\u{1}?get_boolean@xpath_variable@pugi@@QEBA_NXZ"]
    pub fn pugi_xpath_variable_get_boolean(this: *const pugi_xpath_variable) -> bool;
}
extern "C" {
    #[link_name = "\u{1}?get_number@xpath_variable@pugi@@QEBANXZ"]
    pub fn pugi_xpath_variable_get_number(this: *const pugi_xpath_variable) -> f64;
}
extern "C" {
    #[link_name = "\u{1}?get_string@xpath_variable@pugi@@QEBAPEBDXZ"]
    pub fn pugi_xpath_variable_get_string(this: *const pugi_xpath_variable) -> *const pugi_char_t;
}
extern "C" {
    #[link_name = "\u{1}?get_node_set@xpath_variable@pugi@@QEBAAEBVxpath_node_set@2@XZ"]
    pub fn pugi_xpath_variable_get_node_set(
        this: *const pugi_xpath_variable,
    ) -> *const pugi_xpath_node_set;
}
extern "C" {
    #[link_name = "\u{1}?set@xpath_variable@pugi@@QEAA_N_N@Z"]
    pub fn pugi_xpath_variable_set(this: *mut pugi_xpath_variable, value: bool) -> bool;
}
extern "C" {
    #[link_name = "\u{1}?set@xpath_variable@pugi@@QEAA_NN@Z"]
    pub fn pugi_xpath_variable_set1(this: *mut pugi_xpath_variable, value: f64) -> bool;
}
extern "C" {
    #[link_name = "\u{1}?set@xpath_variable@pugi@@QEAA_NPEBD@Z"]
    pub fn pugi_xpath_variable_set2(
        this: *mut pugi_xpath_variable,
        value: *const pugi_char_t,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}?set@xpath_variable@pugi@@QEAA_NAEBVxpath_node_set@2@@Z"]
    pub fn pugi_xpath_variable_set3(
        this: *mut pugi_xpath_variable,
        value: *const pugi_xpath_node_set,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}??0xpath_variable@pugi@@IEAA@XZ"]
    pub fn pugi_xpath_variable_xpath_variable(this: *mut pugi_xpath_variable);
}
extern "C" {
    #[link_name = "\u{1}??0xpath_variable@pugi@@IEAA@AEBV01@@Z"]
    pub fn pugi_xpath_variable_xpath_variable1(
        this: *mut pugi_xpath_variable,
        arg1: *const pugi_xpath_variable,
    );
}
impl pugi_xpath_variable {
    #[inline]
    pub unsafe fn name(&self) -> *const pugi_char_t {
        pugi_xpath_variable_name(self)
    }
    #[inline]
    pub unsafe fn type_(&self) -> pugi_xpath_value_type {
        pugi_xpath_variable_type(self)
    }
    #[inline]
    pub unsafe fn get_boolean(&self) -> bool {
        pugi_xpath_variable_get_boolean(self)
    }
    #[inline]
    pub unsafe fn get_number(&self) -> f64 {
        pugi_xpath_variable_get_number(self)
    }
    #[inline]
    pub unsafe fn get_string(&self) -> *const pugi_char_t {
        pugi_xpath_variable_get_string(self)
    }
    #[inline]
    pub unsafe fn get_node_set(&self) -> *const pugi_xpath_node_set {
        pugi_xpath_variable_get_node_set(self)
    }
    #[inline]
    pub unsafe fn set(&mut self, value: bool) -> bool {
        pugi_xpath_variable_set(self, value)
    }
    #[inline]
    pub unsafe fn set1(&mut self, value: f64) -> bool {
        pugi_xpath_variable_set1(self, value)
    }
    #[inline]
    pub unsafe fn set2(&mut self, value: *const pugi_char_t) -> bool {
        pugi_xpath_variable_set2(self, value)
    }
    #[inline]
    pub unsafe fn set3(&mut self, value: *const pugi_xpath_node_set) -> bool {
        pugi_xpath_variable_set3(self, value)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        pugi_xpath_variable_xpath_variable(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new1(arg1: *const pugi_xpath_variable) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        pugi_xpath_variable_xpath_variable1(__bindgen_tmp.as_mut_ptr(), arg1);
        __bindgen_tmp.assume_init()
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct pugi_xpath_variable_set {
    pub _data: [*mut pugi_xpath_variable; 64usize],
}
#[test]
fn bindgen_test_layout_pugi_xpath_variable_set() {
    assert_eq!(
        ::std::mem::size_of::<pugi_xpath_variable_set>(),
        512usize,
        concat!("Size of: ", stringify!(pugi_xpath_variable_set))
    );
    assert_eq!(
        ::std::mem::align_of::<pugi_xpath_variable_set>(),
        8usize,
        concat!("Alignment of ", stringify!(pugi_xpath_variable_set))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pugi_xpath_variable_set>()))._data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pugi_xpath_variable_set),
            "::",
            stringify!(_data)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}?add@xpath_variable_set@pugi@@QEAAPEAVxpath_variable@2@PEBDW4xpath_value_type@2@@Z"]
    pub fn pugi_xpath_variable_set_add(
        this: *mut pugi_xpath_variable_set,
        name: *const pugi_char_t,
        type_: pugi_xpath_value_type,
    ) -> *mut pugi_xpath_variable;
}
extern "C" {
    #[link_name = "\u{1}?set@xpath_variable_set@pugi@@QEAA_NPEBD_N@Z"]
    pub fn pugi_xpath_variable_set_set(
        this: *mut pugi_xpath_variable_set,
        name: *const pugi_char_t,
        value: bool,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}?set@xpath_variable_set@pugi@@QEAA_NPEBDN@Z"]
    pub fn pugi_xpath_variable_set_set1(
        this: *mut pugi_xpath_variable_set,
        name: *const pugi_char_t,
        value: f64,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}?set@xpath_variable_set@pugi@@QEAA_NPEBD0@Z"]
    pub fn pugi_xpath_variable_set_set2(
        this: *mut pugi_xpath_variable_set,
        name: *const pugi_char_t,
        value: *const pugi_char_t,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}?set@xpath_variable_set@pugi@@QEAA_NPEBDAEBVxpath_node_set@2@@Z"]
    pub fn pugi_xpath_variable_set_set3(
        this: *mut pugi_xpath_variable_set,
        name: *const pugi_char_t,
        value: *const pugi_xpath_node_set,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}?get@xpath_variable_set@pugi@@QEAAPEAVxpath_variable@2@PEBD@Z"]
    pub fn pugi_xpath_variable_set_get(
        this: *mut pugi_xpath_variable_set,
        name: *const pugi_char_t,
    ) -> *mut pugi_xpath_variable;
}
extern "C" {
    #[link_name = "\u{1}?get@xpath_variable_set@pugi@@QEBAPEBVxpath_variable@2@PEBD@Z"]
    pub fn pugi_xpath_variable_set_get1(
        this: *const pugi_xpath_variable_set,
        name: *const pugi_char_t,
    ) -> *const pugi_xpath_variable;
}
extern "C" {
    #[link_name = "\u{1}??0xpath_variable_set@pugi@@QEAA@XZ"]
    pub fn pugi_xpath_variable_set_xpath_variable_set(this: *mut pugi_xpath_variable_set);
}
extern "C" {
    #[link_name = "\u{1}??_Dxpath_variable_set@pugi@@QEAAXXZ"]
    pub fn pugi_xpath_variable_set_xpath_variable_set_destructor(
        this: *mut pugi_xpath_variable_set,
    );
}
impl pugi_xpath_variable_set {
    #[inline]
    pub unsafe fn add(
        &mut self,
        name: *const pugi_char_t,
        type_: pugi_xpath_value_type,
    ) -> *mut pugi_xpath_variable {
        pugi_xpath_variable_set_add(self, name, type_)
    }
    #[inline]
    pub unsafe fn set(&mut self, name: *const pugi_char_t, value: bool) -> bool {
        pugi_xpath_variable_set_set(self, name, value)
    }
    #[inline]
    pub unsafe fn set1(&mut self, name: *const pugi_char_t, value: f64) -> bool {
        pugi_xpath_variable_set_set1(self, name, value)
    }
    #[inline]
    pub unsafe fn set2(&mut self, name: *const pugi_char_t, value: *const pugi_char_t) -> bool {
        pugi_xpath_variable_set_set2(self, name, value)
    }
    #[inline]
    pub unsafe fn set3(
        &mut self,
        name: *const pugi_char_t,
        value: *const pugi_xpath_node_set,
    ) -> bool {
        pugi_xpath_variable_set_set3(self, name, value)
    }
    #[inline]
    pub unsafe fn get(&mut self, name: *const pugi_char_t) -> *mut pugi_xpath_variable {
        pugi_xpath_variable_set_get(self, name)
    }
    #[inline]
    pub unsafe fn get1(&self, name: *const pugi_char_t) -> *const pugi_xpath_variable {
        pugi_xpath_variable_set_get1(self, name)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        pugi_xpath_variable_set_xpath_variable_set(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn destruct(&mut self) {
        pugi_xpath_variable_set_xpath_variable_set_destructor(self)
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct pugi_xpath_query {
    pub _impl: *mut ::std::os::raw::c_void,
    pub _result: pugi_xpath_parse_result,
}
pub type pugi_xpath_query_unspecified_bool_type =
    ::std::option::Option<unsafe extern "C" fn(arg1: *mut *mut *mut pugi_xpath_query)>;
#[test]
fn bindgen_test_layout_pugi_xpath_query() {
    assert_eq!(
        ::std::mem::size_of::<pugi_xpath_query>(),
        24usize,
        concat!("Size of: ", stringify!(pugi_xpath_query))
    );
    assert_eq!(
        ::std::mem::align_of::<pugi_xpath_query>(),
        8usize,
        concat!("Alignment of ", stringify!(pugi_xpath_query))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pugi_xpath_query>()))._impl as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pugi_xpath_query),
            "::",
            stringify!(_impl)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pugi_xpath_query>()))._result as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(pugi_xpath_query),
            "::",
            stringify!(_result)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}?return_type@xpath_query@pugi@@QEBA?AW4xpath_value_type@2@XZ"]
    pub fn pugi_xpath_query_return_type(this: *const pugi_xpath_query) -> pugi_xpath_value_type;
}
extern "C" {
    #[link_name = "\u{1}?evaluate_boolean@xpath_query@pugi@@QEBA_NAEBVxpath_node@2@@Z"]
    pub fn pugi_xpath_query_evaluate_boolean(
        this: *const pugi_xpath_query,
        n: *const pugi_xpath_node,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}?evaluate_number@xpath_query@pugi@@QEBANAEBVxpath_node@2@@Z"]
    pub fn pugi_xpath_query_evaluate_number(
        this: *const pugi_xpath_query,
        n: *const pugi_xpath_node,
    ) -> f64;
}
extern "C" {
    #[link_name = "\u{1}?evaluate_string@xpath_query@pugi@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBVxpath_node@2@@Z"]
    pub fn pugi_xpath_query_evaluate_string(
        this: *const pugi_xpath_query,
        n: *const pugi_xpath_node,
    ) -> pugi_string_t;
}
extern "C" {
    #[link_name = "\u{1}?evaluate_string@xpath_query@pugi@@QEBA_KPEAD_KAEBVxpath_node@2@@Z"]
    pub fn pugi_xpath_query_evaluate_string1(
        this: *const pugi_xpath_query,
        buffer: *mut pugi_char_t,
        capacity: size_t,
        n: *const pugi_xpath_node,
    ) -> size_t;
}
extern "C" {
    #[link_name = "\u{1}?evaluate_node_set@xpath_query@pugi@@QEBA?AVxpath_node_set@2@AEBVxpath_node@2@@Z"]
    pub fn pugi_xpath_query_evaluate_node_set(
        this: *const pugi_xpath_query,
        n: *const pugi_xpath_node,
    ) -> pugi_xpath_node_set;
}
extern "C" {
    #[link_name = "\u{1}?result@xpath_query@pugi@@QEBAAEBUxpath_parse_result@2@XZ"]
    pub fn pugi_xpath_query_result(this: *const pugi_xpath_query)
        -> *const pugi_xpath_parse_result;
}
extern "C" {
    #[link_name = "\u{1}??0xpath_query@pugi@@QEAA@PEBDPEAVxpath_variable_set@1@@Z"]
    pub fn pugi_xpath_query_xpath_query(
        this: *mut pugi_xpath_query,
        query: *const pugi_char_t,
        variables: *mut pugi_xpath_variable_set,
    );
}
extern "C" {
    #[link_name = "\u{1}??_Dxpath_query@pugi@@QEAAXXZ"]
    pub fn pugi_xpath_query_xpath_query_destructor(this: *mut pugi_xpath_query);
}
impl pugi_xpath_query {
    #[inline]
    pub unsafe fn return_type(&self) -> pugi_xpath_value_type {
        pugi_xpath_query_return_type(self)
    }
    #[inline]
    pub unsafe fn evaluate_boolean(&self, n: *const pugi_xpath_node) -> bool {
        pugi_xpath_query_evaluate_boolean(self, n)
    }
    #[inline]
    pub unsafe fn evaluate_number(&self, n: *const pugi_xpath_node) -> f64 {
        pugi_xpath_query_evaluate_number(self, n)
    }
    #[inline]
    pub unsafe fn evaluate_string(&self, n: *const pugi_xpath_node) -> pugi_string_t {
        pugi_xpath_query_evaluate_string(self, n)
    }
    #[inline]
    pub unsafe fn evaluate_string1(
        &self,
        buffer: *mut pugi_char_t,
        capacity: size_t,
        n: *const pugi_xpath_node,
    ) -> size_t {
        pugi_xpath_query_evaluate_string1(self, buffer, capacity, n)
    }
    #[inline]
    pub unsafe fn evaluate_node_set(&self, n: *const pugi_xpath_node) -> pugi_xpath_node_set {
        pugi_xpath_query_evaluate_node_set(self, n)
    }
    #[inline]
    pub unsafe fn result(&self) -> *const pugi_xpath_parse_result {
        pugi_xpath_query_result(self)
    }
    #[inline]
    pub unsafe fn new(query: *const pugi_char_t, variables: *mut pugi_xpath_variable_set) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        pugi_xpath_query_xpath_query(__bindgen_tmp.as_mut_ptr(), query, variables);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn destruct(&mut self) {
        pugi_xpath_query_xpath_query_destructor(self)
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pugi_xpath_node {
    pub _node: pugi_xml_node,
    pub _attribute: pugi_xml_attribute,
}
pub type pugi_xpath_node_unspecified_bool_type =
    ::std::option::Option<unsafe extern "C" fn(arg1: *mut *mut *mut pugi_xpath_node)>;
#[test]
fn bindgen_test_layout_pugi_xpath_node() {
    assert_eq!(
        ::std::mem::size_of::<pugi_xpath_node>(),
        16usize,
        concat!("Size of: ", stringify!(pugi_xpath_node))
    );
    assert_eq!(
        ::std::mem::align_of::<pugi_xpath_node>(),
        8usize,
        concat!("Alignment of ", stringify!(pugi_xpath_node))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pugi_xpath_node>()))._node as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pugi_xpath_node),
            "::",
            stringify!(_node)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pugi_xpath_node>()))._attribute as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(pugi_xpath_node),
            "::",
            stringify!(_attribute)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}?node@xpath_node@pugi@@QEBA?AVxml_node@2@XZ"]
    pub fn pugi_xpath_node_node(this: *const pugi_xpath_node) -> pugi_xml_node;
}
extern "C" {
    #[link_name = "\u{1}?attribute@xpath_node@pugi@@QEBA?AVxml_attribute@2@XZ"]
    pub fn pugi_xpath_node_attribute(this: *const pugi_xpath_node) -> pugi_xml_attribute;
}
extern "C" {
    #[link_name = "\u{1}?parent@xpath_node@pugi@@QEBA?AVxml_node@2@XZ"]
    pub fn pugi_xpath_node_parent(this: *const pugi_xpath_node) -> pugi_xml_node;
}
extern "C" {
    #[link_name = "\u{1}??0xpath_node@pugi@@QEAA@XZ"]
    pub fn pugi_xpath_node_xpath_node(this: *mut pugi_xpath_node);
}
extern "C" {
    #[link_name = "\u{1}??0xpath_node@pugi@@QEAA@AEBVxml_node@1@@Z"]
    pub fn pugi_xpath_node_xpath_node1(this: *mut pugi_xpath_node, node: *const pugi_xml_node);
}
extern "C" {
    #[link_name = "\u{1}??0xpath_node@pugi@@QEAA@AEBVxml_attribute@1@AEBVxml_node@1@@Z"]
    pub fn pugi_xpath_node_xpath_node2(
        this: *mut pugi_xpath_node,
        attribute: *const pugi_xml_attribute,
        parent: *const pugi_xml_node,
    );
}
impl pugi_xpath_node {
    #[inline]
    pub unsafe fn node(&self) -> pugi_xml_node {
        pugi_xpath_node_node(self)
    }
    #[inline]
    pub unsafe fn attribute(&self) -> pugi_xml_attribute {
        pugi_xpath_node_attribute(self)
    }
    #[inline]
    pub unsafe fn parent(&self) -> pugi_xml_node {
        pugi_xpath_node_parent(self)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        pugi_xpath_node_xpath_node(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new1(node: *const pugi_xml_node) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        pugi_xpath_node_xpath_node1(__bindgen_tmp.as_mut_ptr(), node);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new2(attribute: *const pugi_xml_attribute, parent: *const pugi_xml_node) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        pugi_xpath_node_xpath_node2(__bindgen_tmp.as_mut_ptr(), attribute, parent);
        __bindgen_tmp.assume_init()
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct pugi_xpath_node_set {
    pub _type: pugi_xpath_node_set_type_t,
    pub _storage: pugi_xpath_node,
    pub _begin: *mut pugi_xpath_node,
    pub _end: *mut pugi_xpath_node,
}
pub const pugi_xpath_node_set_type_t_type_unsorted: pugi_xpath_node_set_type_t = 0;
pub const pugi_xpath_node_set_type_t_type_sorted: pugi_xpath_node_set_type_t = 1;
pub const pugi_xpath_node_set_type_t_type_sorted_reverse: pugi_xpath_node_set_type_t = 2;
pub type pugi_xpath_node_set_type_t = ::std::os::raw::c_int;
pub type pugi_xpath_node_set_const_iterator = *const pugi_xpath_node;
#[test]
fn bindgen_test_layout_pugi_xpath_node_set() {
    assert_eq!(
        ::std::mem::size_of::<pugi_xpath_node_set>(),
        40usize,
        concat!("Size of: ", stringify!(pugi_xpath_node_set))
    );
    assert_eq!(
        ::std::mem::align_of::<pugi_xpath_node_set>(),
        8usize,
        concat!("Alignment of ", stringify!(pugi_xpath_node_set))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pugi_xpath_node_set>()))._type as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pugi_xpath_node_set),
            "::",
            stringify!(_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pugi_xpath_node_set>()))._storage as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(pugi_xpath_node_set),
            "::",
            stringify!(_storage)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pugi_xpath_node_set>()))._begin as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(pugi_xpath_node_set),
            "::",
            stringify!(_begin)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pugi_xpath_node_set>()))._end as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(pugi_xpath_node_set),
            "::",
            stringify!(_end)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}?type@xpath_node_set@pugi@@QEBA?AW4type_t@12@XZ"]
    pub fn pugi_xpath_node_set_type(this: *const pugi_xpath_node_set)
        -> pugi_xpath_node_set_type_t;
}
extern "C" {
    #[link_name = "\u{1}?size@xpath_node_set@pugi@@QEBA_KXZ"]
    pub fn pugi_xpath_node_set_size(this: *const pugi_xpath_node_set) -> size_t;
}
extern "C" {
    #[link_name = "\u{1}?begin@xpath_node_set@pugi@@QEBAPEBVxpath_node@2@XZ"]
    pub fn pugi_xpath_node_set_begin(
        this: *const pugi_xpath_node_set,
    ) -> pugi_xpath_node_set_const_iterator;
}
extern "C" {
    #[link_name = "\u{1}?end@xpath_node_set@pugi@@QEBAPEBVxpath_node@2@XZ"]
    pub fn pugi_xpath_node_set_end(
        this: *const pugi_xpath_node_set,
    ) -> pugi_xpath_node_set_const_iterator;
}
extern "C" {
    #[link_name = "\u{1}?sort@xpath_node_set@pugi@@QEAAX_N@Z"]
    pub fn pugi_xpath_node_set_sort(this: *mut pugi_xpath_node_set, reverse: bool);
}
extern "C" {
    #[link_name = "\u{1}?first@xpath_node_set@pugi@@QEBA?AVxpath_node@2@XZ"]
    pub fn pugi_xpath_node_set_first(this: *const pugi_xpath_node_set) -> pugi_xpath_node;
}
extern "C" {
    #[link_name = "\u{1}?empty@xpath_node_set@pugi@@QEBA_NXZ"]
    pub fn pugi_xpath_node_set_empty(this: *const pugi_xpath_node_set) -> bool;
}
extern "C" {
    #[link_name = "\u{1}??0xpath_node_set@pugi@@QEAA@XZ"]
    pub fn pugi_xpath_node_set_xpath_node_set(this: *mut pugi_xpath_node_set);
}
extern "C" {
    #[link_name = "\u{1}??0xpath_node_set@pugi@@QEAA@PEBVxpath_node@1@0W4type_t@01@@Z"]
    pub fn pugi_xpath_node_set_xpath_node_set1(
        this: *mut pugi_xpath_node_set,
        begin: pugi_xpath_node_set_const_iterator,
        end: pugi_xpath_node_set_const_iterator,
        type_: pugi_xpath_node_set_type_t,
    );
}
extern "C" {
    #[link_name = "\u{1}??0xpath_node_set@pugi@@QEAA@AEBV01@@Z"]
    pub fn pugi_xpath_node_set_xpath_node_set2(
        this: *mut pugi_xpath_node_set,
        ns: *const pugi_xpath_node_set,
    );
}
extern "C" {
    #[link_name = "\u{1}??_Dxpath_node_set@pugi@@QEAAXXZ"]
    pub fn pugi_xpath_node_set_xpath_node_set_destructor(this: *mut pugi_xpath_node_set);
}
impl pugi_xpath_node_set {
    #[inline]
    pub unsafe fn type_(&self) -> pugi_xpath_node_set_type_t {
        pugi_xpath_node_set_type(self)
    }
    #[inline]
    pub unsafe fn size(&self) -> size_t {
        pugi_xpath_node_set_size(self)
    }
    #[inline]
    pub unsafe fn begin(&self) -> pugi_xpath_node_set_const_iterator {
        pugi_xpath_node_set_begin(self)
    }
    #[inline]
    pub unsafe fn end(&self) -> pugi_xpath_node_set_const_iterator {
        pugi_xpath_node_set_end(self)
    }
    #[inline]
    pub unsafe fn sort(&mut self, reverse: bool) {
        pugi_xpath_node_set_sort(self, reverse)
    }
    #[inline]
    pub unsafe fn first(&self) -> pugi_xpath_node {
        pugi_xpath_node_set_first(self)
    }
    #[inline]
    pub unsafe fn empty(&self) -> bool {
        pugi_xpath_node_set_empty(self)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        pugi_xpath_node_set_xpath_node_set(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new1(
        begin: pugi_xpath_node_set_const_iterator,
        end: pugi_xpath_node_set_const_iterator,
        type_: pugi_xpath_node_set_type_t,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        pugi_xpath_node_set_xpath_node_set1(__bindgen_tmp.as_mut_ptr(), begin, end, type_);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new2(ns: *const pugi_xpath_node_set) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        pugi_xpath_node_set_xpath_node_set2(__bindgen_tmp.as_mut_ptr(), ns);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn destruct(&mut self) {
        pugi_xpath_node_set_xpath_node_set_destructor(self)
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct DS_Dictionary {
    pub doc: pugi_xml_document,
    pub dictTree: [u64; 3usize],
    pub compatible: bool,
}
#[test]
fn bindgen_test_layout_DS_Dictionary() {
    assert_eq!(
        ::std::mem::size_of::<DS_Dictionary>(),
        240usize,
        concat!("Size of: ", stringify!(DS_Dictionary))
    );
    assert_eq!(
        ::std::mem::align_of::<DS_Dictionary>(),
        8usize,
        concat!("Alignment of ", stringify!(DS_Dictionary))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<DS_Dictionary>())).doc as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DS_Dictionary),
            "::",
            stringify!(doc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<DS_Dictionary>())).dictTree as *const _ as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(DS_Dictionary),
            "::",
            stringify!(dictTree)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<DS_Dictionary>())).compatible as *const _ as usize },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(DS_Dictionary),
            "::",
            stringify!(compatible)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}?copyFile@DS_Dictionary@@SAXPEBD0@Z"]
    pub fn DS_Dictionary_copyFile(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    #[link_name = "\u{1}?decodeObjectForKey@DS_Dictionary@@QEAAPEAVCCObject@cocos2d@@PEBD_NH@Z"]
    pub fn DS_Dictionary_decodeObjectForKey(
        this: *mut DS_Dictionary,
        arg1: *const ::std::os::raw::c_char,
        arg2: bool,
        arg3: ::std::os::raw::c_int,
    ) -> *mut cocos2d_CCObject;
}
extern "C" {
    #[link_name = "\u{1}?loadRootSubDictFromFile@DS_Dictionary@@QEAA_NPEBD@Z"]
    pub fn DS_Dictionary_loadRootSubDictFromFile(
        this: *mut DS_Dictionary,
        arg1: *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}?loadRootSubDictFromCompressedFile@DS_Dictionary@@QEAA_NPEBD@Z"]
    pub fn DS_Dictionary_loadRootSubDictFromCompressedFile(
        this: *mut DS_Dictionary,
        arg1: *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}?loadRootSubDictFromString@DS_Dictionary@@QEAA_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z"]
    pub fn DS_Dictionary_loadRootSubDictFromString(
        this: *mut DS_Dictionary,
        arg1: std_string,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}?saveRootSubDictToFile@DS_Dictionary@@QEAA_NPEBD@Z"]
    pub fn DS_Dictionary_saveRootSubDictToFile(
        this: *mut DS_Dictionary,
        arg1: *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}?saveRootSubDictToCompressedFile@DS_Dictionary@@QEAA_NPEBD@Z"]
    pub fn DS_Dictionary_saveRootSubDictToCompressedFile(
        this: *mut DS_Dictionary,
        arg1: *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}?saveRootSubDictToString@DS_Dictionary@@QEAA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ"]
    pub fn DS_Dictionary_saveRootSubDictToString(this: *mut DS_Dictionary) -> std_string;
}
extern "C" {
    #[link_name = "\u{1}?stepIntoSubDictWithKey@DS_Dictionary@@QEAA_NPEBD@Z"]
    pub fn DS_Dictionary_stepIntoSubDictWithKey(
        this: *mut DS_Dictionary,
        arg1: *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}?stepOutOfSubDict@DS_Dictionary@@QEAAXXZ"]
    pub fn DS_Dictionary_stepOutOfSubDict(this: *mut DS_Dictionary);
}
extern "C" {
    #[link_name = "\u{1}?stepBackToRootSubDict@DS_Dictionary@@QEAAXXZ"]
    pub fn DS_Dictionary_stepBackToRootSubDict(this: *mut DS_Dictionary);
}
extern "C" {
    #[link_name = "\u{1}?getNumKeys@DS_Dictionary@@QEAAIXZ"]
    pub fn DS_Dictionary_getNumKeys(this: *mut DS_Dictionary) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[link_name = "\u{1}?getKey@DS_Dictionary@@QEAA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@I@Z"]
    pub fn DS_Dictionary_getKey(
        this: *mut DS_Dictionary,
        arg1: ::std::os::raw::c_uint,
    ) -> std_string;
}
extern "C" {
    #[link_name = "\u{1}?getAllKeys@DS_Dictionary@@QEAA?AV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@XZ"]
    pub fn DS_Dictionary_getAllKeys(this: *mut DS_Dictionary) -> [u64; 3usize];
}
extern "C" {
    #[link_name = "\u{1}?getIndexOfKey@DS_Dictionary@@QEAAIPEBD@Z"]
    pub fn DS_Dictionary_getIndexOfKey(
        this: *mut DS_Dictionary,
        arg1: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[link_name = "\u{1}?getIndexOfKeyWithClosestAlphaNumericalMatch@DS_Dictionary@@QEAAIPEBD@Z"]
    pub fn DS_Dictionary_getIndexOfKeyWithClosestAlphaNumericalMatch(
        this: *mut DS_Dictionary,
        arg1: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[link_name = "\u{1}?removeKey@DS_Dictionary@@QEAAXI@Z"]
    pub fn DS_Dictionary_removeKey(this: *mut DS_Dictionary, arg1: ::std::os::raw::c_uint);
}
extern "C" {
    #[link_name = "\u{1}?removeKey@DS_Dictionary@@QEAAXPEBD@Z"]
    pub fn DS_Dictionary_removeKey1(this: *mut DS_Dictionary, arg1: *const ::std::os::raw::c_char);
}
extern "C" {
    #[link_name = "\u{1}?removeAllKeys@DS_Dictionary@@QEAAXXZ"]
    pub fn DS_Dictionary_removeAllKeys(this: *mut DS_Dictionary);
}
extern "C" {
    #[link_name = "\u{1}?getIntegerForKey@DS_Dictionary@@QEAAHPEBD@Z"]
    pub fn DS_Dictionary_getIntegerForKey(
        this: *mut DS_Dictionary,
        arg1: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}?getBoolForKey@DS_Dictionary@@QEAA_NPEBD@Z"]
    pub fn DS_Dictionary_getBoolForKey(
        this: *mut DS_Dictionary,
        arg1: *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}?getFloatForKey@DS_Dictionary@@QEAAMPEBD@Z"]
    pub fn DS_Dictionary_getFloatForKey(
        this: *mut DS_Dictionary,
        arg1: *const ::std::os::raw::c_char,
    ) -> f32;
}
extern "C" {
    #[link_name = "\u{1}?getStringForKey@DS_Dictionary@@QEAA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEBD@Z"]
    pub fn DS_Dictionary_getStringForKey(
        this: *mut DS_Dictionary,
        arg1: *const ::std::os::raw::c_char,
    ) -> std_string;
}
extern "C" {
    #[link_name = "\u{1}?getVec2ForKey@DS_Dictionary@@QEAA?AVCCPoint@cocos2d@@PEBD@Z"]
    pub fn DS_Dictionary_getVec2ForKey(
        this: *mut DS_Dictionary,
        arg1: *const ::std::os::raw::c_char,
    ) -> cocos2d_CCPoint;
}
extern "C" {
    #[link_name = "\u{1}?getRectForKey@DS_Dictionary@@QEAA?AVCCRect@cocos2d@@PEBD@Z"]
    pub fn DS_Dictionary_getRectForKey(
        this: *mut DS_Dictionary,
        arg1: *const ::std::os::raw::c_char,
    ) -> cocos2d_CCRect;
}
extern "C" {
    #[link_name = "\u{1}?getStringArrayForKey@DS_Dictionary@@QEAA?AV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@PEBD@Z"]
    pub fn DS_Dictionary_getStringArrayForKey(
        this: *mut DS_Dictionary,
        arg1: *const ::std::os::raw::c_char,
    ) -> [u64; 3usize];
}
extern "C" {
    #[link_name = "\u{1}?getVec2ArrayForKey@DS_Dictionary@@QEAA?AV?$vector@VCCPoint@cocos2d@@V?$allocator@VCCPoint@cocos2d@@@std@@@std@@PEBD@Z"]
    pub fn DS_Dictionary_getVec2ArrayForKey(
        this: *mut DS_Dictionary,
        arg1: *const ::std::os::raw::c_char,
    ) -> u8;
}
extern "C" {
    #[link_name = "\u{1}?getRectArrayForKey@DS_Dictionary@@QEAA?AV?$vector@VCCRect@cocos2d@@V?$allocator@VCCRect@cocos2d@@@std@@@std@@PEBD@Z"]
    pub fn DS_Dictionary_getRectArrayForKey(
        this: *mut DS_Dictionary,
        arg1: *const ::std::os::raw::c_char,
    ) -> u8;
}
extern "C" {
    #[link_name = "\u{1}?getArrayForKey@DS_Dictionary@@QEAAPEAVCCArray@cocos2d@@PEBD_N@Z"]
    pub fn DS_Dictionary_getArrayForKey(
        this: *mut DS_Dictionary,
        arg1: *const ::std::os::raw::c_char,
        arg2: bool,
    ) -> *mut cocos2d_CCArray;
}
extern "C" {
    #[link_name = "\u{1}?getDictForKey@DS_Dictionary@@QEAAPEAVCCDictionary@cocos2d@@PEBD_N@Z"]
    pub fn DS_Dictionary_getDictForKey(
        this: *mut DS_Dictionary,
        arg1: *const ::std::os::raw::c_char,
        arg2: bool,
    ) -> *mut cocos2d_CCDictionary;
}
extern "C" {
    #[link_name = "\u{1}?getObjectForKey@DS_Dictionary@@QEAAPEAVCCObject@cocos2d@@PEBD@Z"]
    pub fn DS_Dictionary_getObjectForKey(
        this: *mut DS_Dictionary,
        arg1: *const ::std::os::raw::c_char,
    ) -> *mut cocos2d_CCObject;
}
extern "C" {
    #[link_name = "\u{1}?setIntegerForKey@DS_Dictionary@@QEAAXPEBDH@Z"]
    pub fn DS_Dictionary_setIntegerForKey(
        this: *mut DS_Dictionary,
        arg1: *const ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}?setIntegerForKey@DS_Dictionary@@QEAAXPEBDH_N@Z"]
    pub fn DS_Dictionary_setIntegerForKey1(
        this: *mut DS_Dictionary,
        arg1: *const ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_int,
        arg3: bool,
    );
}
extern "C" {
    #[link_name = "\u{1}?setBoolForKey@DS_Dictionary@@QEAAXPEBD_N@Z"]
    pub fn DS_Dictionary_setBoolForKey(
        this: *mut DS_Dictionary,
        arg1: *const ::std::os::raw::c_char,
        arg2: bool,
    );
}
extern "C" {
    #[link_name = "\u{1}?setBoolForKey@DS_Dictionary@@QEAAXPEBD_N1@Z"]
    pub fn DS_Dictionary_setBoolForKey1(
        this: *mut DS_Dictionary,
        arg1: *const ::std::os::raw::c_char,
        arg2: bool,
        arg3: bool,
    );
}
extern "C" {
    #[link_name = "\u{1}?setFloatForKey@DS_Dictionary@@QEAAXPEBDM@Z"]
    pub fn DS_Dictionary_setFloatForKey(
        this: *mut DS_Dictionary,
        arg1: *const ::std::os::raw::c_char,
        arg2: f32,
    );
}
extern "C" {
    #[link_name = "\u{1}?setFloatForKey@DS_Dictionary@@QEAAXPEBDM_N@Z"]
    pub fn DS_Dictionary_setFloatForKey1(
        this: *mut DS_Dictionary,
        arg1: *const ::std::os::raw::c_char,
        arg2: f32,
        arg3: bool,
    );
}
extern "C" {
    #[link_name = "\u{1}?setStringForKey@DS_Dictionary@@QEAAXPEBDAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z"]
    pub fn DS_Dictionary_setStringForKey(
        this: *mut DS_Dictionary,
        arg1: *const ::std::os::raw::c_char,
        arg2: *const std_string,
    );
}
extern "C" {
    #[link_name = "\u{1}?setStringForKey@DS_Dictionary@@QEAAXPEBDAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_N@Z"]
    pub fn DS_Dictionary_setStringForKey1(
        this: *mut DS_Dictionary,
        arg1: *const ::std::os::raw::c_char,
        arg2: *const std_string,
        arg3: bool,
    );
}
extern "C" {
    #[link_name = "\u{1}?setVec2ForKey@DS_Dictionary@@QEAAXPEBDAEBVCCPoint@cocos2d@@@Z"]
    pub fn DS_Dictionary_setVec2ForKey(
        this: *mut DS_Dictionary,
        arg1: *const ::std::os::raw::c_char,
        arg2: *const cocos2d_CCPoint,
    );
}
extern "C" {
    #[link_name = "\u{1}?setVec2ForKey@DS_Dictionary@@QEAAXPEBDAEBVCCPoint@cocos2d@@_N@Z"]
    pub fn DS_Dictionary_setVec2ForKey1(
        this: *mut DS_Dictionary,
        arg1: *const ::std::os::raw::c_char,
        arg2: *const cocos2d_CCPoint,
        arg3: bool,
    );
}
extern "C" {
    #[link_name = "\u{1}?setRectForKey@DS_Dictionary@@QEAAXPEBDAEBVCCRect@cocos2d@@@Z"]
    pub fn DS_Dictionary_setRectForKey(
        this: *mut DS_Dictionary,
        arg1: *const ::std::os::raw::c_char,
        arg2: *const cocos2d_CCRect,
    );
}
extern "C" {
    #[link_name = "\u{1}?setRectForKey@DS_Dictionary@@QEAAXPEBDAEBVCCRect@cocos2d@@_N@Z"]
    pub fn DS_Dictionary_setRectForKey1(
        this: *mut DS_Dictionary,
        arg1: *const ::std::os::raw::c_char,
        arg2: *const cocos2d_CCRect,
        arg3: bool,
    );
}
extern "C" {
    #[link_name = "\u{1}?setStringArrayForKey@DS_Dictionary@@QEAAXPEBDAEBV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@Z"]
    pub fn DS_Dictionary_setStringArrayForKey(
        this: *mut DS_Dictionary,
        arg1: *const ::std::os::raw::c_char,
        arg2: *const [u64; 3usize],
    );
}
extern "C" {
    #[link_name = "\u{1}?setStringArrayForKey@DS_Dictionary@@QEAAXPEBDAEBV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@_N@Z"]
    pub fn DS_Dictionary_setStringArrayForKey1(
        this: *mut DS_Dictionary,
        arg1: *const ::std::os::raw::c_char,
        arg2: *const [u64; 3usize],
        arg3: bool,
    );
}
extern "C" {
    #[link_name = "\u{1}?setVec2ArrayForKey@DS_Dictionary@@QEAAXPEBDAEBV?$vector@VCCPoint@cocos2d@@V?$allocator@VCCPoint@cocos2d@@@std@@@std@@@Z"]
    pub fn DS_Dictionary_setVec2ArrayForKey(
        this: *mut DS_Dictionary,
        arg1: *const ::std::os::raw::c_char,
        arg2: *const u8,
    );
}
extern "C" {
    #[link_name = "\u{1}?setVec2ArrayForKey@DS_Dictionary@@QEAAXPEBDAEBV?$vector@VCCPoint@cocos2d@@V?$allocator@VCCPoint@cocos2d@@@std@@@std@@_N@Z"]
    pub fn DS_Dictionary_setVec2ArrayForKey1(
        this: *mut DS_Dictionary,
        arg1: *const ::std::os::raw::c_char,
        arg2: *const u8,
        arg3: bool,
    );
}
extern "C" {
    #[link_name = "\u{1}?setRectArrayForKey@DS_Dictionary@@QEAAXPEBDAEBV?$vector@VCCRect@cocos2d@@V?$allocator@VCCRect@cocos2d@@@std@@@std@@@Z"]
    pub fn DS_Dictionary_setRectArrayForKey(
        this: *mut DS_Dictionary,
        arg1: *const ::std::os::raw::c_char,
        arg2: *const u8,
    );
}
extern "C" {
    #[link_name = "\u{1}?setRectArrayForKey@DS_Dictionary@@QEAAXPEBDAEBV?$vector@VCCRect@cocos2d@@V?$allocator@VCCRect@cocos2d@@@std@@@std@@_N@Z"]
    pub fn DS_Dictionary_setRectArrayForKey1(
        this: *mut DS_Dictionary,
        arg1: *const ::std::os::raw::c_char,
        arg2: *const u8,
        arg3: bool,
    );
}
extern "C" {
    #[link_name = "\u{1}?setArrayForKey@DS_Dictionary@@QEAAXPEBDPEAVCCArray@cocos2d@@@Z"]
    pub fn DS_Dictionary_setArrayForKey(
        this: *mut DS_Dictionary,
        arg1: *const ::std::os::raw::c_char,
        arg2: *mut cocos2d_CCArray,
    );
}
extern "C" {
    #[link_name = "\u{1}?setBoolMapForKey@DS_Dictionary@@QEAAXPEBDAEBV?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_NU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_N@std@@@2@@std@@@Z"]
    pub fn DS_Dictionary_setBoolMapForKey(
        this: *mut DS_Dictionary,
        arg1: *const ::std::os::raw::c_char,
        arg2: *const u8,
    );
}
extern "C" {
    #[link_name = "\u{1}?setSubDictForKey@DS_Dictionary@@QEAAXPEBD@Z"]
    pub fn DS_Dictionary_setSubDictForKey(
        this: *mut DS_Dictionary,
        arg1: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    #[link_name = "\u{1}?setSubDictForKey@DS_Dictionary@@QEAAXPEBD_N1@Z"]
    pub fn DS_Dictionary_setSubDictForKey1(
        this: *mut DS_Dictionary,
        arg1: *const ::std::os::raw::c_char,
        arg2: bool,
        arg3: bool,
    );
}
extern "C" {
    #[link_name = "\u{1}?setDictForKey@DS_Dictionary@@QEAAXPEBDPEAVCCDictionary@cocos2d@@@Z"]
    pub fn DS_Dictionary_setDictForKey(
        this: *mut DS_Dictionary,
        arg1: *const ::std::os::raw::c_char,
        arg2: *mut cocos2d_CCDictionary,
    );
}
extern "C" {
    #[link_name = "\u{1}?setObjectForKey@DS_Dictionary@@QEAAXPEBDPEAVCCObject@cocos2d@@@Z"]
    pub fn DS_Dictionary_setObjectForKey(
        this: *mut DS_Dictionary,
        arg1: *const ::std::os::raw::c_char,
        arg2: *mut cocos2d_CCObject,
    );
}
extern "C" {
    #[link_name = "\u{1}?addBoolValuesToMapForKey@DS_Dictionary@@QEAAXAEBV?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_NU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_N@std@@@2@@std@@PEBD_N@Z"]
    pub fn DS_Dictionary_addBoolValuesToMapForKey(
        this: *mut DS_Dictionary,
        arg1: *const u8,
        arg2: *const ::std::os::raw::c_char,
        arg3: bool,
    );
}
extern "C" {
    #[link_name = "\u{1}?addBoolValuesToMapForKeySpecial@DS_Dictionary@@QEAAXAEBV?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_NU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_N@std@@@2@@std@@PEBD_N@Z"]
    pub fn DS_Dictionary_addBoolValuesToMapForKeySpecial(
        this: *mut DS_Dictionary,
        arg1: *const u8,
        arg2: *const ::std::os::raw::c_char,
        arg3: bool,
    );
}
extern "C" {
    #[link_name = "\u{1}?checkCompatibility@DS_Dictionary@@QEAAXXZ"]
    pub fn DS_Dictionary_checkCompatibility(this: *mut DS_Dictionary);
}
extern "C" {
    #[link_name = "\u{1}??0DS_Dictionary@@QEAA@XZ"]
    pub fn DS_Dictionary_DS_Dictionary(this: *mut DS_Dictionary);
}
extern "C" {
    #[link_name = "\u{1}??_DDS_Dictionary@@QEAAXXZ"]
    pub fn DS_Dictionary_DS_Dictionary_destructor(this: *mut DS_Dictionary);
}
impl DS_Dictionary {
    #[inline]
    pub unsafe fn copyFile(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
    ) {
        DS_Dictionary_copyFile(arg1, arg2)
    }
    #[inline]
    pub unsafe fn decodeObjectForKey(
        &mut self,
        arg1: *const ::std::os::raw::c_char,
        arg2: bool,
        arg3: ::std::os::raw::c_int,
    ) -> *mut cocos2d_CCObject {
        DS_Dictionary_decodeObjectForKey(self, arg1, arg2, arg3)
    }
    #[inline]
    pub unsafe fn loadRootSubDictFromFile(&mut self, arg1: *const ::std::os::raw::c_char) -> bool {
        DS_Dictionary_loadRootSubDictFromFile(self, arg1)
    }
    #[inline]
    pub unsafe fn loadRootSubDictFromCompressedFile(
        &mut self,
        arg1: *const ::std::os::raw::c_char,
    ) -> bool {
        DS_Dictionary_loadRootSubDictFromCompressedFile(self, arg1)
    }
    #[inline]
    pub unsafe fn loadRootSubDictFromString(&mut self, arg1: std_string) -> bool {
        DS_Dictionary_loadRootSubDictFromString(self, arg1)
    }
    #[inline]
    pub unsafe fn saveRootSubDictToFile(&mut self, arg1: *const ::std::os::raw::c_char) -> bool {
        DS_Dictionary_saveRootSubDictToFile(self, arg1)
    }
    #[inline]
    pub unsafe fn saveRootSubDictToCompressedFile(
        &mut self,
        arg1: *const ::std::os::raw::c_char,
    ) -> bool {
        DS_Dictionary_saveRootSubDictToCompressedFile(self, arg1)
    }
    #[inline]
    pub unsafe fn saveRootSubDictToString(&mut self) -> std_string {
        DS_Dictionary_saveRootSubDictToString(self)
    }
    #[inline]
    pub unsafe fn stepIntoSubDictWithKey(&mut self, arg1: *const ::std::os::raw::c_char) -> bool {
        DS_Dictionary_stepIntoSubDictWithKey(self, arg1)
    }
    #[inline]
    pub unsafe fn stepOutOfSubDict(&mut self) {
        DS_Dictionary_stepOutOfSubDict(self)
    }
    #[inline]
    pub unsafe fn stepBackToRootSubDict(&mut self) {
        DS_Dictionary_stepBackToRootSubDict(self)
    }
    #[inline]
    pub unsafe fn getNumKeys(&mut self) -> ::std::os::raw::c_uint {
        DS_Dictionary_getNumKeys(self)
    }
    #[inline]
    pub unsafe fn getKey(&mut self, arg1: ::std::os::raw::c_uint) -> std_string {
        DS_Dictionary_getKey(self, arg1)
    }
    #[inline]
    pub unsafe fn getAllKeys(&mut self) -> [u64; 3usize] {
        DS_Dictionary_getAllKeys(self)
    }
    #[inline]
    pub unsafe fn getIndexOfKey(
        &mut self,
        arg1: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_uint {
        DS_Dictionary_getIndexOfKey(self, arg1)
    }
    #[inline]
    pub unsafe fn getIndexOfKeyWithClosestAlphaNumericalMatch(
        &mut self,
        arg1: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_uint {
        DS_Dictionary_getIndexOfKeyWithClosestAlphaNumericalMatch(self, arg1)
    }
    #[inline]
    pub unsafe fn removeKey(&mut self, arg1: ::std::os::raw::c_uint) {
        DS_Dictionary_removeKey(self, arg1)
    }
    #[inline]
    pub unsafe fn removeKey1(&mut self, arg1: *const ::std::os::raw::c_char) {
        DS_Dictionary_removeKey1(self, arg1)
    }
    #[inline]
    pub unsafe fn removeAllKeys(&mut self) {
        DS_Dictionary_removeAllKeys(self)
    }
    #[inline]
    pub unsafe fn getIntegerForKey(
        &mut self,
        arg1: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int {
        DS_Dictionary_getIntegerForKey(self, arg1)
    }
    #[inline]
    pub unsafe fn getBoolForKey(&mut self, arg1: *const ::std::os::raw::c_char) -> bool {
        DS_Dictionary_getBoolForKey(self, arg1)
    }
    #[inline]
    pub unsafe fn getFloatForKey(&mut self, arg1: *const ::std::os::raw::c_char) -> f32 {
        DS_Dictionary_getFloatForKey(self, arg1)
    }
    #[inline]
    pub unsafe fn getStringForKey(&mut self, arg1: *const ::std::os::raw::c_char) -> std_string {
        DS_Dictionary_getStringForKey(self, arg1)
    }
    #[inline]
    pub unsafe fn getVec2ForKey(&mut self, arg1: *const ::std::os::raw::c_char) -> cocos2d_CCPoint {
        DS_Dictionary_getVec2ForKey(self, arg1)
    }
    #[inline]
    pub unsafe fn getRectForKey(&mut self, arg1: *const ::std::os::raw::c_char) -> cocos2d_CCRect {
        DS_Dictionary_getRectForKey(self, arg1)
    }
    #[inline]
    pub unsafe fn getStringArrayForKey(
        &mut self,
        arg1: *const ::std::os::raw::c_char,
    ) -> [u64; 3usize] {
        DS_Dictionary_getStringArrayForKey(self, arg1)
    }
    #[inline]
    pub unsafe fn getVec2ArrayForKey(&mut self, arg1: *const ::std::os::raw::c_char) -> u8 {
        DS_Dictionary_getVec2ArrayForKey(self, arg1)
    }
    #[inline]
    pub unsafe fn getRectArrayForKey(&mut self, arg1: *const ::std::os::raw::c_char) -> u8 {
        DS_Dictionary_getRectArrayForKey(self, arg1)
    }
    #[inline]
    pub unsafe fn getArrayForKey(
        &mut self,
        arg1: *const ::std::os::raw::c_char,
        arg2: bool,
    ) -> *mut cocos2d_CCArray {
        DS_Dictionary_getArrayForKey(self, arg1, arg2)
    }
    #[inline]
    pub unsafe fn getDictForKey(
        &mut self,
        arg1: *const ::std::os::raw::c_char,
        arg2: bool,
    ) -> *mut cocos2d_CCDictionary {
        DS_Dictionary_getDictForKey(self, arg1, arg2)
    }
    #[inline]
    pub unsafe fn getObjectForKey(
        &mut self,
        arg1: *const ::std::os::raw::c_char,
    ) -> *mut cocos2d_CCObject {
        DS_Dictionary_getObjectForKey(self, arg1)
    }
    #[inline]
    pub unsafe fn setIntegerForKey(
        &mut self,
        arg1: *const ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_int,
    ) {
        DS_Dictionary_setIntegerForKey(self, arg1, arg2)
    }
    #[inline]
    pub unsafe fn setIntegerForKey1(
        &mut self,
        arg1: *const ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_int,
        arg3: bool,
    ) {
        DS_Dictionary_setIntegerForKey1(self, arg1, arg2, arg3)
    }
    #[inline]
    pub unsafe fn setBoolForKey(&mut self, arg1: *const ::std::os::raw::c_char, arg2: bool) {
        DS_Dictionary_setBoolForKey(self, arg1, arg2)
    }
    #[inline]
    pub unsafe fn setBoolForKey1(
        &mut self,
        arg1: *const ::std::os::raw::c_char,
        arg2: bool,
        arg3: bool,
    ) {
        DS_Dictionary_setBoolForKey1(self, arg1, arg2, arg3)
    }
    #[inline]
    pub unsafe fn setFloatForKey(&mut self, arg1: *const ::std::os::raw::c_char, arg2: f32) {
        DS_Dictionary_setFloatForKey(self, arg1, arg2)
    }
    #[inline]
    pub unsafe fn setFloatForKey1(
        &mut self,
        arg1: *const ::std::os::raw::c_char,
        arg2: f32,
        arg3: bool,
    ) {
        DS_Dictionary_setFloatForKey1(self, arg1, arg2, arg3)
    }
    #[inline]
    pub unsafe fn setStringForKey(
        &mut self,
        arg1: *const ::std::os::raw::c_char,
        arg2: *const std_string,
    ) {
        DS_Dictionary_setStringForKey(self, arg1, arg2)
    }
    #[inline]
    pub unsafe fn setStringForKey1(
        &mut self,
        arg1: *const ::std::os::raw::c_char,
        arg2: *const std_string,
        arg3: bool,
    ) {
        DS_Dictionary_setStringForKey1(self, arg1, arg2, arg3)
    }
    #[inline]
    pub unsafe fn setVec2ForKey(
        &mut self,
        arg1: *const ::std::os::raw::c_char,
        arg2: *const cocos2d_CCPoint,
    ) {
        DS_Dictionary_setVec2ForKey(self, arg1, arg2)
    }
    #[inline]
    pub unsafe fn setVec2ForKey1(
        &mut self,
        arg1: *const ::std::os::raw::c_char,
        arg2: *const cocos2d_CCPoint,
        arg3: bool,
    ) {
        DS_Dictionary_setVec2ForKey1(self, arg1, arg2, arg3)
    }
    #[inline]
    pub unsafe fn setRectForKey(
        &mut self,
        arg1: *const ::std::os::raw::c_char,
        arg2: *const cocos2d_CCRect,
    ) {
        DS_Dictionary_setRectForKey(self, arg1, arg2)
    }
    #[inline]
    pub unsafe fn setRectForKey1(
        &mut self,
        arg1: *const ::std::os::raw::c_char,
        arg2: *const cocos2d_CCRect,
        arg3: bool,
    ) {
        DS_Dictionary_setRectForKey1(self, arg1, arg2, arg3)
    }
    #[inline]
    pub unsafe fn setStringArrayForKey(
        &mut self,
        arg1: *const ::std::os::raw::c_char,
        arg2: *const [u64; 3usize],
    ) {
        DS_Dictionary_setStringArrayForKey(self, arg1, arg2)
    }
    #[inline]
    pub unsafe fn setStringArrayForKey1(
        &mut self,
        arg1: *const ::std::os::raw::c_char,
        arg2: *const [u64; 3usize],
        arg3: bool,
    ) {
        DS_Dictionary_setStringArrayForKey1(self, arg1, arg2, arg3)
    }
    #[inline]
    pub unsafe fn setVec2ArrayForKey(
        &mut self,
        arg1: *const ::std::os::raw::c_char,
        arg2: *const u8,
    ) {
        DS_Dictionary_setVec2ArrayForKey(self, arg1, arg2)
    }
    #[inline]
    pub unsafe fn setVec2ArrayForKey1(
        &mut self,
        arg1: *const ::std::os::raw::c_char,
        arg2: *const u8,
        arg3: bool,
    ) {
        DS_Dictionary_setVec2ArrayForKey1(self, arg1, arg2, arg3)
    }
    #[inline]
    pub unsafe fn setRectArrayForKey(
        &mut self,
        arg1: *const ::std::os::raw::c_char,
        arg2: *const u8,
    ) {
        DS_Dictionary_setRectArrayForKey(self, arg1, arg2)
    }
    #[inline]
    pub unsafe fn setRectArrayForKey1(
        &mut self,
        arg1: *const ::std::os::raw::c_char,
        arg2: *const u8,
        arg3: bool,
    ) {
        DS_Dictionary_setRectArrayForKey1(self, arg1, arg2, arg3)
    }
    #[inline]
    pub unsafe fn setArrayForKey(
        &mut self,
        arg1: *const ::std::os::raw::c_char,
        arg2: *mut cocos2d_CCArray,
    ) {
        DS_Dictionary_setArrayForKey(self, arg1, arg2)
    }
    #[inline]
    pub unsafe fn setBoolMapForKey(
        &mut self,
        arg1: *const ::std::os::raw::c_char,
        arg2: *const u8,
    ) {
        DS_Dictionary_setBoolMapForKey(self, arg1, arg2)
    }
    #[inline]
    pub unsafe fn setSubDictForKey(&mut self, arg1: *const ::std::os::raw::c_char) {
        DS_Dictionary_setSubDictForKey(self, arg1)
    }
    #[inline]
    pub unsafe fn setSubDictForKey1(
        &mut self,
        arg1: *const ::std::os::raw::c_char,
        arg2: bool,
        arg3: bool,
    ) {
        DS_Dictionary_setSubDictForKey1(self, arg1, arg2, arg3)
    }
    #[inline]
    pub unsafe fn setDictForKey(
        &mut self,
        arg1: *const ::std::os::raw::c_char,
        arg2: *mut cocos2d_CCDictionary,
    ) {
        DS_Dictionary_setDictForKey(self, arg1, arg2)
    }
    #[inline]
    pub unsafe fn setObjectForKey(
        &mut self,
        arg1: *const ::std::os::raw::c_char,
        arg2: *mut cocos2d_CCObject,
    ) {
        DS_Dictionary_setObjectForKey(self, arg1, arg2)
    }
    #[inline]
    pub unsafe fn addBoolValuesToMapForKey(
        &mut self,
        arg1: *const u8,
        arg2: *const ::std::os::raw::c_char,
        arg3: bool,
    ) {
        DS_Dictionary_addBoolValuesToMapForKey(self, arg1, arg2, arg3)
    }
    #[inline]
    pub unsafe fn addBoolValuesToMapForKeySpecial(
        &mut self,
        arg1: *const u8,
        arg2: *const ::std::os::raw::c_char,
        arg3: bool,
    ) {
        DS_Dictionary_addBoolValuesToMapForKeySpecial(self, arg1, arg2, arg3)
    }
    #[inline]
    pub unsafe fn checkCompatibility(&mut self) {
        DS_Dictionary_checkCompatibility(self)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        DS_Dictionary_DS_Dictionary(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn destruct(&mut self) {
        DS_Dictionary_DS_Dictionary_destructor(self)
    }
}
